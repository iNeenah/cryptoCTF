{"id": "rsa_small_exponent_1", "team": "crypto_experts", "repo": "curated_crypto", "challenge_name": "RSA Small Exponent e=3", "attack_type": "RSA", "writeup": "# RSA Small Exponent Attack (e=3)\n\n## Challenge Description\nWe have an RSA encryption with a very small public exponent e=3. The ciphertext and modulus are given.\n\n## Analysis\nWhen e=3 and the plaintext m is small enough that m^3 < n, then:\nc ≡ m^3 (mod n) = m^3\n\nSince m^3 < n, we can simply compute the cube root of c to recover m.\n\n## Solution\n```python\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\nn = 0x9a0b1c2d3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b\ne = 3\nc = 0x1234567890abcdef1234567890abcdef1234567890abcdef\n\n# Take cube root\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(f\"Flag: {flag.decode()}\")\n```\n\n## Key Learning\nSmall exponents in RSA can be vulnerable when the plaintext is small relative to the modulus.", "solution_code": "import gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\nn = 0x9a0b1c2d3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b\ne = 3\nc = 0x1234567890abcdef1234567890abcdef1234567890abcdef\n\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(f\"Flag: {flag.decode()}\")", "flag": "flag{small_exponent_attack}", "scraped_at": "2025-10-26T18:37:53.057270"}
{"id": "rsa_common_modulus", "team": "crypto_experts", "repo": "curated_crypto", "challenge_name": "RSA Common Modulus Attack", "attack_type": "RSA", "writeup": "# RSA Common Modulus Attack\n\n## Challenge Description\nTwo messages encrypted with the same modulus n but different exponents e1 and e2 where gcd(e1, e2) = 1.\n\n## Analysis\nIf we have:\n- c1 ≡ m^e1 (mod n)\n- c2 ≡ m^e2 (mod n)\n- gcd(e1, e2) = 1\n\nWe can use the extended Euclidean algorithm to find a and b such that:\na*e1 + b*e2 = 1\n\nThen: m ≡ c1^a * c2^b (mod n)\n\n## Solution\n```python\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef extended_gcd(a, b):\n    if a == 0:\n        return b, 0, 1\n    gcd, x1, y1 = extended_gcd(b % a, a)\n    x = y1 - (b // a) * x1\n    y = x1\n    return gcd, x, y\n\nn = 0x9a0b1c2d3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b\ne1 = 3\ne2 = 65537\nc1 = 0x1234567890abcdef\nc2 = 0xfedcba0987654321\n\ngcd, a, b = extended_gcd(e1, e2)\nif gcd == 1:\n    if a < 0:\n        c1 = gmpy2.invert(c1, n)\n        a = -a\n    if b < 0:\n        c2 = gmpy2.invert(c2, n)\n        b = -b\n    \n    m = pow(c1, a, n) * pow(c2, b, n) % n\n    flag = long_to_bytes(m)\n    print(f\"Flag: {flag.decode()}\")\n```\n\n## Key Learning\nNever reuse the same modulus with different exponents in RSA.", "solution_code": "import gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef extended_gcd(a, b):\n    if a == 0:\n        return b, 0, 1\n    gcd, x1, y1 = extended_gcd(b % a, a)\n    x = y1 - (b // a) * x1\n    y = x1\n    return gcd, x, y\n\nn = 0x9a0b1c2d3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b\ne1 = 3\ne2 = 65537\nc1 = 0x1234567890abcdef\nc2 = 0xfedcba0987654321\n\ngcd, a, b = extended_gcd(e1, e2)\nif gcd == 1:\n    if a < 0:\n        c1 = gmpy2.invert(c1, n)\n        a = -a\n    if b < 0:\n        c2 = gmpy2.invert(c2, n)\n        b = -b\n    \n    m = pow(c1, a, n) * pow(c2, b, n) % n\n    flag = long_to_bytes(m)\n    print(f\"Flag: {flag.decode()}\")", "flag": "flag{common_modulus_attack}", "scraped_at": "2025-10-26T18:37:53.057318"}
{"id": "rsa_wiener_attack", "team": "crypto_experts", "repo": "curated_crypto", "challenge_name": "RSA Wiener Attack", "attack_type": "RSA", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with a small private exponent d. When d < (1/3) * n^(1/4), Wiener's attack can recover d.\n\n## Analysis\nWiener's attack exploits the continued fraction expansion of e/n to find the private key when d is small.\n\n## Solution\n```python\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef continued_fractions(e, n):\n    cf = []\n    while n:\n        cf.append(e // n)\n        e, n = n, e % n\n    return cf\n\ndef convergents(cf):\n    convergents = []\n    for i in range(len(cf)):\n        if i == 0:\n            convergents.append((cf[0], 1))\n        elif i == 1:\n            convergents.append((cf[1] * cf[0] + 1, cf[1]))\n        else:\n            p = cf[i] * convergents[i-1][0] + convergents[i-2][0]\n            q = cf[i] * convergents[i-1][1] + convergents[i-2][1]\n            convergents.append((p, q))\n    return convergents\n\ndef wiener_attack(e, n, c):\n    cf = continued_fractions(e, n)\n    convergents_list = convergents(cf)\n    \n    for k, d in convergents_list:\n        if k == 0:\n            continue\n        \n        # Check if this d works\n        try:\n            m = pow(c, d, n)\n            flag = long_to_bytes(m)\n            if b'flag' in flag:\n                return flag.decode()\n        except:\n            continue\n    \n    return None\n\nn = 0x9a0b1c2d3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b\ne = 65537\nc = 0x1234567890abcdef\n\nflag = wiener_attack(e, n, c)\nif flag:\n    print(f\"Flag: {flag}\")\n```\n\n## Key Learning\nSmall private exponents make RSA vulnerable to Wiener's attack.", "solution_code": "import gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef continued_fractions(e, n):\n    cf = []\n    while n:\n        cf.append(e // n)\n        e, n = n, e % n\n    return cf\n\ndef convergents(cf):\n    convergents = []\n    for i in range(len(cf)):\n        if i == 0:\n            convergents.append((cf[0], 1))\n        elif i == 1:\n            convergents.append((cf[1] * cf[0] + 1, cf[1]))\n        else:\n            p = cf[i] * convergents[i-1][0] + convergents[i-2][0]\n            q = cf[i] * convergents[i-1][1] + convergents[i-2][1]\n            convergents.append((p, q))\n    return convergents\n\ndef wiener_attack(e, n, c):\n    cf = continued_fractions(e, n)\n    convergents_list = convergents(cf)\n    \n    for k, d in convergents_list:\n        if k == 0:\n            continue\n        \n        try:\n            m = pow(c, d, n)\n            flag = long_to_bytes(m)\n            if b'flag' in flag:\n                return flag.decode()\n        except:\n            continue\n    \n    return None", "flag": "flag{wiener_attack_success}", "scraped_at": "2025-10-26T18:37:53.057321"}
{"id": "aes_ecb_oracle", "team": "crypto_experts", "repo": "curated_crypto", "challenge_name": "AES ECB Oracle Attack", "attack_type": "AES", "writeup": "# AES ECB Oracle Attack\n\n## Challenge Description\nWe have an AES ECB encryption oracle that encrypts our input concatenated with a secret flag.\n\n## Analysis\nECB mode encrypts each 16-byte block independently. We can exploit this by:\n1. Controlling input to align the flag at block boundaries\n2. Brute forcing one byte at a time\n3. Using the oracle to compare encrypted blocks\n\n## Solution\n```python\nfrom Crypto.Cipher import AES\nimport string\n\ndef ecb_oracle(plaintext, secret_flag, key):\n    # Simulated oracle\n    data = plaintext + secret_flag\n    # Pad to multiple of 16\n    pad_len = 16 - (len(data) % 16)\n    data += bytes([pad_len] * pad_len)\n    \n    cipher = AES.new(key, AES.MODE_ECB)\n    return cipher.encrypt(data)\n\ndef extract_flag(oracle_func):\n    flag = b\"\"\n    \n    for i in range(50):  # Assume flag is < 50 chars\n        # Create padding to align flag byte at end of block\n        padding = b\"A\" * (15 - (i % 16))\n        \n        # Get target block\n        target = oracle_func(padding)\n        target_block = target[len(padding) + i:len(padding) + i + 16]\n        \n        # Brute force the byte\n        for c in string.printable.encode():\n            test_input = padding + flag + bytes([c])\n            test_output = oracle_func(test_input)\n            test_block = test_output[:16]\n            \n            if test_block == target_block:\n                flag += bytes([c])\n                print(f\"Found: {flag}\")\n                if flag.endswith(b\"}\"):\n                    return flag\n                break\n    \n    return flag\n\n# Simulated attack\nkey = b\"YELLOW SUBMARINE\"\nsecret = b\"flag{ecb_oracle_attack}\"\n\ndef oracle(plaintext):\n    return ecb_oracle(plaintext, secret, key)\n\nrecovered_flag = extract_flag(oracle)\nprint(f\"Recovered flag: {recovered_flag.decode()}\")\n```\n\n## Key Learning\nECB mode is vulnerable to chosen plaintext attacks due to its deterministic nature.", "solution_code": "from Crypto.Cipher import AES\nimport string\n\ndef ecb_oracle(plaintext, secret_flag, key):\n    data = plaintext + secret_flag\n    pad_len = 16 - (len(data) % 16)\n    data += bytes([pad_len] * pad_len)\n    \n    cipher = AES.new(key, AES.MODE_ECB)\n    return cipher.encrypt(data)\n\ndef extract_flag(oracle_func):\n    flag = b\"\"\n    \n    for i in range(50):\n        padding = b\"A\" * (15 - (i % 16))\n        target = oracle_func(padding)\n        target_block = target[len(padding) + i:len(padding) + i + 16]\n        \n        for c in string.printable.encode():\n            test_input = padding + flag + bytes([c])\n            test_output = oracle_func(test_input)\n            test_block = test_output[:16]\n            \n            if test_block == target_block:\n                flag += bytes([c])\n                if flag.endswith(b\"}\"):\n                    return flag\n                break\n    \n    return flag", "flag": "flag{ecb_oracle_attack}", "scraped_at": "2025-10-26T18:37:53.057324"}
{"id": "vigenere_frequency", "team": "crypto_experts", "repo": "curated_crypto", "challenge_name": "Vigenère Cipher Frequency Analysis", "attack_type": "Classical", "writeup": "# Vigenère Cipher Frequency Analysis\n\n## Challenge Description\nA Vigenère cipher with unknown key length and key. We need to break it using frequency analysis.\n\n## Analysis\n1. Determine key length using Index of Coincidence or Kasiski examination\n2. Split ciphertext into groups based on key length\n3. Perform frequency analysis on each group (Caesar cipher)\n4. Reconstruct the key\n\n## Solution\n```python\ndef index_of_coincidence(text):\n    text = text.upper()\n    n = len(text)\n    freqs = [text.count(chr(i + ord('A'))) for i in range(26)]\n    ic = sum(f * (f - 1) for f in freqs) / (n * (n - 1))\n    return ic\n\ndef find_key_length(ciphertext, max_len=20):\n    best_len = 1\n    best_ic = 0\n    \n    for length in range(1, max_len + 1):\n        groups = [''] * length\n        for i, char in enumerate(ciphertext):\n            if char.isalpha():\n                groups[i % length] += char\n        \n        avg_ic = sum(index_of_coincidence(group) for group in groups) / length\n        \n        if avg_ic > best_ic:\n            best_ic = avg_ic\n            best_len = length\n    \n    return best_len\n\ndef break_caesar(ciphertext):\n    best_shift = 0\n    best_score = 0\n    \n    for shift in range(26):\n        decrypted = \"\"\n        for char in ciphertext:\n            if char.isalpha():\n                base = ord('A') if char.isupper() else ord('a')\n                decrypted += chr((ord(char) - base - shift) % 26 + base)\n            else:\n                decrypted += char\n        \n        # Score based on English letter frequency\n        score = sum(decrypted.upper().count(letter) for letter in 'ETAOINSHRDLU')\n        \n        if score > best_score:\n            best_score = score\n            best_shift = shift\n    \n    return best_shift\n\ndef break_vigenere(ciphertext):\n    key_length = find_key_length(ciphertext)\n    print(f\"Detected key length: {key_length}\")\n    \n    key = \"\"\n    for i in range(key_length):\n        group = \"\"\n        for j in range(i, len(ciphertext), key_length):\n            if ciphertext[j].isalpha():\n                group += ciphertext[j]\n        \n        shift = break_caesar(group)\n        key += chr(shift + ord('A'))\n    \n    return key\n\nciphertext = \"LXFOPVEFRNHR\"\nkey = break_vigenere(ciphertext)\nprint(f\"Key: {key}\")\n\n# Decrypt with found key\ndef vigenere_decrypt(ciphertext, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in ciphertext:\n        if char.isalpha():\n            base = ord('A') if char.isupper() else ord('a')\n            key_char = key[key_index % len(key)]\n            shift = ord(key_char) - ord('A')\n            result += chr((ord(char) - base - shift) % 26 + base)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\nplaintext = vigenere_decrypt(ciphertext, key)\nprint(f\"Plaintext: {plaintext}\")\n```\n\n## Key Learning\nVigenère ciphers can be broken by determining key length and then treating each position as a Caesar cipher.", "solution_code": "def index_of_coincidence(text):\n    text = text.upper()\n    n = len(text)\n    freqs = [text.count(chr(i + ord('A'))) for i in range(26)]\n    ic = sum(f * (f - 1) for f in freqs) / (n * (n - 1))\n    return ic\n\ndef find_key_length(ciphertext, max_len=20):\n    best_len = 1\n    best_ic = 0\n    \n    for length in range(1, max_len + 1):\n        groups = [''] * length\n        for i, char in enumerate(ciphertext):\n            if char.isalpha():\n                groups[i % length] += char\n        \n        avg_ic = sum(index_of_coincidence(group) for group in groups) / length\n        \n        if avg_ic > best_ic:\n            best_ic = avg_ic\n            best_len = length\n    \n    return best_len\n\ndef break_caesar(ciphertext):\n    best_shift = 0\n    best_score = 0\n    \n    for shift in range(26):\n        decrypted = \"\"\n        for char in ciphertext:\n            if char.isalpha():\n                base = ord('A') if char.isupper() else ord('a')\n                decrypted += chr((ord(char) - base - shift) % 26 + base)\n            else:\n                decrypted += char\n        \n        score = sum(decrypted.upper().count(letter) for letter in 'ETAOINSHRDLU')\n        \n        if score > best_score:\n            best_score = score\n            best_shift = shift\n    \n    return best_shift", "flag": "flag{vigenere_broken}", "scraped_at": "2025-10-26T18:37:53.057326"}
{"id": "hash_length_extension", "team": "crypto_experts", "repo": "curated_crypto", "challenge_name": "Hash Length Extension Attack", "attack_type": "Hash", "writeup": "# Hash Length Extension Attack\n\n## Challenge Description\nWe have a hash-based message authentication system using MD5/SHA1. We know a valid message-hash pair and want to forge a new message.\n\n## Analysis\nMD5 and SHA1 are vulnerable to length extension attacks. If we know:\n- hash(secret + message)\n- The length of the secret\n- The original message\n\nWe can compute hash(secret + message + padding + extension) without knowing the secret.\n\n## Solution\n```python\nimport hashlib\nimport struct\n\ndef md5_padding(message_len):\n    # MD5 padding: message + 0x80 + zeros + length\n    padding = b''\n    \n    # Calculate padding length\n    while (message_len + len(padding)) % 64 != 56:\n        padding += b'\u0000'\n    \n    # Append original length in bits as 64-bit little-endian\n    padding += struct.pack('<Q', message_len * 8)\n    \n    return padding\n\ndef length_extension_attack(original_hash, original_msg, secret_len, extension):\n    # Calculate what the internal state would be after processing original message\n    original_msg_len = secret_len + len(original_msg)\n    padding = md5_padding(original_msg_len)\n    \n    # Create new message: original + padding + extension\n    new_msg = original_msg + padding + extension\n    \n    # Calculate new hash by continuing from the original hash state\n    # This requires implementing MD5 with custom initial state\n    # For demonstration, we'll use a simplified approach\n    \n    # In a real attack, you'd implement MD5 with custom IV\n    # Here's the concept:\n    h = hashlib.md5()\n    \n    # Set internal state to original_hash (this is the key part)\n    # In practice, you'd need to modify the hash function\n    \n    # Process the extension\n    total_len = original_msg_len + len(padding) + len(extension)\n    \n    print(f\"Original message: {original_msg}\")\n    print(f\"Padding: {padding.hex()}\")\n    print(f\"Extension: {extension}\")\n    print(f\"New message: {new_msg}\")\n    print(f\"Total length: {total_len}\")\n    \n    return new_msg\n\n# Example usage\noriginal_msg = b\"user=guest\"\noriginal_hash = \"5d41402abc4b2a76b9719d911017c592\"  # MD5 of secret + original_msg\nsecret_len = 16  # Assumed secret length\nextension = b\"&admin=true\"\n\nforged_msg = length_extension_attack(original_hash, original_msg, secret_len, extension)\nprint(f\"Forged message: {forged_msg}\")\n```\n\n## Key Learning\nNever use MD5 or SHA1 for HMAC-like constructions. Use proper HMAC or SHA-3.", "solution_code": "import hashlib\nimport struct\n\ndef md5_padding(message_len):\n    padding = b''\n    \n    while (message_len + len(padding)) % 64 != 56:\n        padding += b'\u0000'\n    \n    padding += struct.pack('<Q', message_len * 8)\n    \n    return padding\n\ndef length_extension_attack(original_hash, original_msg, secret_len, extension):\n    original_msg_len = secret_len + len(original_msg)\n    padding = md5_padding(original_msg_len)\n    \n    new_msg = original_msg + padding + extension\n    \n    total_len = original_msg_len + len(padding) + len(extension)\n    \n    return new_msg", "flag": "flag{length_extension_attack}", "scraped_at": "2025-10-26T18:37:53.057329"}
{"id": "xor_key_reuse", "team": "crypto_experts", "repo": "curated_crypto", "challenge_name": "XOR Key Reuse Attack", "attack_type": "XOR", "writeup": "# XOR Key Reuse Attack\n\n## Challenge Description\nTwo messages encrypted with the same XOR key. We can exploit this to recover both messages.\n\n## Analysis\nIf we have:\n- c1 = m1 ⊕ k\n- c2 = m2 ⊕ k\n\nThen: c1 ⊕ c2 = m1 ⊕ m2\n\nWe can use frequency analysis and known plaintext patterns to recover the messages.\n\n## Solution\n```python\ndef xor_bytes(a, b):\n    return bytes(x ^ y for x, y in zip(a, b))\n\ndef frequency_analysis(data):\n    # Count character frequencies\n    freq = {}\n    for byte in data:\n        freq[byte] = freq.get(byte, 0) + 1\n    return freq\n\ndef find_key_byte(ciphertexts, position):\n    # Try all possible key bytes\n    best_key = 0\n    best_score = 0\n    \n    for key_byte in range(256):\n        decrypted_bytes = []\n        for ct in ciphertexts:\n            if position < len(ct):\n                decrypted_bytes.append(ct[position] ^ key_byte)\n        \n        # Score based on English text characteristics\n        score = 0\n        for byte in decrypted_bytes:\n            if 32 <= byte <= 126:  # Printable ASCII\n                score += 1\n            if byte in b'etaoinshrdlu':  # Common letters\n                score += 2\n        \n        if score > best_score:\n            best_score = score\n            best_key = key_byte\n    \n    return best_key\n\ndef break_xor_key_reuse(ciphertexts):\n    # Find the maximum length\n    max_len = max(len(ct) for ct in ciphertexts)\n    \n    key = []\n    for i in range(max_len):\n        key_byte = find_key_byte(ciphertexts, i)\n        key.append(key_byte)\n    \n    return bytes(key)\n\ndef decrypt_with_key(ciphertext, key):\n    return xor_bytes(ciphertext, key * (len(ciphertext) // len(key) + 1))\n\n# Example ciphertexts (encrypted with same key)\nct1 = bytes.fromhex(\"1c0e1f0a1b0e1f0a1b0e1f0a\")\nct2 = bytes.fromhex(\"1f0b1c0d1e0b1c0d1e0b1c0d\")\n\nciphertexts = [ct1, ct2]\n\n# Break the key\nrecovered_key = break_xor_key_reuse(ciphertexts)\nprint(f\"Recovered key: {recovered_key}\")\n\n# Decrypt messages\nfor i, ct in enumerate(ciphertexts):\n    plaintext = decrypt_with_key(ct, recovered_key)\n    print(f\"Message {i+1}: {plaintext}\")\n```\n\n## Key Learning\nNever reuse XOR keys. Each encryption should use a unique key or nonce.", "solution_code": "def xor_bytes(a, b):\n    return bytes(x ^ y for x, y in zip(a, b))\n\ndef find_key_byte(ciphertexts, position):\n    best_key = 0\n    best_score = 0\n    \n    for key_byte in range(256):\n        decrypted_bytes = []\n        for ct in ciphertexts:\n            if position < len(ct):\n                decrypted_bytes.append(ct[position] ^ key_byte)\n        \n        score = 0\n        for byte in decrypted_bytes:\n            if 32 <= byte <= 126:\n                score += 1\n            if byte in b'etaoinshrdlu':\n                score += 2\n        \n        if score > best_score:\n            best_score = score\n            best_key = key_byte\n    \n    return best_key\n\ndef break_xor_key_reuse(ciphertexts):\n    max_len = max(len(ct) for ct in ciphertexts)\n    \n    key = []\n    for i in range(max_len):\n        key_byte = find_key_byte(ciphertexts, i)\n        key.append(key_byte)\n    \n    return bytes(key)", "flag": "flag{xor_key_reuse_broken}", "scraped_at": "2025-10-26T18:37:53.057331"}
{"id": "rsa_factorization_1", "team": "crypto_team", "repo": "synthetic", "challenge_name": "RSA Factorization Challenge", "attack_type": "RSA", "writeup": "# RSA Factorization Challenge\n\n## Challenge\nWe have RSA parameters where n can be factorized easily.\n\nGiven:\n- n = p * q (small factors)\n- e = 65537\n- c = encrypted flag\n\n## Solution\nFactor n to find p and q, then compute private key d.\n\n```python\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef factorize_n(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return i, n // i\n    return None, None\n\nn = 0x123456789abcdef\ne = 65537\nc = 0xfedcba987654321\n\np, q = factorize_n(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n```", "solution_code": "import gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef factorize_n(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return i, n // i\n    return None, None\n\nn = 0x123456789abcdef\ne = 65537\nc = 0xfedcba987654321\n\np, q = factorize_n(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())", "flag": "flag{rsa_factorization}", "scraped_at": "2025-10-26T18:43:01.758821"}
{"id": "rsa_fermat_1", "team": "crypto_team", "repo": "synthetic", "challenge_name": "RSA Fermat Attack", "attack_type": "RSA", "writeup": "# RSA Fermat Attack\n\n## Challenge\nRSA with p and q very close to each other.\n\n## Analysis\nWhen p ≈ q, Fermat factorization works efficiently.\n\n## Solution\n```python\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factor(n):\n    a = gmpy2.isqrt(n) + 1\n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        if b * b == b_squared:\n            return a + b, a - b\n        a += 1\n\nn = 0x123456789abcdef\ne = 65537\nc = 0xfedcba987654321\n\np, q = fermat_factor(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n```", "solution_code": "import gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factor(n):\n    a = gmpy2.isqrt(n) + 1\n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        if b * b == b_squared:\n            return a + b, a - b\n        a += 1", "flag": "flag{fermat_attack}", "scraped_at": "2025-10-26T18:43:01.758855"}
{"id": "caesar_basic_1", "team": "crypto_team", "repo": "synthetic", "challenge_name": "Caesar Cipher Basic", "attack_type": "Classical", "writeup": "# Caesar Cipher Challenge\n\n## Challenge\nDecrypt the Caesar cipher: \"WKLV LV D WHVW\"\n\n## Solution\nTry all 26 possible shifts.\n\n```python\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            base = ord('A') if char.isupper() else ord('a')\n            result += chr((ord(char) - base - shift) % 26 + base)\n        else:\n            result += char\n    return result\n\nciphertext = \"WKLV LV D WHVW\"\nfor shift in range(26):\n    plaintext = caesar_decrypt(ciphertext, shift)\n    if \"flag\" in plaintext.lower():\n        print(f\"Shift {shift}: {plaintext}\")\n```", "solution_code": "def caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            base = ord('A') if char.isupper() else ord('a')\n            result += chr((ord(char) - base - shift) % 26 + base)\n        else:\n            result += char\n    return result\n\nciphertext = \"WKLV LV D WHVW\"\nfor shift in range(26):\n    plaintext = caesar_decrypt(ciphertext, shift)\n    if \"flag\" in plaintext.lower():\n        print(f\"Shift {shift}: {plaintext}\")", "flag": "flag{this_is_a_test}", "scraped_at": "2025-10-26T18:43:01.758858"}
{"id": "substitution_1", "team": "crypto_team", "repo": "synthetic", "challenge_name": "Substitution Cipher", "attack_type": "Classical", "writeup": "# Substitution Cipher\n\n## Challenge\nMonoalphabetic substitution cipher with frequency analysis.\n\n## Solution\nUse frequency analysis to map letters.\n\n```python\ndef frequency_analysis(text):\n    freq = {}\n    for char in text.upper():\n        if char.isalpha():\n            freq[char] = freq.get(char, 0) + 1\n    return sorted(freq.items(), key=lambda x: x[1], reverse=True)\n\ndef substitute(text, mapping):\n    result = \"\"\n    for char in text:\n        if char.upper() in mapping:\n            new_char = mapping[char.upper()]\n            result += new_char.lower() if char.islower() else new_char\n        else:\n            result += char\n    return result\n\nciphertext = \"SYNT{FHOFGVGHGVBA_PVCURE}\"\nfreq = frequency_analysis(ciphertext)\nprint(\"Frequency:\", freq)\n\n# Manual mapping based on frequency\nmapping = {'S': 'F', 'Y': 'L', 'N': 'A', 'T': 'G', 'F': 'S', 'H': 'U', 'O': 'B', 'G': 'T', 'V': 'I', 'P': 'C', 'C': 'P', 'E': 'R', 'U': 'H'}\nplaintext = substitute(ciphertext, mapping)\nprint(f\"Plaintext: {plaintext}\")\n```", "solution_code": "def frequency_analysis(text):\n    freq = {}\n    for char in text.upper():\n        if char.isalpha():\n            freq[char] = freq.get(char, 0) + 1\n    return sorted(freq.items(), key=lambda x: x[1], reverse=True)\n\ndef substitute(text, mapping):\n    result = \"\"\n    for char in text:\n        if char.upper() in mapping:\n            new_char = mapping[char.upper()]\n            result += new_char.lower() if char.islower() else new_char\n        else:\n            result += char\n    return result", "flag": "flag{substitution_cipher}", "scraped_at": "2025-10-26T18:43:01.758862"}
{"id": "xor_repeating_key_1", "team": "crypto_team", "repo": "synthetic", "challenge_name": "XOR Repeating Key", "attack_type": "XOR", "writeup": "# XOR Repeating Key\n\n## Challenge\nText encrypted with repeating XOR key.\n\n## Solution\nFind key length using Hamming distance, then break each position.\n\n```python\ndef hamming_distance(s1, s2):\n    return sum(bin(a ^ b).count('1') for a, b in zip(s1, s2))\n\ndef find_key_length(ciphertext, max_len=20):\n    best_len = 1\n    best_score = float('inf')\n    \n    for length in range(2, max_len + 1):\n        chunks = [ciphertext[i:i+length] for i in range(0, len(ciphertext), length)]\n        if len(chunks) < 2:\n            continue\n        \n        distances = []\n        for i in range(len(chunks) - 1):\n            if len(chunks[i]) == len(chunks[i+1]):\n                distances.append(hamming_distance(chunks[i], chunks[i+1]) / length)\n        \n        if distances:\n            avg_distance = sum(distances) / len(distances)\n            if avg_distance < best_score:\n                best_score = avg_distance\n                best_len = length\n    \n    return best_len\n\nciphertext = bytes.fromhex(\"1a2b3c4d5e6f\")\nkey_length = find_key_length(ciphertext)\nprint(f\"Key length: {key_length}\")\n```", "solution_code": "def hamming_distance(s1, s2):\n    return sum(bin(a ^ b).count('1') for a, b in zip(s1, s2))\n\ndef find_key_length(ciphertext, max_len=20):\n    best_len = 1\n    best_score = float('inf')\n    \n    for length in range(2, max_len + 1):\n        chunks = [ciphertext[i:i+length] for i in range(0, len(ciphertext), length)]\n        if len(chunks) < 2:\n            continue\n        \n        distances = []\n        for i in range(len(chunks) - 1):\n            if len(chunks[i]) == len(chunks[i+1]):\n                distances.append(hamming_distance(chunks[i], chunks[i+1]) / length)\n        \n        if distances:\n            avg_distance = sum(distances) / len(distances)\n            if avg_distance < best_score:\n                best_score = avg_distance\n                best_len = length\n    \n    return best_len", "flag": "flag{repeating_xor_key}", "scraped_at": "2025-10-26T18:43:01.758865"}
{"id": "aes_cbc_padding_1", "team": "crypto_team", "repo": "synthetic", "challenge_name": "AES CBC Padding Oracle", "attack_type": "AES", "writeup": "# AES CBC Padding Oracle\n\n## Challenge\nAES CBC with padding oracle vulnerability.\n\n## Solution\nUse padding oracle attack to decrypt byte by byte.\n\n```python\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad, unpad\n\ndef padding_oracle(ciphertext, iv, key):\n    try:\n        cipher = AES.new(key, AES.MODE_CBC, iv)\n        plaintext = cipher.decrypt(ciphertext)\n        unpad(plaintext, 16)\n        return True\n    except:\n        return False\n\ndef padding_oracle_attack(ciphertext, iv, oracle_func):\n    # Simplified padding oracle attack\n    plaintext = b\"\"\n    \n    for block_idx in range(len(ciphertext) // 16):\n        block = ciphertext[block_idx*16:(block_idx+1)*16]\n        prev_block = iv if block_idx == 0 else ciphertext[(block_idx-1)*16:block_idx*16]\n        \n        # Attack each byte in the block\n        for byte_pos in range(15, -1, -1):\n            for guess in range(256):\n                # Modify previous block to test padding\n                test_prev = bytearray(prev_block)\n                test_prev[byte_pos] ^= guess\n                \n                if oracle_func(block, bytes(test_prev)):\n                    # Found valid padding\n                    plaintext_byte = guess ^ (16 - byte_pos)\n                    plaintext = bytes([plaintext_byte]) + plaintext\n                    break\n    \n    return plaintext\n\n# Example usage\nkey = b\"YELLOW SUBMARINE\"\niv = b\"0123456789abcdef\"\nciphertext = bytes.fromhex(\"deadbeefcafebabe\")\n\noracle = lambda ct, iv: padding_oracle(ct, iv, key)\nplaintext = padding_oracle_attack(ciphertext, iv, oracle)\nprint(f\"Plaintext: {plaintext}\")\n```", "solution_code": "from Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad, unpad\n\ndef padding_oracle(ciphertext, iv, key):\n    try:\n        cipher = AES.new(key, AES.MODE_CBC, iv)\n        plaintext = cipher.decrypt(ciphertext)\n        unpad(plaintext, 16)\n        return True\n    except:\n        return False\n\ndef padding_oracle_attack(ciphertext, iv, oracle_func):\n    plaintext = b\"\"\n    \n    for block_idx in range(len(ciphertext) // 16):\n        block = ciphertext[block_idx*16:(block_idx+1)*16]\n        prev_block = iv if block_idx == 0 else ciphertext[(block_idx-1)*16:block_idx*16]\n        \n        for byte_pos in range(15, -1, -1):\n            for guess in range(256):\n                test_prev = bytearray(prev_block)\n                test_prev[byte_pos] ^= guess\n                \n                if oracle_func(block, bytes(test_prev)):\n                    plaintext_byte = guess ^ (16 - byte_pos)\n                    plaintext = bytes([plaintext_byte]) + plaintext\n                    break\n    \n    return plaintext", "flag": "flag{padding_oracle_attack}", "scraped_at": "2025-10-26T18:43:01.758868"}
{"id": "hash_collision_1", "team": "crypto_team", "repo": "synthetic", "challenge_name": "Hash Collision Attack", "attack_type": "Hash", "writeup": "# Hash Collision Attack\n\n## Challenge\nFind two different inputs that produce the same hash.\n\n## Solution\nUse birthday paradox or known collision techniques.\n\n```python\nimport hashlib\n\ndef find_collision(hash_func, prefix_len=4):\n    seen = {}\n    counter = 0\n    \n    while True:\n        data = f\"input_{counter}\".encode()\n        hash_val = hash_func(data).hexdigest()[:prefix_len]\n        \n        if hash_val in seen:\n            return seen[hash_val], data, hash_val\n        \n        seen[hash_val] = data\n        counter += 1\n        \n        if counter > 100000:  # Prevent infinite loop\n            break\n    \n    return None, None, None\n\n# Find MD5 collision (first 4 hex chars)\ninput1, input2, collision_hash = find_collision(hashlib.md5, 4)\n\nif input1 and input2:\n    print(f\"Collision found!\")\n    print(f\"Input 1: {input1}\")\n    print(f\"Input 2: {input2}\")\n    print(f\"Hash prefix: {collision_hash}\")\n    \n    # Verify\n    hash1 = hashlib.md5(input1).hexdigest()[:4]\n    hash2 = hashlib.md5(input2).hexdigest()[:4]\n    print(f\"Verification: {hash1} == {hash2}\")\n```", "solution_code": "import hashlib\n\ndef find_collision(hash_func, prefix_len=4):\n    seen = {}\n    counter = 0\n    \n    while True:\n        data = f\"input_{counter}\".encode()\n        hash_val = hash_func(data).hexdigest()[:prefix_len]\n        \n        if hash_val in seen:\n            return seen[hash_val], data, hash_val\n        \n        seen[hash_val] = data\n        counter += 1\n        \n        if counter > 100000:\n            break\n    \n    return None, None, None", "flag": "flag{hash_collision_found}", "scraped_at": "2025-10-26T18:43:01.758872"}
{"id": "base64_layers_1", "team": "crypto_team", "repo": "synthetic", "challenge_name": "Base64 Multiple Layers", "attack_type": "Encoding", "writeup": "# Base64 Multiple Layers\n\n## Challenge\nFlag encoded with multiple layers of Base64.\n\n## Solution\nDecode recursively until we get readable text.\n\n```python\nimport base64\nimport re\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data.strip()\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded[:50]}...\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if it's still base64\n            if re.match(r'^[A-Za-z0-9+/=]+$', decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n                \n        except:\n            return current\n    \n    return current\n\nencoded = \"Vm14YUZvemRHbFpXRTVzVG1wU1ptSkhSalZhV0VwNldESkdlVnBXT1cxa1Z6VTU=\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Flag: {flag}\")\n```", "solution_code": "import base64\nimport re\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data.strip()\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded[:50]}...\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            if re.match(r'^[A-Za-z0-9+/=]+$', decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n                \n        except:\n            return current\n    \n    return current", "flag": "flag{base64_layers_decoded}", "scraped_at": "2025-10-26T18:43:01.758875"}
