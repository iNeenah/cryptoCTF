{"id": "writeup_001", "content": "\n# RSA Small Exponent Attack (e=3)\n\nThis challenge presents a classic RSA vulnerability where the public exponent e=3 is too small.\n\n## Challenge Analysis\n- n = 12345678901234567890123456789012345678901234567890\n- e = 3  \n- c = 9876543210987654321098765432109876543210987654321\n\n## Solution Approach\nSince e=3 is very small, we can try a cube root attack. If the plaintext m is small enough that m^3 < n, then we can simply compute the cube root of c to get m.\n\n## Implementation\n```python\nimport gmpy2\nc = 9876543210987654321098765432109876543210987654321\nm = gmpy2.iroot(c, 3)[0]\nprint(long_to_bytes(m))\n```\n\n## Key Learning\nAlways check for small exponent vulnerabilities in RSA challenges.\n            ", "repo": "github/ashutosh1206", "words": 150, "ctf_event": "PicoCTF 2023"}
{"id": "writeup_002", "content": "\n# Caesar Cipher ROT13 Writeup\n\nSimple substitution cipher where each letter is shifted by 13 positions.\n\n## Challenge\nciphertext = \"synt{pnrfne_pvcure_vf_abg_frpher}\"\n\n## Solution\nROT13 is its own inverse, so we just apply ROT13 again:\n```python\ndef rot13(text):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            base = ord('A') if char.isupper() else ord('a')\n            result += chr((ord(char) - base + 13) % 26 + base)\n        else:\n            result += char\n    return result\n\nflag = rot13(\"synt{pnrfne_pvcure_vf_abg_frpher}\")\nprint(flag)  # flag{caesar_cipher_is_not_secure}\n```\n\n## Pattern\nLook for patterns in classical ciphers - frequency analysis, common words.\n            ", "repo": "github/7rocky", "words": 120, "ctf_event": "CSAW 2023"}
{"id": "writeup_003", "content": "\n# XOR Single Byte Key Recovery\n\nChallenge where flag is XORed with a single byte key.\n\n## Analysis\nencrypted = bytes.fromhex(\"1a0e1b1c5b7e0e1f5b1a0e1b1c5b0e1f5b7e0e1f\")\n\n## Brute Force Approach\nSince it's single byte, only 256 possibilities:\n```python\nfor key in range(256):\n    decrypted = bytes([b ^ key for b in encrypted])\n    if b'flag{' in decrypted:\n        print(f\"Key: {key}, Flag: {decrypted.decode()}\")\n        break\n```\n\n## Advanced: Frequency Analysis\nLook for common English patterns like 'the', 'and', etc.\n\n## Result\nKey was 0x42, flag{xor_is_not_secure}\n            ", "repo": "github/sajjadium", "words": 100, "ctf_event": "DEFCON 31"}
{"id": "writeup_004", "content": "\n# Base64 Decoding Challenge\n\nNot really encryption, just encoding.\n\n## Challenge\nencoded = \"ZmxhZ3tiYXNlNjRfaXNfbm90X2VuY3J5cHRpb259\"\n\n## Solution\n```python\nimport base64\ndecoded = base64.b64decode(encoded)\nprint(decoded.decode())  # flag{base64_is_not_encryption}\n```\n\n## Key Point\nBase64 is encoding, not encryption. Always try basic decoding first.\n            ", "repo": "github/crypto-cat", "words": 60, "ctf_event": "BSides 2023"}
{"id": "writeup_005", "content": "\n# MD5 Hash Cracking\n\nHash cracking using dictionary attack.\n\n## Challenge\ntarget_hash = \"5d41402abc4b2a76b9719d911017c592\"\n\n## Solution Approach\n1. Try common passwords\n2. Use rainbow tables\n3. Brute force if needed\n\n```python\nimport hashlib\ncommon_words = [\"hello\", \"world\", \"password\", \"admin\"]\nfor word in common_words:\n    if hashlib.md5(word.encode()).hexdigest() == target_hash:\n        print(f\"Found: {word}\")\n        break\n```\n\nResult: \"hello\" -> flag{hello_cracked}\n            ", "repo": "github/hash-master", "words": 90, "ctf_event": "HackTheBox"}
