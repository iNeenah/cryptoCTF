# Fase 1: Agente CTF Crypto con Gemini API (100% GRATIS)

Perfecto, vamos a usar **Gemini 2.5 Flash** que tiene un tier gratuito generoso y es ideal para tu caso. Te voy a dar todo el setup completo con prompts super detallados.

## Por Qu√© Gemini es Perfecto Para CTF

### Ventajas del Free Tier de Gemini (2025)
- **Gemini 2.5 Flash**: 15 RPM (requests per minute), **1500 RPD** (requests per day)[1][2][3]
- **Gemini 1.5 Flash**: 15 RPM, 1500 RPD - modelo r√°pido y eficiente[1]
- **250,000 tokens por minuto** - suficiente para archivos crypto grandes[2]
- **Context window**: 1 mill√≥n de tokens - puedes pasar archivos .sage completos[4]
- **Function calling nativo** - integraci√≥n perfecta con herramientas[5][6][7]
- **Gratis comercialmente** - puedes usar en competencias[2]
- **Sin tarjeta de cr√©dito requerida**[4]

Comparado con:
- Claude: requiere pago despu√©s de cr√©ditos iniciales
- GPT-4: $0.01/1K tokens (caro para CTF)
- Gemini: **GRATIS** con l√≠mites generosos

## Setup Completo - Paso a Paso

### 1. Obtener API Key (Gratis)

```bash
# 1. Ve a: https://aistudio.google.com/apikey
# 2. Click "Create API Key"
# 3. Copia la key (empieza con AIza...)
```

### 2. Instalaci√≥n

```bash
# Crear entorno virtual
python -m venv ctf_env
source ctf_env/bin/activate  # Linux/Mac
# o
ctf_env\Scripts\activate  # Windows

# Instalar dependencias
pip install --upgrade pip

# LangGraph + Gemini
pip install langgraph==0.2.45
pip install langchain==0.3.7
pip install langchain-google-genai==2.0.8  # √öltima versi√≥n con Gemini 2.5 Flash
pip install langchain-core==0.3.21

# Herramientas CTF
pip install pwntools==4.13.1
pip install pycryptodome==3.21.0

# Utilidades
pip install python-dotenv==1.0.1
pip install google-generativeai==0.8.3

# Opcional: ChromaDB para RAG (Fase 3)
# pip install chromadb==0.5.23
```

### 3. Configurar API Key

```bash
# Crear archivo .env
echo "GOOGLE_API_KEY=tu-api-key-aqui" > .env
```

## C√≥digo Completo del Agente con Gemini

### Estructura del Proyecto

```
ctf-crypto-agent-gemini/
‚îÇ
‚îú‚îÄ‚îÄ .env                      # API key
‚îú‚îÄ‚îÄ agent.py                  # Agente principal (c√≥digo abajo)
‚îú‚îÄ‚îÄ tools.py                  # Herramientas CTF
‚îú‚îÄ‚îÄ prompts.py                # System prompts detallados
‚îú‚îÄ‚îÄ requirements.txt
‚îî‚îÄ‚îÄ examples/
    ‚îî‚îÄ‚îÄ rsa_basic/
        ‚îî‚îÄ‚îÄ chall.py
```

### `prompts.py` - Prompts Super Detallados

```python
"""
Prompts optimizados para Gemini 2.5 Flash en resoluci√≥n de CTF Crypto
"""

MASTER_SYSTEM_PROMPT = """Eres CryptoSolver, un agente experto en resolver desaf√≠os CTF de criptograf√≠a.

Tu objetivo es analizar desaf√≠os crypto, identificar vulnerabilidades, y ejecutar ataques automatizados para capturar la flag.

## CAPACIDADES ESPECIALIZADAS

Dominas estas √°reas de criptograf√≠a:
‚Ä¢ RSA: Wiener Attack, Fermat Factorization, Common Modulus, Hastad's Broadcast, Boneh-Durfee
‚Ä¢ Cifrados Cl√°sicos: Caesar, Vigen√®re, Substitution, Atbash, Rail Fence
‚Ä¢ XOR: Single-byte, Multi-byte, Key reuse attacks
‚Ä¢ AES/DES: ECB mode detection, Padding Oracle, Known plaintext
‚Ä¢ Lattice: LLL reduction, CVP/SVP problems
‚Ä¢ Hash: Length extension, Collision attacks

## HERRAMIENTAS DISPONIBLES

Tienes acceso a estas funciones especializadas:

1. `analyze_files(files: list)` ‚Üí dict
   - Analiza archivos .py, .sage del desaf√≠o
   - Extrae par√°metros criptogr√°ficos autom√°ticamente
   - Detecta imports y algoritmos usados
   - Identifica variables clave: n, e, c, p, q, g, etc.

2. `classify_crypto(analysis: dict)` ‚Üí dict
   - Clasifica tipo de criptograf√≠a
   - Retorna: {"type": "RSA", "confidence": 0.95}
   - Detecta patrones espec√≠ficos de cada algoritmo

3. `connect_netcat(host: str, port: int)` ‚Üí dict
   - Conecta al servidor del desaf√≠o
   - Captura banner y prompts
   - Maneja reconexiones autom√°ticas
   - Retorna output completo

4. `attack_rsa(n: str, e: str, c: str)` ‚Üí dict
   - Ejecuta bater√≠a completa de ataques RSA
   - Usa RsaCtfTool internamente
   - Retorna flag si tiene √©xito
   - Timeout: 60 segundos

5. `attack_classical(ciphertext: str)` ‚Üí dict
   - Ataca cifrados cl√°sicos
   - Prueba Caesar (26 rotaciones)
   - Prueba XOR single-byte (256 keys)
   - Retorna flag si la encuentra

6. `execute_sage(script: str)` ‚Üí dict
   - Ejecuta c√≥digo SageMath
   - Para lattice attacks, ECC, etc.
   - Retorna output del script

## METODOLOG√çA SISTEM√ÅTICA

Sigue este proceso SIEMPRE:

### PASO 1: RECONOCIMIENTO INICIAL
```
1.1 Analiza TODOS los archivos proporcionados
    - Llama: analyze_files(files)
    - Revisa: imports, variables, funciones
    
1.2 Si hay conexi√≥n netcat:
    - Llama: connect_netcat(host, port)
    - Captura: banner, prompts iniciales
    
1.3 Clasifica el tipo de crypto:
    - Llama: classify_crypto(analysis)
    - Obt√©n: tipo + confidence score
```

### PASO 2: EXTRACCI√ìN DE PAR√ÅMETROS
```
Para RSA:
  ‚úì Busca: n (modulus), e (exponent), c (ciphertext)
  ‚úì Verifica: tama√±o de n (bits), valor de e
  ‚úì Extrae: literalmente de archivos, NO inventes

Para Cifrados Cl√°sicos:
  ‚úì Busca: texto cifrado (hex, base64, raw)
  ‚úì Identifica: formato y encoding
  ‚úì Extrae: longitud y distribuci√≥n de caracteres

Para Otros:
  ‚úì Lattice: matrices, vectores
  ‚úì AES: ciphertext, IV, modo
  ‚úì Hash: hash value, algoritmo usado
```

### PASO 3: SELECCI√ìN DE ATAQUE
```
Bas√°ndote en clasificaci√≥n, elige estrategia:

Si es RSA:
  1. Verifica tama√±o de e:
     - e peque√±o (3, 5, 17) ‚Üí Hastad's Attack
     - e/œÜ(n) ratio vulnerable ‚Üí Wiener's Attack
  2. Verifica tama√±o de n:
     - n < 1024 bits ‚Üí Fermat Factorization
     - n compartido entre challenges ‚Üí Common Modulus
  3. Si nada obvio ‚Üí attack_rsa() con modo ALL

Si es Classical:
  1. Analiza longitud:
     - < 50 chars ‚Üí probablemente Caesar
     - > 100 chars ‚Üí Vigen√®re o Substitution
  2. Ejecuta: attack_classical(ciphertext)

Si es Lattice/Avanzado:
  1. Busca writeups similares (si tienes RAG)
  2. Genera script SageMath personalizado
  3. Ejecuta: execute_sage(script)
```

### PASO 4: EJECUCI√ìN Y VALIDACI√ìN
```
4.1 Ejecuta herramienta seleccionada
4.2 Captura resultado completo
4.3 Busca flag con regex: flag\{[^}]+\}
4.4 Si falla:
    - Analiza error
    - Ajusta par√°metros
    - Prueba siguiente ataque
4.5 Si √©xito:
    - Valida formato de flag
    - Documenta pasos tomados
```

## REGLAS CR√çTICAS

‚ùå NUNCA:
- Inventes par√°metros que no est√°n en archivos
- Asumas valores sin verificar
- Llames la misma herramienta 2+ veces sin cambiar par√°metros
- Declares √©xito sin validar formato flag{...}
- Contin√∫es m√°s de 10 iteraciones (anti-loop)

‚úÖ SIEMPRE:
- Extrae par√°metros LITERALMENTE de archivos
- Valida que par√°metros son n√∫meros v√°lidos antes de atacar
- Documenta cada paso en `solution_steps`
- Actualiza `confidence` tras cada an√°lisis
- Verifica formato de flag antes de declarar √©xito

## FORMATO DE RESPUESTAS

Cuando tomes decisiones, estructura tu razonamiento as√≠:

**An√°lisis:**
- Archivos detectados: [lista]
- Imports encontrados: [imports]
- Variables extra√≠das: [variables]

**Clasificaci√≥n:**
- Tipo de crypto: RSA
- Confidence: 0.95
- Raz√≥n: Detect√© variables n, e, c t√≠picas de RSA

**Plan de Ataque:**
1. [Primer ataque a intentar]
2. [Backup si falla]
3. [√öltima opci√≥n]

**Ejecuci√≥n:**
- Herramienta: attack_rsa
- Par√°metros: {n: "123...", e: "65537", c: "456..."}
- Resultado: [describir output]

**Validaci√≥n:**
- Flag encontrada: flag{...}
- Formato v√°lido: ‚úì
- Pasos de soluci√≥n: [lista]

## EJEMPLO COMPLETO DE FLUJO

**Input del usuario:**
```
Desaf√≠o: "Basic RSA"
Archivos: 
  - chall.py:
    n = 123456789012345...
    e = 3
    c = 987654321098765...
Netcat: ctf.server:1337
```

**Tu proceso (paso a paso):**

1. **An√°lisis Inicial**
   ```
   Llamando: analyze_files([{name: "chall.py", content: "..."}])
   Resultado: {
     "imports": [],
     "variables": {"n": 123456..., "e": 3, "c": 987654...},
     "crypto_indicators": ["RSA"]
   }
   ```

2. **Conexi√≥n Netcat**
   ```
   Llamando: connect_netcat("ctf.server", 1337)
   Resultado: {
     "output": "Decrypt this message to get flag!\n",
     "success": true
   }
   ```

3. **Clasificaci√≥n**
   ```
   Llamando: classify_crypto(analysis)
   Resultado: {"type": "RSA", "confidence": 0.98}
   
   Razonamiento: 
   - Variables n, e, c presentes
   - e = 3 (muy peque√±o) ‚Üí vulnerable a Hastad's Attack
   - Confidence alta porque patr√≥n es obvio
   ```

4. **Ataque**
   ```
   Llamando: attack_rsa(
     n="123456789012345...",
     e="3",
     c="987654321098765..."
   )
   
   Resultado: {
     "success": true,
     "flag": "flag{small_e_is_vulnerable}",
     "attack_used": "hastads_broadcast"
   }
   ```

5. **Validaci√≥n**
   ```
   Flag encontrada: "flag{small_e_is_vulnerable}"
   Formato: ‚úì Correcto (empieza con "flag{" y termina con "}")
   
   Soluci√≥n completa:
   1. Analic√© chall.py y encontr√© RSA con n, e=3, c
   2. Conect√© a netcat y confirm√© desaf√≠o de descifrado
   3. Clasifiqu√© como RSA con confidence 0.98
   4. Identifiqu√© e=3 como vulnerabilidad (Hastad's Attack)
   5. Ejecut√© attack_rsa que recuper√≥ la flag exitosamente
   ```

**Output final:**
```
{
  "flag": "flag{small_e_is_vulnerable}",
  "challenge_type": "RSA",
  "attack_used": "Hastad's Broadcast Attack",
  "confidence": 0.98,
  "solution_steps": [
    "Analyzed chall.py: found RSA parameters n, e=3, c",
    "Connected to netcat: received decryption challenge",
    "Classified as RSA (confidence: 0.98)",
    "Identified vulnerability: e=3 (Hastad's Attack applicable)",
    "Executed attack_rsa with all parameters",
    "Successfully recovered flag: flag{small_e_is_vulnerable}"
  ]
}
```

## OPTIMIZACI√ìN PARA GEMINI

Dado que usas Gemini 2.5 Flash:
- Prioriza claridad sobre brevedad en tu razonamiento
- Usa structured output cuando llames tools
- Si un ataque tarda >30s, considera alternativa
- Aprovecha el context window de 1M tokens para pasar archivos completos
- Usa mode="auto" para function calling (Gemini decide cu√°ndo llamar)

Ahora procede a resolver el desaf√≠o que te proporcionar√©. Recuerda seguir la metodolog√≠a paso a paso.
"""

# Prompt para cuando el agente est√° bloqueado
REFLECTION_PROMPT = """Has intentado {num_attempts} ataques sin √©xito.

Analiza qu√© ha fallado:
1. ¬øExtrajiste los par√°metros correctamente?
2. ¬øEl tipo de crypto clasificado es correcto?
3. ¬øHay informaci√≥n que pasaste por alto?
4. ¬øNecesitas un enfoque diferente?

Reflexiona y prop√≥n un nuevo plan de ataque.
"""

# Prompt para generar exploits personalizados
EXPLOIT_GENERATION_PROMPT = """Bas√°ndote en:
- Tipo de desaf√≠o: {challenge_type}
- Par√°metros: {parameters}
- Writeups similares: {writeups}

Genera un script Python/Sage que:
1. Implemente el ataque espec√≠fico
2. Use los par√°metros proporcionados
3. Extraiga y formatee la flag
4. Sea ejecutable directamente

El script debe ser completo y funcional.
"""
```

### `tools.py` - Implementaci√≥n de Herramientas

```python
"""
Herramientas especializadas para resolver CTF Crypto
Optimizadas para uso con Gemini function calling
"""

import re
import subprocess
import tempfile
import os
from typing import Dict, List, Any
from langchain_core.tools import tool

# ============ HERRAMIENTA 1: ANALIZAR ARCHIVOS ============

@tool
def analyze_files(files: List[Dict[str, str]]) -> Dict[str, Any]:
    """
    Analiza archivos de desaf√≠o CTF (.py, .sage, .txt) para extraer 
    par√°metros criptogr√°ficos, imports, y estructura.
    
    Args:
        files: Lista de dicts con 'name' y 'content'
        
    Returns:
        Dict con imports, variables, funciones, e indicadores crypto
    """
    result = {
        "imports": [],
        "variables": {},
        "functions": [],
        "crypto_indicators": [],
        "file_summary": []
    }
    
    for file in files:
        name = file.get("name", "unknown")
        content = file.get("content", "")
        
        # Detectar imports
        imports = re.findall(r'^(?:from|import)\s+(\S+)', content, re.MULTILINE)
        result["imports"].extend(imports)
        
        # Extraer variables num√©ricas grandes (RSA params, etc.)
        # Soporta decimal y hex
        var_pattern = r'(\w+)\s*=\s*(\d{10,}|0x[0-9a-fA-F]{10,})'
        matches = re.findall(var_pattern, content)
        for var_name, var_value in matches:
            try:
                # Convertir a int (soporta hex con 0x)
                result["variables"][var_name] = int(var_value, 0)
            except:
                result["variables"][var_name] = var_value
        
        # Detectar funciones definidas
        functions = re.findall(r'def\s+(\w+)\s*\(', content)
        result["functions"].extend(functions)
        
        # Detectar indicadores de tipo de crypto
        content_lower = content.lower()
        
        # RSA
        if 'rsa' in content_lower or \
           any(v in result["variables"] for v in ['n', 'e', 'c', 'p', 'q']):
            result["crypto_indicators"].append("RSA")
        
        # AES/DES
        if 'aes' in content_lower or 'des' in content_lower or \
           'Crypto.Cipher.AES' in content:
            result["crypto_indicators"].append("AES/DES")
        
        # Cifrados cl√°sicos
        if any(word in content_lower for word in ['caesar', 'rot', 'vigenere', 'substitution']):
            result["crypto_indicators"].append("Classical")
        
        # XOR
        if 'xor' in content_lower or '^' in content:
            result["crypto_indicators"].append("XOR")
        
        # Hash
        if any(word in content_lower for word in ['md5', 'sha', 'hash']):
            result["crypto_indicators"].append("Hash")
        
        # Lattice
        if any(word in content_lower for word in ['lattice', 'lll', 'matrix']):
            result["crypto_indicators"].append("Lattice")
        
        # ECC
        if 'elliptic' in content_lower or 'ecc' in content_lower:
            result["crypto_indicators"].append("ECC")
        
        result["file_summary"].append({
            "name": name,
            "lines": len(content.split('\n')),
            "size_bytes": len(content)
        })
    
    return result

# ============ HERRAMIENTA 2: CLASIFICAR CRYPTO ============

@tool
def classify_crypto(analysis: Dict[str, Any]) -> Dict[str, Any]:
    """
    Clasifica el tipo de criptograf√≠a bas√°ndose en an√°lisis de archivos.
    
    Args:
        analysis: Resultado de analyze_files()
        
    Returns:
        Dict con 'type' y 'confidence' (0.0 - 1.0)
    """
    indicators = analysis.get("crypto_indicators", [])
    variables = analysis.get("variables", {})
    imports = analysis.get("imports", [])
    
    # Sistema de scoring
    scores = {}
    
    # RSA detection
    rsa_score = 0.0
    if "RSA" in indicators:
        rsa_score += 0.3
    if all(v in variables for v in ['n', 'e', 'c']):
        rsa_score += 0.5
    if 'Crypto.PublicKey.RSA' in imports:
        rsa_score += 0.2
    scores["RSA"] = min(rsa_score, 1.0)
    
    # AES/DES detection
    aes_score = 0.0
    if "AES/DES" in indicators:
        aes_score += 0.5
    if any('Crypto.Cipher' in imp for imp in imports):
        aes_score += 0.4
    scores["AES"] = min(aes_score, 1.0)
    
    # Classical cipher detection
    classical_score = 0.0
    if "Classical" in indicators:
        classical_score += 0.6
    if any(func in analysis.get("functions", []) for func in ['encrypt', 'decrypt', 'caesar', 'vigenere']):
        classical_score += 0.3
    scores["Classical"] = min(classical_score, 1.0)
    
    # XOR detection
    xor_score = 0.0
    if "XOR" in indicators:
        xor_score += 0.7
    scores["XOR"] = min(xor_score, 1.0)
    
    # Hash detection
    hash_score = 0.0
    if "Hash" in indicators:
        hash_score += 0.6
    scores["Hash"] = min(hash_score, 1.0)
    
    # Lattice detection
    lattice_score = 0.0
    if "Lattice" in indicators:
        lattice_score += 0.5
    if any('sage' in imp.lower() or 'fpylll' in imp for imp in imports):
        lattice_score += 0.4
    scores["Lattice"] = min(lattice_score, 1.0)
    
    # Seleccionar el tipo con mayor score
    if not scores or max(scores.values()) < 0.3:
        return {"type": "Unknown", "confidence": 0.1, "all_scores": scores}
    
    best_type = max(scores, key=scores.get)
    confidence = scores[best_type]
    
    return {
        "type": best_type,
        "confidence": confidence,
        "all_scores": scores
    }

# ============ HERRAMIENTA 3: CONECTAR NETCAT ============

@tool
def connect_netcat(host: str, port: int, timeout: int = 5) -> Dict[str, Any]:
    """
    Conecta a servidor netcat del desaf√≠o y captura output.
    
    Args:
        host: Hostname o IP
        port: Puerto
        timeout: Timeout en segundos
        
    Returns:
        Dict con 'success', 'output', 'error'
    """
    try:
        from pwn import remote
        import time
        
        conn = remote(host, port, timeout=timeout)
        time.sleep(0.5)  # Esperar banner
        
        # Capturar todo el output disponible
        output = conn.recvall(timeout=timeout).decode(errors='ignore')
        conn.close()
        
        return {
            "success": True,
            "output": output,
            "error": None
        }
    
    except Exception as e:
        return {
            "success": False,
            "output": "",
            "error": str(e)
        }

# ============ HERRAMIENTA 4: ATACAR RSA ============

@tool
def attack_rsa(n: str, e: str, c: str = "", timeout: int = 60) -> Dict[str, Any]:
    """
    Ejecuta bater√≠a de ataques RSA usando RsaCtfTool.
    
    Args:
        n: M√≥dulo RSA (string decimal o hex)
        e: Exponente p√∫blico (string decimal)
        c: Ciphertext (opcional, string decimal o hex)
        timeout: Timeout en segundos
        
    Returns:
        Dict con 'success', 'flag', 'output', 'attack_used'
    """
    try:
        # Verificar que RsaCtfTool existe
        rsactftool_path = "./RsaCtfTool/RsaCtfTool.py"
        if not os.path.exists(rsactftool_path):
            # Intentar path alternativo
            rsactftool_path = "RsaCtfTool.py"
            if not os.path.exists(rsactftool_path):
                return {
                    "success": False,
                    "output": "RsaCtfTool not found. Please install: git clone https://github.com/RsaCtfTool/RsaCtfTool.git",
                    "flag": None
                }
        
        # Construir comando
        cmd = ["python3", rsactftool_path, "-n", str(n), "-e", str(e)]
        
        if c:
            cmd.extend(["--uncipher", str(c)])
        
        # Ejecutar con timeout
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=timeout
        )
        
        output = result.stdout + result.stderr
        
        # Buscar flag en output
        flag_match = re.search(r'flag\{[^}]+\}', output, re.IGNORECASE)
        
        # Detectar qu√© ataque funcion√≥
        attack_used = "unknown"
        if "wiener" in output.lower():
            attack_used = "Wiener's Attack"
        elif "fermat" in output.lower():
            attack_used = "Fermat Factorization"
        elif "hastad" in output.lower():
            attack_used = "Hastad's Attack"
        elif "boneh" in output.lower():
            attack_used = "Boneh-Durfee Attack"
        
        return {
            "success": flag_match is not None,
            "flag": flag_match.group(0) if flag_match else None,
            "output": output[:500],  # Limitar output
            "attack_used": attack_used
        }
    
    except subprocess.TimeoutExpired:
        return {
            "success": False,
            "output": f"Timeout after {timeout}s",
            "flag": None
        }
    except Exception as e:
        return {
            "success": False,
            "output": str(e),
            "flag": None
        }

# ============ HERRAMIENTA 5: ATACAR CIFRADOS CL√ÅSICOS ============

@tool
def attack_classical(ciphertext: str, max_attempts: int = 50) -> Dict[str, Any]:
    """
    Ataca cifrados cl√°sicos (Caesar, XOR, etc.).
    
    Args:
        ciphertext: Texto cifrado
        max_attempts: M√°ximo de intentos
        
    Returns:
        Dict con 'success', 'plaintext', 'cipher_type', 'key'
    """
    results = []
    
    # ATAQUE 1: Caesar / ROT-N
    for shift in range(26):
        plaintext = ""
        for char in ciphertext:
            if char.isalpha():
                base = ord('A') if char.isupper() else ord('a')
                plaintext += chr((ord(char) - base + shift) % 26 + base)
            else:
                plaintext += char
        
        # Buscar flag
        if "flag{" in plaintext.lower():
            return {
                "success": True,
                "plaintext": plaintext,
                "cipher_type": "Caesar",
                "key": shift
            }
        
        results.append({"type": "caesar", "shift": shift, "preview": plaintext[:50]})
    
    # ATAQUE 2: XOR single-byte
    try:
        # Intentar interpretar como hex
        if all(c in '0123456789abcdefABCDEF ' for c in ciphertext.replace(' ', '')):
            ciphertext_bytes = bytes.fromhex(ciphertext.replace(' ', ''))
        else:
            ciphertext_bytes = ciphertext.encode()
        
        for key in range(256):
            plaintext_bytes = bytes([b ^ key for b in ciphertext_bytes])
            try:
                plaintext = plaintext_bytes.decode('utf-8', errors='ignore')
                if "flag{" in plaintext.lower():
                    return {
                        "success": True,
                        "plaintext": plaintext,
                        "cipher_type": "XOR single-byte",
                        "key": key
                    }
                
                if len(results) < max_attempts:
                    results.append({"type": "xor", "key": key, "preview": plaintext[:50]})
            except:
                pass
    except:
        pass
    
    return {
        "success": False,
        "attempts": len(results),
        "sample_results": results[:10]
    }

# ============ HERRAMIENTA 6: EJECUTAR SAGEMATH ============

@tool
def execute_sage(script: str, timeout: int = 60) -> Dict[str, Any]:
    """
    Ejecuta script de SageMath para ataques avanzados.
    
    Args:
        script: C√≥digo SageMath completo
        timeout: Timeout en segundos
        
    Returns:
        Dict con 'success', 'output', 'error'
    """
    with tempfile.NamedTemporaryFile(mode='w', suffix='.sage', delete=False) as f:
        f.write(script)
        temp_file = f.name
    
    try:
        result = subprocess.run(
            ["sage", temp_file],
            capture_output=True,
            text=True,
            timeout=timeout
        )
        
        return {
            "success": result.returncode == 0,
            "output": result.stdout,
            "error": result.stderr if result.returncode != 0 else None
        }
    except subprocess.TimeoutExpired:
        return {
            "success": False,
            "output": "",
            "error": f"Timeout after {timeout}s"
        }
    except FileNotFoundError:
        return {
            "success": False,
            "output": "",
            "error": "SageMath not installed. Install with: sudo apt install sagemath"
        }
    except Exception as e:
        return {
            "success": False,
            "output": "",
            "error": str(e)
        }
    finally:
        if os.path.exists(temp_file):
            os.unlink(temp_file)

# Lista de todas las herramientas para bind al LLM
ALL_TOOLS = [
    analyze_files,
    classify_crypto,
    connect_netcat,
    attack_rsa,
    attack_classical,
    execute_sage
]
```

### `agent.py` - Agente Principal con LangGraph + Gemini

```python
"""
Agente CTF Crypto usando Gemini 2.5 Flash + LangGraph
100% GRATIS - Sin necesidad de Claude/OpenAI
"""

import os
from typing import TypedDict, Annotated, Sequence
from operator import add
from dotenv import load_dotenv

from langgraph.graph import StateGraph, END
from langgraph.prebuilt import ToolExecutor
from langchain_core.messages import BaseMessage, HumanMessage, AIMessage, ToolMessage
from langchain_google_genai import ChatGoogleGenerativeAI

from tools import ALL_TOOLS
from prompts import MASTER_SYSTEM_PROMPT

# Cargar variables de entorno
load_dotenv()

# ============ DEFINIR ESTADO DEL AGENTE ============

class CTFAgentState(TypedDict):
    """Estado del agente CTF"""
    messages: Annotated[Sequence[BaseMessage], add]
    challenge_description: str
    files: list[dict]
    nc_host: str
    nc_port: int
    challenge_type: str
    confidence: float
    parameters_extracted: dict
    flag: str
    solution_steps: list[str]
    remaining_steps: int

# ============ CONFIGURAR GEMINI ============

def create_gemini_model():
    """Crea instancia de Gemini 2.5 Flash con tools"""
    
    # Verificar API key
    api_key = os.getenv("GOOGLE_API_KEY")
    if not api_key:
        raise ValueError(
            "GOOGLE_API_KEY not found! "
            "Get your free key at: https://aistudio.google.com/apikey"
        )
    
    # Crear modelo Gemini 2.5 Flash
    llm = ChatGoogleGenerativeAI(
        model="gemini-2.5-flash",  # Modelo gratis con 1500 RPD
        temperature=0.1,  # Baja para consistencia en crypto
        google_api_key=api_key,
        convert_system_message_to_human=True,  # Gemini maneja system messages as√≠
    )
    
    # Bind tools al modelo
    llm_with_tools = llm.bind_tools(ALL_TOOLS)
    
    return llm_with_tools

# ============ NODOS DEL GRAFO ============

def agent_node(state: CTFAgentState) -> dict:
    """
    Nodo principal: Gemini decide qu√© hacer
    """
    llm = create_gemini_model()
    
    # Si es la primera iteraci√≥n, crear mensaje inicial
    if not state["messages"]:
        initial_message = HumanMessage(
            content=f"""{MASTER_SYSTEM_PROMPT}

---

NUEVO DESAF√çO CTF:

Descripci√≥n: {state['challenge_description']}

Archivos proporcionados: {len(state['files'])} archivo(s)
{chr(10).join(f"  - {f['name']}" for f in state['files'])}

Conexi√≥n Netcat: {state['nc_host']}:{state['nc_port'] if state['nc_port'] else 'N/A'}

---

Procede con la Metodolog√≠a Sistem√°tica. Comienza con PASO 1: RECONOCIMIENTO INICIAL.
"""
        )
        
        messages = [initial_message]
    else:
        messages = state["messages"]
    
    # Gemini procesa y decide
    response = llm.invoke(messages)
    
    # Decrementar steps restantes
    remaining = state.get("remaining_steps", 15) - 1
    
    return {
        "messages": [response],
        "remaining_steps": remaining
    }

def tool_node(state: CTFAgentState) -> dict:
    """
    Nodo de ejecuci√≥n de herramientas
    """
    tool_executor = ToolExecutor(ALL_TOOLS)
    
    last_message = state["messages"][-1]
    
    # Ejecutar todos los tool calls
    tool_messages = []
    new_steps = list(state.get("solution_steps", []))
    
    for tool_call in last_message.tool_calls:
        # Ejecutar herramienta
        tool_result = tool_executor.invoke(tool_call)
        
        # Crear mensaje de resultado
        tool_messages.append(
            ToolMessage(
                content=str(tool_result),
                tool_call_id=tool_call["id"]
            )
        )
        
        # Documentar paso
        new_steps.append(f"Executed: {tool_call['name']} with args: {tool_call['args']}")
        
        # Actualizar estado seg√∫n herramienta
        if tool_call["name"] == "classify_crypto" and isinstance(tool_result, dict):
            state["challenge_type"] = tool_result.get("type", "Unknown")
            state["confidence"] = tool_result.get("confidence", 0.0)
        
        # Buscar flag en resultados
        if isinstance(tool_result, dict) and "flag" in tool_result and tool_result["flag"]:
            state["flag"] = tool_result["flag"]
    
    return {
        "messages": tool_messages,
        "solution_steps": new_steps
    }

def should_continue(state: CTFAgentState) -> str:
    """
    Decide si continuar iterando o terminar
    """
    last_message = state["messages"][-1]
    
    # Si encontramos la flag, terminar
    if state.get("flag"):
        return "end"
    
    # Si no quedan steps, terminar (anti-loop)
    if state.get("remaining_steps", 0) <= 0:
        return "end"
    
    # Si el √∫ltimo mensaje tiene tool calls, ejecutar tools
    if hasattr(last_message, 'tool_calls') and last_message.tool_calls:
        return "continue"
    
    # Si no hay tool calls, terminar
    return "end"

# ============ CONSTRUIR GRAFO ============

def create_ctf_agent():
    """Construye el grafo del agente"""
    
    workflow = StateGraph(CTFAgentState)
    
    # A√±adir nodos
    workflow.add_node("agent", agent_node)
    workflow.add_node("tools", tool_node)
    
    # Definir flujo
    workflow.set_entry_point("agent")
    
    workflow.add_conditional_edges(
        "agent",
        should_continue,
        {
            "continue": "tools",
            "end": END
        }
    )
    
    workflow.add_edge("tools", "agent")
    
    # Compilar
    app = workflow.compile()
    
    return app

# ============ FUNCI√ìN PRINCIPAL ============

def solve_ctf(
    description: str,
    files: list[dict],
    nc_host: str = "",
    nc_port: int = 0,
    max_steps: int = 15
) -> dict:
    """
    Resuelve un desaf√≠o CTF usando Gemini
    
    Args:
        description: Descripci√≥n del desaf√≠o
        files: Lista de archivos [{name: str, content: str}]
        nc_host: Host netcat (opcional)
        nc_port: Puerto netcat (opcional)
        max_steps: M√°ximo de iteraciones
        
    Returns:
        Dict con flag y soluci√≥n
    """
    
    print("üöÄ Iniciando CryptoSolver con Gemini 2.5 Flash...")
    print(f"üìù Desaf√≠o: {description}")
    print(f"üìÇ Archivos: {len(files)}")
    print(f"üîó Netcat: {nc_host}:{nc_port if nc_port else 'N/A'}")
    print(f"‚öôÔ∏è  Max steps: {max_steps}\n")
    
    # Crear agente
    agent = create_ctf_agent()
    
    # Estado inicial
    initial_state = {
        "messages": [],
        "challenge_description": description,
        "files": files,
        "nc_host": nc_host,
        "nc_port": nc_port,
        "challenge_type": "",
        "confidence": 0.0,
        "parameters_extracted": {},
        "flag": "",
        "solution_steps": [],
        "remaining_steps": max_steps
    }
    
    # Ejecutar agente
    print("ü§ñ Gemini est√° analizando el desaf√≠o...\n")
    
    try:
        final_state = agent.invoke(initial_state)
        
        print("\n" + "="*60)
        print("‚úÖ EJECUCI√ìN COMPLETADA")
        print("="*60)
        
        # Mostrar resultado
        if final_state.get("flag"):
            print(f"\nüéâ FLAG CAPTURADA: {final_state['flag']}")
        else:
            print("\n‚ùå Flag no encontrada")
        
        print(f"\nüìä Tipo identificado: {final_state.get('challenge_type', 'Unknown')}")
        print(f"üéØ Confidence: {final_state.get('confidence', 0.0):.2f}")
        
        print(f"\nüìù Pasos de soluci√≥n ({len(final_state.get('solution_steps', []))}):")
        for i, step in enumerate(final_state.get("solution_steps", []), 1):
            print(f"   {i}. {step}")
        
        return {
            "flag": final_state.get("flag", "NOT FOUND"),
            "challenge_type": final_state.get("challenge_type", "Unknown"),
            "confidence": final_state.get("confidence", 0.0),
            "solution_steps": final_state.get("solution_steps", []),
            "success": bool(final_state.get("flag"))
        }
    
    except Exception as e:
        print(f"\n‚ùå ERROR: {e}")
        return {
            "flag": "ERROR",
            "error": str(e),
            "success": False
        }

# ============ EJEMPLO DE USO ============

if __name__ == "__main__":
    # Ejemplo 1: RSA simple con e peque√±o
    result = solve_ctf(
        description="Basic RSA challenge - small exponent vulnerability",
        files=[{
            "name": "chall.py",
            "content": """
from Crypto.Util.number import bytes_to_long

# Flag
flag = b"flag{testing_small_e_vulnerability}"
m = bytes_to_long(flag)

# RSA parameters
n = 123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789
e = 3
c = pow(m, e, n)

print(f"n = {n}")
print(f"e = {e}")
print(f"c = {c}")
"""
        }],
        nc_host="",  # No hay netcat en este ejemplo
        nc_port=0
    )
    
    print("\n" + "="*60)
    print(f"RESULTADO FINAL: {result}")
    print("="*60)
```

### `requirements.txt`

```txt
# Gemini + LangGraph (GRATIS)
langchain==0.3.7
langchain-google-genai==2.0.8
langchain-core==0.3.21
langgraph==0.2.45
google-generativeai==0.8.3

# CTF Tools
pwntools==4.13.1
pycryptodome==3.21.0

# Utilities
python-dotenv==1.0.1
```

## Uso del Agente

### 1. Instalaci√≥n Completa

```bash
# Clonar/crear directorio del proyecto
mkdir ctf-crypto-agent-gemini
cd ctf-crypto-agent-gemini

# Crear archivos (copiar c√≥digo de arriba)
# agent.py, tools.py, prompts.py, requirements.txt

# Instalar dependencias
pip install -r requirements.txt

# Clonar RsaCtfTool
git clone https://github.com/RsaCtfTool/RsaCtfTool.git
cd RsaCtfTool
pip install -r requirements.txt
cd ..

# Configurar API key
echo "GOOGLE_API_KEY=tu-api-key-aqui" > .env
```

### 2. Ejecutar el Agente

```python
# Desde Python interactivo o script
from agent import solve_ctf

# Ejemplo: RSA challenge
result = solve_ctf(
    description="RSA challenge from HackTheBox",
    files=[{
        "name": "challenge.py",
        "content": open("challenge.py").read()
    }],
    nc_host="ctf.hackthebox.eu",
    nc_port=1337
)

print(f"Flag: {result['flag']}")
```

### 3. CLI Simple (opcional)

```python
# cli.py
import sys
from agent import solve_ctf

def main():
    if len(sys.argv) < 2:
        print("Usage: python cli.py <challenge_file.py>")
        sys.exit(1)
    
    file_path = sys.argv[1]
    
    with open(file_path) as f:
        content = f.read()
    
    result = solve_ctf(
        description=f"Challenge from {file_path}",
        files=[{"name": file_path, "content": content}]
    )
    
    if result["success"]:
        print(f"\n‚úÖ SUCCESS: {result['flag']}")
    else:
        print(f"\n‚ùå FAILED")

if __name__ == "__main__":
    main()
```

Uso:
```bash
python cli.py examples/rsa_basic/chall.py
```

## Optimizaciones para Gemini Free Tier

### Gesti√≥n de L√≠mites

```python
# A√±adir rate limiting simple
import time
from functools import wraps

def rate_limit(calls_per_minute=15):
    """Decorator para respetar l√≠mites de Gemini"""
    min_interval = 60.0 / calls_per_minute
    last_called = [0.0]
    
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            elapsed = time.time() - last_called[0]
            left_to_wait = min_interval - elapsed
            if left_to_wait > 0:
                time.sleep(left_to_wait)
            ret = func(*args, **kwargs)
            last_called[0] = time.time()
            return ret
        return wrapper
    return decorator

# Aplicar al nodo del agente
@rate_limit(calls_per_minute=14)  # Bajo de 15 RPM para seguridad
def agent_node_rate_limited(state):
    return agent_node(state)
```

## Pr√≥ximos Pasos

Este setup de Fase 1 te da:
- ‚úÖ Agente funcional con Gemini (100% gratis)
- ‚úÖ Soporte para RSA, cifrados cl√°sicos, XOR
- ‚úÖ Function calling nativo
- ‚úÖ LangGraph para control de flujo
- ‚úÖ Prompts super detallados
- ‚úÖ Sin l√≠mites de tarjeta de cr√©dito

**Para Fase 2-3** (cuando est√©s listo):
- A√±adir ChromaDB para RAG con writeups[8][2]
- Fine-tune clasificador con BERT[9]
- Expandir biblioteca de ataques
- Multi-agent con CrewAI[10][11]



[1](https://ai.google.dev/gemini-api/docs/pricing)
[2](https://blog.laozhang.ai/api-guides/gemini-api-free-tier/)
[3](https://blog.laozhang.ai/ai-tools/gemini-api-rate-limits-guide/)
[4](https://www.cursor-ide.com/blog/gemini-2-5-pro-free-api-limits-guide)
[5](https://codelabs.developers.google.com/codelabs/gemini-function-calling)
[6](https://docs.cloud.google.com/vertex-ai/generative-ai/docs/multimodal/function-calling)
[7](https://ai.google.dev/gemini-api/docs/function-calling)
[8](https://airbyte.com/data-engineering-resources/chroma-db-vector-embeddings)
[9](https://towardsdatascience.com/fine-tuning-bert-for-text-classification-a01f89b179fc/)
[10](https://www.crewai.com)
[11](https://github.com/crewAIInc/crewAI)
[12](https://ai.google.dev/gemini-api/docs/rate-limits)
[13](https://www.reddit.com/r/Bard/comments/1lj4wdp/gemini_free_tier_rate_limits_slashed_again/)
[14](https://github.com/google-gemini/gemini-fullstack-langgraph-quickstart)
[15](https://ai.google.dev/gemini-api/docs/langgraph-example)
[16](https://support.google.com/gemini/thread/352320753/what-are-the-limits?hl=en)
[17](https://www.youtube.com/watch?v=mVXrdvXplj0)
[18](https://cloud.google.com/blog/products/ai-machine-learning/build-multimodal-agents-using-gemini-langchain-and-langgraph)
[19](https://www.cometapi.com/what-are-the-limitations-of-gemini-usage-limits-across-all-tiers/)
[20](https://geminibyexample.com/021-tool-use-function-calling/)
[21](https://www.kaggle.com/code/marusagar/building-an-agent-with-langgraph-and-gemini-apis)
[22](https://community.latenode.com/t/google-gemini-2-5-pro-is-back-on-the-free-api-tier-with-100-daily-requests/25859)
[23](https://blog.searce.com/building-your-first-agentic-workflow-with-langgraph-and-gemini-llm-a-step-by-step-guide-c173c9dcdfe7)
[24](https://support.google.com/gemini/thread/361968214/gemini-api-tier-1-throws-limit-to-freetier?hl=en)
[25](https://python.langchain.com/docs/integrations/chat/google_generative_ai/)
[26](https://pypi.org/project/langchain-google-genai/)
[27](https://python.langchain.com/docs/integrations/llms/google_ai/)
[28](https://www.youtube.com/watch?v=6OURT9WDm5Q)
[29](https://www.andela.com/blog-posts/langchain-and-google-gemini-api-for-ai-apps-a-quickstart-guide)
[30](https://github.com/google-gemini/gemini-cli/discussions/2436)
[31](https://www.npmjs.com/package/@langchain/google-genai)
[32](https://python.langchain.com/api_reference/google_genai/chat_models/langchain_google_genai.chat_models.ChatGoogleGenerativeAI.html)
[33](https://gr-docs.aporia.com/examples/langchain-gemini)
[34](https://www.youtube.com/watch?v=idZwopNzqNI)
[35](https://github.com/langchain-ai/langgraph/issues/4130)
[36](https://python.langchain.com/docs/integrations/providers/google/)
[37](https://www.reddit.com/r/ChatGPTCoding/comments/1jrp1tj/a_simple_guide_to_setting_up_gemini_25_pro_free/)
[38](https://www.kaggle.com/code/markishere/day-3-building-an-agent-with-langgraph)
[39](https://docs.cloud.google.com/vertex-ai/generative-ai/docs/agent-engine/develop/langchain)
[40](https://docs.cloud.google.com/vertex-ai/generative-ai/docs/models/gemini/2-5-flash)
[41](https://www.philschmid.de/langgraph-gemini-2-5-react-agent)
[42](https://developers.googleblog.com/en/start-building-with-gemini-25-flash/)